
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model answers
 * 
 */
export type answers = $Result.DefaultSelection<Prisma.$answersPayload>
/**
 * Model applicants
 * 
 */
export type applicants = $Result.DefaultSelection<Prisma.$applicantsPayload>
/**
 * Model awards
 * 
 */
export type awards = $Result.DefaultSelection<Prisma.$awardsPayload>
/**
 * Model blogs
 * 
 */
export type blogs = $Result.DefaultSelection<Prisma.$blogsPayload>
/**
 * Model careerPathSteps
 * 
 */
export type careerPathSteps = $Result.DefaultSelection<Prisma.$careerPathStepsPayload>
/**
 * Model careerPaths
 * 
 */
export type careerPaths = $Result.DefaultSelection<Prisma.$careerPathsPayload>
/**
 * Model categories
 * 
 */
export type categories = $Result.DefaultSelection<Prisma.$categoriesPayload>
/**
 * Model certificates
 * 
 */
export type certificates = $Result.DefaultSelection<Prisma.$certificatesPayload>
/**
 * Model companies
 * 
 */
export type companies = $Result.DefaultSelection<Prisma.$companiesPayload>
/**
 * Model companyActivitiesHistory
 * 
 */
export type companyActivitiesHistory = $Result.DefaultSelection<Prisma.$companyActivitiesHistoryPayload>
/**
 * Model companyLabels
 * 
 */
export type companyLabels = $Result.DefaultSelection<Prisma.$companyLabelsPayload>
/**
 * Model companyNotifications
 * 
 */
export type companyNotifications = $Result.DefaultSelection<Prisma.$companyNotificationsPayload>
/**
 * Model cvs
 * 
 */
export type cvs = $Result.DefaultSelection<Prisma.$cvsPayload>
/**
 * Model educations
 * 
 */
export type educations = $Result.DefaultSelection<Prisma.$educationsPayload>
/**
 * Model experiences
 * 
 */
export type experiences = $Result.DefaultSelection<Prisma.$experiencesPayload>
/**
 * Model features
 * 
 */
export type features = $Result.DefaultSelection<Prisma.$featuresPayload>
/**
 * Model feedbacks
 * 
 */
export type feedbacks = $Result.DefaultSelection<Prisma.$feedbacksPayload>
/**
 * Model fields
 * 
 */
export type fields = $Result.DefaultSelection<Prisma.$fieldsPayload>
/**
 * Model followedCompanies
 * 
 */
export type followedCompanies = $Result.DefaultSelection<Prisma.$followedCompaniesPayload>
/**
 * Model jobCategories
 * 
 */
export type jobCategories = $Result.DefaultSelection<Prisma.$jobCategoriesPayload>
/**
 * Model jobLabels
 * 
 */
export type jobLabels = $Result.DefaultSelection<Prisma.$jobLabelsPayload>
/**
 * Model jobSpecialized
 * 
 */
export type jobSpecialized = $Result.DefaultSelection<Prisma.$jobSpecializedPayload>
/**
 * Model jobs
 * 
 */
export type jobs = $Result.DefaultSelection<Prisma.$jobsPayload>
/**
 * Model membershipPlans
 * 
 */
export type membershipPlans = $Result.DefaultSelection<Prisma.$membershipPlansPayload>
/**
 * Model messages
 * 
 */
export type messages = $Result.DefaultSelection<Prisma.$messagesPayload>
/**
 * Model payments
 * 
 */
export type payments = $Result.DefaultSelection<Prisma.$paymentsPayload>
/**
 * Model personalityTestResults
 * 
 */
export type personalityTestResults = $Result.DefaultSelection<Prisma.$personalityTestResultsPayload>
/**
 * Model projects
 * 
 */
export type projects = $Result.DefaultSelection<Prisma.$projectsPayload>
/**
 * Model questions
 * 
 */
export type questions = $Result.DefaultSelection<Prisma.$questionsPayload>
/**
 * Model references
 * 
 */
export type references = $Result.DefaultSelection<Prisma.$referencesPayload>
/**
 * Model roles
 * 
 */
export type roles = $Result.DefaultSelection<Prisma.$rolesPayload>
/**
 * Model savedJobs
 * 
 */
export type savedJobs = $Result.DefaultSelection<Prisma.$savedJobsPayload>
/**
 * Model subscriptions
 * 
 */
export type subscriptions = $Result.DefaultSelection<Prisma.$subscriptionsPayload>
/**
 * Model userActivitiesHistory
 * 
 */
export type userActivitiesHistory = $Result.DefaultSelection<Prisma.$userActivitiesHistoryPayload>
/**
 * Model userNotifications
 * 
 */
export type userNotifications = $Result.DefaultSelection<Prisma.$userNotificationsPayload>
/**
 * Model users
 * 
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const ApplicantsStatus: {
  ang_ch_: 'ang_ch_',
  Ch_p_nh_n: 'Ch_p_nh_n',
  T__ch_i: 'T__ch_i'
};

export type ApplicantsStatus = (typeof ApplicantsStatus)[keyof typeof ApplicantsStatus]


export const Company_Type: {
  H__kinh_doanh: 'H__kinh_doanh',
  Doanh_nghi_p: 'Doanh_nghi_p'
};

export type Company_Type = (typeof Company_Type)[keyof typeof Company_Type]


export const Education: {
  C__nh_n: 'C__nh_n',
  Th_c_s_: 'Th_c_s_',
  Ti_n_s_: 'Ti_n_s_',
  Kh_c: 'Kh_c',
  T_t_nghi_p_trung_h_c_ph__th_ng: 'T_t_nghi_p_trung_h_c_ph__th_ng'
};

export type Education = (typeof Education)[keyof typeof Education]


export const Gender: {
  Name: 'Name',
  N_: 'N_',
  Kh_c: 'Kh_c'
};

export type Gender = (typeof Gender)[keyof typeof Gender]


export const Job_Status: {
  H_t_h_n: 'H_t_h_n',
  ang_m_: 'ang_m_'
};

export type Job_Status = (typeof Job_Status)[keyof typeof Job_Status]


export const Job_Type: {
  Remote: 'Remote',
  Part_time: 'Part_time',
  Full_time: 'Full_time',
  Kh_c: 'Kh_c'
};

export type Job_Type = (typeof Job_Type)[keyof typeof Job_Type]


export const NotificationsType: {
  H__th_ng: 'H__th_ng',
  G_i___ng_k_: 'G_i___ng_k_',
  H__s_: 'H__s_',
  ang_theo_d_i: 'ang_theo_d_i'
};

export type NotificationsType = (typeof NotificationsType)[keyof typeof NotificationsType]


export const PaymentGateway: {
  MoMo: 'MoMo',
  Bank: 'Bank',
  ZaloPay: 'ZaloPay',
  Stripe: 'Stripe'
};

export type PaymentGateway = (typeof PaymentGateway)[keyof typeof PaymentGateway]


export const PaymentMethod: {
  Th__ng_n_h_ng: 'Th__ng_n_h_ng',
  V___i_n_t_: 'V___i_n_t_',
  Chuy_n_kho_n: 'Chuy_n_kho_n',
  M__QR: 'M__QR'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const PaymentStatus: {
  Th_nh_c_ng: 'Th_nh_c_ng',
  Th_t_b_i: 'Th_t_b_i'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const SubscriptionStatus: {
  C_n_h_n: 'C_n_h_n',
  H_t_h_n: 'H_t_h_n',
  h_y: 'h_y'
};

export type SubscriptionStatus = (typeof SubscriptionStatus)[keyof typeof SubscriptionStatus]

}

export type ApplicantsStatus = $Enums.ApplicantsStatus

export const ApplicantsStatus: typeof $Enums.ApplicantsStatus

export type Company_Type = $Enums.Company_Type

export const Company_Type: typeof $Enums.Company_Type

export type Education = $Enums.Education

export const Education: typeof $Enums.Education

export type Gender = $Enums.Gender

export const Gender: typeof $Enums.Gender

export type Job_Status = $Enums.Job_Status

export const Job_Status: typeof $Enums.Job_Status

export type Job_Type = $Enums.Job_Type

export const Job_Type: typeof $Enums.Job_Type

export type NotificationsType = $Enums.NotificationsType

export const NotificationsType: typeof $Enums.NotificationsType

export type PaymentGateway = $Enums.PaymentGateway

export const PaymentGateway: typeof $Enums.PaymentGateway

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type SubscriptionStatus = $Enums.SubscriptionStatus

export const SubscriptionStatus: typeof $Enums.SubscriptionStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Answers
 * const answers = await prisma.answers.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Answers
   * const answers = await prisma.answers.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.answers`: Exposes CRUD operations for the **answers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Answers
    * const answers = await prisma.answers.findMany()
    * ```
    */
  get answers(): Prisma.answersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.applicants`: Exposes CRUD operations for the **applicants** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Applicants
    * const applicants = await prisma.applicants.findMany()
    * ```
    */
  get applicants(): Prisma.applicantsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.awards`: Exposes CRUD operations for the **awards** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Awards
    * const awards = await prisma.awards.findMany()
    * ```
    */
  get awards(): Prisma.awardsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.blogs`: Exposes CRUD operations for the **blogs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Blogs
    * const blogs = await prisma.blogs.findMany()
    * ```
    */
  get blogs(): Prisma.blogsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.careerPathSteps`: Exposes CRUD operations for the **careerPathSteps** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CareerPathSteps
    * const careerPathSteps = await prisma.careerPathSteps.findMany()
    * ```
    */
  get careerPathSteps(): Prisma.careerPathStepsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.careerPaths`: Exposes CRUD operations for the **careerPaths** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CareerPaths
    * const careerPaths = await prisma.careerPaths.findMany()
    * ```
    */
  get careerPaths(): Prisma.careerPathsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.categories`: Exposes CRUD operations for the **categories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.categories.findMany()
    * ```
    */
  get categories(): Prisma.categoriesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.certificates`: Exposes CRUD operations for the **certificates** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Certificates
    * const certificates = await prisma.certificates.findMany()
    * ```
    */
  get certificates(): Prisma.certificatesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.companies`: Exposes CRUD operations for the **companies** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companies
    * const companies = await prisma.companies.findMany()
    * ```
    */
  get companies(): Prisma.companiesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.companyActivitiesHistory`: Exposes CRUD operations for the **companyActivitiesHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompanyActivitiesHistories
    * const companyActivitiesHistories = await prisma.companyActivitiesHistory.findMany()
    * ```
    */
  get companyActivitiesHistory(): Prisma.companyActivitiesHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.companyLabels`: Exposes CRUD operations for the **companyLabels** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompanyLabels
    * const companyLabels = await prisma.companyLabels.findMany()
    * ```
    */
  get companyLabels(): Prisma.companyLabelsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.companyNotifications`: Exposes CRUD operations for the **companyNotifications** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompanyNotifications
    * const companyNotifications = await prisma.companyNotifications.findMany()
    * ```
    */
  get companyNotifications(): Prisma.companyNotificationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cvs`: Exposes CRUD operations for the **cvs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cvs
    * const cvs = await prisma.cvs.findMany()
    * ```
    */
  get cvs(): Prisma.cvsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.educations`: Exposes CRUD operations for the **educations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Educations
    * const educations = await prisma.educations.findMany()
    * ```
    */
  get educations(): Prisma.educationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.experiences`: Exposes CRUD operations for the **experiences** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Experiences
    * const experiences = await prisma.experiences.findMany()
    * ```
    */
  get experiences(): Prisma.experiencesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.features`: Exposes CRUD operations for the **features** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Features
    * const features = await prisma.features.findMany()
    * ```
    */
  get features(): Prisma.featuresDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.feedbacks`: Exposes CRUD operations for the **feedbacks** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Feedbacks
    * const feedbacks = await prisma.feedbacks.findMany()
    * ```
    */
  get feedbacks(): Prisma.feedbacksDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fields`: Exposes CRUD operations for the **fields** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fields
    * const fields = await prisma.fields.findMany()
    * ```
    */
  get fields(): Prisma.fieldsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.followedCompanies`: Exposes CRUD operations for the **followedCompanies** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FollowedCompanies
    * const followedCompanies = await prisma.followedCompanies.findMany()
    * ```
    */
  get followedCompanies(): Prisma.followedCompaniesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.jobCategories`: Exposes CRUD operations for the **jobCategories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JobCategories
    * const jobCategories = await prisma.jobCategories.findMany()
    * ```
    */
  get jobCategories(): Prisma.jobCategoriesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.jobLabels`: Exposes CRUD operations for the **jobLabels** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JobLabels
    * const jobLabels = await prisma.jobLabels.findMany()
    * ```
    */
  get jobLabels(): Prisma.jobLabelsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.jobSpecialized`: Exposes CRUD operations for the **jobSpecialized** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JobSpecializeds
    * const jobSpecializeds = await prisma.jobSpecialized.findMany()
    * ```
    */
  get jobSpecialized(): Prisma.jobSpecializedDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.jobs`: Exposes CRUD operations for the **jobs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Jobs
    * const jobs = await prisma.jobs.findMany()
    * ```
    */
  get jobs(): Prisma.jobsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.membershipPlans`: Exposes CRUD operations for the **membershipPlans** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MembershipPlans
    * const membershipPlans = await prisma.membershipPlans.findMany()
    * ```
    */
  get membershipPlans(): Prisma.membershipPlansDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.messages`: Exposes CRUD operations for the **messages** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.messages.findMany()
    * ```
    */
  get messages(): Prisma.messagesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payments`: Exposes CRUD operations for the **payments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payments.findMany()
    * ```
    */
  get payments(): Prisma.paymentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.personalityTestResults`: Exposes CRUD operations for the **personalityTestResults** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PersonalityTestResults
    * const personalityTestResults = await prisma.personalityTestResults.findMany()
    * ```
    */
  get personalityTestResults(): Prisma.personalityTestResultsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projects`: Exposes CRUD operations for the **projects** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.projects.findMany()
    * ```
    */
  get projects(): Prisma.projectsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.questions`: Exposes CRUD operations for the **questions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Questions
    * const questions = await prisma.questions.findMany()
    * ```
    */
  get questions(): Prisma.questionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.references`: Exposes CRUD operations for the **references** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more References
    * const references = await prisma.references.findMany()
    * ```
    */
  get references(): Prisma.referencesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.roles`: Exposes CRUD operations for the **roles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.roles.findMany()
    * ```
    */
  get roles(): Prisma.rolesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.savedJobs`: Exposes CRUD operations for the **savedJobs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SavedJobs
    * const savedJobs = await prisma.savedJobs.findMany()
    * ```
    */
  get savedJobs(): Prisma.savedJobsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subscriptions`: Exposes CRUD operations for the **subscriptions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscriptions.findMany()
    * ```
    */
  get subscriptions(): Prisma.subscriptionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userActivitiesHistory`: Exposes CRUD operations for the **userActivitiesHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserActivitiesHistories
    * const userActivitiesHistories = await prisma.userActivitiesHistory.findMany()
    * ```
    */
  get userActivitiesHistory(): Prisma.userActivitiesHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userNotifications`: Exposes CRUD operations for the **userNotifications** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserNotifications
    * const userNotifications = await prisma.userNotifications.findMany()
    * ```
    */
  get userNotifications(): Prisma.userNotificationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.16.2
   * Query Engine version: 1c57fdcd7e44b29b9313256c76699e91c3ac3c43
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    answers: 'answers',
    applicants: 'applicants',
    awards: 'awards',
    blogs: 'blogs',
    careerPathSteps: 'careerPathSteps',
    careerPaths: 'careerPaths',
    categories: 'categories',
    certificates: 'certificates',
    companies: 'companies',
    companyActivitiesHistory: 'companyActivitiesHistory',
    companyLabels: 'companyLabels',
    companyNotifications: 'companyNotifications',
    cvs: 'cvs',
    educations: 'educations',
    experiences: 'experiences',
    features: 'features',
    feedbacks: 'feedbacks',
    fields: 'fields',
    followedCompanies: 'followedCompanies',
    jobCategories: 'jobCategories',
    jobLabels: 'jobLabels',
    jobSpecialized: 'jobSpecialized',
    jobs: 'jobs',
    membershipPlans: 'membershipPlans',
    messages: 'messages',
    payments: 'payments',
    personalityTestResults: 'personalityTestResults',
    projects: 'projects',
    questions: 'questions',
    references: 'references',
    roles: 'roles',
    savedJobs: 'savedJobs',
    subscriptions: 'subscriptions',
    userActivitiesHistory: 'userActivitiesHistory',
    userNotifications: 'userNotifications',
    users: 'users'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "answers" | "applicants" | "awards" | "blogs" | "careerPathSteps" | "careerPaths" | "categories" | "certificates" | "companies" | "companyActivitiesHistory" | "companyLabels" | "companyNotifications" | "cvs" | "educations" | "experiences" | "features" | "feedbacks" | "fields" | "followedCompanies" | "jobCategories" | "jobLabels" | "jobSpecialized" | "jobs" | "membershipPlans" | "messages" | "payments" | "personalityTestResults" | "projects" | "questions" | "references" | "roles" | "savedJobs" | "subscriptions" | "userActivitiesHistory" | "userNotifications" | "users"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      answers: {
        payload: Prisma.$answersPayload<ExtArgs>
        fields: Prisma.answersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.answersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$answersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.answersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$answersPayload>
          }
          findFirst: {
            args: Prisma.answersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$answersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.answersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$answersPayload>
          }
          findMany: {
            args: Prisma.answersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$answersPayload>[]
          }
          create: {
            args: Prisma.answersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$answersPayload>
          }
          createMany: {
            args: Prisma.answersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.answersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$answersPayload>[]
          }
          delete: {
            args: Prisma.answersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$answersPayload>
          }
          update: {
            args: Prisma.answersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$answersPayload>
          }
          deleteMany: {
            args: Prisma.answersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.answersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.answersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$answersPayload>[]
          }
          upsert: {
            args: Prisma.answersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$answersPayload>
          }
          aggregate: {
            args: Prisma.AnswersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAnswers>
          }
          groupBy: {
            args: Prisma.answersGroupByArgs<ExtArgs>
            result: $Utils.Optional<AnswersGroupByOutputType>[]
          }
          count: {
            args: Prisma.answersCountArgs<ExtArgs>
            result: $Utils.Optional<AnswersCountAggregateOutputType> | number
          }
        }
      }
      applicants: {
        payload: Prisma.$applicantsPayload<ExtArgs>
        fields: Prisma.applicantsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.applicantsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicantsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.applicantsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicantsPayload>
          }
          findFirst: {
            args: Prisma.applicantsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicantsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.applicantsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicantsPayload>
          }
          findMany: {
            args: Prisma.applicantsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicantsPayload>[]
          }
          create: {
            args: Prisma.applicantsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicantsPayload>
          }
          createMany: {
            args: Prisma.applicantsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.applicantsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicantsPayload>[]
          }
          delete: {
            args: Prisma.applicantsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicantsPayload>
          }
          update: {
            args: Prisma.applicantsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicantsPayload>
          }
          deleteMany: {
            args: Prisma.applicantsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.applicantsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.applicantsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicantsPayload>[]
          }
          upsert: {
            args: Prisma.applicantsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$applicantsPayload>
          }
          aggregate: {
            args: Prisma.ApplicantsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApplicants>
          }
          groupBy: {
            args: Prisma.applicantsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ApplicantsGroupByOutputType>[]
          }
          count: {
            args: Prisma.applicantsCountArgs<ExtArgs>
            result: $Utils.Optional<ApplicantsCountAggregateOutputType> | number
          }
        }
      }
      awards: {
        payload: Prisma.$awardsPayload<ExtArgs>
        fields: Prisma.awardsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.awardsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$awardsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.awardsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$awardsPayload>
          }
          findFirst: {
            args: Prisma.awardsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$awardsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.awardsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$awardsPayload>
          }
          findMany: {
            args: Prisma.awardsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$awardsPayload>[]
          }
          create: {
            args: Prisma.awardsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$awardsPayload>
          }
          createMany: {
            args: Prisma.awardsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.awardsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$awardsPayload>[]
          }
          delete: {
            args: Prisma.awardsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$awardsPayload>
          }
          update: {
            args: Prisma.awardsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$awardsPayload>
          }
          deleteMany: {
            args: Prisma.awardsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.awardsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.awardsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$awardsPayload>[]
          }
          upsert: {
            args: Prisma.awardsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$awardsPayload>
          }
          aggregate: {
            args: Prisma.AwardsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAwards>
          }
          groupBy: {
            args: Prisma.awardsGroupByArgs<ExtArgs>
            result: $Utils.Optional<AwardsGroupByOutputType>[]
          }
          count: {
            args: Prisma.awardsCountArgs<ExtArgs>
            result: $Utils.Optional<AwardsCountAggregateOutputType> | number
          }
        }
      }
      blogs: {
        payload: Prisma.$blogsPayload<ExtArgs>
        fields: Prisma.blogsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.blogsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blogsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.blogsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blogsPayload>
          }
          findFirst: {
            args: Prisma.blogsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blogsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.blogsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blogsPayload>
          }
          findMany: {
            args: Prisma.blogsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blogsPayload>[]
          }
          create: {
            args: Prisma.blogsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blogsPayload>
          }
          createMany: {
            args: Prisma.blogsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.blogsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blogsPayload>[]
          }
          delete: {
            args: Prisma.blogsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blogsPayload>
          }
          update: {
            args: Prisma.blogsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blogsPayload>
          }
          deleteMany: {
            args: Prisma.blogsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.blogsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.blogsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blogsPayload>[]
          }
          upsert: {
            args: Prisma.blogsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$blogsPayload>
          }
          aggregate: {
            args: Prisma.BlogsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlogs>
          }
          groupBy: {
            args: Prisma.blogsGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlogsGroupByOutputType>[]
          }
          count: {
            args: Prisma.blogsCountArgs<ExtArgs>
            result: $Utils.Optional<BlogsCountAggregateOutputType> | number
          }
        }
      }
      careerPathSteps: {
        payload: Prisma.$careerPathStepsPayload<ExtArgs>
        fields: Prisma.careerPathStepsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.careerPathStepsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$careerPathStepsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.careerPathStepsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$careerPathStepsPayload>
          }
          findFirst: {
            args: Prisma.careerPathStepsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$careerPathStepsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.careerPathStepsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$careerPathStepsPayload>
          }
          findMany: {
            args: Prisma.careerPathStepsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$careerPathStepsPayload>[]
          }
          create: {
            args: Prisma.careerPathStepsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$careerPathStepsPayload>
          }
          createMany: {
            args: Prisma.careerPathStepsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.careerPathStepsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$careerPathStepsPayload>[]
          }
          delete: {
            args: Prisma.careerPathStepsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$careerPathStepsPayload>
          }
          update: {
            args: Prisma.careerPathStepsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$careerPathStepsPayload>
          }
          deleteMany: {
            args: Prisma.careerPathStepsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.careerPathStepsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.careerPathStepsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$careerPathStepsPayload>[]
          }
          upsert: {
            args: Prisma.careerPathStepsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$careerPathStepsPayload>
          }
          aggregate: {
            args: Prisma.CareerPathStepsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCareerPathSteps>
          }
          groupBy: {
            args: Prisma.careerPathStepsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CareerPathStepsGroupByOutputType>[]
          }
          count: {
            args: Prisma.careerPathStepsCountArgs<ExtArgs>
            result: $Utils.Optional<CareerPathStepsCountAggregateOutputType> | number
          }
        }
      }
      careerPaths: {
        payload: Prisma.$careerPathsPayload<ExtArgs>
        fields: Prisma.careerPathsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.careerPathsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$careerPathsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.careerPathsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$careerPathsPayload>
          }
          findFirst: {
            args: Prisma.careerPathsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$careerPathsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.careerPathsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$careerPathsPayload>
          }
          findMany: {
            args: Prisma.careerPathsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$careerPathsPayload>[]
          }
          create: {
            args: Prisma.careerPathsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$careerPathsPayload>
          }
          createMany: {
            args: Prisma.careerPathsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.careerPathsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$careerPathsPayload>[]
          }
          delete: {
            args: Prisma.careerPathsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$careerPathsPayload>
          }
          update: {
            args: Prisma.careerPathsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$careerPathsPayload>
          }
          deleteMany: {
            args: Prisma.careerPathsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.careerPathsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.careerPathsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$careerPathsPayload>[]
          }
          upsert: {
            args: Prisma.careerPathsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$careerPathsPayload>
          }
          aggregate: {
            args: Prisma.CareerPathsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCareerPaths>
          }
          groupBy: {
            args: Prisma.careerPathsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CareerPathsGroupByOutputType>[]
          }
          count: {
            args: Prisma.careerPathsCountArgs<ExtArgs>
            result: $Utils.Optional<CareerPathsCountAggregateOutputType> | number
          }
        }
      }
      categories: {
        payload: Prisma.$categoriesPayload<ExtArgs>
        fields: Prisma.categoriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.categoriesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.categoriesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>
          }
          findFirst: {
            args: Prisma.categoriesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.categoriesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>
          }
          findMany: {
            args: Prisma.categoriesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>[]
          }
          create: {
            args: Prisma.categoriesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>
          }
          createMany: {
            args: Prisma.categoriesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.categoriesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>[]
          }
          delete: {
            args: Prisma.categoriesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>
          }
          update: {
            args: Prisma.categoriesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>
          }
          deleteMany: {
            args: Prisma.categoriesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.categoriesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.categoriesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>[]
          }
          upsert: {
            args: Prisma.categoriesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>
          }
          aggregate: {
            args: Prisma.CategoriesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategories>
          }
          groupBy: {
            args: Prisma.categoriesGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.categoriesCountArgs<ExtArgs>
            result: $Utils.Optional<CategoriesCountAggregateOutputType> | number
          }
        }
      }
      certificates: {
        payload: Prisma.$certificatesPayload<ExtArgs>
        fields: Prisma.certificatesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.certificatesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificatesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.certificatesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificatesPayload>
          }
          findFirst: {
            args: Prisma.certificatesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificatesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.certificatesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificatesPayload>
          }
          findMany: {
            args: Prisma.certificatesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificatesPayload>[]
          }
          create: {
            args: Prisma.certificatesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificatesPayload>
          }
          createMany: {
            args: Prisma.certificatesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.certificatesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificatesPayload>[]
          }
          delete: {
            args: Prisma.certificatesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificatesPayload>
          }
          update: {
            args: Prisma.certificatesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificatesPayload>
          }
          deleteMany: {
            args: Prisma.certificatesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.certificatesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.certificatesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificatesPayload>[]
          }
          upsert: {
            args: Prisma.certificatesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$certificatesPayload>
          }
          aggregate: {
            args: Prisma.CertificatesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCertificates>
          }
          groupBy: {
            args: Prisma.certificatesGroupByArgs<ExtArgs>
            result: $Utils.Optional<CertificatesGroupByOutputType>[]
          }
          count: {
            args: Prisma.certificatesCountArgs<ExtArgs>
            result: $Utils.Optional<CertificatesCountAggregateOutputType> | number
          }
        }
      }
      companies: {
        payload: Prisma.$companiesPayload<ExtArgs>
        fields: Prisma.companiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.companiesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.companiesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>
          }
          findFirst: {
            args: Prisma.companiesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.companiesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>
          }
          findMany: {
            args: Prisma.companiesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>[]
          }
          create: {
            args: Prisma.companiesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>
          }
          createMany: {
            args: Prisma.companiesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.companiesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>[]
          }
          delete: {
            args: Prisma.companiesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>
          }
          update: {
            args: Prisma.companiesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>
          }
          deleteMany: {
            args: Prisma.companiesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.companiesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.companiesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>[]
          }
          upsert: {
            args: Prisma.companiesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>
          }
          aggregate: {
            args: Prisma.CompaniesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompanies>
          }
          groupBy: {
            args: Prisma.companiesGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompaniesGroupByOutputType>[]
          }
          count: {
            args: Prisma.companiesCountArgs<ExtArgs>
            result: $Utils.Optional<CompaniesCountAggregateOutputType> | number
          }
        }
      }
      companyActivitiesHistory: {
        payload: Prisma.$companyActivitiesHistoryPayload<ExtArgs>
        fields: Prisma.companyActivitiesHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.companyActivitiesHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyActivitiesHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.companyActivitiesHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyActivitiesHistoryPayload>
          }
          findFirst: {
            args: Prisma.companyActivitiesHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyActivitiesHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.companyActivitiesHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyActivitiesHistoryPayload>
          }
          findMany: {
            args: Prisma.companyActivitiesHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyActivitiesHistoryPayload>[]
          }
          create: {
            args: Prisma.companyActivitiesHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyActivitiesHistoryPayload>
          }
          createMany: {
            args: Prisma.companyActivitiesHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.companyActivitiesHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyActivitiesHistoryPayload>[]
          }
          delete: {
            args: Prisma.companyActivitiesHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyActivitiesHistoryPayload>
          }
          update: {
            args: Prisma.companyActivitiesHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyActivitiesHistoryPayload>
          }
          deleteMany: {
            args: Prisma.companyActivitiesHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.companyActivitiesHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.companyActivitiesHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyActivitiesHistoryPayload>[]
          }
          upsert: {
            args: Prisma.companyActivitiesHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyActivitiesHistoryPayload>
          }
          aggregate: {
            args: Prisma.CompanyActivitiesHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompanyActivitiesHistory>
          }
          groupBy: {
            args: Prisma.companyActivitiesHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyActivitiesHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.companyActivitiesHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyActivitiesHistoryCountAggregateOutputType> | number
          }
        }
      }
      companyLabels: {
        payload: Prisma.$companyLabelsPayload<ExtArgs>
        fields: Prisma.companyLabelsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.companyLabelsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyLabelsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.companyLabelsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyLabelsPayload>
          }
          findFirst: {
            args: Prisma.companyLabelsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyLabelsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.companyLabelsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyLabelsPayload>
          }
          findMany: {
            args: Prisma.companyLabelsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyLabelsPayload>[]
          }
          create: {
            args: Prisma.companyLabelsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyLabelsPayload>
          }
          createMany: {
            args: Prisma.companyLabelsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.companyLabelsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyLabelsPayload>[]
          }
          delete: {
            args: Prisma.companyLabelsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyLabelsPayload>
          }
          update: {
            args: Prisma.companyLabelsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyLabelsPayload>
          }
          deleteMany: {
            args: Prisma.companyLabelsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.companyLabelsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.companyLabelsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyLabelsPayload>[]
          }
          upsert: {
            args: Prisma.companyLabelsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyLabelsPayload>
          }
          aggregate: {
            args: Prisma.CompanyLabelsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompanyLabels>
          }
          groupBy: {
            args: Prisma.companyLabelsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyLabelsGroupByOutputType>[]
          }
          count: {
            args: Prisma.companyLabelsCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyLabelsCountAggregateOutputType> | number
          }
        }
      }
      companyNotifications: {
        payload: Prisma.$companyNotificationsPayload<ExtArgs>
        fields: Prisma.companyNotificationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.companyNotificationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyNotificationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.companyNotificationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyNotificationsPayload>
          }
          findFirst: {
            args: Prisma.companyNotificationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyNotificationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.companyNotificationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyNotificationsPayload>
          }
          findMany: {
            args: Prisma.companyNotificationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyNotificationsPayload>[]
          }
          create: {
            args: Prisma.companyNotificationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyNotificationsPayload>
          }
          createMany: {
            args: Prisma.companyNotificationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.companyNotificationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyNotificationsPayload>[]
          }
          delete: {
            args: Prisma.companyNotificationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyNotificationsPayload>
          }
          update: {
            args: Prisma.companyNotificationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyNotificationsPayload>
          }
          deleteMany: {
            args: Prisma.companyNotificationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.companyNotificationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.companyNotificationsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyNotificationsPayload>[]
          }
          upsert: {
            args: Prisma.companyNotificationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companyNotificationsPayload>
          }
          aggregate: {
            args: Prisma.CompanyNotificationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompanyNotifications>
          }
          groupBy: {
            args: Prisma.companyNotificationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyNotificationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.companyNotificationsCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyNotificationsCountAggregateOutputType> | number
          }
        }
      }
      cvs: {
        payload: Prisma.$cvsPayload<ExtArgs>
        fields: Prisma.cvsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.cvsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cvsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.cvsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cvsPayload>
          }
          findFirst: {
            args: Prisma.cvsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cvsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.cvsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cvsPayload>
          }
          findMany: {
            args: Prisma.cvsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cvsPayload>[]
          }
          create: {
            args: Prisma.cvsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cvsPayload>
          }
          createMany: {
            args: Prisma.cvsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.cvsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cvsPayload>[]
          }
          delete: {
            args: Prisma.cvsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cvsPayload>
          }
          update: {
            args: Prisma.cvsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cvsPayload>
          }
          deleteMany: {
            args: Prisma.cvsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.cvsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.cvsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cvsPayload>[]
          }
          upsert: {
            args: Prisma.cvsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cvsPayload>
          }
          aggregate: {
            args: Prisma.CvsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCvs>
          }
          groupBy: {
            args: Prisma.cvsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CvsGroupByOutputType>[]
          }
          count: {
            args: Prisma.cvsCountArgs<ExtArgs>
            result: $Utils.Optional<CvsCountAggregateOutputType> | number
          }
        }
      }
      educations: {
        payload: Prisma.$educationsPayload<ExtArgs>
        fields: Prisma.educationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.educationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$educationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.educationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$educationsPayload>
          }
          findFirst: {
            args: Prisma.educationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$educationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.educationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$educationsPayload>
          }
          findMany: {
            args: Prisma.educationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$educationsPayload>[]
          }
          create: {
            args: Prisma.educationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$educationsPayload>
          }
          createMany: {
            args: Prisma.educationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.educationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$educationsPayload>[]
          }
          delete: {
            args: Prisma.educationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$educationsPayload>
          }
          update: {
            args: Prisma.educationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$educationsPayload>
          }
          deleteMany: {
            args: Prisma.educationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.educationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.educationsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$educationsPayload>[]
          }
          upsert: {
            args: Prisma.educationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$educationsPayload>
          }
          aggregate: {
            args: Prisma.EducationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEducations>
          }
          groupBy: {
            args: Prisma.educationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<EducationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.educationsCountArgs<ExtArgs>
            result: $Utils.Optional<EducationsCountAggregateOutputType> | number
          }
        }
      }
      experiences: {
        payload: Prisma.$experiencesPayload<ExtArgs>
        fields: Prisma.experiencesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.experiencesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$experiencesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.experiencesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$experiencesPayload>
          }
          findFirst: {
            args: Prisma.experiencesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$experiencesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.experiencesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$experiencesPayload>
          }
          findMany: {
            args: Prisma.experiencesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$experiencesPayload>[]
          }
          create: {
            args: Prisma.experiencesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$experiencesPayload>
          }
          createMany: {
            args: Prisma.experiencesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.experiencesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$experiencesPayload>[]
          }
          delete: {
            args: Prisma.experiencesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$experiencesPayload>
          }
          update: {
            args: Prisma.experiencesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$experiencesPayload>
          }
          deleteMany: {
            args: Prisma.experiencesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.experiencesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.experiencesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$experiencesPayload>[]
          }
          upsert: {
            args: Prisma.experiencesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$experiencesPayload>
          }
          aggregate: {
            args: Prisma.ExperiencesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExperiences>
          }
          groupBy: {
            args: Prisma.experiencesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExperiencesGroupByOutputType>[]
          }
          count: {
            args: Prisma.experiencesCountArgs<ExtArgs>
            result: $Utils.Optional<ExperiencesCountAggregateOutputType> | number
          }
        }
      }
      features: {
        payload: Prisma.$featuresPayload<ExtArgs>
        fields: Prisma.featuresFieldRefs
        operations: {
          findUnique: {
            args: Prisma.featuresFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$featuresPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.featuresFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$featuresPayload>
          }
          findFirst: {
            args: Prisma.featuresFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$featuresPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.featuresFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$featuresPayload>
          }
          findMany: {
            args: Prisma.featuresFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$featuresPayload>[]
          }
          create: {
            args: Prisma.featuresCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$featuresPayload>
          }
          createMany: {
            args: Prisma.featuresCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.featuresCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$featuresPayload>[]
          }
          delete: {
            args: Prisma.featuresDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$featuresPayload>
          }
          update: {
            args: Prisma.featuresUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$featuresPayload>
          }
          deleteMany: {
            args: Prisma.featuresDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.featuresUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.featuresUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$featuresPayload>[]
          }
          upsert: {
            args: Prisma.featuresUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$featuresPayload>
          }
          aggregate: {
            args: Prisma.FeaturesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeatures>
          }
          groupBy: {
            args: Prisma.featuresGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeaturesGroupByOutputType>[]
          }
          count: {
            args: Prisma.featuresCountArgs<ExtArgs>
            result: $Utils.Optional<FeaturesCountAggregateOutputType> | number
          }
        }
      }
      feedbacks: {
        payload: Prisma.$feedbacksPayload<ExtArgs>
        fields: Prisma.feedbacksFieldRefs
        operations: {
          findUnique: {
            args: Prisma.feedbacksFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feedbacksPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.feedbacksFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feedbacksPayload>
          }
          findFirst: {
            args: Prisma.feedbacksFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feedbacksPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.feedbacksFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feedbacksPayload>
          }
          findMany: {
            args: Prisma.feedbacksFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feedbacksPayload>[]
          }
          create: {
            args: Prisma.feedbacksCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feedbacksPayload>
          }
          createMany: {
            args: Prisma.feedbacksCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.feedbacksCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feedbacksPayload>[]
          }
          delete: {
            args: Prisma.feedbacksDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feedbacksPayload>
          }
          update: {
            args: Prisma.feedbacksUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feedbacksPayload>
          }
          deleteMany: {
            args: Prisma.feedbacksDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.feedbacksUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.feedbacksUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feedbacksPayload>[]
          }
          upsert: {
            args: Prisma.feedbacksUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$feedbacksPayload>
          }
          aggregate: {
            args: Prisma.FeedbacksAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeedbacks>
          }
          groupBy: {
            args: Prisma.feedbacksGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeedbacksGroupByOutputType>[]
          }
          count: {
            args: Prisma.feedbacksCountArgs<ExtArgs>
            result: $Utils.Optional<FeedbacksCountAggregateOutputType> | number
          }
        }
      }
      fields: {
        payload: Prisma.$fieldsPayload<ExtArgs>
        fields: Prisma.fieldsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.fieldsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fieldsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.fieldsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fieldsPayload>
          }
          findFirst: {
            args: Prisma.fieldsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fieldsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.fieldsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fieldsPayload>
          }
          findMany: {
            args: Prisma.fieldsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fieldsPayload>[]
          }
          create: {
            args: Prisma.fieldsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fieldsPayload>
          }
          createMany: {
            args: Prisma.fieldsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.fieldsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fieldsPayload>[]
          }
          delete: {
            args: Prisma.fieldsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fieldsPayload>
          }
          update: {
            args: Prisma.fieldsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fieldsPayload>
          }
          deleteMany: {
            args: Prisma.fieldsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.fieldsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.fieldsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fieldsPayload>[]
          }
          upsert: {
            args: Prisma.fieldsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fieldsPayload>
          }
          aggregate: {
            args: Prisma.FieldsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFields>
          }
          groupBy: {
            args: Prisma.fieldsGroupByArgs<ExtArgs>
            result: $Utils.Optional<FieldsGroupByOutputType>[]
          }
          count: {
            args: Prisma.fieldsCountArgs<ExtArgs>
            result: $Utils.Optional<FieldsCountAggregateOutputType> | number
          }
        }
      }
      followedCompanies: {
        payload: Prisma.$followedCompaniesPayload<ExtArgs>
        fields: Prisma.followedCompaniesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.followedCompaniesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$followedCompaniesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.followedCompaniesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$followedCompaniesPayload>
          }
          findFirst: {
            args: Prisma.followedCompaniesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$followedCompaniesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.followedCompaniesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$followedCompaniesPayload>
          }
          findMany: {
            args: Prisma.followedCompaniesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$followedCompaniesPayload>[]
          }
          create: {
            args: Prisma.followedCompaniesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$followedCompaniesPayload>
          }
          createMany: {
            args: Prisma.followedCompaniesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.followedCompaniesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$followedCompaniesPayload>[]
          }
          delete: {
            args: Prisma.followedCompaniesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$followedCompaniesPayload>
          }
          update: {
            args: Prisma.followedCompaniesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$followedCompaniesPayload>
          }
          deleteMany: {
            args: Prisma.followedCompaniesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.followedCompaniesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.followedCompaniesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$followedCompaniesPayload>[]
          }
          upsert: {
            args: Prisma.followedCompaniesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$followedCompaniesPayload>
          }
          aggregate: {
            args: Prisma.FollowedCompaniesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFollowedCompanies>
          }
          groupBy: {
            args: Prisma.followedCompaniesGroupByArgs<ExtArgs>
            result: $Utils.Optional<FollowedCompaniesGroupByOutputType>[]
          }
          count: {
            args: Prisma.followedCompaniesCountArgs<ExtArgs>
            result: $Utils.Optional<FollowedCompaniesCountAggregateOutputType> | number
          }
        }
      }
      jobCategories: {
        payload: Prisma.$jobCategoriesPayload<ExtArgs>
        fields: Prisma.jobCategoriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.jobCategoriesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobCategoriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.jobCategoriesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobCategoriesPayload>
          }
          findFirst: {
            args: Prisma.jobCategoriesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobCategoriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.jobCategoriesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobCategoriesPayload>
          }
          findMany: {
            args: Prisma.jobCategoriesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobCategoriesPayload>[]
          }
          create: {
            args: Prisma.jobCategoriesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobCategoriesPayload>
          }
          createMany: {
            args: Prisma.jobCategoriesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.jobCategoriesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobCategoriesPayload>[]
          }
          delete: {
            args: Prisma.jobCategoriesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobCategoriesPayload>
          }
          update: {
            args: Prisma.jobCategoriesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobCategoriesPayload>
          }
          deleteMany: {
            args: Prisma.jobCategoriesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.jobCategoriesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.jobCategoriesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobCategoriesPayload>[]
          }
          upsert: {
            args: Prisma.jobCategoriesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobCategoriesPayload>
          }
          aggregate: {
            args: Prisma.JobCategoriesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJobCategories>
          }
          groupBy: {
            args: Prisma.jobCategoriesGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobCategoriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.jobCategoriesCountArgs<ExtArgs>
            result: $Utils.Optional<JobCategoriesCountAggregateOutputType> | number
          }
        }
      }
      jobLabels: {
        payload: Prisma.$jobLabelsPayload<ExtArgs>
        fields: Prisma.jobLabelsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.jobLabelsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobLabelsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.jobLabelsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobLabelsPayload>
          }
          findFirst: {
            args: Prisma.jobLabelsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobLabelsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.jobLabelsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobLabelsPayload>
          }
          findMany: {
            args: Prisma.jobLabelsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobLabelsPayload>[]
          }
          create: {
            args: Prisma.jobLabelsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobLabelsPayload>
          }
          createMany: {
            args: Prisma.jobLabelsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.jobLabelsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobLabelsPayload>[]
          }
          delete: {
            args: Prisma.jobLabelsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobLabelsPayload>
          }
          update: {
            args: Prisma.jobLabelsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobLabelsPayload>
          }
          deleteMany: {
            args: Prisma.jobLabelsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.jobLabelsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.jobLabelsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobLabelsPayload>[]
          }
          upsert: {
            args: Prisma.jobLabelsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobLabelsPayload>
          }
          aggregate: {
            args: Prisma.JobLabelsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJobLabels>
          }
          groupBy: {
            args: Prisma.jobLabelsGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobLabelsGroupByOutputType>[]
          }
          count: {
            args: Prisma.jobLabelsCountArgs<ExtArgs>
            result: $Utils.Optional<JobLabelsCountAggregateOutputType> | number
          }
        }
      }
      jobSpecialized: {
        payload: Prisma.$jobSpecializedPayload<ExtArgs>
        fields: Prisma.jobSpecializedFieldRefs
        operations: {
          findUnique: {
            args: Prisma.jobSpecializedFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobSpecializedPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.jobSpecializedFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobSpecializedPayload>
          }
          findFirst: {
            args: Prisma.jobSpecializedFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobSpecializedPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.jobSpecializedFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobSpecializedPayload>
          }
          findMany: {
            args: Prisma.jobSpecializedFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobSpecializedPayload>[]
          }
          create: {
            args: Prisma.jobSpecializedCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobSpecializedPayload>
          }
          createMany: {
            args: Prisma.jobSpecializedCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.jobSpecializedCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobSpecializedPayload>[]
          }
          delete: {
            args: Prisma.jobSpecializedDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobSpecializedPayload>
          }
          update: {
            args: Prisma.jobSpecializedUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobSpecializedPayload>
          }
          deleteMany: {
            args: Prisma.jobSpecializedDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.jobSpecializedUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.jobSpecializedUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobSpecializedPayload>[]
          }
          upsert: {
            args: Prisma.jobSpecializedUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobSpecializedPayload>
          }
          aggregate: {
            args: Prisma.JobSpecializedAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJobSpecialized>
          }
          groupBy: {
            args: Prisma.jobSpecializedGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobSpecializedGroupByOutputType>[]
          }
          count: {
            args: Prisma.jobSpecializedCountArgs<ExtArgs>
            result: $Utils.Optional<JobSpecializedCountAggregateOutputType> | number
          }
        }
      }
      jobs: {
        payload: Prisma.$jobsPayload<ExtArgs>
        fields: Prisma.jobsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.jobsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.jobsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobsPayload>
          }
          findFirst: {
            args: Prisma.jobsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.jobsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobsPayload>
          }
          findMany: {
            args: Prisma.jobsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobsPayload>[]
          }
          create: {
            args: Prisma.jobsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobsPayload>
          }
          createMany: {
            args: Prisma.jobsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.jobsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobsPayload>[]
          }
          delete: {
            args: Prisma.jobsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobsPayload>
          }
          update: {
            args: Prisma.jobsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobsPayload>
          }
          deleteMany: {
            args: Prisma.jobsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.jobsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.jobsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobsPayload>[]
          }
          upsert: {
            args: Prisma.jobsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobsPayload>
          }
          aggregate: {
            args: Prisma.JobsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJobs>
          }
          groupBy: {
            args: Prisma.jobsGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobsGroupByOutputType>[]
          }
          count: {
            args: Prisma.jobsCountArgs<ExtArgs>
            result: $Utils.Optional<JobsCountAggregateOutputType> | number
          }
        }
      }
      membershipPlans: {
        payload: Prisma.$membershipPlansPayload<ExtArgs>
        fields: Prisma.membershipPlansFieldRefs
        operations: {
          findUnique: {
            args: Prisma.membershipPlansFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$membershipPlansPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.membershipPlansFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$membershipPlansPayload>
          }
          findFirst: {
            args: Prisma.membershipPlansFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$membershipPlansPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.membershipPlansFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$membershipPlansPayload>
          }
          findMany: {
            args: Prisma.membershipPlansFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$membershipPlansPayload>[]
          }
          create: {
            args: Prisma.membershipPlansCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$membershipPlansPayload>
          }
          createMany: {
            args: Prisma.membershipPlansCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.membershipPlansCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$membershipPlansPayload>[]
          }
          delete: {
            args: Prisma.membershipPlansDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$membershipPlansPayload>
          }
          update: {
            args: Prisma.membershipPlansUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$membershipPlansPayload>
          }
          deleteMany: {
            args: Prisma.membershipPlansDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.membershipPlansUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.membershipPlansUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$membershipPlansPayload>[]
          }
          upsert: {
            args: Prisma.membershipPlansUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$membershipPlansPayload>
          }
          aggregate: {
            args: Prisma.MembershipPlansAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMembershipPlans>
          }
          groupBy: {
            args: Prisma.membershipPlansGroupByArgs<ExtArgs>
            result: $Utils.Optional<MembershipPlansGroupByOutputType>[]
          }
          count: {
            args: Prisma.membershipPlansCountArgs<ExtArgs>
            result: $Utils.Optional<MembershipPlansCountAggregateOutputType> | number
          }
        }
      }
      messages: {
        payload: Prisma.$messagesPayload<ExtArgs>
        fields: Prisma.messagesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.messagesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.messagesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload>
          }
          findFirst: {
            args: Prisma.messagesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.messagesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload>
          }
          findMany: {
            args: Prisma.messagesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload>[]
          }
          create: {
            args: Prisma.messagesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload>
          }
          createMany: {
            args: Prisma.messagesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.messagesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload>[]
          }
          delete: {
            args: Prisma.messagesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload>
          }
          update: {
            args: Prisma.messagesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload>
          }
          deleteMany: {
            args: Prisma.messagesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.messagesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.messagesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload>[]
          }
          upsert: {
            args: Prisma.messagesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$messagesPayload>
          }
          aggregate: {
            args: Prisma.MessagesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessages>
          }
          groupBy: {
            args: Prisma.messagesGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessagesGroupByOutputType>[]
          }
          count: {
            args: Prisma.messagesCountArgs<ExtArgs>
            result: $Utils.Optional<MessagesCountAggregateOutputType> | number
          }
        }
      }
      payments: {
        payload: Prisma.$paymentsPayload<ExtArgs>
        fields: Prisma.paymentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.paymentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.paymentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          findFirst: {
            args: Prisma.paymentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.paymentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          findMany: {
            args: Prisma.paymentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>[]
          }
          create: {
            args: Prisma.paymentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          createMany: {
            args: Prisma.paymentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.paymentsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>[]
          }
          delete: {
            args: Prisma.paymentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          update: {
            args: Prisma.paymentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          deleteMany: {
            args: Prisma.paymentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.paymentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.paymentsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>[]
          }
          upsert: {
            args: Prisma.paymentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          aggregate: {
            args: Prisma.PaymentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayments>
          }
          groupBy: {
            args: Prisma.paymentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.paymentsCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentsCountAggregateOutputType> | number
          }
        }
      }
      personalityTestResults: {
        payload: Prisma.$personalityTestResultsPayload<ExtArgs>
        fields: Prisma.personalityTestResultsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.personalityTestResultsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$personalityTestResultsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.personalityTestResultsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$personalityTestResultsPayload>
          }
          findFirst: {
            args: Prisma.personalityTestResultsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$personalityTestResultsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.personalityTestResultsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$personalityTestResultsPayload>
          }
          findMany: {
            args: Prisma.personalityTestResultsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$personalityTestResultsPayload>[]
          }
          create: {
            args: Prisma.personalityTestResultsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$personalityTestResultsPayload>
          }
          createMany: {
            args: Prisma.personalityTestResultsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.personalityTestResultsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$personalityTestResultsPayload>[]
          }
          delete: {
            args: Prisma.personalityTestResultsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$personalityTestResultsPayload>
          }
          update: {
            args: Prisma.personalityTestResultsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$personalityTestResultsPayload>
          }
          deleteMany: {
            args: Prisma.personalityTestResultsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.personalityTestResultsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.personalityTestResultsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$personalityTestResultsPayload>[]
          }
          upsert: {
            args: Prisma.personalityTestResultsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$personalityTestResultsPayload>
          }
          aggregate: {
            args: Prisma.PersonalityTestResultsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePersonalityTestResults>
          }
          groupBy: {
            args: Prisma.personalityTestResultsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PersonalityTestResultsGroupByOutputType>[]
          }
          count: {
            args: Prisma.personalityTestResultsCountArgs<ExtArgs>
            result: $Utils.Optional<PersonalityTestResultsCountAggregateOutputType> | number
          }
        }
      }
      projects: {
        payload: Prisma.$projectsPayload<ExtArgs>
        fields: Prisma.projectsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.projectsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.projectsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectsPayload>
          }
          findFirst: {
            args: Prisma.projectsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.projectsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectsPayload>
          }
          findMany: {
            args: Prisma.projectsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectsPayload>[]
          }
          create: {
            args: Prisma.projectsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectsPayload>
          }
          createMany: {
            args: Prisma.projectsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.projectsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectsPayload>[]
          }
          delete: {
            args: Prisma.projectsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectsPayload>
          }
          update: {
            args: Prisma.projectsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectsPayload>
          }
          deleteMany: {
            args: Prisma.projectsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.projectsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.projectsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectsPayload>[]
          }
          upsert: {
            args: Prisma.projectsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$projectsPayload>
          }
          aggregate: {
            args: Prisma.ProjectsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjects>
          }
          groupBy: {
            args: Prisma.projectsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectsGroupByOutputType>[]
          }
          count: {
            args: Prisma.projectsCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectsCountAggregateOutputType> | number
          }
        }
      }
      questions: {
        payload: Prisma.$questionsPayload<ExtArgs>
        fields: Prisma.questionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.questionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.questionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionsPayload>
          }
          findFirst: {
            args: Prisma.questionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.questionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionsPayload>
          }
          findMany: {
            args: Prisma.questionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionsPayload>[]
          }
          create: {
            args: Prisma.questionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionsPayload>
          }
          createMany: {
            args: Prisma.questionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.questionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionsPayload>[]
          }
          delete: {
            args: Prisma.questionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionsPayload>
          }
          update: {
            args: Prisma.questionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionsPayload>
          }
          deleteMany: {
            args: Prisma.questionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.questionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.questionsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionsPayload>[]
          }
          upsert: {
            args: Prisma.questionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$questionsPayload>
          }
          aggregate: {
            args: Prisma.QuestionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestions>
          }
          groupBy: {
            args: Prisma.questionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuestionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.questionsCountArgs<ExtArgs>
            result: $Utils.Optional<QuestionsCountAggregateOutputType> | number
          }
        }
      }
      references: {
        payload: Prisma.$referencesPayload<ExtArgs>
        fields: Prisma.referencesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.referencesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$referencesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.referencesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$referencesPayload>
          }
          findFirst: {
            args: Prisma.referencesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$referencesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.referencesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$referencesPayload>
          }
          findMany: {
            args: Prisma.referencesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$referencesPayload>[]
          }
          create: {
            args: Prisma.referencesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$referencesPayload>
          }
          createMany: {
            args: Prisma.referencesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.referencesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$referencesPayload>[]
          }
          delete: {
            args: Prisma.referencesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$referencesPayload>
          }
          update: {
            args: Prisma.referencesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$referencesPayload>
          }
          deleteMany: {
            args: Prisma.referencesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.referencesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.referencesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$referencesPayload>[]
          }
          upsert: {
            args: Prisma.referencesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$referencesPayload>
          }
          aggregate: {
            args: Prisma.ReferencesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReferences>
          }
          groupBy: {
            args: Prisma.referencesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReferencesGroupByOutputType>[]
          }
          count: {
            args: Prisma.referencesCountArgs<ExtArgs>
            result: $Utils.Optional<ReferencesCountAggregateOutputType> | number
          }
        }
      }
      roles: {
        payload: Prisma.$rolesPayload<ExtArgs>
        fields: Prisma.rolesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.rolesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.rolesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          findFirst: {
            args: Prisma.rolesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.rolesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          findMany: {
            args: Prisma.rolesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>[]
          }
          create: {
            args: Prisma.rolesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          createMany: {
            args: Prisma.rolesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.rolesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>[]
          }
          delete: {
            args: Prisma.rolesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          update: {
            args: Prisma.rolesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          deleteMany: {
            args: Prisma.rolesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.rolesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.rolesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>[]
          }
          upsert: {
            args: Prisma.rolesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          aggregate: {
            args: Prisma.RolesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoles>
          }
          groupBy: {
            args: Prisma.rolesGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolesGroupByOutputType>[]
          }
          count: {
            args: Prisma.rolesCountArgs<ExtArgs>
            result: $Utils.Optional<RolesCountAggregateOutputType> | number
          }
        }
      }
      savedJobs: {
        payload: Prisma.$savedJobsPayload<ExtArgs>
        fields: Prisma.savedJobsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.savedJobsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$savedJobsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.savedJobsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$savedJobsPayload>
          }
          findFirst: {
            args: Prisma.savedJobsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$savedJobsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.savedJobsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$savedJobsPayload>
          }
          findMany: {
            args: Prisma.savedJobsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$savedJobsPayload>[]
          }
          create: {
            args: Prisma.savedJobsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$savedJobsPayload>
          }
          createMany: {
            args: Prisma.savedJobsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.savedJobsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$savedJobsPayload>[]
          }
          delete: {
            args: Prisma.savedJobsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$savedJobsPayload>
          }
          update: {
            args: Prisma.savedJobsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$savedJobsPayload>
          }
          deleteMany: {
            args: Prisma.savedJobsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.savedJobsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.savedJobsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$savedJobsPayload>[]
          }
          upsert: {
            args: Prisma.savedJobsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$savedJobsPayload>
          }
          aggregate: {
            args: Prisma.SavedJobsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSavedJobs>
          }
          groupBy: {
            args: Prisma.savedJobsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SavedJobsGroupByOutputType>[]
          }
          count: {
            args: Prisma.savedJobsCountArgs<ExtArgs>
            result: $Utils.Optional<SavedJobsCountAggregateOutputType> | number
          }
        }
      }
      subscriptions: {
        payload: Prisma.$subscriptionsPayload<ExtArgs>
        fields: Prisma.subscriptionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.subscriptionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.subscriptionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload>
          }
          findFirst: {
            args: Prisma.subscriptionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.subscriptionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload>
          }
          findMany: {
            args: Prisma.subscriptionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload>[]
          }
          create: {
            args: Prisma.subscriptionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload>
          }
          createMany: {
            args: Prisma.subscriptionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.subscriptionsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload>[]
          }
          delete: {
            args: Prisma.subscriptionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload>
          }
          update: {
            args: Prisma.subscriptionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload>
          }
          deleteMany: {
            args: Prisma.subscriptionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.subscriptionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.subscriptionsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload>[]
          }
          upsert: {
            args: Prisma.subscriptionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscriptions>
          }
          groupBy: {
            args: Prisma.subscriptionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.subscriptionsCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionsCountAggregateOutputType> | number
          }
        }
      }
      userActivitiesHistory: {
        payload: Prisma.$userActivitiesHistoryPayload<ExtArgs>
        fields: Prisma.userActivitiesHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userActivitiesHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userActivitiesHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userActivitiesHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userActivitiesHistoryPayload>
          }
          findFirst: {
            args: Prisma.userActivitiesHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userActivitiesHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userActivitiesHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userActivitiesHistoryPayload>
          }
          findMany: {
            args: Prisma.userActivitiesHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userActivitiesHistoryPayload>[]
          }
          create: {
            args: Prisma.userActivitiesHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userActivitiesHistoryPayload>
          }
          createMany: {
            args: Prisma.userActivitiesHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.userActivitiesHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userActivitiesHistoryPayload>[]
          }
          delete: {
            args: Prisma.userActivitiesHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userActivitiesHistoryPayload>
          }
          update: {
            args: Prisma.userActivitiesHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userActivitiesHistoryPayload>
          }
          deleteMany: {
            args: Prisma.userActivitiesHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.userActivitiesHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.userActivitiesHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userActivitiesHistoryPayload>[]
          }
          upsert: {
            args: Prisma.userActivitiesHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userActivitiesHistoryPayload>
          }
          aggregate: {
            args: Prisma.UserActivitiesHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserActivitiesHistory>
          }
          groupBy: {
            args: Prisma.userActivitiesHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserActivitiesHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.userActivitiesHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<UserActivitiesHistoryCountAggregateOutputType> | number
          }
        }
      }
      userNotifications: {
        payload: Prisma.$userNotificationsPayload<ExtArgs>
        fields: Prisma.userNotificationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userNotificationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userNotificationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userNotificationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userNotificationsPayload>
          }
          findFirst: {
            args: Prisma.userNotificationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userNotificationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userNotificationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userNotificationsPayload>
          }
          findMany: {
            args: Prisma.userNotificationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userNotificationsPayload>[]
          }
          create: {
            args: Prisma.userNotificationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userNotificationsPayload>
          }
          createMany: {
            args: Prisma.userNotificationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.userNotificationsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userNotificationsPayload>[]
          }
          delete: {
            args: Prisma.userNotificationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userNotificationsPayload>
          }
          update: {
            args: Prisma.userNotificationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userNotificationsPayload>
          }
          deleteMany: {
            args: Prisma.userNotificationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.userNotificationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.userNotificationsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userNotificationsPayload>[]
          }
          upsert: {
            args: Prisma.userNotificationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userNotificationsPayload>
          }
          aggregate: {
            args: Prisma.UserNotificationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserNotifications>
          }
          groupBy: {
            args: Prisma.userNotificationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserNotificationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.userNotificationsCountArgs<ExtArgs>
            result: $Utils.Optional<UserNotificationsCountAggregateOutputType> | number
          }
        }
      }
      users: {
        payload: Prisma.$usersPayload<ExtArgs>
        fields: Prisma.usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.usersCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.usersUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    answers?: answersOmit
    applicants?: applicantsOmit
    awards?: awardsOmit
    blogs?: blogsOmit
    careerPathSteps?: careerPathStepsOmit
    careerPaths?: careerPathsOmit
    categories?: categoriesOmit
    certificates?: certificatesOmit
    companies?: companiesOmit
    companyActivitiesHistory?: companyActivitiesHistoryOmit
    companyLabels?: companyLabelsOmit
    companyNotifications?: companyNotificationsOmit
    cvs?: cvsOmit
    educations?: educationsOmit
    experiences?: experiencesOmit
    features?: featuresOmit
    feedbacks?: feedbacksOmit
    fields?: fieldsOmit
    followedCompanies?: followedCompaniesOmit
    jobCategories?: jobCategoriesOmit
    jobLabels?: jobLabelsOmit
    jobSpecialized?: jobSpecializedOmit
    jobs?: jobsOmit
    membershipPlans?: membershipPlansOmit
    messages?: messagesOmit
    payments?: paymentsOmit
    personalityTestResults?: personalityTestResultsOmit
    projects?: projectsOmit
    questions?: questionsOmit
    references?: referencesOmit
    roles?: rolesOmit
    savedJobs?: savedJobsOmit
    subscriptions?: subscriptionsOmit
    userActivitiesHistory?: userActivitiesHistoryOmit
    userNotifications?: userNotificationsOmit
    users?: usersOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AnswersCountOutputType
   */

  export type AnswersCountOutputType = {
    personalityTestResults: number
  }

  export type AnswersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    personalityTestResults?: boolean | AnswersCountOutputTypeCountPersonalityTestResultsArgs
  }

  // Custom InputTypes
  /**
   * AnswersCountOutputType without action
   */
  export type AnswersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AnswersCountOutputType
     */
    select?: AnswersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AnswersCountOutputType without action
   */
  export type AnswersCountOutputTypeCountPersonalityTestResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: personalityTestResultsWhereInput
  }


  /**
   * Count Type CareerPathsCountOutputType
   */

  export type CareerPathsCountOutputType = {
    careerPathSteps: number
  }

  export type CareerPathsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    careerPathSteps?: boolean | CareerPathsCountOutputTypeCountCareerPathStepsArgs
  }

  // Custom InputTypes
  /**
   * CareerPathsCountOutputType without action
   */
  export type CareerPathsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CareerPathsCountOutputType
     */
    select?: CareerPathsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CareerPathsCountOutputType without action
   */
  export type CareerPathsCountOutputTypeCountCareerPathStepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: careerPathStepsWhereInput
  }


  /**
   * Count Type CategoriesCountOutputType
   */

  export type CategoriesCountOutputType = {
    jobs: number
  }

  export type CategoriesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobs?: boolean | CategoriesCountOutputTypeCountJobsArgs
  }

  // Custom InputTypes
  /**
   * CategoriesCountOutputType without action
   */
  export type CategoriesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriesCountOutputType
     */
    select?: CategoriesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoriesCountOutputType without action
   */
  export type CategoriesCountOutputTypeCountJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: jobsWhereInput
  }


  /**
   * Count Type CompaniesCountOutputType
   */

  export type CompaniesCountOutputType = {
    companyActivitiesHistory: number
    companyNotifications: number
    feedbacks: number
    followedCompanies: number
  }

  export type CompaniesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companyActivitiesHistory?: boolean | CompaniesCountOutputTypeCountCompanyActivitiesHistoryArgs
    companyNotifications?: boolean | CompaniesCountOutputTypeCountCompanyNotificationsArgs
    feedbacks?: boolean | CompaniesCountOutputTypeCountFeedbacksArgs
    followedCompanies?: boolean | CompaniesCountOutputTypeCountFollowedCompaniesArgs
  }

  // Custom InputTypes
  /**
   * CompaniesCountOutputType without action
   */
  export type CompaniesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesCountOutputType
     */
    select?: CompaniesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompaniesCountOutputType without action
   */
  export type CompaniesCountOutputTypeCountCompanyActivitiesHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: companyActivitiesHistoryWhereInput
  }

  /**
   * CompaniesCountOutputType without action
   */
  export type CompaniesCountOutputTypeCountCompanyNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: companyNotificationsWhereInput
  }

  /**
   * CompaniesCountOutputType without action
   */
  export type CompaniesCountOutputTypeCountFeedbacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: feedbacksWhereInput
  }

  /**
   * CompaniesCountOutputType without action
   */
  export type CompaniesCountOutputTypeCountFollowedCompaniesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: followedCompaniesWhereInput
  }


  /**
   * Count Type CompanyLabelsCountOutputType
   */

  export type CompanyLabelsCountOutputType = {
    companies: number
  }

  export type CompanyLabelsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companies?: boolean | CompanyLabelsCountOutputTypeCountCompaniesArgs
  }

  // Custom InputTypes
  /**
   * CompanyLabelsCountOutputType without action
   */
  export type CompanyLabelsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyLabelsCountOutputType
     */
    select?: CompanyLabelsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompanyLabelsCountOutputType without action
   */
  export type CompanyLabelsCountOutputTypeCountCompaniesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: companiesWhereInput
  }


  /**
   * Count Type CvsCountOutputType
   */

  export type CvsCountOutputType = {
    applicants: number
    awards: number
    certificates: number
    educations: number
    experiences: number
    projects: number
    references: number
  }

  export type CvsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applicants?: boolean | CvsCountOutputTypeCountApplicantsArgs
    awards?: boolean | CvsCountOutputTypeCountAwardsArgs
    certificates?: boolean | CvsCountOutputTypeCountCertificatesArgs
    educations?: boolean | CvsCountOutputTypeCountEducationsArgs
    experiences?: boolean | CvsCountOutputTypeCountExperiencesArgs
    projects?: boolean | CvsCountOutputTypeCountProjectsArgs
    references?: boolean | CvsCountOutputTypeCountReferencesArgs
  }

  // Custom InputTypes
  /**
   * CvsCountOutputType without action
   */
  export type CvsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CvsCountOutputType
     */
    select?: CvsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CvsCountOutputType without action
   */
  export type CvsCountOutputTypeCountApplicantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: applicantsWhereInput
  }

  /**
   * CvsCountOutputType without action
   */
  export type CvsCountOutputTypeCountAwardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: awardsWhereInput
  }

  /**
   * CvsCountOutputType without action
   */
  export type CvsCountOutputTypeCountCertificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: certificatesWhereInput
  }

  /**
   * CvsCountOutputType without action
   */
  export type CvsCountOutputTypeCountEducationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: educationsWhereInput
  }

  /**
   * CvsCountOutputType without action
   */
  export type CvsCountOutputTypeCountExperiencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: experiencesWhereInput
  }

  /**
   * CvsCountOutputType without action
   */
  export type CvsCountOutputTypeCountProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: projectsWhereInput
  }

  /**
   * CvsCountOutputType without action
   */
  export type CvsCountOutputTypeCountReferencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: referencesWhereInput
  }


  /**
   * Count Type FieldsCountOutputType
   */

  export type FieldsCountOutputType = {
    companies: number
  }

  export type FieldsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companies?: boolean | FieldsCountOutputTypeCountCompaniesArgs
  }

  // Custom InputTypes
  /**
   * FieldsCountOutputType without action
   */
  export type FieldsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FieldsCountOutputType
     */
    select?: FieldsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FieldsCountOutputType without action
   */
  export type FieldsCountOutputTypeCountCompaniesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: companiesWhereInput
  }


  /**
   * Count Type JobCategoriesCountOutputType
   */

  export type JobCategoriesCountOutputType = {
    jobSpecialized: number
  }

  export type JobCategoriesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobSpecialized?: boolean | JobCategoriesCountOutputTypeCountJobSpecializedArgs
  }

  // Custom InputTypes
  /**
   * JobCategoriesCountOutputType without action
   */
  export type JobCategoriesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobCategoriesCountOutputType
     */
    select?: JobCategoriesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * JobCategoriesCountOutputType without action
   */
  export type JobCategoriesCountOutputTypeCountJobSpecializedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: jobSpecializedWhereInput
  }


  /**
   * Count Type JobLabelsCountOutputType
   */

  export type JobLabelsCountOutputType = {
    jobs: number
  }

  export type JobLabelsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobs?: boolean | JobLabelsCountOutputTypeCountJobsArgs
  }

  // Custom InputTypes
  /**
   * JobLabelsCountOutputType without action
   */
  export type JobLabelsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobLabelsCountOutputType
     */
    select?: JobLabelsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * JobLabelsCountOutputType without action
   */
  export type JobLabelsCountOutputTypeCountJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: jobsWhereInput
  }


  /**
   * Count Type JobsCountOutputType
   */

  export type JobsCountOutputType = {
    applicants: number
    savedJobs: number
  }

  export type JobsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applicants?: boolean | JobsCountOutputTypeCountApplicantsArgs
    savedJobs?: boolean | JobsCountOutputTypeCountSavedJobsArgs
  }

  // Custom InputTypes
  /**
   * JobsCountOutputType without action
   */
  export type JobsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JobsCountOutputType
     */
    select?: JobsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * JobsCountOutputType without action
   */
  export type JobsCountOutputTypeCountApplicantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: applicantsWhereInput
  }

  /**
   * JobsCountOutputType without action
   */
  export type JobsCountOutputTypeCountSavedJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: savedJobsWhereInput
  }


  /**
   * Count Type MembershipPlansCountOutputType
   */

  export type MembershipPlansCountOutputType = {
    features: number
    subscriptions: number
  }

  export type MembershipPlansCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    features?: boolean | MembershipPlansCountOutputTypeCountFeaturesArgs
    subscriptions?: boolean | MembershipPlansCountOutputTypeCountSubscriptionsArgs
  }

  // Custom InputTypes
  /**
   * MembershipPlansCountOutputType without action
   */
  export type MembershipPlansCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MembershipPlansCountOutputType
     */
    select?: MembershipPlansCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MembershipPlansCountOutputType without action
   */
  export type MembershipPlansCountOutputTypeCountFeaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: featuresWhereInput
  }

  /**
   * MembershipPlansCountOutputType without action
   */
  export type MembershipPlansCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: subscriptionsWhereInput
  }


  /**
   * Count Type QuestionsCountOutputType
   */

  export type QuestionsCountOutputType = {
    answers: number
    personalityTestResults: number
  }

  export type QuestionsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    answers?: boolean | QuestionsCountOutputTypeCountAnswersArgs
    personalityTestResults?: boolean | QuestionsCountOutputTypeCountPersonalityTestResultsArgs
  }

  // Custom InputTypes
  /**
   * QuestionsCountOutputType without action
   */
  export type QuestionsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionsCountOutputType
     */
    select?: QuestionsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuestionsCountOutputType without action
   */
  export type QuestionsCountOutputTypeCountAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: answersWhereInput
  }

  /**
   * QuestionsCountOutputType without action
   */
  export type QuestionsCountOutputTypeCountPersonalityTestResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: personalityTestResultsWhereInput
  }


  /**
   * Count Type RolesCountOutputType
   */

  export type RolesCountOutputType = {
    users: number
  }

  export type RolesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | RolesCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * RolesCountOutputType without action
   */
  export type RolesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolesCountOutputType
     */
    select?: RolesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RolesCountOutputType without action
   */
  export type RolesCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
  }


  /**
   * Count Type UsersCountOutputType
   */

  export type UsersCountOutputType = {
    blogs: number
    careerPaths: number
    feedbacks: number
    followedCompanies: number
    messages: number
    payments: number
    personalityTestResults: number
    savedJobs: number
    subscriptions: number
    userActivitiesHistory: number
    userNotifications: number
  }

  export type UsersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blogs?: boolean | UsersCountOutputTypeCountBlogsArgs
    careerPaths?: boolean | UsersCountOutputTypeCountCareerPathsArgs
    feedbacks?: boolean | UsersCountOutputTypeCountFeedbacksArgs
    followedCompanies?: boolean | UsersCountOutputTypeCountFollowedCompaniesArgs
    messages?: boolean | UsersCountOutputTypeCountMessagesArgs
    payments?: boolean | UsersCountOutputTypeCountPaymentsArgs
    personalityTestResults?: boolean | UsersCountOutputTypeCountPersonalityTestResultsArgs
    savedJobs?: boolean | UsersCountOutputTypeCountSavedJobsArgs
    subscriptions?: boolean | UsersCountOutputTypeCountSubscriptionsArgs
    userActivitiesHistory?: boolean | UsersCountOutputTypeCountUserActivitiesHistoryArgs
    userNotifications?: boolean | UsersCountOutputTypeCountUserNotificationsArgs
  }

  // Custom InputTypes
  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsersCountOutputType
     */
    select?: UsersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountBlogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: blogsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountCareerPathsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: careerPathsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountFeedbacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: feedbacksWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountFollowedCompaniesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: followedCompaniesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: messagesWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paymentsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountPersonalityTestResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: personalityTestResultsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountSavedJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: savedJobsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: subscriptionsWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountUserActivitiesHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userActivitiesHistoryWhereInput
  }

  /**
   * UsersCountOutputType without action
   */
  export type UsersCountOutputTypeCountUserNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userNotificationsWhereInput
  }


  /**
   * Models
   */

  /**
   * Model answers
   */

  export type AggregateAnswers = {
    _count: AnswersCountAggregateOutputType | null
    _avg: AnswersAvgAggregateOutputType | null
    _sum: AnswersSumAggregateOutputType | null
    _min: AnswersMinAggregateOutputType | null
    _max: AnswersMaxAggregateOutputType | null
  }

  export type AnswersAvgAggregateOutputType = {
    id: number | null
    question_id: number | null
  }

  export type AnswersSumAggregateOutputType = {
    id: number | null
    question_id: number | null
  }

  export type AnswersMinAggregateOutputType = {
    id: number | null
    answer: string | null
    question_id: number | null
  }

  export type AnswersMaxAggregateOutputType = {
    id: number | null
    answer: string | null
    question_id: number | null
  }

  export type AnswersCountAggregateOutputType = {
    id: number
    answer: number
    question_id: number
    _all: number
  }


  export type AnswersAvgAggregateInputType = {
    id?: true
    question_id?: true
  }

  export type AnswersSumAggregateInputType = {
    id?: true
    question_id?: true
  }

  export type AnswersMinAggregateInputType = {
    id?: true
    answer?: true
    question_id?: true
  }

  export type AnswersMaxAggregateInputType = {
    id?: true
    answer?: true
    question_id?: true
  }

  export type AnswersCountAggregateInputType = {
    id?: true
    answer?: true
    question_id?: true
    _all?: true
  }

  export type AnswersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which answers to aggregate.
     */
    where?: answersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of answers to fetch.
     */
    orderBy?: answersOrderByWithRelationInput | answersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: answersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` answers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned answers
    **/
    _count?: true | AnswersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AnswersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AnswersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AnswersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AnswersMaxAggregateInputType
  }

  export type GetAnswersAggregateType<T extends AnswersAggregateArgs> = {
        [P in keyof T & keyof AggregateAnswers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnswers[P]>
      : GetScalarType<T[P], AggregateAnswers[P]>
  }




  export type answersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: answersWhereInput
    orderBy?: answersOrderByWithAggregationInput | answersOrderByWithAggregationInput[]
    by: AnswersScalarFieldEnum[] | AnswersScalarFieldEnum
    having?: answersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AnswersCountAggregateInputType | true
    _avg?: AnswersAvgAggregateInputType
    _sum?: AnswersSumAggregateInputType
    _min?: AnswersMinAggregateInputType
    _max?: AnswersMaxAggregateInputType
  }

  export type AnswersGroupByOutputType = {
    id: number
    answer: string
    question_id: number
    _count: AnswersCountAggregateOutputType | null
    _avg: AnswersAvgAggregateOutputType | null
    _sum: AnswersSumAggregateOutputType | null
    _min: AnswersMinAggregateOutputType | null
    _max: AnswersMaxAggregateOutputType | null
  }

  type GetAnswersGroupByPayload<T extends answersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnswersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AnswersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnswersGroupByOutputType[P]>
            : GetScalarType<T[P], AnswersGroupByOutputType[P]>
        }
      >
    >


  export type answersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    answer?: boolean
    question_id?: boolean
    questions?: boolean | questionsDefaultArgs<ExtArgs>
    personalityTestResults?: boolean | answers$personalityTestResultsArgs<ExtArgs>
    _count?: boolean | AnswersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["answers"]>

  export type answersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    answer?: boolean
    question_id?: boolean
    questions?: boolean | questionsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["answers"]>

  export type answersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    answer?: boolean
    question_id?: boolean
    questions?: boolean | questionsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["answers"]>

  export type answersSelectScalar = {
    id?: boolean
    answer?: boolean
    question_id?: boolean
  }

  export type answersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "answer" | "question_id", ExtArgs["result"]["answers"]>
  export type answersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | questionsDefaultArgs<ExtArgs>
    personalityTestResults?: boolean | answers$personalityTestResultsArgs<ExtArgs>
    _count?: boolean | AnswersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type answersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | questionsDefaultArgs<ExtArgs>
  }
  export type answersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | questionsDefaultArgs<ExtArgs>
  }

  export type $answersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "answers"
    objects: {
      questions: Prisma.$questionsPayload<ExtArgs>
      personalityTestResults: Prisma.$personalityTestResultsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      answer: string
      question_id: number
    }, ExtArgs["result"]["answers"]>
    composites: {}
  }

  type answersGetPayload<S extends boolean | null | undefined | answersDefaultArgs> = $Result.GetResult<Prisma.$answersPayload, S>

  type answersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<answersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AnswersCountAggregateInputType | true
    }

  export interface answersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['answers'], meta: { name: 'answers' } }
    /**
     * Find zero or one Answers that matches the filter.
     * @param {answersFindUniqueArgs} args - Arguments to find a Answers
     * @example
     * // Get one Answers
     * const answers = await prisma.answers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends answersFindUniqueArgs>(args: SelectSubset<T, answersFindUniqueArgs<ExtArgs>>): Prisma__answersClient<$Result.GetResult<Prisma.$answersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Answers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {answersFindUniqueOrThrowArgs} args - Arguments to find a Answers
     * @example
     * // Get one Answers
     * const answers = await prisma.answers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends answersFindUniqueOrThrowArgs>(args: SelectSubset<T, answersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__answersClient<$Result.GetResult<Prisma.$answersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Answers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {answersFindFirstArgs} args - Arguments to find a Answers
     * @example
     * // Get one Answers
     * const answers = await prisma.answers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends answersFindFirstArgs>(args?: SelectSubset<T, answersFindFirstArgs<ExtArgs>>): Prisma__answersClient<$Result.GetResult<Prisma.$answersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Answers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {answersFindFirstOrThrowArgs} args - Arguments to find a Answers
     * @example
     * // Get one Answers
     * const answers = await prisma.answers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends answersFindFirstOrThrowArgs>(args?: SelectSubset<T, answersFindFirstOrThrowArgs<ExtArgs>>): Prisma__answersClient<$Result.GetResult<Prisma.$answersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Answers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {answersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Answers
     * const answers = await prisma.answers.findMany()
     * 
     * // Get first 10 Answers
     * const answers = await prisma.answers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const answersWithIdOnly = await prisma.answers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends answersFindManyArgs>(args?: SelectSubset<T, answersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$answersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Answers.
     * @param {answersCreateArgs} args - Arguments to create a Answers.
     * @example
     * // Create one Answers
     * const Answers = await prisma.answers.create({
     *   data: {
     *     // ... data to create a Answers
     *   }
     * })
     * 
     */
    create<T extends answersCreateArgs>(args: SelectSubset<T, answersCreateArgs<ExtArgs>>): Prisma__answersClient<$Result.GetResult<Prisma.$answersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Answers.
     * @param {answersCreateManyArgs} args - Arguments to create many Answers.
     * @example
     * // Create many Answers
     * const answers = await prisma.answers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends answersCreateManyArgs>(args?: SelectSubset<T, answersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Answers and returns the data saved in the database.
     * @param {answersCreateManyAndReturnArgs} args - Arguments to create many Answers.
     * @example
     * // Create many Answers
     * const answers = await prisma.answers.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Answers and only return the `id`
     * const answersWithIdOnly = await prisma.answers.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends answersCreateManyAndReturnArgs>(args?: SelectSubset<T, answersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$answersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Answers.
     * @param {answersDeleteArgs} args - Arguments to delete one Answers.
     * @example
     * // Delete one Answers
     * const Answers = await prisma.answers.delete({
     *   where: {
     *     // ... filter to delete one Answers
     *   }
     * })
     * 
     */
    delete<T extends answersDeleteArgs>(args: SelectSubset<T, answersDeleteArgs<ExtArgs>>): Prisma__answersClient<$Result.GetResult<Prisma.$answersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Answers.
     * @param {answersUpdateArgs} args - Arguments to update one Answers.
     * @example
     * // Update one Answers
     * const answers = await prisma.answers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends answersUpdateArgs>(args: SelectSubset<T, answersUpdateArgs<ExtArgs>>): Prisma__answersClient<$Result.GetResult<Prisma.$answersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Answers.
     * @param {answersDeleteManyArgs} args - Arguments to filter Answers to delete.
     * @example
     * // Delete a few Answers
     * const { count } = await prisma.answers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends answersDeleteManyArgs>(args?: SelectSubset<T, answersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Answers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {answersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Answers
     * const answers = await prisma.answers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends answersUpdateManyArgs>(args: SelectSubset<T, answersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Answers and returns the data updated in the database.
     * @param {answersUpdateManyAndReturnArgs} args - Arguments to update many Answers.
     * @example
     * // Update many Answers
     * const answers = await prisma.answers.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Answers and only return the `id`
     * const answersWithIdOnly = await prisma.answers.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends answersUpdateManyAndReturnArgs>(args: SelectSubset<T, answersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$answersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Answers.
     * @param {answersUpsertArgs} args - Arguments to update or create a Answers.
     * @example
     * // Update or create a Answers
     * const answers = await prisma.answers.upsert({
     *   create: {
     *     // ... data to create a Answers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Answers we want to update
     *   }
     * })
     */
    upsert<T extends answersUpsertArgs>(args: SelectSubset<T, answersUpsertArgs<ExtArgs>>): Prisma__answersClient<$Result.GetResult<Prisma.$answersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Answers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {answersCountArgs} args - Arguments to filter Answers to count.
     * @example
     * // Count the number of Answers
     * const count = await prisma.answers.count({
     *   where: {
     *     // ... the filter for the Answers we want to count
     *   }
     * })
    **/
    count<T extends answersCountArgs>(
      args?: Subset<T, answersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnswersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Answers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnswersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AnswersAggregateArgs>(args: Subset<T, AnswersAggregateArgs>): Prisma.PrismaPromise<GetAnswersAggregateType<T>>

    /**
     * Group by Answers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {answersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends answersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: answersGroupByArgs['orderBy'] }
        : { orderBy?: answersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, answersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAnswersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the answers model
   */
  readonly fields: answersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for answers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__answersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    questions<T extends questionsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, questionsDefaultArgs<ExtArgs>>): Prisma__questionsClient<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    personalityTestResults<T extends answers$personalityTestResultsArgs<ExtArgs> = {}>(args?: Subset<T, answers$personalityTestResultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$personalityTestResultsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the answers model
   */
  interface answersFieldRefs {
    readonly id: FieldRef<"answers", 'Int'>
    readonly answer: FieldRef<"answers", 'String'>
    readonly question_id: FieldRef<"answers", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * answers findUnique
   */
  export type answersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the answers
     */
    select?: answersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the answers
     */
    omit?: answersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: answersInclude<ExtArgs> | null
    /**
     * Filter, which answers to fetch.
     */
    where: answersWhereUniqueInput
  }

  /**
   * answers findUniqueOrThrow
   */
  export type answersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the answers
     */
    select?: answersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the answers
     */
    omit?: answersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: answersInclude<ExtArgs> | null
    /**
     * Filter, which answers to fetch.
     */
    where: answersWhereUniqueInput
  }

  /**
   * answers findFirst
   */
  export type answersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the answers
     */
    select?: answersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the answers
     */
    omit?: answersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: answersInclude<ExtArgs> | null
    /**
     * Filter, which answers to fetch.
     */
    where?: answersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of answers to fetch.
     */
    orderBy?: answersOrderByWithRelationInput | answersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for answers.
     */
    cursor?: answersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` answers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of answers.
     */
    distinct?: AnswersScalarFieldEnum | AnswersScalarFieldEnum[]
  }

  /**
   * answers findFirstOrThrow
   */
  export type answersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the answers
     */
    select?: answersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the answers
     */
    omit?: answersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: answersInclude<ExtArgs> | null
    /**
     * Filter, which answers to fetch.
     */
    where?: answersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of answers to fetch.
     */
    orderBy?: answersOrderByWithRelationInput | answersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for answers.
     */
    cursor?: answersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` answers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of answers.
     */
    distinct?: AnswersScalarFieldEnum | AnswersScalarFieldEnum[]
  }

  /**
   * answers findMany
   */
  export type answersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the answers
     */
    select?: answersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the answers
     */
    omit?: answersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: answersInclude<ExtArgs> | null
    /**
     * Filter, which answers to fetch.
     */
    where?: answersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of answers to fetch.
     */
    orderBy?: answersOrderByWithRelationInput | answersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing answers.
     */
    cursor?: answersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` answers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` answers.
     */
    skip?: number
    distinct?: AnswersScalarFieldEnum | AnswersScalarFieldEnum[]
  }

  /**
   * answers create
   */
  export type answersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the answers
     */
    select?: answersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the answers
     */
    omit?: answersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: answersInclude<ExtArgs> | null
    /**
     * The data needed to create a answers.
     */
    data: XOR<answersCreateInput, answersUncheckedCreateInput>
  }

  /**
   * answers createMany
   */
  export type answersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many answers.
     */
    data: answersCreateManyInput | answersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * answers createManyAndReturn
   */
  export type answersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the answers
     */
    select?: answersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the answers
     */
    omit?: answersOmit<ExtArgs> | null
    /**
     * The data used to create many answers.
     */
    data: answersCreateManyInput | answersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: answersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * answers update
   */
  export type answersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the answers
     */
    select?: answersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the answers
     */
    omit?: answersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: answersInclude<ExtArgs> | null
    /**
     * The data needed to update a answers.
     */
    data: XOR<answersUpdateInput, answersUncheckedUpdateInput>
    /**
     * Choose, which answers to update.
     */
    where: answersWhereUniqueInput
  }

  /**
   * answers updateMany
   */
  export type answersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update answers.
     */
    data: XOR<answersUpdateManyMutationInput, answersUncheckedUpdateManyInput>
    /**
     * Filter which answers to update
     */
    where?: answersWhereInput
    /**
     * Limit how many answers to update.
     */
    limit?: number
  }

  /**
   * answers updateManyAndReturn
   */
  export type answersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the answers
     */
    select?: answersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the answers
     */
    omit?: answersOmit<ExtArgs> | null
    /**
     * The data used to update answers.
     */
    data: XOR<answersUpdateManyMutationInput, answersUncheckedUpdateManyInput>
    /**
     * Filter which answers to update
     */
    where?: answersWhereInput
    /**
     * Limit how many answers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: answersIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * answers upsert
   */
  export type answersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the answers
     */
    select?: answersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the answers
     */
    omit?: answersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: answersInclude<ExtArgs> | null
    /**
     * The filter to search for the answers to update in case it exists.
     */
    where: answersWhereUniqueInput
    /**
     * In case the answers found by the `where` argument doesn't exist, create a new answers with this data.
     */
    create: XOR<answersCreateInput, answersUncheckedCreateInput>
    /**
     * In case the answers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<answersUpdateInput, answersUncheckedUpdateInput>
  }

  /**
   * answers delete
   */
  export type answersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the answers
     */
    select?: answersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the answers
     */
    omit?: answersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: answersInclude<ExtArgs> | null
    /**
     * Filter which answers to delete.
     */
    where: answersWhereUniqueInput
  }

  /**
   * answers deleteMany
   */
  export type answersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which answers to delete
     */
    where?: answersWhereInput
    /**
     * Limit how many answers to delete.
     */
    limit?: number
  }

  /**
   * answers.personalityTestResults
   */
  export type answers$personalityTestResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the personalityTestResults
     */
    select?: personalityTestResultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the personalityTestResults
     */
    omit?: personalityTestResultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: personalityTestResultsInclude<ExtArgs> | null
    where?: personalityTestResultsWhereInput
    orderBy?: personalityTestResultsOrderByWithRelationInput | personalityTestResultsOrderByWithRelationInput[]
    cursor?: personalityTestResultsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersonalityTestResultsScalarFieldEnum | PersonalityTestResultsScalarFieldEnum[]
  }

  /**
   * answers without action
   */
  export type answersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the answers
     */
    select?: answersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the answers
     */
    omit?: answersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: answersInclude<ExtArgs> | null
  }


  /**
   * Model applicants
   */

  export type AggregateApplicants = {
    _count: ApplicantsCountAggregateOutputType | null
    _avg: ApplicantsAvgAggregateOutputType | null
    _sum: ApplicantsSumAggregateOutputType | null
    _min: ApplicantsMinAggregateOutputType | null
    _max: ApplicantsMaxAggregateOutputType | null
  }

  export type ApplicantsAvgAggregateOutputType = {
    cv_id: number | null
  }

  export type ApplicantsSumAggregateOutputType = {
    cv_id: number | null
  }

  export type ApplicantsMinAggregateOutputType = {
    cv_id: number | null
    job_id: string | null
    description: string | null
    apply_date: Date | null
    verified_date: Date | null
    status: $Enums.ApplicantsStatus | null
    feedback: string | null
  }

  export type ApplicantsMaxAggregateOutputType = {
    cv_id: number | null
    job_id: string | null
    description: string | null
    apply_date: Date | null
    verified_date: Date | null
    status: $Enums.ApplicantsStatus | null
    feedback: string | null
  }

  export type ApplicantsCountAggregateOutputType = {
    cv_id: number
    job_id: number
    description: number
    apply_date: number
    verified_date: number
    status: number
    feedback: number
    _all: number
  }


  export type ApplicantsAvgAggregateInputType = {
    cv_id?: true
  }

  export type ApplicantsSumAggregateInputType = {
    cv_id?: true
  }

  export type ApplicantsMinAggregateInputType = {
    cv_id?: true
    job_id?: true
    description?: true
    apply_date?: true
    verified_date?: true
    status?: true
    feedback?: true
  }

  export type ApplicantsMaxAggregateInputType = {
    cv_id?: true
    job_id?: true
    description?: true
    apply_date?: true
    verified_date?: true
    status?: true
    feedback?: true
  }

  export type ApplicantsCountAggregateInputType = {
    cv_id?: true
    job_id?: true
    description?: true
    apply_date?: true
    verified_date?: true
    status?: true
    feedback?: true
    _all?: true
  }

  export type ApplicantsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which applicants to aggregate.
     */
    where?: applicantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of applicants to fetch.
     */
    orderBy?: applicantsOrderByWithRelationInput | applicantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: applicantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` applicants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` applicants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned applicants
    **/
    _count?: true | ApplicantsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ApplicantsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ApplicantsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApplicantsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApplicantsMaxAggregateInputType
  }

  export type GetApplicantsAggregateType<T extends ApplicantsAggregateArgs> = {
        [P in keyof T & keyof AggregateApplicants]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApplicants[P]>
      : GetScalarType<T[P], AggregateApplicants[P]>
  }




  export type applicantsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: applicantsWhereInput
    orderBy?: applicantsOrderByWithAggregationInput | applicantsOrderByWithAggregationInput[]
    by: ApplicantsScalarFieldEnum[] | ApplicantsScalarFieldEnum
    having?: applicantsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApplicantsCountAggregateInputType | true
    _avg?: ApplicantsAvgAggregateInputType
    _sum?: ApplicantsSumAggregateInputType
    _min?: ApplicantsMinAggregateInputType
    _max?: ApplicantsMaxAggregateInputType
  }

  export type ApplicantsGroupByOutputType = {
    cv_id: number
    job_id: string
    description: string | null
    apply_date: Date
    verified_date: Date
    status: $Enums.ApplicantsStatus
    feedback: string | null
    _count: ApplicantsCountAggregateOutputType | null
    _avg: ApplicantsAvgAggregateOutputType | null
    _sum: ApplicantsSumAggregateOutputType | null
    _min: ApplicantsMinAggregateOutputType | null
    _max: ApplicantsMaxAggregateOutputType | null
  }

  type GetApplicantsGroupByPayload<T extends applicantsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApplicantsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApplicantsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApplicantsGroupByOutputType[P]>
            : GetScalarType<T[P], ApplicantsGroupByOutputType[P]>
        }
      >
    >


  export type applicantsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cv_id?: boolean
    job_id?: boolean
    description?: boolean
    apply_date?: boolean
    verified_date?: boolean
    status?: boolean
    feedback?: boolean
    cvs?: boolean | cvsDefaultArgs<ExtArgs>
    jobs?: boolean | jobsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["applicants"]>

  export type applicantsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cv_id?: boolean
    job_id?: boolean
    description?: boolean
    apply_date?: boolean
    verified_date?: boolean
    status?: boolean
    feedback?: boolean
    cvs?: boolean | cvsDefaultArgs<ExtArgs>
    jobs?: boolean | jobsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["applicants"]>

  export type applicantsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    cv_id?: boolean
    job_id?: boolean
    description?: boolean
    apply_date?: boolean
    verified_date?: boolean
    status?: boolean
    feedback?: boolean
    cvs?: boolean | cvsDefaultArgs<ExtArgs>
    jobs?: boolean | jobsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["applicants"]>

  export type applicantsSelectScalar = {
    cv_id?: boolean
    job_id?: boolean
    description?: boolean
    apply_date?: boolean
    verified_date?: boolean
    status?: boolean
    feedback?: boolean
  }

  export type applicantsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"cv_id" | "job_id" | "description" | "apply_date" | "verified_date" | "status" | "feedback", ExtArgs["result"]["applicants"]>
  export type applicantsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cvs?: boolean | cvsDefaultArgs<ExtArgs>
    jobs?: boolean | jobsDefaultArgs<ExtArgs>
  }
  export type applicantsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cvs?: boolean | cvsDefaultArgs<ExtArgs>
    jobs?: boolean | jobsDefaultArgs<ExtArgs>
  }
  export type applicantsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cvs?: boolean | cvsDefaultArgs<ExtArgs>
    jobs?: boolean | jobsDefaultArgs<ExtArgs>
  }

  export type $applicantsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "applicants"
    objects: {
      cvs: Prisma.$cvsPayload<ExtArgs>
      jobs: Prisma.$jobsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      cv_id: number
      job_id: string
      description: string | null
      apply_date: Date
      verified_date: Date
      status: $Enums.ApplicantsStatus
      feedback: string | null
    }, ExtArgs["result"]["applicants"]>
    composites: {}
  }

  type applicantsGetPayload<S extends boolean | null | undefined | applicantsDefaultArgs> = $Result.GetResult<Prisma.$applicantsPayload, S>

  type applicantsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<applicantsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ApplicantsCountAggregateInputType | true
    }

  export interface applicantsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['applicants'], meta: { name: 'applicants' } }
    /**
     * Find zero or one Applicants that matches the filter.
     * @param {applicantsFindUniqueArgs} args - Arguments to find a Applicants
     * @example
     * // Get one Applicants
     * const applicants = await prisma.applicants.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends applicantsFindUniqueArgs>(args: SelectSubset<T, applicantsFindUniqueArgs<ExtArgs>>): Prisma__applicantsClient<$Result.GetResult<Prisma.$applicantsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Applicants that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {applicantsFindUniqueOrThrowArgs} args - Arguments to find a Applicants
     * @example
     * // Get one Applicants
     * const applicants = await prisma.applicants.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends applicantsFindUniqueOrThrowArgs>(args: SelectSubset<T, applicantsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__applicantsClient<$Result.GetResult<Prisma.$applicantsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Applicants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {applicantsFindFirstArgs} args - Arguments to find a Applicants
     * @example
     * // Get one Applicants
     * const applicants = await prisma.applicants.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends applicantsFindFirstArgs>(args?: SelectSubset<T, applicantsFindFirstArgs<ExtArgs>>): Prisma__applicantsClient<$Result.GetResult<Prisma.$applicantsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Applicants that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {applicantsFindFirstOrThrowArgs} args - Arguments to find a Applicants
     * @example
     * // Get one Applicants
     * const applicants = await prisma.applicants.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends applicantsFindFirstOrThrowArgs>(args?: SelectSubset<T, applicantsFindFirstOrThrowArgs<ExtArgs>>): Prisma__applicantsClient<$Result.GetResult<Prisma.$applicantsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Applicants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {applicantsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Applicants
     * const applicants = await prisma.applicants.findMany()
     * 
     * // Get first 10 Applicants
     * const applicants = await prisma.applicants.findMany({ take: 10 })
     * 
     * // Only select the `cv_id`
     * const applicantsWithCv_idOnly = await prisma.applicants.findMany({ select: { cv_id: true } })
     * 
     */
    findMany<T extends applicantsFindManyArgs>(args?: SelectSubset<T, applicantsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$applicantsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Applicants.
     * @param {applicantsCreateArgs} args - Arguments to create a Applicants.
     * @example
     * // Create one Applicants
     * const Applicants = await prisma.applicants.create({
     *   data: {
     *     // ... data to create a Applicants
     *   }
     * })
     * 
     */
    create<T extends applicantsCreateArgs>(args: SelectSubset<T, applicantsCreateArgs<ExtArgs>>): Prisma__applicantsClient<$Result.GetResult<Prisma.$applicantsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Applicants.
     * @param {applicantsCreateManyArgs} args - Arguments to create many Applicants.
     * @example
     * // Create many Applicants
     * const applicants = await prisma.applicants.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends applicantsCreateManyArgs>(args?: SelectSubset<T, applicantsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Applicants and returns the data saved in the database.
     * @param {applicantsCreateManyAndReturnArgs} args - Arguments to create many Applicants.
     * @example
     * // Create many Applicants
     * const applicants = await prisma.applicants.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Applicants and only return the `cv_id`
     * const applicantsWithCv_idOnly = await prisma.applicants.createManyAndReturn({
     *   select: { cv_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends applicantsCreateManyAndReturnArgs>(args?: SelectSubset<T, applicantsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$applicantsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Applicants.
     * @param {applicantsDeleteArgs} args - Arguments to delete one Applicants.
     * @example
     * // Delete one Applicants
     * const Applicants = await prisma.applicants.delete({
     *   where: {
     *     // ... filter to delete one Applicants
     *   }
     * })
     * 
     */
    delete<T extends applicantsDeleteArgs>(args: SelectSubset<T, applicantsDeleteArgs<ExtArgs>>): Prisma__applicantsClient<$Result.GetResult<Prisma.$applicantsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Applicants.
     * @param {applicantsUpdateArgs} args - Arguments to update one Applicants.
     * @example
     * // Update one Applicants
     * const applicants = await prisma.applicants.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends applicantsUpdateArgs>(args: SelectSubset<T, applicantsUpdateArgs<ExtArgs>>): Prisma__applicantsClient<$Result.GetResult<Prisma.$applicantsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Applicants.
     * @param {applicantsDeleteManyArgs} args - Arguments to filter Applicants to delete.
     * @example
     * // Delete a few Applicants
     * const { count } = await prisma.applicants.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends applicantsDeleteManyArgs>(args?: SelectSubset<T, applicantsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Applicants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {applicantsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Applicants
     * const applicants = await prisma.applicants.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends applicantsUpdateManyArgs>(args: SelectSubset<T, applicantsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Applicants and returns the data updated in the database.
     * @param {applicantsUpdateManyAndReturnArgs} args - Arguments to update many Applicants.
     * @example
     * // Update many Applicants
     * const applicants = await prisma.applicants.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Applicants and only return the `cv_id`
     * const applicantsWithCv_idOnly = await prisma.applicants.updateManyAndReturn({
     *   select: { cv_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends applicantsUpdateManyAndReturnArgs>(args: SelectSubset<T, applicantsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$applicantsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Applicants.
     * @param {applicantsUpsertArgs} args - Arguments to update or create a Applicants.
     * @example
     * // Update or create a Applicants
     * const applicants = await prisma.applicants.upsert({
     *   create: {
     *     // ... data to create a Applicants
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Applicants we want to update
     *   }
     * })
     */
    upsert<T extends applicantsUpsertArgs>(args: SelectSubset<T, applicantsUpsertArgs<ExtArgs>>): Prisma__applicantsClient<$Result.GetResult<Prisma.$applicantsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Applicants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {applicantsCountArgs} args - Arguments to filter Applicants to count.
     * @example
     * // Count the number of Applicants
     * const count = await prisma.applicants.count({
     *   where: {
     *     // ... the filter for the Applicants we want to count
     *   }
     * })
    **/
    count<T extends applicantsCountArgs>(
      args?: Subset<T, applicantsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApplicantsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Applicants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApplicantsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApplicantsAggregateArgs>(args: Subset<T, ApplicantsAggregateArgs>): Prisma.PrismaPromise<GetApplicantsAggregateType<T>>

    /**
     * Group by Applicants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {applicantsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends applicantsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: applicantsGroupByArgs['orderBy'] }
        : { orderBy?: applicantsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, applicantsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApplicantsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the applicants model
   */
  readonly fields: applicantsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for applicants.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__applicantsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cvs<T extends cvsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, cvsDefaultArgs<ExtArgs>>): Prisma__cvsClient<$Result.GetResult<Prisma.$cvsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    jobs<T extends jobsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, jobsDefaultArgs<ExtArgs>>): Prisma__jobsClient<$Result.GetResult<Prisma.$jobsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the applicants model
   */
  interface applicantsFieldRefs {
    readonly cv_id: FieldRef<"applicants", 'Int'>
    readonly job_id: FieldRef<"applicants", 'String'>
    readonly description: FieldRef<"applicants", 'String'>
    readonly apply_date: FieldRef<"applicants", 'DateTime'>
    readonly verified_date: FieldRef<"applicants", 'DateTime'>
    readonly status: FieldRef<"applicants", 'ApplicantsStatus'>
    readonly feedback: FieldRef<"applicants", 'String'>
  }
    

  // Custom InputTypes
  /**
   * applicants findUnique
   */
  export type applicantsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicants
     */
    select?: applicantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applicants
     */
    omit?: applicantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicantsInclude<ExtArgs> | null
    /**
     * Filter, which applicants to fetch.
     */
    where: applicantsWhereUniqueInput
  }

  /**
   * applicants findUniqueOrThrow
   */
  export type applicantsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicants
     */
    select?: applicantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applicants
     */
    omit?: applicantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicantsInclude<ExtArgs> | null
    /**
     * Filter, which applicants to fetch.
     */
    where: applicantsWhereUniqueInput
  }

  /**
   * applicants findFirst
   */
  export type applicantsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicants
     */
    select?: applicantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applicants
     */
    omit?: applicantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicantsInclude<ExtArgs> | null
    /**
     * Filter, which applicants to fetch.
     */
    where?: applicantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of applicants to fetch.
     */
    orderBy?: applicantsOrderByWithRelationInput | applicantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for applicants.
     */
    cursor?: applicantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` applicants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` applicants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of applicants.
     */
    distinct?: ApplicantsScalarFieldEnum | ApplicantsScalarFieldEnum[]
  }

  /**
   * applicants findFirstOrThrow
   */
  export type applicantsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicants
     */
    select?: applicantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applicants
     */
    omit?: applicantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicantsInclude<ExtArgs> | null
    /**
     * Filter, which applicants to fetch.
     */
    where?: applicantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of applicants to fetch.
     */
    orderBy?: applicantsOrderByWithRelationInput | applicantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for applicants.
     */
    cursor?: applicantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` applicants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` applicants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of applicants.
     */
    distinct?: ApplicantsScalarFieldEnum | ApplicantsScalarFieldEnum[]
  }

  /**
   * applicants findMany
   */
  export type applicantsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicants
     */
    select?: applicantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applicants
     */
    omit?: applicantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicantsInclude<ExtArgs> | null
    /**
     * Filter, which applicants to fetch.
     */
    where?: applicantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of applicants to fetch.
     */
    orderBy?: applicantsOrderByWithRelationInput | applicantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing applicants.
     */
    cursor?: applicantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` applicants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` applicants.
     */
    skip?: number
    distinct?: ApplicantsScalarFieldEnum | ApplicantsScalarFieldEnum[]
  }

  /**
   * applicants create
   */
  export type applicantsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicants
     */
    select?: applicantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applicants
     */
    omit?: applicantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicantsInclude<ExtArgs> | null
    /**
     * The data needed to create a applicants.
     */
    data: XOR<applicantsCreateInput, applicantsUncheckedCreateInput>
  }

  /**
   * applicants createMany
   */
  export type applicantsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many applicants.
     */
    data: applicantsCreateManyInput | applicantsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * applicants createManyAndReturn
   */
  export type applicantsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicants
     */
    select?: applicantsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the applicants
     */
    omit?: applicantsOmit<ExtArgs> | null
    /**
     * The data used to create many applicants.
     */
    data: applicantsCreateManyInput | applicantsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicantsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * applicants update
   */
  export type applicantsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicants
     */
    select?: applicantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applicants
     */
    omit?: applicantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicantsInclude<ExtArgs> | null
    /**
     * The data needed to update a applicants.
     */
    data: XOR<applicantsUpdateInput, applicantsUncheckedUpdateInput>
    /**
     * Choose, which applicants to update.
     */
    where: applicantsWhereUniqueInput
  }

  /**
   * applicants updateMany
   */
  export type applicantsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update applicants.
     */
    data: XOR<applicantsUpdateManyMutationInput, applicantsUncheckedUpdateManyInput>
    /**
     * Filter which applicants to update
     */
    where?: applicantsWhereInput
    /**
     * Limit how many applicants to update.
     */
    limit?: number
  }

  /**
   * applicants updateManyAndReturn
   */
  export type applicantsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicants
     */
    select?: applicantsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the applicants
     */
    omit?: applicantsOmit<ExtArgs> | null
    /**
     * The data used to update applicants.
     */
    data: XOR<applicantsUpdateManyMutationInput, applicantsUncheckedUpdateManyInput>
    /**
     * Filter which applicants to update
     */
    where?: applicantsWhereInput
    /**
     * Limit how many applicants to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicantsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * applicants upsert
   */
  export type applicantsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicants
     */
    select?: applicantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applicants
     */
    omit?: applicantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicantsInclude<ExtArgs> | null
    /**
     * The filter to search for the applicants to update in case it exists.
     */
    where: applicantsWhereUniqueInput
    /**
     * In case the applicants found by the `where` argument doesn't exist, create a new applicants with this data.
     */
    create: XOR<applicantsCreateInput, applicantsUncheckedCreateInput>
    /**
     * In case the applicants was found with the provided `where` argument, update it with this data.
     */
    update: XOR<applicantsUpdateInput, applicantsUncheckedUpdateInput>
  }

  /**
   * applicants delete
   */
  export type applicantsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicants
     */
    select?: applicantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applicants
     */
    omit?: applicantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicantsInclude<ExtArgs> | null
    /**
     * Filter which applicants to delete.
     */
    where: applicantsWhereUniqueInput
  }

  /**
   * applicants deleteMany
   */
  export type applicantsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which applicants to delete
     */
    where?: applicantsWhereInput
    /**
     * Limit how many applicants to delete.
     */
    limit?: number
  }

  /**
   * applicants without action
   */
  export type applicantsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicants
     */
    select?: applicantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applicants
     */
    omit?: applicantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicantsInclude<ExtArgs> | null
  }


  /**
   * Model awards
   */

  export type AggregateAwards = {
    _count: AwardsCountAggregateOutputType | null
    _avg: AwardsAvgAggregateOutputType | null
    _sum: AwardsSumAggregateOutputType | null
    _min: AwardsMinAggregateOutputType | null
    _max: AwardsMaxAggregateOutputType | null
  }

  export type AwardsAvgAggregateOutputType = {
    id: number | null
    cv_id: number | null
  }

  export type AwardsSumAggregateOutputType = {
    id: number | null
    cv_id: number | null
  }

  export type AwardsMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    start_date: Date | null
    end_date: Date | null
    cv_id: number | null
  }

  export type AwardsMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    start_date: Date | null
    end_date: Date | null
    cv_id: number | null
  }

  export type AwardsCountAggregateOutputType = {
    id: number
    title: number
    description: number
    start_date: number
    end_date: number
    cv_id: number
    _all: number
  }


  export type AwardsAvgAggregateInputType = {
    id?: true
    cv_id?: true
  }

  export type AwardsSumAggregateInputType = {
    id?: true
    cv_id?: true
  }

  export type AwardsMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    start_date?: true
    end_date?: true
    cv_id?: true
  }

  export type AwardsMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    start_date?: true
    end_date?: true
    cv_id?: true
  }

  export type AwardsCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    start_date?: true
    end_date?: true
    cv_id?: true
    _all?: true
  }

  export type AwardsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which awards to aggregate.
     */
    where?: awardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of awards to fetch.
     */
    orderBy?: awardsOrderByWithRelationInput | awardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: awardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` awards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` awards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned awards
    **/
    _count?: true | AwardsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AwardsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AwardsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AwardsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AwardsMaxAggregateInputType
  }

  export type GetAwardsAggregateType<T extends AwardsAggregateArgs> = {
        [P in keyof T & keyof AggregateAwards]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAwards[P]>
      : GetScalarType<T[P], AggregateAwards[P]>
  }




  export type awardsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: awardsWhereInput
    orderBy?: awardsOrderByWithAggregationInput | awardsOrderByWithAggregationInput[]
    by: AwardsScalarFieldEnum[] | AwardsScalarFieldEnum
    having?: awardsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AwardsCountAggregateInputType | true
    _avg?: AwardsAvgAggregateInputType
    _sum?: AwardsSumAggregateInputType
    _min?: AwardsMinAggregateInputType
    _max?: AwardsMaxAggregateInputType
  }

  export type AwardsGroupByOutputType = {
    id: number
    title: string
    description: string | null
    start_date: Date | null
    end_date: Date | null
    cv_id: number
    _count: AwardsCountAggregateOutputType | null
    _avg: AwardsAvgAggregateOutputType | null
    _sum: AwardsSumAggregateOutputType | null
    _min: AwardsMinAggregateOutputType | null
    _max: AwardsMaxAggregateOutputType | null
  }

  type GetAwardsGroupByPayload<T extends awardsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AwardsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AwardsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AwardsGroupByOutputType[P]>
            : GetScalarType<T[P], AwardsGroupByOutputType[P]>
        }
      >
    >


  export type awardsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    start_date?: boolean
    end_date?: boolean
    cv_id?: boolean
    cvs?: boolean | cvsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["awards"]>

  export type awardsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    start_date?: boolean
    end_date?: boolean
    cv_id?: boolean
    cvs?: boolean | cvsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["awards"]>

  export type awardsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    start_date?: boolean
    end_date?: boolean
    cv_id?: boolean
    cvs?: boolean | cvsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["awards"]>

  export type awardsSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    start_date?: boolean
    end_date?: boolean
    cv_id?: boolean
  }

  export type awardsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "start_date" | "end_date" | "cv_id", ExtArgs["result"]["awards"]>
  export type awardsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cvs?: boolean | cvsDefaultArgs<ExtArgs>
  }
  export type awardsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cvs?: boolean | cvsDefaultArgs<ExtArgs>
  }
  export type awardsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cvs?: boolean | cvsDefaultArgs<ExtArgs>
  }

  export type $awardsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "awards"
    objects: {
      cvs: Prisma.$cvsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string | null
      start_date: Date | null
      end_date: Date | null
      cv_id: number
    }, ExtArgs["result"]["awards"]>
    composites: {}
  }

  type awardsGetPayload<S extends boolean | null | undefined | awardsDefaultArgs> = $Result.GetResult<Prisma.$awardsPayload, S>

  type awardsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<awardsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AwardsCountAggregateInputType | true
    }

  export interface awardsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['awards'], meta: { name: 'awards' } }
    /**
     * Find zero or one Awards that matches the filter.
     * @param {awardsFindUniqueArgs} args - Arguments to find a Awards
     * @example
     * // Get one Awards
     * const awards = await prisma.awards.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends awardsFindUniqueArgs>(args: SelectSubset<T, awardsFindUniqueArgs<ExtArgs>>): Prisma__awardsClient<$Result.GetResult<Prisma.$awardsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Awards that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {awardsFindUniqueOrThrowArgs} args - Arguments to find a Awards
     * @example
     * // Get one Awards
     * const awards = await prisma.awards.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends awardsFindUniqueOrThrowArgs>(args: SelectSubset<T, awardsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__awardsClient<$Result.GetResult<Prisma.$awardsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Awards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {awardsFindFirstArgs} args - Arguments to find a Awards
     * @example
     * // Get one Awards
     * const awards = await prisma.awards.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends awardsFindFirstArgs>(args?: SelectSubset<T, awardsFindFirstArgs<ExtArgs>>): Prisma__awardsClient<$Result.GetResult<Prisma.$awardsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Awards that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {awardsFindFirstOrThrowArgs} args - Arguments to find a Awards
     * @example
     * // Get one Awards
     * const awards = await prisma.awards.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends awardsFindFirstOrThrowArgs>(args?: SelectSubset<T, awardsFindFirstOrThrowArgs<ExtArgs>>): Prisma__awardsClient<$Result.GetResult<Prisma.$awardsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Awards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {awardsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Awards
     * const awards = await prisma.awards.findMany()
     * 
     * // Get first 10 Awards
     * const awards = await prisma.awards.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const awardsWithIdOnly = await prisma.awards.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends awardsFindManyArgs>(args?: SelectSubset<T, awardsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$awardsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Awards.
     * @param {awardsCreateArgs} args - Arguments to create a Awards.
     * @example
     * // Create one Awards
     * const Awards = await prisma.awards.create({
     *   data: {
     *     // ... data to create a Awards
     *   }
     * })
     * 
     */
    create<T extends awardsCreateArgs>(args: SelectSubset<T, awardsCreateArgs<ExtArgs>>): Prisma__awardsClient<$Result.GetResult<Prisma.$awardsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Awards.
     * @param {awardsCreateManyArgs} args - Arguments to create many Awards.
     * @example
     * // Create many Awards
     * const awards = await prisma.awards.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends awardsCreateManyArgs>(args?: SelectSubset<T, awardsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Awards and returns the data saved in the database.
     * @param {awardsCreateManyAndReturnArgs} args - Arguments to create many Awards.
     * @example
     * // Create many Awards
     * const awards = await prisma.awards.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Awards and only return the `id`
     * const awardsWithIdOnly = await prisma.awards.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends awardsCreateManyAndReturnArgs>(args?: SelectSubset<T, awardsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$awardsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Awards.
     * @param {awardsDeleteArgs} args - Arguments to delete one Awards.
     * @example
     * // Delete one Awards
     * const Awards = await prisma.awards.delete({
     *   where: {
     *     // ... filter to delete one Awards
     *   }
     * })
     * 
     */
    delete<T extends awardsDeleteArgs>(args: SelectSubset<T, awardsDeleteArgs<ExtArgs>>): Prisma__awardsClient<$Result.GetResult<Prisma.$awardsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Awards.
     * @param {awardsUpdateArgs} args - Arguments to update one Awards.
     * @example
     * // Update one Awards
     * const awards = await prisma.awards.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends awardsUpdateArgs>(args: SelectSubset<T, awardsUpdateArgs<ExtArgs>>): Prisma__awardsClient<$Result.GetResult<Prisma.$awardsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Awards.
     * @param {awardsDeleteManyArgs} args - Arguments to filter Awards to delete.
     * @example
     * // Delete a few Awards
     * const { count } = await prisma.awards.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends awardsDeleteManyArgs>(args?: SelectSubset<T, awardsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Awards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {awardsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Awards
     * const awards = await prisma.awards.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends awardsUpdateManyArgs>(args: SelectSubset<T, awardsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Awards and returns the data updated in the database.
     * @param {awardsUpdateManyAndReturnArgs} args - Arguments to update many Awards.
     * @example
     * // Update many Awards
     * const awards = await prisma.awards.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Awards and only return the `id`
     * const awardsWithIdOnly = await prisma.awards.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends awardsUpdateManyAndReturnArgs>(args: SelectSubset<T, awardsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$awardsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Awards.
     * @param {awardsUpsertArgs} args - Arguments to update or create a Awards.
     * @example
     * // Update or create a Awards
     * const awards = await prisma.awards.upsert({
     *   create: {
     *     // ... data to create a Awards
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Awards we want to update
     *   }
     * })
     */
    upsert<T extends awardsUpsertArgs>(args: SelectSubset<T, awardsUpsertArgs<ExtArgs>>): Prisma__awardsClient<$Result.GetResult<Prisma.$awardsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Awards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {awardsCountArgs} args - Arguments to filter Awards to count.
     * @example
     * // Count the number of Awards
     * const count = await prisma.awards.count({
     *   where: {
     *     // ... the filter for the Awards we want to count
     *   }
     * })
    **/
    count<T extends awardsCountArgs>(
      args?: Subset<T, awardsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AwardsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Awards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AwardsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AwardsAggregateArgs>(args: Subset<T, AwardsAggregateArgs>): Prisma.PrismaPromise<GetAwardsAggregateType<T>>

    /**
     * Group by Awards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {awardsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends awardsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: awardsGroupByArgs['orderBy'] }
        : { orderBy?: awardsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, awardsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAwardsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the awards model
   */
  readonly fields: awardsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for awards.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__awardsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cvs<T extends cvsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, cvsDefaultArgs<ExtArgs>>): Prisma__cvsClient<$Result.GetResult<Prisma.$cvsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the awards model
   */
  interface awardsFieldRefs {
    readonly id: FieldRef<"awards", 'Int'>
    readonly title: FieldRef<"awards", 'String'>
    readonly description: FieldRef<"awards", 'String'>
    readonly start_date: FieldRef<"awards", 'DateTime'>
    readonly end_date: FieldRef<"awards", 'DateTime'>
    readonly cv_id: FieldRef<"awards", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * awards findUnique
   */
  export type awardsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the awards
     */
    select?: awardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the awards
     */
    omit?: awardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: awardsInclude<ExtArgs> | null
    /**
     * Filter, which awards to fetch.
     */
    where: awardsWhereUniqueInput
  }

  /**
   * awards findUniqueOrThrow
   */
  export type awardsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the awards
     */
    select?: awardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the awards
     */
    omit?: awardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: awardsInclude<ExtArgs> | null
    /**
     * Filter, which awards to fetch.
     */
    where: awardsWhereUniqueInput
  }

  /**
   * awards findFirst
   */
  export type awardsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the awards
     */
    select?: awardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the awards
     */
    omit?: awardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: awardsInclude<ExtArgs> | null
    /**
     * Filter, which awards to fetch.
     */
    where?: awardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of awards to fetch.
     */
    orderBy?: awardsOrderByWithRelationInput | awardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for awards.
     */
    cursor?: awardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` awards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` awards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of awards.
     */
    distinct?: AwardsScalarFieldEnum | AwardsScalarFieldEnum[]
  }

  /**
   * awards findFirstOrThrow
   */
  export type awardsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the awards
     */
    select?: awardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the awards
     */
    omit?: awardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: awardsInclude<ExtArgs> | null
    /**
     * Filter, which awards to fetch.
     */
    where?: awardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of awards to fetch.
     */
    orderBy?: awardsOrderByWithRelationInput | awardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for awards.
     */
    cursor?: awardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` awards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` awards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of awards.
     */
    distinct?: AwardsScalarFieldEnum | AwardsScalarFieldEnum[]
  }

  /**
   * awards findMany
   */
  export type awardsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the awards
     */
    select?: awardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the awards
     */
    omit?: awardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: awardsInclude<ExtArgs> | null
    /**
     * Filter, which awards to fetch.
     */
    where?: awardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of awards to fetch.
     */
    orderBy?: awardsOrderByWithRelationInput | awardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing awards.
     */
    cursor?: awardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` awards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` awards.
     */
    skip?: number
    distinct?: AwardsScalarFieldEnum | AwardsScalarFieldEnum[]
  }

  /**
   * awards create
   */
  export type awardsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the awards
     */
    select?: awardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the awards
     */
    omit?: awardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: awardsInclude<ExtArgs> | null
    /**
     * The data needed to create a awards.
     */
    data: XOR<awardsCreateInput, awardsUncheckedCreateInput>
  }

  /**
   * awards createMany
   */
  export type awardsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many awards.
     */
    data: awardsCreateManyInput | awardsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * awards createManyAndReturn
   */
  export type awardsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the awards
     */
    select?: awardsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the awards
     */
    omit?: awardsOmit<ExtArgs> | null
    /**
     * The data used to create many awards.
     */
    data: awardsCreateManyInput | awardsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: awardsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * awards update
   */
  export type awardsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the awards
     */
    select?: awardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the awards
     */
    omit?: awardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: awardsInclude<ExtArgs> | null
    /**
     * The data needed to update a awards.
     */
    data: XOR<awardsUpdateInput, awardsUncheckedUpdateInput>
    /**
     * Choose, which awards to update.
     */
    where: awardsWhereUniqueInput
  }

  /**
   * awards updateMany
   */
  export type awardsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update awards.
     */
    data: XOR<awardsUpdateManyMutationInput, awardsUncheckedUpdateManyInput>
    /**
     * Filter which awards to update
     */
    where?: awardsWhereInput
    /**
     * Limit how many awards to update.
     */
    limit?: number
  }

  /**
   * awards updateManyAndReturn
   */
  export type awardsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the awards
     */
    select?: awardsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the awards
     */
    omit?: awardsOmit<ExtArgs> | null
    /**
     * The data used to update awards.
     */
    data: XOR<awardsUpdateManyMutationInput, awardsUncheckedUpdateManyInput>
    /**
     * Filter which awards to update
     */
    where?: awardsWhereInput
    /**
     * Limit how many awards to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: awardsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * awards upsert
   */
  export type awardsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the awards
     */
    select?: awardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the awards
     */
    omit?: awardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: awardsInclude<ExtArgs> | null
    /**
     * The filter to search for the awards to update in case it exists.
     */
    where: awardsWhereUniqueInput
    /**
     * In case the awards found by the `where` argument doesn't exist, create a new awards with this data.
     */
    create: XOR<awardsCreateInput, awardsUncheckedCreateInput>
    /**
     * In case the awards was found with the provided `where` argument, update it with this data.
     */
    update: XOR<awardsUpdateInput, awardsUncheckedUpdateInput>
  }

  /**
   * awards delete
   */
  export type awardsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the awards
     */
    select?: awardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the awards
     */
    omit?: awardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: awardsInclude<ExtArgs> | null
    /**
     * Filter which awards to delete.
     */
    where: awardsWhereUniqueInput
  }

  /**
   * awards deleteMany
   */
  export type awardsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which awards to delete
     */
    where?: awardsWhereInput
    /**
     * Limit how many awards to delete.
     */
    limit?: number
  }

  /**
   * awards without action
   */
  export type awardsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the awards
     */
    select?: awardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the awards
     */
    omit?: awardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: awardsInclude<ExtArgs> | null
  }


  /**
   * Model blogs
   */

  export type AggregateBlogs = {
    _count: BlogsCountAggregateOutputType | null
    _avg: BlogsAvgAggregateOutputType | null
    _sum: BlogsSumAggregateOutputType | null
    _min: BlogsMinAggregateOutputType | null
    _max: BlogsMaxAggregateOutputType | null
  }

  export type BlogsAvgAggregateOutputType = {
    id: number | null
  }

  export type BlogsSumAggregateOutputType = {
    id: number | null
  }

  export type BlogsMinAggregateOutputType = {
    id: number | null
    title: string | null
    cover_image_url: string | null
    description_url: string | null
    created_at: Date | null
    updated_at: Date | null
    user_id: string | null
  }

  export type BlogsMaxAggregateOutputType = {
    id: number | null
    title: string | null
    cover_image_url: string | null
    description_url: string | null
    created_at: Date | null
    updated_at: Date | null
    user_id: string | null
  }

  export type BlogsCountAggregateOutputType = {
    id: number
    title: number
    cover_image_url: number
    description_url: number
    created_at: number
    updated_at: number
    user_id: number
    _all: number
  }


  export type BlogsAvgAggregateInputType = {
    id?: true
  }

  export type BlogsSumAggregateInputType = {
    id?: true
  }

  export type BlogsMinAggregateInputType = {
    id?: true
    title?: true
    cover_image_url?: true
    description_url?: true
    created_at?: true
    updated_at?: true
    user_id?: true
  }

  export type BlogsMaxAggregateInputType = {
    id?: true
    title?: true
    cover_image_url?: true
    description_url?: true
    created_at?: true
    updated_at?: true
    user_id?: true
  }

  export type BlogsCountAggregateInputType = {
    id?: true
    title?: true
    cover_image_url?: true
    description_url?: true
    created_at?: true
    updated_at?: true
    user_id?: true
    _all?: true
  }

  export type BlogsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which blogs to aggregate.
     */
    where?: blogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blogs to fetch.
     */
    orderBy?: blogsOrderByWithRelationInput | blogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: blogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned blogs
    **/
    _count?: true | BlogsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BlogsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BlogsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlogsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlogsMaxAggregateInputType
  }

  export type GetBlogsAggregateType<T extends BlogsAggregateArgs> = {
        [P in keyof T & keyof AggregateBlogs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlogs[P]>
      : GetScalarType<T[P], AggregateBlogs[P]>
  }




  export type blogsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: blogsWhereInput
    orderBy?: blogsOrderByWithAggregationInput | blogsOrderByWithAggregationInput[]
    by: BlogsScalarFieldEnum[] | BlogsScalarFieldEnum
    having?: blogsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlogsCountAggregateInputType | true
    _avg?: BlogsAvgAggregateInputType
    _sum?: BlogsSumAggregateInputType
    _min?: BlogsMinAggregateInputType
    _max?: BlogsMaxAggregateInputType
  }

  export type BlogsGroupByOutputType = {
    id: number
    title: string
    cover_image_url: string
    description_url: string
    created_at: Date
    updated_at: Date
    user_id: string
    _count: BlogsCountAggregateOutputType | null
    _avg: BlogsAvgAggregateOutputType | null
    _sum: BlogsSumAggregateOutputType | null
    _min: BlogsMinAggregateOutputType | null
    _max: BlogsMaxAggregateOutputType | null
  }

  type GetBlogsGroupByPayload<T extends blogsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlogsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlogsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlogsGroupByOutputType[P]>
            : GetScalarType<T[P], BlogsGroupByOutputType[P]>
        }
      >
    >


  export type blogsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    cover_image_url?: boolean
    description_url?: boolean
    created_at?: boolean
    updated_at?: boolean
    user_id?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blogs"]>

  export type blogsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    cover_image_url?: boolean
    description_url?: boolean
    created_at?: boolean
    updated_at?: boolean
    user_id?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blogs"]>

  export type blogsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    cover_image_url?: boolean
    description_url?: boolean
    created_at?: boolean
    updated_at?: boolean
    user_id?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["blogs"]>

  export type blogsSelectScalar = {
    id?: boolean
    title?: boolean
    cover_image_url?: boolean
    description_url?: boolean
    created_at?: boolean
    updated_at?: boolean
    user_id?: boolean
  }

  export type blogsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "cover_image_url" | "description_url" | "created_at" | "updated_at" | "user_id", ExtArgs["result"]["blogs"]>
  export type blogsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type blogsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type blogsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $blogsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "blogs"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      cover_image_url: string
      description_url: string
      created_at: Date
      updated_at: Date
      user_id: string
    }, ExtArgs["result"]["blogs"]>
    composites: {}
  }

  type blogsGetPayload<S extends boolean | null | undefined | blogsDefaultArgs> = $Result.GetResult<Prisma.$blogsPayload, S>

  type blogsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<blogsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BlogsCountAggregateInputType | true
    }

  export interface blogsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['blogs'], meta: { name: 'blogs' } }
    /**
     * Find zero or one Blogs that matches the filter.
     * @param {blogsFindUniqueArgs} args - Arguments to find a Blogs
     * @example
     * // Get one Blogs
     * const blogs = await prisma.blogs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends blogsFindUniqueArgs>(args: SelectSubset<T, blogsFindUniqueArgs<ExtArgs>>): Prisma__blogsClient<$Result.GetResult<Prisma.$blogsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Blogs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {blogsFindUniqueOrThrowArgs} args - Arguments to find a Blogs
     * @example
     * // Get one Blogs
     * const blogs = await prisma.blogs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends blogsFindUniqueOrThrowArgs>(args: SelectSubset<T, blogsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__blogsClient<$Result.GetResult<Prisma.$blogsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Blogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blogsFindFirstArgs} args - Arguments to find a Blogs
     * @example
     * // Get one Blogs
     * const blogs = await prisma.blogs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends blogsFindFirstArgs>(args?: SelectSubset<T, blogsFindFirstArgs<ExtArgs>>): Prisma__blogsClient<$Result.GetResult<Prisma.$blogsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Blogs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blogsFindFirstOrThrowArgs} args - Arguments to find a Blogs
     * @example
     * // Get one Blogs
     * const blogs = await prisma.blogs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends blogsFindFirstOrThrowArgs>(args?: SelectSubset<T, blogsFindFirstOrThrowArgs<ExtArgs>>): Prisma__blogsClient<$Result.GetResult<Prisma.$blogsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Blogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blogsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Blogs
     * const blogs = await prisma.blogs.findMany()
     * 
     * // Get first 10 Blogs
     * const blogs = await prisma.blogs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blogsWithIdOnly = await prisma.blogs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends blogsFindManyArgs>(args?: SelectSubset<T, blogsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$blogsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Blogs.
     * @param {blogsCreateArgs} args - Arguments to create a Blogs.
     * @example
     * // Create one Blogs
     * const Blogs = await prisma.blogs.create({
     *   data: {
     *     // ... data to create a Blogs
     *   }
     * })
     * 
     */
    create<T extends blogsCreateArgs>(args: SelectSubset<T, blogsCreateArgs<ExtArgs>>): Prisma__blogsClient<$Result.GetResult<Prisma.$blogsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Blogs.
     * @param {blogsCreateManyArgs} args - Arguments to create many Blogs.
     * @example
     * // Create many Blogs
     * const blogs = await prisma.blogs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends blogsCreateManyArgs>(args?: SelectSubset<T, blogsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Blogs and returns the data saved in the database.
     * @param {blogsCreateManyAndReturnArgs} args - Arguments to create many Blogs.
     * @example
     * // Create many Blogs
     * const blogs = await prisma.blogs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Blogs and only return the `id`
     * const blogsWithIdOnly = await prisma.blogs.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends blogsCreateManyAndReturnArgs>(args?: SelectSubset<T, blogsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$blogsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Blogs.
     * @param {blogsDeleteArgs} args - Arguments to delete one Blogs.
     * @example
     * // Delete one Blogs
     * const Blogs = await prisma.blogs.delete({
     *   where: {
     *     // ... filter to delete one Blogs
     *   }
     * })
     * 
     */
    delete<T extends blogsDeleteArgs>(args: SelectSubset<T, blogsDeleteArgs<ExtArgs>>): Prisma__blogsClient<$Result.GetResult<Prisma.$blogsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Blogs.
     * @param {blogsUpdateArgs} args - Arguments to update one Blogs.
     * @example
     * // Update one Blogs
     * const blogs = await prisma.blogs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends blogsUpdateArgs>(args: SelectSubset<T, blogsUpdateArgs<ExtArgs>>): Prisma__blogsClient<$Result.GetResult<Prisma.$blogsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Blogs.
     * @param {blogsDeleteManyArgs} args - Arguments to filter Blogs to delete.
     * @example
     * // Delete a few Blogs
     * const { count } = await prisma.blogs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends blogsDeleteManyArgs>(args?: SelectSubset<T, blogsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blogsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Blogs
     * const blogs = await prisma.blogs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends blogsUpdateManyArgs>(args: SelectSubset<T, blogsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Blogs and returns the data updated in the database.
     * @param {blogsUpdateManyAndReturnArgs} args - Arguments to update many Blogs.
     * @example
     * // Update many Blogs
     * const blogs = await prisma.blogs.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Blogs and only return the `id`
     * const blogsWithIdOnly = await prisma.blogs.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends blogsUpdateManyAndReturnArgs>(args: SelectSubset<T, blogsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$blogsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Blogs.
     * @param {blogsUpsertArgs} args - Arguments to update or create a Blogs.
     * @example
     * // Update or create a Blogs
     * const blogs = await prisma.blogs.upsert({
     *   create: {
     *     // ... data to create a Blogs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Blogs we want to update
     *   }
     * })
     */
    upsert<T extends blogsUpsertArgs>(args: SelectSubset<T, blogsUpsertArgs<ExtArgs>>): Prisma__blogsClient<$Result.GetResult<Prisma.$blogsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Blogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blogsCountArgs} args - Arguments to filter Blogs to count.
     * @example
     * // Count the number of Blogs
     * const count = await prisma.blogs.count({
     *   where: {
     *     // ... the filter for the Blogs we want to count
     *   }
     * })
    **/
    count<T extends blogsCountArgs>(
      args?: Subset<T, blogsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlogsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Blogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlogsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlogsAggregateArgs>(args: Subset<T, BlogsAggregateArgs>): Prisma.PrismaPromise<GetBlogsAggregateType<T>>

    /**
     * Group by Blogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {blogsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends blogsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: blogsGroupByArgs['orderBy'] }
        : { orderBy?: blogsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, blogsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlogsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the blogs model
   */
  readonly fields: blogsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for blogs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__blogsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the blogs model
   */
  interface blogsFieldRefs {
    readonly id: FieldRef<"blogs", 'Int'>
    readonly title: FieldRef<"blogs", 'String'>
    readonly cover_image_url: FieldRef<"blogs", 'String'>
    readonly description_url: FieldRef<"blogs", 'String'>
    readonly created_at: FieldRef<"blogs", 'DateTime'>
    readonly updated_at: FieldRef<"blogs", 'DateTime'>
    readonly user_id: FieldRef<"blogs", 'String'>
  }
    

  // Custom InputTypes
  /**
   * blogs findUnique
   */
  export type blogsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blogs
     */
    select?: blogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blogs
     */
    omit?: blogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blogsInclude<ExtArgs> | null
    /**
     * Filter, which blogs to fetch.
     */
    where: blogsWhereUniqueInput
  }

  /**
   * blogs findUniqueOrThrow
   */
  export type blogsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blogs
     */
    select?: blogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blogs
     */
    omit?: blogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blogsInclude<ExtArgs> | null
    /**
     * Filter, which blogs to fetch.
     */
    where: blogsWhereUniqueInput
  }

  /**
   * blogs findFirst
   */
  export type blogsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blogs
     */
    select?: blogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blogs
     */
    omit?: blogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blogsInclude<ExtArgs> | null
    /**
     * Filter, which blogs to fetch.
     */
    where?: blogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blogs to fetch.
     */
    orderBy?: blogsOrderByWithRelationInput | blogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for blogs.
     */
    cursor?: blogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of blogs.
     */
    distinct?: BlogsScalarFieldEnum | BlogsScalarFieldEnum[]
  }

  /**
   * blogs findFirstOrThrow
   */
  export type blogsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blogs
     */
    select?: blogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blogs
     */
    omit?: blogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blogsInclude<ExtArgs> | null
    /**
     * Filter, which blogs to fetch.
     */
    where?: blogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blogs to fetch.
     */
    orderBy?: blogsOrderByWithRelationInput | blogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for blogs.
     */
    cursor?: blogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of blogs.
     */
    distinct?: BlogsScalarFieldEnum | BlogsScalarFieldEnum[]
  }

  /**
   * blogs findMany
   */
  export type blogsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blogs
     */
    select?: blogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blogs
     */
    omit?: blogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blogsInclude<ExtArgs> | null
    /**
     * Filter, which blogs to fetch.
     */
    where?: blogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of blogs to fetch.
     */
    orderBy?: blogsOrderByWithRelationInput | blogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing blogs.
     */
    cursor?: blogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` blogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` blogs.
     */
    skip?: number
    distinct?: BlogsScalarFieldEnum | BlogsScalarFieldEnum[]
  }

  /**
   * blogs create
   */
  export type blogsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blogs
     */
    select?: blogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blogs
     */
    omit?: blogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blogsInclude<ExtArgs> | null
    /**
     * The data needed to create a blogs.
     */
    data: XOR<blogsCreateInput, blogsUncheckedCreateInput>
  }

  /**
   * blogs createMany
   */
  export type blogsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many blogs.
     */
    data: blogsCreateManyInput | blogsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * blogs createManyAndReturn
   */
  export type blogsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blogs
     */
    select?: blogsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the blogs
     */
    omit?: blogsOmit<ExtArgs> | null
    /**
     * The data used to create many blogs.
     */
    data: blogsCreateManyInput | blogsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blogsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * blogs update
   */
  export type blogsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blogs
     */
    select?: blogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blogs
     */
    omit?: blogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blogsInclude<ExtArgs> | null
    /**
     * The data needed to update a blogs.
     */
    data: XOR<blogsUpdateInput, blogsUncheckedUpdateInput>
    /**
     * Choose, which blogs to update.
     */
    where: blogsWhereUniqueInput
  }

  /**
   * blogs updateMany
   */
  export type blogsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update blogs.
     */
    data: XOR<blogsUpdateManyMutationInput, blogsUncheckedUpdateManyInput>
    /**
     * Filter which blogs to update
     */
    where?: blogsWhereInput
    /**
     * Limit how many blogs to update.
     */
    limit?: number
  }

  /**
   * blogs updateManyAndReturn
   */
  export type blogsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blogs
     */
    select?: blogsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the blogs
     */
    omit?: blogsOmit<ExtArgs> | null
    /**
     * The data used to update blogs.
     */
    data: XOR<blogsUpdateManyMutationInput, blogsUncheckedUpdateManyInput>
    /**
     * Filter which blogs to update
     */
    where?: blogsWhereInput
    /**
     * Limit how many blogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blogsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * blogs upsert
   */
  export type blogsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blogs
     */
    select?: blogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blogs
     */
    omit?: blogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blogsInclude<ExtArgs> | null
    /**
     * The filter to search for the blogs to update in case it exists.
     */
    where: blogsWhereUniqueInput
    /**
     * In case the blogs found by the `where` argument doesn't exist, create a new blogs with this data.
     */
    create: XOR<blogsCreateInput, blogsUncheckedCreateInput>
    /**
     * In case the blogs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<blogsUpdateInput, blogsUncheckedUpdateInput>
  }

  /**
   * blogs delete
   */
  export type blogsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blogs
     */
    select?: blogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blogs
     */
    omit?: blogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blogsInclude<ExtArgs> | null
    /**
     * Filter which blogs to delete.
     */
    where: blogsWhereUniqueInput
  }

  /**
   * blogs deleteMany
   */
  export type blogsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which blogs to delete
     */
    where?: blogsWhereInput
    /**
     * Limit how many blogs to delete.
     */
    limit?: number
  }

  /**
   * blogs without action
   */
  export type blogsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blogs
     */
    select?: blogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blogs
     */
    omit?: blogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blogsInclude<ExtArgs> | null
  }


  /**
   * Model careerPathSteps
   */

  export type AggregateCareerPathSteps = {
    _count: CareerPathStepsCountAggregateOutputType | null
    _avg: CareerPathStepsAvgAggregateOutputType | null
    _sum: CareerPathStepsSumAggregateOutputType | null
    _min: CareerPathStepsMinAggregateOutputType | null
    _max: CareerPathStepsMaxAggregateOutputType | null
  }

  export type CareerPathStepsAvgAggregateOutputType = {
    id: number | null
    career_id: number | null
  }

  export type CareerPathStepsSumAggregateOutputType = {
    id: number | null
    career_id: number | null
  }

  export type CareerPathStepsMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    resources: string | null
    career_id: number | null
  }

  export type CareerPathStepsMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    resources: string | null
    career_id: number | null
  }

  export type CareerPathStepsCountAggregateOutputType = {
    id: number
    title: number
    description: number
    resources: number
    career_id: number
    _all: number
  }


  export type CareerPathStepsAvgAggregateInputType = {
    id?: true
    career_id?: true
  }

  export type CareerPathStepsSumAggregateInputType = {
    id?: true
    career_id?: true
  }

  export type CareerPathStepsMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    resources?: true
    career_id?: true
  }

  export type CareerPathStepsMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    resources?: true
    career_id?: true
  }

  export type CareerPathStepsCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    resources?: true
    career_id?: true
    _all?: true
  }

  export type CareerPathStepsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which careerPathSteps to aggregate.
     */
    where?: careerPathStepsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of careerPathSteps to fetch.
     */
    orderBy?: careerPathStepsOrderByWithRelationInput | careerPathStepsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: careerPathStepsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` careerPathSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` careerPathSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned careerPathSteps
    **/
    _count?: true | CareerPathStepsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CareerPathStepsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CareerPathStepsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CareerPathStepsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CareerPathStepsMaxAggregateInputType
  }

  export type GetCareerPathStepsAggregateType<T extends CareerPathStepsAggregateArgs> = {
        [P in keyof T & keyof AggregateCareerPathSteps]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCareerPathSteps[P]>
      : GetScalarType<T[P], AggregateCareerPathSteps[P]>
  }




  export type careerPathStepsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: careerPathStepsWhereInput
    orderBy?: careerPathStepsOrderByWithAggregationInput | careerPathStepsOrderByWithAggregationInput[]
    by: CareerPathStepsScalarFieldEnum[] | CareerPathStepsScalarFieldEnum
    having?: careerPathStepsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CareerPathStepsCountAggregateInputType | true
    _avg?: CareerPathStepsAvgAggregateInputType
    _sum?: CareerPathStepsSumAggregateInputType
    _min?: CareerPathStepsMinAggregateInputType
    _max?: CareerPathStepsMaxAggregateInputType
  }

  export type CareerPathStepsGroupByOutputType = {
    id: number
    title: string
    description: string | null
    resources: string | null
    career_id: number
    _count: CareerPathStepsCountAggregateOutputType | null
    _avg: CareerPathStepsAvgAggregateOutputType | null
    _sum: CareerPathStepsSumAggregateOutputType | null
    _min: CareerPathStepsMinAggregateOutputType | null
    _max: CareerPathStepsMaxAggregateOutputType | null
  }

  type GetCareerPathStepsGroupByPayload<T extends careerPathStepsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CareerPathStepsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CareerPathStepsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CareerPathStepsGroupByOutputType[P]>
            : GetScalarType<T[P], CareerPathStepsGroupByOutputType[P]>
        }
      >
    >


  export type careerPathStepsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    resources?: boolean
    career_id?: boolean
    careerPaths?: boolean | careerPathsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["careerPathSteps"]>

  export type careerPathStepsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    resources?: boolean
    career_id?: boolean
    careerPaths?: boolean | careerPathsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["careerPathSteps"]>

  export type careerPathStepsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    resources?: boolean
    career_id?: boolean
    careerPaths?: boolean | careerPathsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["careerPathSteps"]>

  export type careerPathStepsSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    resources?: boolean
    career_id?: boolean
  }

  export type careerPathStepsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "resources" | "career_id", ExtArgs["result"]["careerPathSteps"]>
  export type careerPathStepsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    careerPaths?: boolean | careerPathsDefaultArgs<ExtArgs>
  }
  export type careerPathStepsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    careerPaths?: boolean | careerPathsDefaultArgs<ExtArgs>
  }
  export type careerPathStepsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    careerPaths?: boolean | careerPathsDefaultArgs<ExtArgs>
  }

  export type $careerPathStepsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "careerPathSteps"
    objects: {
      careerPaths: Prisma.$careerPathsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string | null
      resources: string | null
      career_id: number
    }, ExtArgs["result"]["careerPathSteps"]>
    composites: {}
  }

  type careerPathStepsGetPayload<S extends boolean | null | undefined | careerPathStepsDefaultArgs> = $Result.GetResult<Prisma.$careerPathStepsPayload, S>

  type careerPathStepsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<careerPathStepsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CareerPathStepsCountAggregateInputType | true
    }

  export interface careerPathStepsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['careerPathSteps'], meta: { name: 'careerPathSteps' } }
    /**
     * Find zero or one CareerPathSteps that matches the filter.
     * @param {careerPathStepsFindUniqueArgs} args - Arguments to find a CareerPathSteps
     * @example
     * // Get one CareerPathSteps
     * const careerPathSteps = await prisma.careerPathSteps.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends careerPathStepsFindUniqueArgs>(args: SelectSubset<T, careerPathStepsFindUniqueArgs<ExtArgs>>): Prisma__careerPathStepsClient<$Result.GetResult<Prisma.$careerPathStepsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CareerPathSteps that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {careerPathStepsFindUniqueOrThrowArgs} args - Arguments to find a CareerPathSteps
     * @example
     * // Get one CareerPathSteps
     * const careerPathSteps = await prisma.careerPathSteps.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends careerPathStepsFindUniqueOrThrowArgs>(args: SelectSubset<T, careerPathStepsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__careerPathStepsClient<$Result.GetResult<Prisma.$careerPathStepsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CareerPathSteps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {careerPathStepsFindFirstArgs} args - Arguments to find a CareerPathSteps
     * @example
     * // Get one CareerPathSteps
     * const careerPathSteps = await prisma.careerPathSteps.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends careerPathStepsFindFirstArgs>(args?: SelectSubset<T, careerPathStepsFindFirstArgs<ExtArgs>>): Prisma__careerPathStepsClient<$Result.GetResult<Prisma.$careerPathStepsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CareerPathSteps that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {careerPathStepsFindFirstOrThrowArgs} args - Arguments to find a CareerPathSteps
     * @example
     * // Get one CareerPathSteps
     * const careerPathSteps = await prisma.careerPathSteps.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends careerPathStepsFindFirstOrThrowArgs>(args?: SelectSubset<T, careerPathStepsFindFirstOrThrowArgs<ExtArgs>>): Prisma__careerPathStepsClient<$Result.GetResult<Prisma.$careerPathStepsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CareerPathSteps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {careerPathStepsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CareerPathSteps
     * const careerPathSteps = await prisma.careerPathSteps.findMany()
     * 
     * // Get first 10 CareerPathSteps
     * const careerPathSteps = await prisma.careerPathSteps.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const careerPathStepsWithIdOnly = await prisma.careerPathSteps.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends careerPathStepsFindManyArgs>(args?: SelectSubset<T, careerPathStepsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$careerPathStepsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CareerPathSteps.
     * @param {careerPathStepsCreateArgs} args - Arguments to create a CareerPathSteps.
     * @example
     * // Create one CareerPathSteps
     * const CareerPathSteps = await prisma.careerPathSteps.create({
     *   data: {
     *     // ... data to create a CareerPathSteps
     *   }
     * })
     * 
     */
    create<T extends careerPathStepsCreateArgs>(args: SelectSubset<T, careerPathStepsCreateArgs<ExtArgs>>): Prisma__careerPathStepsClient<$Result.GetResult<Prisma.$careerPathStepsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CareerPathSteps.
     * @param {careerPathStepsCreateManyArgs} args - Arguments to create many CareerPathSteps.
     * @example
     * // Create many CareerPathSteps
     * const careerPathSteps = await prisma.careerPathSteps.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends careerPathStepsCreateManyArgs>(args?: SelectSubset<T, careerPathStepsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CareerPathSteps and returns the data saved in the database.
     * @param {careerPathStepsCreateManyAndReturnArgs} args - Arguments to create many CareerPathSteps.
     * @example
     * // Create many CareerPathSteps
     * const careerPathSteps = await prisma.careerPathSteps.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CareerPathSteps and only return the `id`
     * const careerPathStepsWithIdOnly = await prisma.careerPathSteps.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends careerPathStepsCreateManyAndReturnArgs>(args?: SelectSubset<T, careerPathStepsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$careerPathStepsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CareerPathSteps.
     * @param {careerPathStepsDeleteArgs} args - Arguments to delete one CareerPathSteps.
     * @example
     * // Delete one CareerPathSteps
     * const CareerPathSteps = await prisma.careerPathSteps.delete({
     *   where: {
     *     // ... filter to delete one CareerPathSteps
     *   }
     * })
     * 
     */
    delete<T extends careerPathStepsDeleteArgs>(args: SelectSubset<T, careerPathStepsDeleteArgs<ExtArgs>>): Prisma__careerPathStepsClient<$Result.GetResult<Prisma.$careerPathStepsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CareerPathSteps.
     * @param {careerPathStepsUpdateArgs} args - Arguments to update one CareerPathSteps.
     * @example
     * // Update one CareerPathSteps
     * const careerPathSteps = await prisma.careerPathSteps.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends careerPathStepsUpdateArgs>(args: SelectSubset<T, careerPathStepsUpdateArgs<ExtArgs>>): Prisma__careerPathStepsClient<$Result.GetResult<Prisma.$careerPathStepsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CareerPathSteps.
     * @param {careerPathStepsDeleteManyArgs} args - Arguments to filter CareerPathSteps to delete.
     * @example
     * // Delete a few CareerPathSteps
     * const { count } = await prisma.careerPathSteps.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends careerPathStepsDeleteManyArgs>(args?: SelectSubset<T, careerPathStepsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CareerPathSteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {careerPathStepsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CareerPathSteps
     * const careerPathSteps = await prisma.careerPathSteps.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends careerPathStepsUpdateManyArgs>(args: SelectSubset<T, careerPathStepsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CareerPathSteps and returns the data updated in the database.
     * @param {careerPathStepsUpdateManyAndReturnArgs} args - Arguments to update many CareerPathSteps.
     * @example
     * // Update many CareerPathSteps
     * const careerPathSteps = await prisma.careerPathSteps.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CareerPathSteps and only return the `id`
     * const careerPathStepsWithIdOnly = await prisma.careerPathSteps.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends careerPathStepsUpdateManyAndReturnArgs>(args: SelectSubset<T, careerPathStepsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$careerPathStepsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CareerPathSteps.
     * @param {careerPathStepsUpsertArgs} args - Arguments to update or create a CareerPathSteps.
     * @example
     * // Update or create a CareerPathSteps
     * const careerPathSteps = await prisma.careerPathSteps.upsert({
     *   create: {
     *     // ... data to create a CareerPathSteps
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CareerPathSteps we want to update
     *   }
     * })
     */
    upsert<T extends careerPathStepsUpsertArgs>(args: SelectSubset<T, careerPathStepsUpsertArgs<ExtArgs>>): Prisma__careerPathStepsClient<$Result.GetResult<Prisma.$careerPathStepsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CareerPathSteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {careerPathStepsCountArgs} args - Arguments to filter CareerPathSteps to count.
     * @example
     * // Count the number of CareerPathSteps
     * const count = await prisma.careerPathSteps.count({
     *   where: {
     *     // ... the filter for the CareerPathSteps we want to count
     *   }
     * })
    **/
    count<T extends careerPathStepsCountArgs>(
      args?: Subset<T, careerPathStepsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CareerPathStepsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CareerPathSteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareerPathStepsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CareerPathStepsAggregateArgs>(args: Subset<T, CareerPathStepsAggregateArgs>): Prisma.PrismaPromise<GetCareerPathStepsAggregateType<T>>

    /**
     * Group by CareerPathSteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {careerPathStepsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends careerPathStepsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: careerPathStepsGroupByArgs['orderBy'] }
        : { orderBy?: careerPathStepsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, careerPathStepsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCareerPathStepsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the careerPathSteps model
   */
  readonly fields: careerPathStepsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for careerPathSteps.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__careerPathStepsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    careerPaths<T extends careerPathsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, careerPathsDefaultArgs<ExtArgs>>): Prisma__careerPathsClient<$Result.GetResult<Prisma.$careerPathsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the careerPathSteps model
   */
  interface careerPathStepsFieldRefs {
    readonly id: FieldRef<"careerPathSteps", 'Int'>
    readonly title: FieldRef<"careerPathSteps", 'String'>
    readonly description: FieldRef<"careerPathSteps", 'String'>
    readonly resources: FieldRef<"careerPathSteps", 'String'>
    readonly career_id: FieldRef<"careerPathSteps", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * careerPathSteps findUnique
   */
  export type careerPathStepsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the careerPathSteps
     */
    select?: careerPathStepsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the careerPathSteps
     */
    omit?: careerPathStepsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: careerPathStepsInclude<ExtArgs> | null
    /**
     * Filter, which careerPathSteps to fetch.
     */
    where: careerPathStepsWhereUniqueInput
  }

  /**
   * careerPathSteps findUniqueOrThrow
   */
  export type careerPathStepsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the careerPathSteps
     */
    select?: careerPathStepsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the careerPathSteps
     */
    omit?: careerPathStepsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: careerPathStepsInclude<ExtArgs> | null
    /**
     * Filter, which careerPathSteps to fetch.
     */
    where: careerPathStepsWhereUniqueInput
  }

  /**
   * careerPathSteps findFirst
   */
  export type careerPathStepsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the careerPathSteps
     */
    select?: careerPathStepsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the careerPathSteps
     */
    omit?: careerPathStepsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: careerPathStepsInclude<ExtArgs> | null
    /**
     * Filter, which careerPathSteps to fetch.
     */
    where?: careerPathStepsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of careerPathSteps to fetch.
     */
    orderBy?: careerPathStepsOrderByWithRelationInput | careerPathStepsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for careerPathSteps.
     */
    cursor?: careerPathStepsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` careerPathSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` careerPathSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of careerPathSteps.
     */
    distinct?: CareerPathStepsScalarFieldEnum | CareerPathStepsScalarFieldEnum[]
  }

  /**
   * careerPathSteps findFirstOrThrow
   */
  export type careerPathStepsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the careerPathSteps
     */
    select?: careerPathStepsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the careerPathSteps
     */
    omit?: careerPathStepsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: careerPathStepsInclude<ExtArgs> | null
    /**
     * Filter, which careerPathSteps to fetch.
     */
    where?: careerPathStepsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of careerPathSteps to fetch.
     */
    orderBy?: careerPathStepsOrderByWithRelationInput | careerPathStepsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for careerPathSteps.
     */
    cursor?: careerPathStepsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` careerPathSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` careerPathSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of careerPathSteps.
     */
    distinct?: CareerPathStepsScalarFieldEnum | CareerPathStepsScalarFieldEnum[]
  }

  /**
   * careerPathSteps findMany
   */
  export type careerPathStepsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the careerPathSteps
     */
    select?: careerPathStepsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the careerPathSteps
     */
    omit?: careerPathStepsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: careerPathStepsInclude<ExtArgs> | null
    /**
     * Filter, which careerPathSteps to fetch.
     */
    where?: careerPathStepsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of careerPathSteps to fetch.
     */
    orderBy?: careerPathStepsOrderByWithRelationInput | careerPathStepsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing careerPathSteps.
     */
    cursor?: careerPathStepsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` careerPathSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` careerPathSteps.
     */
    skip?: number
    distinct?: CareerPathStepsScalarFieldEnum | CareerPathStepsScalarFieldEnum[]
  }

  /**
   * careerPathSteps create
   */
  export type careerPathStepsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the careerPathSteps
     */
    select?: careerPathStepsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the careerPathSteps
     */
    omit?: careerPathStepsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: careerPathStepsInclude<ExtArgs> | null
    /**
     * The data needed to create a careerPathSteps.
     */
    data: XOR<careerPathStepsCreateInput, careerPathStepsUncheckedCreateInput>
  }

  /**
   * careerPathSteps createMany
   */
  export type careerPathStepsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many careerPathSteps.
     */
    data: careerPathStepsCreateManyInput | careerPathStepsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * careerPathSteps createManyAndReturn
   */
  export type careerPathStepsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the careerPathSteps
     */
    select?: careerPathStepsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the careerPathSteps
     */
    omit?: careerPathStepsOmit<ExtArgs> | null
    /**
     * The data used to create many careerPathSteps.
     */
    data: careerPathStepsCreateManyInput | careerPathStepsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: careerPathStepsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * careerPathSteps update
   */
  export type careerPathStepsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the careerPathSteps
     */
    select?: careerPathStepsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the careerPathSteps
     */
    omit?: careerPathStepsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: careerPathStepsInclude<ExtArgs> | null
    /**
     * The data needed to update a careerPathSteps.
     */
    data: XOR<careerPathStepsUpdateInput, careerPathStepsUncheckedUpdateInput>
    /**
     * Choose, which careerPathSteps to update.
     */
    where: careerPathStepsWhereUniqueInput
  }

  /**
   * careerPathSteps updateMany
   */
  export type careerPathStepsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update careerPathSteps.
     */
    data: XOR<careerPathStepsUpdateManyMutationInput, careerPathStepsUncheckedUpdateManyInput>
    /**
     * Filter which careerPathSteps to update
     */
    where?: careerPathStepsWhereInput
    /**
     * Limit how many careerPathSteps to update.
     */
    limit?: number
  }

  /**
   * careerPathSteps updateManyAndReturn
   */
  export type careerPathStepsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the careerPathSteps
     */
    select?: careerPathStepsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the careerPathSteps
     */
    omit?: careerPathStepsOmit<ExtArgs> | null
    /**
     * The data used to update careerPathSteps.
     */
    data: XOR<careerPathStepsUpdateManyMutationInput, careerPathStepsUncheckedUpdateManyInput>
    /**
     * Filter which careerPathSteps to update
     */
    where?: careerPathStepsWhereInput
    /**
     * Limit how many careerPathSteps to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: careerPathStepsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * careerPathSteps upsert
   */
  export type careerPathStepsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the careerPathSteps
     */
    select?: careerPathStepsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the careerPathSteps
     */
    omit?: careerPathStepsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: careerPathStepsInclude<ExtArgs> | null
    /**
     * The filter to search for the careerPathSteps to update in case it exists.
     */
    where: careerPathStepsWhereUniqueInput
    /**
     * In case the careerPathSteps found by the `where` argument doesn't exist, create a new careerPathSteps with this data.
     */
    create: XOR<careerPathStepsCreateInput, careerPathStepsUncheckedCreateInput>
    /**
     * In case the careerPathSteps was found with the provided `where` argument, update it with this data.
     */
    update: XOR<careerPathStepsUpdateInput, careerPathStepsUncheckedUpdateInput>
  }

  /**
   * careerPathSteps delete
   */
  export type careerPathStepsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the careerPathSteps
     */
    select?: careerPathStepsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the careerPathSteps
     */
    omit?: careerPathStepsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: careerPathStepsInclude<ExtArgs> | null
    /**
     * Filter which careerPathSteps to delete.
     */
    where: careerPathStepsWhereUniqueInput
  }

  /**
   * careerPathSteps deleteMany
   */
  export type careerPathStepsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which careerPathSteps to delete
     */
    where?: careerPathStepsWhereInput
    /**
     * Limit how many careerPathSteps to delete.
     */
    limit?: number
  }

  /**
   * careerPathSteps without action
   */
  export type careerPathStepsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the careerPathSteps
     */
    select?: careerPathStepsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the careerPathSteps
     */
    omit?: careerPathStepsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: careerPathStepsInclude<ExtArgs> | null
  }


  /**
   * Model careerPaths
   */

  export type AggregateCareerPaths = {
    _count: CareerPathsCountAggregateOutputType | null
    _avg: CareerPathsAvgAggregateOutputType | null
    _sum: CareerPathsSumAggregateOutputType | null
    _min: CareerPathsMinAggregateOutputType | null
    _max: CareerPathsMaxAggregateOutputType | null
  }

  export type CareerPathsAvgAggregateOutputType = {
    id: number | null
    jobspecialized_id: number | null
  }

  export type CareerPathsSumAggregateOutputType = {
    id: number | null
    jobspecialized_id: number | null
  }

  export type CareerPathsMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    resources: string | null
    level: string | null
    estimate_duration: string | null
    user_id: string | null
    jobspecialized_id: number | null
  }

  export type CareerPathsMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    resources: string | null
    level: string | null
    estimate_duration: string | null
    user_id: string | null
    jobspecialized_id: number | null
  }

  export type CareerPathsCountAggregateOutputType = {
    id: number
    title: number
    description: number
    resources: number
    level: number
    estimate_duration: number
    user_id: number
    jobspecialized_id: number
    _all: number
  }


  export type CareerPathsAvgAggregateInputType = {
    id?: true
    jobspecialized_id?: true
  }

  export type CareerPathsSumAggregateInputType = {
    id?: true
    jobspecialized_id?: true
  }

  export type CareerPathsMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    resources?: true
    level?: true
    estimate_duration?: true
    user_id?: true
    jobspecialized_id?: true
  }

  export type CareerPathsMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    resources?: true
    level?: true
    estimate_duration?: true
    user_id?: true
    jobspecialized_id?: true
  }

  export type CareerPathsCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    resources?: true
    level?: true
    estimate_duration?: true
    user_id?: true
    jobspecialized_id?: true
    _all?: true
  }

  export type CareerPathsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which careerPaths to aggregate.
     */
    where?: careerPathsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of careerPaths to fetch.
     */
    orderBy?: careerPathsOrderByWithRelationInput | careerPathsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: careerPathsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` careerPaths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` careerPaths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned careerPaths
    **/
    _count?: true | CareerPathsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CareerPathsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CareerPathsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CareerPathsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CareerPathsMaxAggregateInputType
  }

  export type GetCareerPathsAggregateType<T extends CareerPathsAggregateArgs> = {
        [P in keyof T & keyof AggregateCareerPaths]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCareerPaths[P]>
      : GetScalarType<T[P], AggregateCareerPaths[P]>
  }




  export type careerPathsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: careerPathsWhereInput
    orderBy?: careerPathsOrderByWithAggregationInput | careerPathsOrderByWithAggregationInput[]
    by: CareerPathsScalarFieldEnum[] | CareerPathsScalarFieldEnum
    having?: careerPathsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CareerPathsCountAggregateInputType | true
    _avg?: CareerPathsAvgAggregateInputType
    _sum?: CareerPathsSumAggregateInputType
    _min?: CareerPathsMinAggregateInputType
    _max?: CareerPathsMaxAggregateInputType
  }

  export type CareerPathsGroupByOutputType = {
    id: number
    title: string
    description: string | null
    resources: string | null
    level: string | null
    estimate_duration: string | null
    user_id: string
    jobspecialized_id: number
    _count: CareerPathsCountAggregateOutputType | null
    _avg: CareerPathsAvgAggregateOutputType | null
    _sum: CareerPathsSumAggregateOutputType | null
    _min: CareerPathsMinAggregateOutputType | null
    _max: CareerPathsMaxAggregateOutputType | null
  }

  type GetCareerPathsGroupByPayload<T extends careerPathsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CareerPathsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CareerPathsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CareerPathsGroupByOutputType[P]>
            : GetScalarType<T[P], CareerPathsGroupByOutputType[P]>
        }
      >
    >


  export type careerPathsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    resources?: boolean
    level?: boolean
    estimate_duration?: boolean
    user_id?: boolean
    jobspecialized_id?: boolean
    careerPathSteps?: boolean | careerPaths$careerPathStepsArgs<ExtArgs>
    jobSpecialized?: boolean | jobSpecializedDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    _count?: boolean | CareerPathsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["careerPaths"]>

  export type careerPathsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    resources?: boolean
    level?: boolean
    estimate_duration?: boolean
    user_id?: boolean
    jobspecialized_id?: boolean
    jobSpecialized?: boolean | jobSpecializedDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["careerPaths"]>

  export type careerPathsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    resources?: boolean
    level?: boolean
    estimate_duration?: boolean
    user_id?: boolean
    jobspecialized_id?: boolean
    jobSpecialized?: boolean | jobSpecializedDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["careerPaths"]>

  export type careerPathsSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    resources?: boolean
    level?: boolean
    estimate_duration?: boolean
    user_id?: boolean
    jobspecialized_id?: boolean
  }

  export type careerPathsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "resources" | "level" | "estimate_duration" | "user_id" | "jobspecialized_id", ExtArgs["result"]["careerPaths"]>
  export type careerPathsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    careerPathSteps?: boolean | careerPaths$careerPathStepsArgs<ExtArgs>
    jobSpecialized?: boolean | jobSpecializedDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    _count?: boolean | CareerPathsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type careerPathsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobSpecialized?: boolean | jobSpecializedDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type careerPathsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobSpecialized?: boolean | jobSpecializedDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $careerPathsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "careerPaths"
    objects: {
      careerPathSteps: Prisma.$careerPathStepsPayload<ExtArgs>[]
      jobSpecialized: Prisma.$jobSpecializedPayload<ExtArgs>
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string | null
      resources: string | null
      level: string | null
      estimate_duration: string | null
      user_id: string
      jobspecialized_id: number
    }, ExtArgs["result"]["careerPaths"]>
    composites: {}
  }

  type careerPathsGetPayload<S extends boolean | null | undefined | careerPathsDefaultArgs> = $Result.GetResult<Prisma.$careerPathsPayload, S>

  type careerPathsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<careerPathsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CareerPathsCountAggregateInputType | true
    }

  export interface careerPathsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['careerPaths'], meta: { name: 'careerPaths' } }
    /**
     * Find zero or one CareerPaths that matches the filter.
     * @param {careerPathsFindUniqueArgs} args - Arguments to find a CareerPaths
     * @example
     * // Get one CareerPaths
     * const careerPaths = await prisma.careerPaths.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends careerPathsFindUniqueArgs>(args: SelectSubset<T, careerPathsFindUniqueArgs<ExtArgs>>): Prisma__careerPathsClient<$Result.GetResult<Prisma.$careerPathsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CareerPaths that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {careerPathsFindUniqueOrThrowArgs} args - Arguments to find a CareerPaths
     * @example
     * // Get one CareerPaths
     * const careerPaths = await prisma.careerPaths.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends careerPathsFindUniqueOrThrowArgs>(args: SelectSubset<T, careerPathsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__careerPathsClient<$Result.GetResult<Prisma.$careerPathsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CareerPaths that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {careerPathsFindFirstArgs} args - Arguments to find a CareerPaths
     * @example
     * // Get one CareerPaths
     * const careerPaths = await prisma.careerPaths.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends careerPathsFindFirstArgs>(args?: SelectSubset<T, careerPathsFindFirstArgs<ExtArgs>>): Prisma__careerPathsClient<$Result.GetResult<Prisma.$careerPathsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CareerPaths that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {careerPathsFindFirstOrThrowArgs} args - Arguments to find a CareerPaths
     * @example
     * // Get one CareerPaths
     * const careerPaths = await prisma.careerPaths.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends careerPathsFindFirstOrThrowArgs>(args?: SelectSubset<T, careerPathsFindFirstOrThrowArgs<ExtArgs>>): Prisma__careerPathsClient<$Result.GetResult<Prisma.$careerPathsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CareerPaths that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {careerPathsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CareerPaths
     * const careerPaths = await prisma.careerPaths.findMany()
     * 
     * // Get first 10 CareerPaths
     * const careerPaths = await prisma.careerPaths.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const careerPathsWithIdOnly = await prisma.careerPaths.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends careerPathsFindManyArgs>(args?: SelectSubset<T, careerPathsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$careerPathsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CareerPaths.
     * @param {careerPathsCreateArgs} args - Arguments to create a CareerPaths.
     * @example
     * // Create one CareerPaths
     * const CareerPaths = await prisma.careerPaths.create({
     *   data: {
     *     // ... data to create a CareerPaths
     *   }
     * })
     * 
     */
    create<T extends careerPathsCreateArgs>(args: SelectSubset<T, careerPathsCreateArgs<ExtArgs>>): Prisma__careerPathsClient<$Result.GetResult<Prisma.$careerPathsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CareerPaths.
     * @param {careerPathsCreateManyArgs} args - Arguments to create many CareerPaths.
     * @example
     * // Create many CareerPaths
     * const careerPaths = await prisma.careerPaths.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends careerPathsCreateManyArgs>(args?: SelectSubset<T, careerPathsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CareerPaths and returns the data saved in the database.
     * @param {careerPathsCreateManyAndReturnArgs} args - Arguments to create many CareerPaths.
     * @example
     * // Create many CareerPaths
     * const careerPaths = await prisma.careerPaths.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CareerPaths and only return the `id`
     * const careerPathsWithIdOnly = await prisma.careerPaths.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends careerPathsCreateManyAndReturnArgs>(args?: SelectSubset<T, careerPathsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$careerPathsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CareerPaths.
     * @param {careerPathsDeleteArgs} args - Arguments to delete one CareerPaths.
     * @example
     * // Delete one CareerPaths
     * const CareerPaths = await prisma.careerPaths.delete({
     *   where: {
     *     // ... filter to delete one CareerPaths
     *   }
     * })
     * 
     */
    delete<T extends careerPathsDeleteArgs>(args: SelectSubset<T, careerPathsDeleteArgs<ExtArgs>>): Prisma__careerPathsClient<$Result.GetResult<Prisma.$careerPathsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CareerPaths.
     * @param {careerPathsUpdateArgs} args - Arguments to update one CareerPaths.
     * @example
     * // Update one CareerPaths
     * const careerPaths = await prisma.careerPaths.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends careerPathsUpdateArgs>(args: SelectSubset<T, careerPathsUpdateArgs<ExtArgs>>): Prisma__careerPathsClient<$Result.GetResult<Prisma.$careerPathsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CareerPaths.
     * @param {careerPathsDeleteManyArgs} args - Arguments to filter CareerPaths to delete.
     * @example
     * // Delete a few CareerPaths
     * const { count } = await prisma.careerPaths.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends careerPathsDeleteManyArgs>(args?: SelectSubset<T, careerPathsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CareerPaths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {careerPathsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CareerPaths
     * const careerPaths = await prisma.careerPaths.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends careerPathsUpdateManyArgs>(args: SelectSubset<T, careerPathsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CareerPaths and returns the data updated in the database.
     * @param {careerPathsUpdateManyAndReturnArgs} args - Arguments to update many CareerPaths.
     * @example
     * // Update many CareerPaths
     * const careerPaths = await prisma.careerPaths.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CareerPaths and only return the `id`
     * const careerPathsWithIdOnly = await prisma.careerPaths.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends careerPathsUpdateManyAndReturnArgs>(args: SelectSubset<T, careerPathsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$careerPathsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CareerPaths.
     * @param {careerPathsUpsertArgs} args - Arguments to update or create a CareerPaths.
     * @example
     * // Update or create a CareerPaths
     * const careerPaths = await prisma.careerPaths.upsert({
     *   create: {
     *     // ... data to create a CareerPaths
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CareerPaths we want to update
     *   }
     * })
     */
    upsert<T extends careerPathsUpsertArgs>(args: SelectSubset<T, careerPathsUpsertArgs<ExtArgs>>): Prisma__careerPathsClient<$Result.GetResult<Prisma.$careerPathsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CareerPaths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {careerPathsCountArgs} args - Arguments to filter CareerPaths to count.
     * @example
     * // Count the number of CareerPaths
     * const count = await prisma.careerPaths.count({
     *   where: {
     *     // ... the filter for the CareerPaths we want to count
     *   }
     * })
    **/
    count<T extends careerPathsCountArgs>(
      args?: Subset<T, careerPathsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CareerPathsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CareerPaths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CareerPathsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CareerPathsAggregateArgs>(args: Subset<T, CareerPathsAggregateArgs>): Prisma.PrismaPromise<GetCareerPathsAggregateType<T>>

    /**
     * Group by CareerPaths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {careerPathsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends careerPathsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: careerPathsGroupByArgs['orderBy'] }
        : { orderBy?: careerPathsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, careerPathsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCareerPathsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the careerPaths model
   */
  readonly fields: careerPathsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for careerPaths.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__careerPathsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    careerPathSteps<T extends careerPaths$careerPathStepsArgs<ExtArgs> = {}>(args?: Subset<T, careerPaths$careerPathStepsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$careerPathStepsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    jobSpecialized<T extends jobSpecializedDefaultArgs<ExtArgs> = {}>(args?: Subset<T, jobSpecializedDefaultArgs<ExtArgs>>): Prisma__jobSpecializedClient<$Result.GetResult<Prisma.$jobSpecializedPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the careerPaths model
   */
  interface careerPathsFieldRefs {
    readonly id: FieldRef<"careerPaths", 'Int'>
    readonly title: FieldRef<"careerPaths", 'String'>
    readonly description: FieldRef<"careerPaths", 'String'>
    readonly resources: FieldRef<"careerPaths", 'String'>
    readonly level: FieldRef<"careerPaths", 'String'>
    readonly estimate_duration: FieldRef<"careerPaths", 'String'>
    readonly user_id: FieldRef<"careerPaths", 'String'>
    readonly jobspecialized_id: FieldRef<"careerPaths", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * careerPaths findUnique
   */
  export type careerPathsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the careerPaths
     */
    select?: careerPathsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the careerPaths
     */
    omit?: careerPathsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: careerPathsInclude<ExtArgs> | null
    /**
     * Filter, which careerPaths to fetch.
     */
    where: careerPathsWhereUniqueInput
  }

  /**
   * careerPaths findUniqueOrThrow
   */
  export type careerPathsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the careerPaths
     */
    select?: careerPathsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the careerPaths
     */
    omit?: careerPathsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: careerPathsInclude<ExtArgs> | null
    /**
     * Filter, which careerPaths to fetch.
     */
    where: careerPathsWhereUniqueInput
  }

  /**
   * careerPaths findFirst
   */
  export type careerPathsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the careerPaths
     */
    select?: careerPathsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the careerPaths
     */
    omit?: careerPathsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: careerPathsInclude<ExtArgs> | null
    /**
     * Filter, which careerPaths to fetch.
     */
    where?: careerPathsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of careerPaths to fetch.
     */
    orderBy?: careerPathsOrderByWithRelationInput | careerPathsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for careerPaths.
     */
    cursor?: careerPathsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` careerPaths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` careerPaths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of careerPaths.
     */
    distinct?: CareerPathsScalarFieldEnum | CareerPathsScalarFieldEnum[]
  }

  /**
   * careerPaths findFirstOrThrow
   */
  export type careerPathsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the careerPaths
     */
    select?: careerPathsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the careerPaths
     */
    omit?: careerPathsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: careerPathsInclude<ExtArgs> | null
    /**
     * Filter, which careerPaths to fetch.
     */
    where?: careerPathsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of careerPaths to fetch.
     */
    orderBy?: careerPathsOrderByWithRelationInput | careerPathsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for careerPaths.
     */
    cursor?: careerPathsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` careerPaths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` careerPaths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of careerPaths.
     */
    distinct?: CareerPathsScalarFieldEnum | CareerPathsScalarFieldEnum[]
  }

  /**
   * careerPaths findMany
   */
  export type careerPathsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the careerPaths
     */
    select?: careerPathsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the careerPaths
     */
    omit?: careerPathsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: careerPathsInclude<ExtArgs> | null
    /**
     * Filter, which careerPaths to fetch.
     */
    where?: careerPathsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of careerPaths to fetch.
     */
    orderBy?: careerPathsOrderByWithRelationInput | careerPathsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing careerPaths.
     */
    cursor?: careerPathsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` careerPaths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` careerPaths.
     */
    skip?: number
    distinct?: CareerPathsScalarFieldEnum | CareerPathsScalarFieldEnum[]
  }

  /**
   * careerPaths create
   */
  export type careerPathsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the careerPaths
     */
    select?: careerPathsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the careerPaths
     */
    omit?: careerPathsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: careerPathsInclude<ExtArgs> | null
    /**
     * The data needed to create a careerPaths.
     */
    data: XOR<careerPathsCreateInput, careerPathsUncheckedCreateInput>
  }

  /**
   * careerPaths createMany
   */
  export type careerPathsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many careerPaths.
     */
    data: careerPathsCreateManyInput | careerPathsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * careerPaths createManyAndReturn
   */
  export type careerPathsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the careerPaths
     */
    select?: careerPathsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the careerPaths
     */
    omit?: careerPathsOmit<ExtArgs> | null
    /**
     * The data used to create many careerPaths.
     */
    data: careerPathsCreateManyInput | careerPathsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: careerPathsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * careerPaths update
   */
  export type careerPathsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the careerPaths
     */
    select?: careerPathsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the careerPaths
     */
    omit?: careerPathsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: careerPathsInclude<ExtArgs> | null
    /**
     * The data needed to update a careerPaths.
     */
    data: XOR<careerPathsUpdateInput, careerPathsUncheckedUpdateInput>
    /**
     * Choose, which careerPaths to update.
     */
    where: careerPathsWhereUniqueInput
  }

  /**
   * careerPaths updateMany
   */
  export type careerPathsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update careerPaths.
     */
    data: XOR<careerPathsUpdateManyMutationInput, careerPathsUncheckedUpdateManyInput>
    /**
     * Filter which careerPaths to update
     */
    where?: careerPathsWhereInput
    /**
     * Limit how many careerPaths to update.
     */
    limit?: number
  }

  /**
   * careerPaths updateManyAndReturn
   */
  export type careerPathsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the careerPaths
     */
    select?: careerPathsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the careerPaths
     */
    omit?: careerPathsOmit<ExtArgs> | null
    /**
     * The data used to update careerPaths.
     */
    data: XOR<careerPathsUpdateManyMutationInput, careerPathsUncheckedUpdateManyInput>
    /**
     * Filter which careerPaths to update
     */
    where?: careerPathsWhereInput
    /**
     * Limit how many careerPaths to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: careerPathsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * careerPaths upsert
   */
  export type careerPathsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the careerPaths
     */
    select?: careerPathsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the careerPaths
     */
    omit?: careerPathsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: careerPathsInclude<ExtArgs> | null
    /**
     * The filter to search for the careerPaths to update in case it exists.
     */
    where: careerPathsWhereUniqueInput
    /**
     * In case the careerPaths found by the `where` argument doesn't exist, create a new careerPaths with this data.
     */
    create: XOR<careerPathsCreateInput, careerPathsUncheckedCreateInput>
    /**
     * In case the careerPaths was found with the provided `where` argument, update it with this data.
     */
    update: XOR<careerPathsUpdateInput, careerPathsUncheckedUpdateInput>
  }

  /**
   * careerPaths delete
   */
  export type careerPathsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the careerPaths
     */
    select?: careerPathsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the careerPaths
     */
    omit?: careerPathsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: careerPathsInclude<ExtArgs> | null
    /**
     * Filter which careerPaths to delete.
     */
    where: careerPathsWhereUniqueInput
  }

  /**
   * careerPaths deleteMany
   */
  export type careerPathsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which careerPaths to delete
     */
    where?: careerPathsWhereInput
    /**
     * Limit how many careerPaths to delete.
     */
    limit?: number
  }

  /**
   * careerPaths.careerPathSteps
   */
  export type careerPaths$careerPathStepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the careerPathSteps
     */
    select?: careerPathStepsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the careerPathSteps
     */
    omit?: careerPathStepsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: careerPathStepsInclude<ExtArgs> | null
    where?: careerPathStepsWhereInput
    orderBy?: careerPathStepsOrderByWithRelationInput | careerPathStepsOrderByWithRelationInput[]
    cursor?: careerPathStepsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CareerPathStepsScalarFieldEnum | CareerPathStepsScalarFieldEnum[]
  }

  /**
   * careerPaths without action
   */
  export type careerPathsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the careerPaths
     */
    select?: careerPathsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the careerPaths
     */
    omit?: careerPathsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: careerPathsInclude<ExtArgs> | null
  }


  /**
   * Model categories
   */

  export type AggregateCategories = {
    _count: CategoriesCountAggregateOutputType | null
    _avg: CategoriesAvgAggregateOutputType | null
    _sum: CategoriesSumAggregateOutputType | null
    _min: CategoriesMinAggregateOutputType | null
    _max: CategoriesMaxAggregateOutputType | null
  }

  export type CategoriesAvgAggregateOutputType = {
    id: number | null
  }

  export type CategoriesSumAggregateOutputType = {
    id: number | null
  }

  export type CategoriesMinAggregateOutputType = {
    id: number | null
    category_name: string | null
  }

  export type CategoriesMaxAggregateOutputType = {
    id: number | null
    category_name: string | null
  }

  export type CategoriesCountAggregateOutputType = {
    id: number
    category_name: number
    _all: number
  }


  export type CategoriesAvgAggregateInputType = {
    id?: true
  }

  export type CategoriesSumAggregateInputType = {
    id?: true
  }

  export type CategoriesMinAggregateInputType = {
    id?: true
    category_name?: true
  }

  export type CategoriesMaxAggregateInputType = {
    id?: true
    category_name?: true
  }

  export type CategoriesCountAggregateInputType = {
    id?: true
    category_name?: true
    _all?: true
  }

  export type CategoriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which categories to aggregate.
     */
    where?: categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoriesOrderByWithRelationInput | categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned categories
    **/
    _count?: true | CategoriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategoriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoriesMaxAggregateInputType
  }

  export type GetCategoriesAggregateType<T extends CategoriesAggregateArgs> = {
        [P in keyof T & keyof AggregateCategories]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategories[P]>
      : GetScalarType<T[P], AggregateCategories[P]>
  }




  export type categoriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: categoriesWhereInput
    orderBy?: categoriesOrderByWithAggregationInput | categoriesOrderByWithAggregationInput[]
    by: CategoriesScalarFieldEnum[] | CategoriesScalarFieldEnum
    having?: categoriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoriesCountAggregateInputType | true
    _avg?: CategoriesAvgAggregateInputType
    _sum?: CategoriesSumAggregateInputType
    _min?: CategoriesMinAggregateInputType
    _max?: CategoriesMaxAggregateInputType
  }

  export type CategoriesGroupByOutputType = {
    id: number
    category_name: string
    _count: CategoriesCountAggregateOutputType | null
    _avg: CategoriesAvgAggregateOutputType | null
    _sum: CategoriesSumAggregateOutputType | null
    _min: CategoriesMinAggregateOutputType | null
    _max: CategoriesMaxAggregateOutputType | null
  }

  type GetCategoriesGroupByPayload<T extends categoriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoriesGroupByOutputType[P]>
            : GetScalarType<T[P], CategoriesGroupByOutputType[P]>
        }
      >
    >


  export type categoriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category_name?: boolean
    jobs?: boolean | categories$jobsArgs<ExtArgs>
    _count?: boolean | CategoriesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categories"]>

  export type categoriesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category_name?: boolean
  }, ExtArgs["result"]["categories"]>

  export type categoriesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category_name?: boolean
  }, ExtArgs["result"]["categories"]>

  export type categoriesSelectScalar = {
    id?: boolean
    category_name?: boolean
  }

  export type categoriesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "category_name", ExtArgs["result"]["categories"]>
  export type categoriesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobs?: boolean | categories$jobsArgs<ExtArgs>
    _count?: boolean | CategoriesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type categoriesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type categoriesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $categoriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "categories"
    objects: {
      jobs: Prisma.$jobsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      category_name: string
    }, ExtArgs["result"]["categories"]>
    composites: {}
  }

  type categoriesGetPayload<S extends boolean | null | undefined | categoriesDefaultArgs> = $Result.GetResult<Prisma.$categoriesPayload, S>

  type categoriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<categoriesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoriesCountAggregateInputType | true
    }

  export interface categoriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['categories'], meta: { name: 'categories' } }
    /**
     * Find zero or one Categories that matches the filter.
     * @param {categoriesFindUniqueArgs} args - Arguments to find a Categories
     * @example
     * // Get one Categories
     * const categories = await prisma.categories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends categoriesFindUniqueArgs>(args: SelectSubset<T, categoriesFindUniqueArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Categories that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {categoriesFindUniqueOrThrowArgs} args - Arguments to find a Categories
     * @example
     * // Get one Categories
     * const categories = await prisma.categories.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends categoriesFindUniqueOrThrowArgs>(args: SelectSubset<T, categoriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriesFindFirstArgs} args - Arguments to find a Categories
     * @example
     * // Get one Categories
     * const categories = await prisma.categories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends categoriesFindFirstArgs>(args?: SelectSubset<T, categoriesFindFirstArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Categories that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriesFindFirstOrThrowArgs} args - Arguments to find a Categories
     * @example
     * // Get one Categories
     * const categories = await prisma.categories.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends categoriesFindFirstOrThrowArgs>(args?: SelectSubset<T, categoriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.categories.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.categories.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoriesWithIdOnly = await prisma.categories.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends categoriesFindManyArgs>(args?: SelectSubset<T, categoriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Categories.
     * @param {categoriesCreateArgs} args - Arguments to create a Categories.
     * @example
     * // Create one Categories
     * const Categories = await prisma.categories.create({
     *   data: {
     *     // ... data to create a Categories
     *   }
     * })
     * 
     */
    create<T extends categoriesCreateArgs>(args: SelectSubset<T, categoriesCreateArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {categoriesCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const categories = await prisma.categories.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends categoriesCreateManyArgs>(args?: SelectSubset<T, categoriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Categories and returns the data saved in the database.
     * @param {categoriesCreateManyAndReturnArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const categories = await prisma.categories.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Categories and only return the `id`
     * const categoriesWithIdOnly = await prisma.categories.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends categoriesCreateManyAndReturnArgs>(args?: SelectSubset<T, categoriesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Categories.
     * @param {categoriesDeleteArgs} args - Arguments to delete one Categories.
     * @example
     * // Delete one Categories
     * const Categories = await prisma.categories.delete({
     *   where: {
     *     // ... filter to delete one Categories
     *   }
     * })
     * 
     */
    delete<T extends categoriesDeleteArgs>(args: SelectSubset<T, categoriesDeleteArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Categories.
     * @param {categoriesUpdateArgs} args - Arguments to update one Categories.
     * @example
     * // Update one Categories
     * const categories = await prisma.categories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends categoriesUpdateArgs>(args: SelectSubset<T, categoriesUpdateArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {categoriesDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.categories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends categoriesDeleteManyArgs>(args?: SelectSubset<T, categoriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const categories = await prisma.categories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends categoriesUpdateManyArgs>(args: SelectSubset<T, categoriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories and returns the data updated in the database.
     * @param {categoriesUpdateManyAndReturnArgs} args - Arguments to update many Categories.
     * @example
     * // Update many Categories
     * const categories = await prisma.categories.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Categories and only return the `id`
     * const categoriesWithIdOnly = await prisma.categories.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends categoriesUpdateManyAndReturnArgs>(args: SelectSubset<T, categoriesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Categories.
     * @param {categoriesUpsertArgs} args - Arguments to update or create a Categories.
     * @example
     * // Update or create a Categories
     * const categories = await prisma.categories.upsert({
     *   create: {
     *     // ... data to create a Categories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Categories we want to update
     *   }
     * })
     */
    upsert<T extends categoriesUpsertArgs>(args: SelectSubset<T, categoriesUpsertArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriesCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.categories.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends categoriesCountArgs>(
      args?: Subset<T, categoriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoriesAggregateArgs>(args: Subset<T, CategoriesAggregateArgs>): Prisma.PrismaPromise<GetCategoriesAggregateType<T>>

    /**
     * Group by Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends categoriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: categoriesGroupByArgs['orderBy'] }
        : { orderBy?: categoriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, categoriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the categories model
   */
  readonly fields: categoriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for categories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__categoriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    jobs<T extends categories$jobsArgs<ExtArgs> = {}>(args?: Subset<T, categories$jobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$jobsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the categories model
   */
  interface categoriesFieldRefs {
    readonly id: FieldRef<"categories", 'Int'>
    readonly category_name: FieldRef<"categories", 'String'>
  }
    

  // Custom InputTypes
  /**
   * categories findUnique
   */
  export type categoriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * Filter, which categories to fetch.
     */
    where: categoriesWhereUniqueInput
  }

  /**
   * categories findUniqueOrThrow
   */
  export type categoriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * Filter, which categories to fetch.
     */
    where: categoriesWhereUniqueInput
  }

  /**
   * categories findFirst
   */
  export type categoriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * Filter, which categories to fetch.
     */
    where?: categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoriesOrderByWithRelationInput | categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categories.
     */
    cursor?: categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categories.
     */
    distinct?: CategoriesScalarFieldEnum | CategoriesScalarFieldEnum[]
  }

  /**
   * categories findFirstOrThrow
   */
  export type categoriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * Filter, which categories to fetch.
     */
    where?: categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoriesOrderByWithRelationInput | categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categories.
     */
    cursor?: categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categories.
     */
    distinct?: CategoriesScalarFieldEnum | CategoriesScalarFieldEnum[]
  }

  /**
   * categories findMany
   */
  export type categoriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * Filter, which categories to fetch.
     */
    where?: categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoriesOrderByWithRelationInput | categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing categories.
     */
    cursor?: categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    distinct?: CategoriesScalarFieldEnum | CategoriesScalarFieldEnum[]
  }

  /**
   * categories create
   */
  export type categoriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * The data needed to create a categories.
     */
    data: XOR<categoriesCreateInput, categoriesUncheckedCreateInput>
  }

  /**
   * categories createMany
   */
  export type categoriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many categories.
     */
    data: categoriesCreateManyInput | categoriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * categories createManyAndReturn
   */
  export type categoriesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * The data used to create many categories.
     */
    data: categoriesCreateManyInput | categoriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * categories update
   */
  export type categoriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * The data needed to update a categories.
     */
    data: XOR<categoriesUpdateInput, categoriesUncheckedUpdateInput>
    /**
     * Choose, which categories to update.
     */
    where: categoriesWhereUniqueInput
  }

  /**
   * categories updateMany
   */
  export type categoriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update categories.
     */
    data: XOR<categoriesUpdateManyMutationInput, categoriesUncheckedUpdateManyInput>
    /**
     * Filter which categories to update
     */
    where?: categoriesWhereInput
    /**
     * Limit how many categories to update.
     */
    limit?: number
  }

  /**
   * categories updateManyAndReturn
   */
  export type categoriesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * The data used to update categories.
     */
    data: XOR<categoriesUpdateManyMutationInput, categoriesUncheckedUpdateManyInput>
    /**
     * Filter which categories to update
     */
    where?: categoriesWhereInput
    /**
     * Limit how many categories to update.
     */
    limit?: number
  }

  /**
   * categories upsert
   */
  export type categoriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * The filter to search for the categories to update in case it exists.
     */
    where: categoriesWhereUniqueInput
    /**
     * In case the categories found by the `where` argument doesn't exist, create a new categories with this data.
     */
    create: XOR<categoriesCreateInput, categoriesUncheckedCreateInput>
    /**
     * In case the categories was found with the provided `where` argument, update it with this data.
     */
    update: XOR<categoriesUpdateInput, categoriesUncheckedUpdateInput>
  }

  /**
   * categories delete
   */
  export type categoriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * Filter which categories to delete.
     */
    where: categoriesWhereUniqueInput
  }

  /**
   * categories deleteMany
   */
  export type categoriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which categories to delete
     */
    where?: categoriesWhereInput
    /**
     * Limit how many categories to delete.
     */
    limit?: number
  }

  /**
   * categories.jobs
   */
  export type categories$jobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobs
     */
    select?: jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobs
     */
    omit?: jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobsInclude<ExtArgs> | null
    where?: jobsWhereInput
    orderBy?: jobsOrderByWithRelationInput | jobsOrderByWithRelationInput[]
    cursor?: jobsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobsScalarFieldEnum | JobsScalarFieldEnum[]
  }

  /**
   * categories without action
   */
  export type categoriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
  }


  /**
   * Model certificates
   */

  export type AggregateCertificates = {
    _count: CertificatesCountAggregateOutputType | null
    _avg: CertificatesAvgAggregateOutputType | null
    _sum: CertificatesSumAggregateOutputType | null
    _min: CertificatesMinAggregateOutputType | null
    _max: CertificatesMaxAggregateOutputType | null
  }

  export type CertificatesAvgAggregateOutputType = {
    id: number | null
    cv_id: number | null
  }

  export type CertificatesSumAggregateOutputType = {
    id: number | null
    cv_id: number | null
  }

  export type CertificatesMinAggregateOutputType = {
    id: number | null
    title: string | null
    link: string | null
    description: string | null
    start_date: Date | null
    end_date: Date | null
    cv_id: number | null
  }

  export type CertificatesMaxAggregateOutputType = {
    id: number | null
    title: string | null
    link: string | null
    description: string | null
    start_date: Date | null
    end_date: Date | null
    cv_id: number | null
  }

  export type CertificatesCountAggregateOutputType = {
    id: number
    title: number
    link: number
    description: number
    start_date: number
    end_date: number
    cv_id: number
    _all: number
  }


  export type CertificatesAvgAggregateInputType = {
    id?: true
    cv_id?: true
  }

  export type CertificatesSumAggregateInputType = {
    id?: true
    cv_id?: true
  }

  export type CertificatesMinAggregateInputType = {
    id?: true
    title?: true
    link?: true
    description?: true
    start_date?: true
    end_date?: true
    cv_id?: true
  }

  export type CertificatesMaxAggregateInputType = {
    id?: true
    title?: true
    link?: true
    description?: true
    start_date?: true
    end_date?: true
    cv_id?: true
  }

  export type CertificatesCountAggregateInputType = {
    id?: true
    title?: true
    link?: true
    description?: true
    start_date?: true
    end_date?: true
    cv_id?: true
    _all?: true
  }

  export type CertificatesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which certificates to aggregate.
     */
    where?: certificatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of certificates to fetch.
     */
    orderBy?: certificatesOrderByWithRelationInput | certificatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: certificatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` certificates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned certificates
    **/
    _count?: true | CertificatesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CertificatesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CertificatesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CertificatesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CertificatesMaxAggregateInputType
  }

  export type GetCertificatesAggregateType<T extends CertificatesAggregateArgs> = {
        [P in keyof T & keyof AggregateCertificates]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCertificates[P]>
      : GetScalarType<T[P], AggregateCertificates[P]>
  }




  export type certificatesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: certificatesWhereInput
    orderBy?: certificatesOrderByWithAggregationInput | certificatesOrderByWithAggregationInput[]
    by: CertificatesScalarFieldEnum[] | CertificatesScalarFieldEnum
    having?: certificatesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CertificatesCountAggregateInputType | true
    _avg?: CertificatesAvgAggregateInputType
    _sum?: CertificatesSumAggregateInputType
    _min?: CertificatesMinAggregateInputType
    _max?: CertificatesMaxAggregateInputType
  }

  export type CertificatesGroupByOutputType = {
    id: number
    title: string
    link: string | null
    description: string | null
    start_date: Date | null
    end_date: Date | null
    cv_id: number
    _count: CertificatesCountAggregateOutputType | null
    _avg: CertificatesAvgAggregateOutputType | null
    _sum: CertificatesSumAggregateOutputType | null
    _min: CertificatesMinAggregateOutputType | null
    _max: CertificatesMaxAggregateOutputType | null
  }

  type GetCertificatesGroupByPayload<T extends certificatesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CertificatesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CertificatesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CertificatesGroupByOutputType[P]>
            : GetScalarType<T[P], CertificatesGroupByOutputType[P]>
        }
      >
    >


  export type certificatesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    link?: boolean
    description?: boolean
    start_date?: boolean
    end_date?: boolean
    cv_id?: boolean
    cvs?: boolean | cvsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["certificates"]>

  export type certificatesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    link?: boolean
    description?: boolean
    start_date?: boolean
    end_date?: boolean
    cv_id?: boolean
    cvs?: boolean | cvsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["certificates"]>

  export type certificatesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    link?: boolean
    description?: boolean
    start_date?: boolean
    end_date?: boolean
    cv_id?: boolean
    cvs?: boolean | cvsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["certificates"]>

  export type certificatesSelectScalar = {
    id?: boolean
    title?: boolean
    link?: boolean
    description?: boolean
    start_date?: boolean
    end_date?: boolean
    cv_id?: boolean
  }

  export type certificatesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "link" | "description" | "start_date" | "end_date" | "cv_id", ExtArgs["result"]["certificates"]>
  export type certificatesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cvs?: boolean | cvsDefaultArgs<ExtArgs>
  }
  export type certificatesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cvs?: boolean | cvsDefaultArgs<ExtArgs>
  }
  export type certificatesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cvs?: boolean | cvsDefaultArgs<ExtArgs>
  }

  export type $certificatesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "certificates"
    objects: {
      cvs: Prisma.$cvsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      link: string | null
      description: string | null
      start_date: Date | null
      end_date: Date | null
      cv_id: number
    }, ExtArgs["result"]["certificates"]>
    composites: {}
  }

  type certificatesGetPayload<S extends boolean | null | undefined | certificatesDefaultArgs> = $Result.GetResult<Prisma.$certificatesPayload, S>

  type certificatesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<certificatesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CertificatesCountAggregateInputType | true
    }

  export interface certificatesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['certificates'], meta: { name: 'certificates' } }
    /**
     * Find zero or one Certificates that matches the filter.
     * @param {certificatesFindUniqueArgs} args - Arguments to find a Certificates
     * @example
     * // Get one Certificates
     * const certificates = await prisma.certificates.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends certificatesFindUniqueArgs>(args: SelectSubset<T, certificatesFindUniqueArgs<ExtArgs>>): Prisma__certificatesClient<$Result.GetResult<Prisma.$certificatesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Certificates that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {certificatesFindUniqueOrThrowArgs} args - Arguments to find a Certificates
     * @example
     * // Get one Certificates
     * const certificates = await prisma.certificates.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends certificatesFindUniqueOrThrowArgs>(args: SelectSubset<T, certificatesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__certificatesClient<$Result.GetResult<Prisma.$certificatesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Certificates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {certificatesFindFirstArgs} args - Arguments to find a Certificates
     * @example
     * // Get one Certificates
     * const certificates = await prisma.certificates.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends certificatesFindFirstArgs>(args?: SelectSubset<T, certificatesFindFirstArgs<ExtArgs>>): Prisma__certificatesClient<$Result.GetResult<Prisma.$certificatesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Certificates that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {certificatesFindFirstOrThrowArgs} args - Arguments to find a Certificates
     * @example
     * // Get one Certificates
     * const certificates = await prisma.certificates.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends certificatesFindFirstOrThrowArgs>(args?: SelectSubset<T, certificatesFindFirstOrThrowArgs<ExtArgs>>): Prisma__certificatesClient<$Result.GetResult<Prisma.$certificatesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Certificates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {certificatesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Certificates
     * const certificates = await prisma.certificates.findMany()
     * 
     * // Get first 10 Certificates
     * const certificates = await prisma.certificates.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const certificatesWithIdOnly = await prisma.certificates.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends certificatesFindManyArgs>(args?: SelectSubset<T, certificatesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$certificatesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Certificates.
     * @param {certificatesCreateArgs} args - Arguments to create a Certificates.
     * @example
     * // Create one Certificates
     * const Certificates = await prisma.certificates.create({
     *   data: {
     *     // ... data to create a Certificates
     *   }
     * })
     * 
     */
    create<T extends certificatesCreateArgs>(args: SelectSubset<T, certificatesCreateArgs<ExtArgs>>): Prisma__certificatesClient<$Result.GetResult<Prisma.$certificatesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Certificates.
     * @param {certificatesCreateManyArgs} args - Arguments to create many Certificates.
     * @example
     * // Create many Certificates
     * const certificates = await prisma.certificates.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends certificatesCreateManyArgs>(args?: SelectSubset<T, certificatesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Certificates and returns the data saved in the database.
     * @param {certificatesCreateManyAndReturnArgs} args - Arguments to create many Certificates.
     * @example
     * // Create many Certificates
     * const certificates = await prisma.certificates.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Certificates and only return the `id`
     * const certificatesWithIdOnly = await prisma.certificates.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends certificatesCreateManyAndReturnArgs>(args?: SelectSubset<T, certificatesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$certificatesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Certificates.
     * @param {certificatesDeleteArgs} args - Arguments to delete one Certificates.
     * @example
     * // Delete one Certificates
     * const Certificates = await prisma.certificates.delete({
     *   where: {
     *     // ... filter to delete one Certificates
     *   }
     * })
     * 
     */
    delete<T extends certificatesDeleteArgs>(args: SelectSubset<T, certificatesDeleteArgs<ExtArgs>>): Prisma__certificatesClient<$Result.GetResult<Prisma.$certificatesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Certificates.
     * @param {certificatesUpdateArgs} args - Arguments to update one Certificates.
     * @example
     * // Update one Certificates
     * const certificates = await prisma.certificates.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends certificatesUpdateArgs>(args: SelectSubset<T, certificatesUpdateArgs<ExtArgs>>): Prisma__certificatesClient<$Result.GetResult<Prisma.$certificatesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Certificates.
     * @param {certificatesDeleteManyArgs} args - Arguments to filter Certificates to delete.
     * @example
     * // Delete a few Certificates
     * const { count } = await prisma.certificates.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends certificatesDeleteManyArgs>(args?: SelectSubset<T, certificatesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Certificates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {certificatesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Certificates
     * const certificates = await prisma.certificates.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends certificatesUpdateManyArgs>(args: SelectSubset<T, certificatesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Certificates and returns the data updated in the database.
     * @param {certificatesUpdateManyAndReturnArgs} args - Arguments to update many Certificates.
     * @example
     * // Update many Certificates
     * const certificates = await prisma.certificates.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Certificates and only return the `id`
     * const certificatesWithIdOnly = await prisma.certificates.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends certificatesUpdateManyAndReturnArgs>(args: SelectSubset<T, certificatesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$certificatesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Certificates.
     * @param {certificatesUpsertArgs} args - Arguments to update or create a Certificates.
     * @example
     * // Update or create a Certificates
     * const certificates = await prisma.certificates.upsert({
     *   create: {
     *     // ... data to create a Certificates
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Certificates we want to update
     *   }
     * })
     */
    upsert<T extends certificatesUpsertArgs>(args: SelectSubset<T, certificatesUpsertArgs<ExtArgs>>): Prisma__certificatesClient<$Result.GetResult<Prisma.$certificatesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Certificates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {certificatesCountArgs} args - Arguments to filter Certificates to count.
     * @example
     * // Count the number of Certificates
     * const count = await prisma.certificates.count({
     *   where: {
     *     // ... the filter for the Certificates we want to count
     *   }
     * })
    **/
    count<T extends certificatesCountArgs>(
      args?: Subset<T, certificatesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CertificatesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Certificates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificatesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CertificatesAggregateArgs>(args: Subset<T, CertificatesAggregateArgs>): Prisma.PrismaPromise<GetCertificatesAggregateType<T>>

    /**
     * Group by Certificates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {certificatesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends certificatesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: certificatesGroupByArgs['orderBy'] }
        : { orderBy?: certificatesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, certificatesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCertificatesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the certificates model
   */
  readonly fields: certificatesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for certificates.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__certificatesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cvs<T extends cvsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, cvsDefaultArgs<ExtArgs>>): Prisma__cvsClient<$Result.GetResult<Prisma.$cvsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the certificates model
   */
  interface certificatesFieldRefs {
    readonly id: FieldRef<"certificates", 'Int'>
    readonly title: FieldRef<"certificates", 'String'>
    readonly link: FieldRef<"certificates", 'String'>
    readonly description: FieldRef<"certificates", 'String'>
    readonly start_date: FieldRef<"certificates", 'DateTime'>
    readonly end_date: FieldRef<"certificates", 'DateTime'>
    readonly cv_id: FieldRef<"certificates", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * certificates findUnique
   */
  export type certificatesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificates
     */
    select?: certificatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the certificates
     */
    omit?: certificatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificatesInclude<ExtArgs> | null
    /**
     * Filter, which certificates to fetch.
     */
    where: certificatesWhereUniqueInput
  }

  /**
   * certificates findUniqueOrThrow
   */
  export type certificatesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificates
     */
    select?: certificatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the certificates
     */
    omit?: certificatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificatesInclude<ExtArgs> | null
    /**
     * Filter, which certificates to fetch.
     */
    where: certificatesWhereUniqueInput
  }

  /**
   * certificates findFirst
   */
  export type certificatesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificates
     */
    select?: certificatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the certificates
     */
    omit?: certificatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificatesInclude<ExtArgs> | null
    /**
     * Filter, which certificates to fetch.
     */
    where?: certificatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of certificates to fetch.
     */
    orderBy?: certificatesOrderByWithRelationInput | certificatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for certificates.
     */
    cursor?: certificatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` certificates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of certificates.
     */
    distinct?: CertificatesScalarFieldEnum | CertificatesScalarFieldEnum[]
  }

  /**
   * certificates findFirstOrThrow
   */
  export type certificatesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificates
     */
    select?: certificatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the certificates
     */
    omit?: certificatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificatesInclude<ExtArgs> | null
    /**
     * Filter, which certificates to fetch.
     */
    where?: certificatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of certificates to fetch.
     */
    orderBy?: certificatesOrderByWithRelationInput | certificatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for certificates.
     */
    cursor?: certificatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` certificates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of certificates.
     */
    distinct?: CertificatesScalarFieldEnum | CertificatesScalarFieldEnum[]
  }

  /**
   * certificates findMany
   */
  export type certificatesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificates
     */
    select?: certificatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the certificates
     */
    omit?: certificatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificatesInclude<ExtArgs> | null
    /**
     * Filter, which certificates to fetch.
     */
    where?: certificatesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of certificates to fetch.
     */
    orderBy?: certificatesOrderByWithRelationInput | certificatesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing certificates.
     */
    cursor?: certificatesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` certificates.
     */
    skip?: number
    distinct?: CertificatesScalarFieldEnum | CertificatesScalarFieldEnum[]
  }

  /**
   * certificates create
   */
  export type certificatesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificates
     */
    select?: certificatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the certificates
     */
    omit?: certificatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificatesInclude<ExtArgs> | null
    /**
     * The data needed to create a certificates.
     */
    data: XOR<certificatesCreateInput, certificatesUncheckedCreateInput>
  }

  /**
   * certificates createMany
   */
  export type certificatesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many certificates.
     */
    data: certificatesCreateManyInput | certificatesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * certificates createManyAndReturn
   */
  export type certificatesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificates
     */
    select?: certificatesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the certificates
     */
    omit?: certificatesOmit<ExtArgs> | null
    /**
     * The data used to create many certificates.
     */
    data: certificatesCreateManyInput | certificatesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificatesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * certificates update
   */
  export type certificatesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificates
     */
    select?: certificatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the certificates
     */
    omit?: certificatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificatesInclude<ExtArgs> | null
    /**
     * The data needed to update a certificates.
     */
    data: XOR<certificatesUpdateInput, certificatesUncheckedUpdateInput>
    /**
     * Choose, which certificates to update.
     */
    where: certificatesWhereUniqueInput
  }

  /**
   * certificates updateMany
   */
  export type certificatesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update certificates.
     */
    data: XOR<certificatesUpdateManyMutationInput, certificatesUncheckedUpdateManyInput>
    /**
     * Filter which certificates to update
     */
    where?: certificatesWhereInput
    /**
     * Limit how many certificates to update.
     */
    limit?: number
  }

  /**
   * certificates updateManyAndReturn
   */
  export type certificatesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificates
     */
    select?: certificatesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the certificates
     */
    omit?: certificatesOmit<ExtArgs> | null
    /**
     * The data used to update certificates.
     */
    data: XOR<certificatesUpdateManyMutationInput, certificatesUncheckedUpdateManyInput>
    /**
     * Filter which certificates to update
     */
    where?: certificatesWhereInput
    /**
     * Limit how many certificates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificatesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * certificates upsert
   */
  export type certificatesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificates
     */
    select?: certificatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the certificates
     */
    omit?: certificatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificatesInclude<ExtArgs> | null
    /**
     * The filter to search for the certificates to update in case it exists.
     */
    where: certificatesWhereUniqueInput
    /**
     * In case the certificates found by the `where` argument doesn't exist, create a new certificates with this data.
     */
    create: XOR<certificatesCreateInput, certificatesUncheckedCreateInput>
    /**
     * In case the certificates was found with the provided `where` argument, update it with this data.
     */
    update: XOR<certificatesUpdateInput, certificatesUncheckedUpdateInput>
  }

  /**
   * certificates delete
   */
  export type certificatesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificates
     */
    select?: certificatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the certificates
     */
    omit?: certificatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificatesInclude<ExtArgs> | null
    /**
     * Filter which certificates to delete.
     */
    where: certificatesWhereUniqueInput
  }

  /**
   * certificates deleteMany
   */
  export type certificatesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which certificates to delete
     */
    where?: certificatesWhereInput
    /**
     * Limit how many certificates to delete.
     */
    limit?: number
  }

  /**
   * certificates without action
   */
  export type certificatesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificates
     */
    select?: certificatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the certificates
     */
    omit?: certificatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificatesInclude<ExtArgs> | null
  }


  /**
   * Model companies
   */

  export type AggregateCompanies = {
    _count: CompaniesCountAggregateOutputType | null
    _avg: CompaniesAvgAggregateOutputType | null
    _sum: CompaniesSumAggregateOutputType | null
    _min: CompaniesMinAggregateOutputType | null
    _max: CompaniesMaxAggregateOutputType | null
  }

  export type CompaniesAvgAggregateOutputType = {
    employees: number | null
    field_id: number | null
    label_id: number | null
  }

  export type CompaniesSumAggregateOutputType = {
    employees: number | null
    field_id: number | null
    label_id: number | null
  }

  export type CompaniesMinAggregateOutputType = {
    id: string | null
    company_name: string | null
    company_website: string | null
    address_street: string | null
    address_ward: string | null
    address_city: string | null
    address_country: string | null
    email: string | null
    phone: string | null
    business_certificate: string | null
    company_type: $Enums.Company_Type | null
    description: string | null
    logo_url: string | null
    background_url: string | null
    employees: number | null
    is_verified: boolean | null
    fax_code: string | null
    is_deleted: boolean | null
    created_at: Date | null
    updated_at: Date | null
    field_id: number | null
    label_id: number | null
  }

  export type CompaniesMaxAggregateOutputType = {
    id: string | null
    company_name: string | null
    company_website: string | null
    address_street: string | null
    address_ward: string | null
    address_city: string | null
    address_country: string | null
    email: string | null
    phone: string | null
    business_certificate: string | null
    company_type: $Enums.Company_Type | null
    description: string | null
    logo_url: string | null
    background_url: string | null
    employees: number | null
    is_verified: boolean | null
    fax_code: string | null
    is_deleted: boolean | null
    created_at: Date | null
    updated_at: Date | null
    field_id: number | null
    label_id: number | null
  }

  export type CompaniesCountAggregateOutputType = {
    id: number
    company_name: number
    company_website: number
    address_street: number
    address_ward: number
    address_city: number
    address_country: number
    email: number
    phone: number
    business_certificate: number
    company_type: number
    description: number
    logo_url: number
    background_url: number
    employees: number
    is_verified: number
    fax_code: number
    is_deleted: number
    created_at: number
    updated_at: number
    field_id: number
    label_id: number
    _all: number
  }


  export type CompaniesAvgAggregateInputType = {
    employees?: true
    field_id?: true
    label_id?: true
  }

  export type CompaniesSumAggregateInputType = {
    employees?: true
    field_id?: true
    label_id?: true
  }

  export type CompaniesMinAggregateInputType = {
    id?: true
    company_name?: true
    company_website?: true
    address_street?: true
    address_ward?: true
    address_city?: true
    address_country?: true
    email?: true
    phone?: true
    business_certificate?: true
    company_type?: true
    description?: true
    logo_url?: true
    background_url?: true
    employees?: true
    is_verified?: true
    fax_code?: true
    is_deleted?: true
    created_at?: true
    updated_at?: true
    field_id?: true
    label_id?: true
  }

  export type CompaniesMaxAggregateInputType = {
    id?: true
    company_name?: true
    company_website?: true
    address_street?: true
    address_ward?: true
    address_city?: true
    address_country?: true
    email?: true
    phone?: true
    business_certificate?: true
    company_type?: true
    description?: true
    logo_url?: true
    background_url?: true
    employees?: true
    is_verified?: true
    fax_code?: true
    is_deleted?: true
    created_at?: true
    updated_at?: true
    field_id?: true
    label_id?: true
  }

  export type CompaniesCountAggregateInputType = {
    id?: true
    company_name?: true
    company_website?: true
    address_street?: true
    address_ward?: true
    address_city?: true
    address_country?: true
    email?: true
    phone?: true
    business_certificate?: true
    company_type?: true
    description?: true
    logo_url?: true
    background_url?: true
    employees?: true
    is_verified?: true
    fax_code?: true
    is_deleted?: true
    created_at?: true
    updated_at?: true
    field_id?: true
    label_id?: true
    _all?: true
  }

  export type CompaniesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which companies to aggregate.
     */
    where?: companiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companies to fetch.
     */
    orderBy?: companiesOrderByWithRelationInput | companiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: companiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned companies
    **/
    _count?: true | CompaniesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompaniesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompaniesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompaniesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompaniesMaxAggregateInputType
  }

  export type GetCompaniesAggregateType<T extends CompaniesAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanies]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanies[P]>
      : GetScalarType<T[P], AggregateCompanies[P]>
  }




  export type companiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: companiesWhereInput
    orderBy?: companiesOrderByWithAggregationInput | companiesOrderByWithAggregationInput[]
    by: CompaniesScalarFieldEnum[] | CompaniesScalarFieldEnum
    having?: companiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompaniesCountAggregateInputType | true
    _avg?: CompaniesAvgAggregateInputType
    _sum?: CompaniesSumAggregateInputType
    _min?: CompaniesMinAggregateInputType
    _max?: CompaniesMaxAggregateInputType
  }

  export type CompaniesGroupByOutputType = {
    id: string
    company_name: string
    company_website: string | null
    address_street: string
    address_ward: string
    address_city: string
    address_country: string
    email: string
    phone: string
    business_certificate: string | null
    company_type: $Enums.Company_Type
    description: string | null
    logo_url: string | null
    background_url: string | null
    employees: number | null
    is_verified: boolean
    fax_code: string | null
    is_deleted: boolean
    created_at: Date
    updated_at: Date
    field_id: number | null
    label_id: number | null
    _count: CompaniesCountAggregateOutputType | null
    _avg: CompaniesAvgAggregateOutputType | null
    _sum: CompaniesSumAggregateOutputType | null
    _min: CompaniesMinAggregateOutputType | null
    _max: CompaniesMaxAggregateOutputType | null
  }

  type GetCompaniesGroupByPayload<T extends companiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompaniesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompaniesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompaniesGroupByOutputType[P]>
            : GetScalarType<T[P], CompaniesGroupByOutputType[P]>
        }
      >
    >


  export type companiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company_name?: boolean
    company_website?: boolean
    address_street?: boolean
    address_ward?: boolean
    address_city?: boolean
    address_country?: boolean
    email?: boolean
    phone?: boolean
    business_certificate?: boolean
    company_type?: boolean
    description?: boolean
    logo_url?: boolean
    background_url?: boolean
    employees?: boolean
    is_verified?: boolean
    fax_code?: boolean
    is_deleted?: boolean
    created_at?: boolean
    updated_at?: boolean
    field_id?: boolean
    label_id?: boolean
    fields?: boolean | companies$fieldsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    companyLabels?: boolean | companies$companyLabelsArgs<ExtArgs>
    companyActivitiesHistory?: boolean | companies$companyActivitiesHistoryArgs<ExtArgs>
    companyNotifications?: boolean | companies$companyNotificationsArgs<ExtArgs>
    feedbacks?: boolean | companies$feedbacksArgs<ExtArgs>
    followedCompanies?: boolean | companies$followedCompaniesArgs<ExtArgs>
    _count?: boolean | CompaniesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companies"]>

  export type companiesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company_name?: boolean
    company_website?: boolean
    address_street?: boolean
    address_ward?: boolean
    address_city?: boolean
    address_country?: boolean
    email?: boolean
    phone?: boolean
    business_certificate?: boolean
    company_type?: boolean
    description?: boolean
    logo_url?: boolean
    background_url?: boolean
    employees?: boolean
    is_verified?: boolean
    fax_code?: boolean
    is_deleted?: boolean
    created_at?: boolean
    updated_at?: boolean
    field_id?: boolean
    label_id?: boolean
    fields?: boolean | companies$fieldsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    companyLabels?: boolean | companies$companyLabelsArgs<ExtArgs>
  }, ExtArgs["result"]["companies"]>

  export type companiesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company_name?: boolean
    company_website?: boolean
    address_street?: boolean
    address_ward?: boolean
    address_city?: boolean
    address_country?: boolean
    email?: boolean
    phone?: boolean
    business_certificate?: boolean
    company_type?: boolean
    description?: boolean
    logo_url?: boolean
    background_url?: boolean
    employees?: boolean
    is_verified?: boolean
    fax_code?: boolean
    is_deleted?: boolean
    created_at?: boolean
    updated_at?: boolean
    field_id?: boolean
    label_id?: boolean
    fields?: boolean | companies$fieldsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    companyLabels?: boolean | companies$companyLabelsArgs<ExtArgs>
  }, ExtArgs["result"]["companies"]>

  export type companiesSelectScalar = {
    id?: boolean
    company_name?: boolean
    company_website?: boolean
    address_street?: boolean
    address_ward?: boolean
    address_city?: boolean
    address_country?: boolean
    email?: boolean
    phone?: boolean
    business_certificate?: boolean
    company_type?: boolean
    description?: boolean
    logo_url?: boolean
    background_url?: boolean
    employees?: boolean
    is_verified?: boolean
    fax_code?: boolean
    is_deleted?: boolean
    created_at?: boolean
    updated_at?: boolean
    field_id?: boolean
    label_id?: boolean
  }

  export type companiesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "company_name" | "company_website" | "address_street" | "address_ward" | "address_city" | "address_country" | "email" | "phone" | "business_certificate" | "company_type" | "description" | "logo_url" | "background_url" | "employees" | "is_verified" | "fax_code" | "is_deleted" | "created_at" | "updated_at" | "field_id" | "label_id", ExtArgs["result"]["companies"]>
  export type companiesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fields?: boolean | companies$fieldsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    companyLabels?: boolean | companies$companyLabelsArgs<ExtArgs>
    companyActivitiesHistory?: boolean | companies$companyActivitiesHistoryArgs<ExtArgs>
    companyNotifications?: boolean | companies$companyNotificationsArgs<ExtArgs>
    feedbacks?: boolean | companies$feedbacksArgs<ExtArgs>
    followedCompanies?: boolean | companies$followedCompaniesArgs<ExtArgs>
    _count?: boolean | CompaniesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type companiesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fields?: boolean | companies$fieldsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    companyLabels?: boolean | companies$companyLabelsArgs<ExtArgs>
  }
  export type companiesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fields?: boolean | companies$fieldsArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
    companyLabels?: boolean | companies$companyLabelsArgs<ExtArgs>
  }

  export type $companiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "companies"
    objects: {
      fields: Prisma.$fieldsPayload<ExtArgs> | null
      users: Prisma.$usersPayload<ExtArgs>
      companyLabels: Prisma.$companyLabelsPayload<ExtArgs> | null
      companyActivitiesHistory: Prisma.$companyActivitiesHistoryPayload<ExtArgs>[]
      companyNotifications: Prisma.$companyNotificationsPayload<ExtArgs>[]
      feedbacks: Prisma.$feedbacksPayload<ExtArgs>[]
      followedCompanies: Prisma.$followedCompaniesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      company_name: string
      company_website: string | null
      address_street: string
      address_ward: string
      address_city: string
      address_country: string
      email: string
      phone: string
      business_certificate: string | null
      company_type: $Enums.Company_Type
      description: string | null
      logo_url: string | null
      background_url: string | null
      employees: number | null
      is_verified: boolean
      fax_code: string | null
      is_deleted: boolean
      created_at: Date
      updated_at: Date
      field_id: number | null
      label_id: number | null
    }, ExtArgs["result"]["companies"]>
    composites: {}
  }

  type companiesGetPayload<S extends boolean | null | undefined | companiesDefaultArgs> = $Result.GetResult<Prisma.$companiesPayload, S>

  type companiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<companiesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompaniesCountAggregateInputType | true
    }

  export interface companiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['companies'], meta: { name: 'companies' } }
    /**
     * Find zero or one Companies that matches the filter.
     * @param {companiesFindUniqueArgs} args - Arguments to find a Companies
     * @example
     * // Get one Companies
     * const companies = await prisma.companies.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends companiesFindUniqueArgs>(args: SelectSubset<T, companiesFindUniqueArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Companies that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {companiesFindUniqueOrThrowArgs} args - Arguments to find a Companies
     * @example
     * // Get one Companies
     * const companies = await prisma.companies.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends companiesFindUniqueOrThrowArgs>(args: SelectSubset<T, companiesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companiesFindFirstArgs} args - Arguments to find a Companies
     * @example
     * // Get one Companies
     * const companies = await prisma.companies.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends companiesFindFirstArgs>(args?: SelectSubset<T, companiesFindFirstArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Companies that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companiesFindFirstOrThrowArgs} args - Arguments to find a Companies
     * @example
     * // Get one Companies
     * const companies = await prisma.companies.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends companiesFindFirstOrThrowArgs>(args?: SelectSubset<T, companiesFindFirstOrThrowArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companies
     * const companies = await prisma.companies.findMany()
     * 
     * // Get first 10 Companies
     * const companies = await prisma.companies.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companiesWithIdOnly = await prisma.companies.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends companiesFindManyArgs>(args?: SelectSubset<T, companiesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Companies.
     * @param {companiesCreateArgs} args - Arguments to create a Companies.
     * @example
     * // Create one Companies
     * const Companies = await prisma.companies.create({
     *   data: {
     *     // ... data to create a Companies
     *   }
     * })
     * 
     */
    create<T extends companiesCreateArgs>(args: SelectSubset<T, companiesCreateArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Companies.
     * @param {companiesCreateManyArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const companies = await prisma.companies.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends companiesCreateManyArgs>(args?: SelectSubset<T, companiesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Companies and returns the data saved in the database.
     * @param {companiesCreateManyAndReturnArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const companies = await prisma.companies.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Companies and only return the `id`
     * const companiesWithIdOnly = await prisma.companies.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends companiesCreateManyAndReturnArgs>(args?: SelectSubset<T, companiesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Companies.
     * @param {companiesDeleteArgs} args - Arguments to delete one Companies.
     * @example
     * // Delete one Companies
     * const Companies = await prisma.companies.delete({
     *   where: {
     *     // ... filter to delete one Companies
     *   }
     * })
     * 
     */
    delete<T extends companiesDeleteArgs>(args: SelectSubset<T, companiesDeleteArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Companies.
     * @param {companiesUpdateArgs} args - Arguments to update one Companies.
     * @example
     * // Update one Companies
     * const companies = await prisma.companies.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends companiesUpdateArgs>(args: SelectSubset<T, companiesUpdateArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Companies.
     * @param {companiesDeleteManyArgs} args - Arguments to filter Companies to delete.
     * @example
     * // Delete a few Companies
     * const { count } = await prisma.companies.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends companiesDeleteManyArgs>(args?: SelectSubset<T, companiesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companies
     * const companies = await prisma.companies.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends companiesUpdateManyArgs>(args: SelectSubset<T, companiesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies and returns the data updated in the database.
     * @param {companiesUpdateManyAndReturnArgs} args - Arguments to update many Companies.
     * @example
     * // Update many Companies
     * const companies = await prisma.companies.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Companies and only return the `id`
     * const companiesWithIdOnly = await prisma.companies.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends companiesUpdateManyAndReturnArgs>(args: SelectSubset<T, companiesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Companies.
     * @param {companiesUpsertArgs} args - Arguments to update or create a Companies.
     * @example
     * // Update or create a Companies
     * const companies = await prisma.companies.upsert({
     *   create: {
     *     // ... data to create a Companies
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Companies we want to update
     *   }
     * })
     */
    upsert<T extends companiesUpsertArgs>(args: SelectSubset<T, companiesUpsertArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companiesCountArgs} args - Arguments to filter Companies to count.
     * @example
     * // Count the number of Companies
     * const count = await prisma.companies.count({
     *   where: {
     *     // ... the filter for the Companies we want to count
     *   }
     * })
    **/
    count<T extends companiesCountArgs>(
      args?: Subset<T, companiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompaniesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompaniesAggregateArgs>(args: Subset<T, CompaniesAggregateArgs>): Prisma.PrismaPromise<GetCompaniesAggregateType<T>>

    /**
     * Group by Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends companiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: companiesGroupByArgs['orderBy'] }
        : { orderBy?: companiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, companiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompaniesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the companies model
   */
  readonly fields: companiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for companies.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__companiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    fields<T extends companies$fieldsArgs<ExtArgs> = {}>(args?: Subset<T, companies$fieldsArgs<ExtArgs>>): Prisma__fieldsClient<$Result.GetResult<Prisma.$fieldsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    companyLabels<T extends companies$companyLabelsArgs<ExtArgs> = {}>(args?: Subset<T, companies$companyLabelsArgs<ExtArgs>>): Prisma__companyLabelsClient<$Result.GetResult<Prisma.$companyLabelsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    companyActivitiesHistory<T extends companies$companyActivitiesHistoryArgs<ExtArgs> = {}>(args?: Subset<T, companies$companyActivitiesHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companyActivitiesHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    companyNotifications<T extends companies$companyNotificationsArgs<ExtArgs> = {}>(args?: Subset<T, companies$companyNotificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companyNotificationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    feedbacks<T extends companies$feedbacksArgs<ExtArgs> = {}>(args?: Subset<T, companies$feedbacksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$feedbacksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    followedCompanies<T extends companies$followedCompaniesArgs<ExtArgs> = {}>(args?: Subset<T, companies$followedCompaniesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$followedCompaniesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the companies model
   */
  interface companiesFieldRefs {
    readonly id: FieldRef<"companies", 'String'>
    readonly company_name: FieldRef<"companies", 'String'>
    readonly company_website: FieldRef<"companies", 'String'>
    readonly address_street: FieldRef<"companies", 'String'>
    readonly address_ward: FieldRef<"companies", 'String'>
    readonly address_city: FieldRef<"companies", 'String'>
    readonly address_country: FieldRef<"companies", 'String'>
    readonly email: FieldRef<"companies", 'String'>
    readonly phone: FieldRef<"companies", 'String'>
    readonly business_certificate: FieldRef<"companies", 'String'>
    readonly company_type: FieldRef<"companies", 'Company_Type'>
    readonly description: FieldRef<"companies", 'String'>
    readonly logo_url: FieldRef<"companies", 'String'>
    readonly background_url: FieldRef<"companies", 'String'>
    readonly employees: FieldRef<"companies", 'Int'>
    readonly is_verified: FieldRef<"companies", 'Boolean'>
    readonly fax_code: FieldRef<"companies", 'String'>
    readonly is_deleted: FieldRef<"companies", 'Boolean'>
    readonly created_at: FieldRef<"companies", 'DateTime'>
    readonly updated_at: FieldRef<"companies", 'DateTime'>
    readonly field_id: FieldRef<"companies", 'Int'>
    readonly label_id: FieldRef<"companies", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * companies findUnique
   */
  export type companiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * Filter, which companies to fetch.
     */
    where: companiesWhereUniqueInput
  }

  /**
   * companies findUniqueOrThrow
   */
  export type companiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * Filter, which companies to fetch.
     */
    where: companiesWhereUniqueInput
  }

  /**
   * companies findFirst
   */
  export type companiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * Filter, which companies to fetch.
     */
    where?: companiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companies to fetch.
     */
    orderBy?: companiesOrderByWithRelationInput | companiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for companies.
     */
    cursor?: companiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of companies.
     */
    distinct?: CompaniesScalarFieldEnum | CompaniesScalarFieldEnum[]
  }

  /**
   * companies findFirstOrThrow
   */
  export type companiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * Filter, which companies to fetch.
     */
    where?: companiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companies to fetch.
     */
    orderBy?: companiesOrderByWithRelationInput | companiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for companies.
     */
    cursor?: companiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of companies.
     */
    distinct?: CompaniesScalarFieldEnum | CompaniesScalarFieldEnum[]
  }

  /**
   * companies findMany
   */
  export type companiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * Filter, which companies to fetch.
     */
    where?: companiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companies to fetch.
     */
    orderBy?: companiesOrderByWithRelationInput | companiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing companies.
     */
    cursor?: companiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companies.
     */
    skip?: number
    distinct?: CompaniesScalarFieldEnum | CompaniesScalarFieldEnum[]
  }

  /**
   * companies create
   */
  export type companiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * The data needed to create a companies.
     */
    data: XOR<companiesCreateInput, companiesUncheckedCreateInput>
  }

  /**
   * companies createMany
   */
  export type companiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many companies.
     */
    data: companiesCreateManyInput | companiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * companies createManyAndReturn
   */
  export type companiesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * The data used to create many companies.
     */
    data: companiesCreateManyInput | companiesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * companies update
   */
  export type companiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * The data needed to update a companies.
     */
    data: XOR<companiesUpdateInput, companiesUncheckedUpdateInput>
    /**
     * Choose, which companies to update.
     */
    where: companiesWhereUniqueInput
  }

  /**
   * companies updateMany
   */
  export type companiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update companies.
     */
    data: XOR<companiesUpdateManyMutationInput, companiesUncheckedUpdateManyInput>
    /**
     * Filter which companies to update
     */
    where?: companiesWhereInput
    /**
     * Limit how many companies to update.
     */
    limit?: number
  }

  /**
   * companies updateManyAndReturn
   */
  export type companiesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * The data used to update companies.
     */
    data: XOR<companiesUpdateManyMutationInput, companiesUncheckedUpdateManyInput>
    /**
     * Filter which companies to update
     */
    where?: companiesWhereInput
    /**
     * Limit how many companies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * companies upsert
   */
  export type companiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * The filter to search for the companies to update in case it exists.
     */
    where: companiesWhereUniqueInput
    /**
     * In case the companies found by the `where` argument doesn't exist, create a new companies with this data.
     */
    create: XOR<companiesCreateInput, companiesUncheckedCreateInput>
    /**
     * In case the companies was found with the provided `where` argument, update it with this data.
     */
    update: XOR<companiesUpdateInput, companiesUncheckedUpdateInput>
  }

  /**
   * companies delete
   */
  export type companiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * Filter which companies to delete.
     */
    where: companiesWhereUniqueInput
  }

  /**
   * companies deleteMany
   */
  export type companiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which companies to delete
     */
    where?: companiesWhereInput
    /**
     * Limit how many companies to delete.
     */
    limit?: number
  }

  /**
   * companies.fields
   */
  export type companies$fieldsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fields
     */
    select?: fieldsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fields
     */
    omit?: fieldsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fieldsInclude<ExtArgs> | null
    where?: fieldsWhereInput
  }

  /**
   * companies.companyLabels
   */
  export type companies$companyLabelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyLabels
     */
    select?: companyLabelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companyLabels
     */
    omit?: companyLabelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyLabelsInclude<ExtArgs> | null
    where?: companyLabelsWhereInput
  }

  /**
   * companies.companyActivitiesHistory
   */
  export type companies$companyActivitiesHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyActivitiesHistory
     */
    select?: companyActivitiesHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the companyActivitiesHistory
     */
    omit?: companyActivitiesHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyActivitiesHistoryInclude<ExtArgs> | null
    where?: companyActivitiesHistoryWhereInput
    orderBy?: companyActivitiesHistoryOrderByWithRelationInput | companyActivitiesHistoryOrderByWithRelationInput[]
    cursor?: companyActivitiesHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyActivitiesHistoryScalarFieldEnum | CompanyActivitiesHistoryScalarFieldEnum[]
  }

  /**
   * companies.companyNotifications
   */
  export type companies$companyNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyNotifications
     */
    select?: companyNotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companyNotifications
     */
    omit?: companyNotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyNotificationsInclude<ExtArgs> | null
    where?: companyNotificationsWhereInput
    orderBy?: companyNotificationsOrderByWithRelationInput | companyNotificationsOrderByWithRelationInput[]
    cursor?: companyNotificationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyNotificationsScalarFieldEnum | CompanyNotificationsScalarFieldEnum[]
  }

  /**
   * companies.feedbacks
   */
  export type companies$feedbacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feedbacks
     */
    select?: feedbacksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the feedbacks
     */
    omit?: feedbacksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feedbacksInclude<ExtArgs> | null
    where?: feedbacksWhereInput
    orderBy?: feedbacksOrderByWithRelationInput | feedbacksOrderByWithRelationInput[]
    cursor?: feedbacksWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeedbacksScalarFieldEnum | FeedbacksScalarFieldEnum[]
  }

  /**
   * companies.followedCompanies
   */
  export type companies$followedCompaniesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the followedCompanies
     */
    select?: followedCompaniesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the followedCompanies
     */
    omit?: followedCompaniesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: followedCompaniesInclude<ExtArgs> | null
    where?: followedCompaniesWhereInput
    orderBy?: followedCompaniesOrderByWithRelationInput | followedCompaniesOrderByWithRelationInput[]
    cursor?: followedCompaniesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FollowedCompaniesScalarFieldEnum | FollowedCompaniesScalarFieldEnum[]
  }

  /**
   * companies without action
   */
  export type companiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
  }


  /**
   * Model companyActivitiesHistory
   */

  export type AggregateCompanyActivitiesHistory = {
    _count: CompanyActivitiesHistoryCountAggregateOutputType | null
    _avg: CompanyActivitiesHistoryAvgAggregateOutputType | null
    _sum: CompanyActivitiesHistorySumAggregateOutputType | null
    _min: CompanyActivitiesHistoryMinAggregateOutputType | null
    _max: CompanyActivitiesHistoryMaxAggregateOutputType | null
  }

  export type CompanyActivitiesHistoryAvgAggregateOutputType = {
    id: number | null
  }

  export type CompanyActivitiesHistorySumAggregateOutputType = {
    id: number | null
  }

  export type CompanyActivitiesHistoryMinAggregateOutputType = {
    id: number | null
    activity_name: string | null
    time: Date | null
    company_id: string | null
  }

  export type CompanyActivitiesHistoryMaxAggregateOutputType = {
    id: number | null
    activity_name: string | null
    time: Date | null
    company_id: string | null
  }

  export type CompanyActivitiesHistoryCountAggregateOutputType = {
    id: number
    activity_name: number
    time: number
    company_id: number
    _all: number
  }


  export type CompanyActivitiesHistoryAvgAggregateInputType = {
    id?: true
  }

  export type CompanyActivitiesHistorySumAggregateInputType = {
    id?: true
  }

  export type CompanyActivitiesHistoryMinAggregateInputType = {
    id?: true
    activity_name?: true
    time?: true
    company_id?: true
  }

  export type CompanyActivitiesHistoryMaxAggregateInputType = {
    id?: true
    activity_name?: true
    time?: true
    company_id?: true
  }

  export type CompanyActivitiesHistoryCountAggregateInputType = {
    id?: true
    activity_name?: true
    time?: true
    company_id?: true
    _all?: true
  }

  export type CompanyActivitiesHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which companyActivitiesHistory to aggregate.
     */
    where?: companyActivitiesHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companyActivitiesHistories to fetch.
     */
    orderBy?: companyActivitiesHistoryOrderByWithRelationInput | companyActivitiesHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: companyActivitiesHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companyActivitiesHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companyActivitiesHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned companyActivitiesHistories
    **/
    _count?: true | CompanyActivitiesHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompanyActivitiesHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompanyActivitiesHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyActivitiesHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyActivitiesHistoryMaxAggregateInputType
  }

  export type GetCompanyActivitiesHistoryAggregateType<T extends CompanyActivitiesHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanyActivitiesHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanyActivitiesHistory[P]>
      : GetScalarType<T[P], AggregateCompanyActivitiesHistory[P]>
  }




  export type companyActivitiesHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: companyActivitiesHistoryWhereInput
    orderBy?: companyActivitiesHistoryOrderByWithAggregationInput | companyActivitiesHistoryOrderByWithAggregationInput[]
    by: CompanyActivitiesHistoryScalarFieldEnum[] | CompanyActivitiesHistoryScalarFieldEnum
    having?: companyActivitiesHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyActivitiesHistoryCountAggregateInputType | true
    _avg?: CompanyActivitiesHistoryAvgAggregateInputType
    _sum?: CompanyActivitiesHistorySumAggregateInputType
    _min?: CompanyActivitiesHistoryMinAggregateInputType
    _max?: CompanyActivitiesHistoryMaxAggregateInputType
  }

  export type CompanyActivitiesHistoryGroupByOutputType = {
    id: number
    activity_name: string
    time: Date
    company_id: string
    _count: CompanyActivitiesHistoryCountAggregateOutputType | null
    _avg: CompanyActivitiesHistoryAvgAggregateOutputType | null
    _sum: CompanyActivitiesHistorySumAggregateOutputType | null
    _min: CompanyActivitiesHistoryMinAggregateOutputType | null
    _max: CompanyActivitiesHistoryMaxAggregateOutputType | null
  }

  type GetCompanyActivitiesHistoryGroupByPayload<T extends companyActivitiesHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyActivitiesHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyActivitiesHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyActivitiesHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyActivitiesHistoryGroupByOutputType[P]>
        }
      >
    >


  export type companyActivitiesHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    activity_name?: boolean
    time?: boolean
    company_id?: boolean
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyActivitiesHistory"]>

  export type companyActivitiesHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    activity_name?: boolean
    time?: boolean
    company_id?: boolean
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyActivitiesHistory"]>

  export type companyActivitiesHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    activity_name?: boolean
    time?: boolean
    company_id?: boolean
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyActivitiesHistory"]>

  export type companyActivitiesHistorySelectScalar = {
    id?: boolean
    activity_name?: boolean
    time?: boolean
    company_id?: boolean
  }

  export type companyActivitiesHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "activity_name" | "time" | "company_id", ExtArgs["result"]["companyActivitiesHistory"]>
  export type companyActivitiesHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }
  export type companyActivitiesHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }
  export type companyActivitiesHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }

  export type $companyActivitiesHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "companyActivitiesHistory"
    objects: {
      companies: Prisma.$companiesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      activity_name: string
      time: Date
      company_id: string
    }, ExtArgs["result"]["companyActivitiesHistory"]>
    composites: {}
  }

  type companyActivitiesHistoryGetPayload<S extends boolean | null | undefined | companyActivitiesHistoryDefaultArgs> = $Result.GetResult<Prisma.$companyActivitiesHistoryPayload, S>

  type companyActivitiesHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<companyActivitiesHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanyActivitiesHistoryCountAggregateInputType | true
    }

  export interface companyActivitiesHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['companyActivitiesHistory'], meta: { name: 'companyActivitiesHistory' } }
    /**
     * Find zero or one CompanyActivitiesHistory that matches the filter.
     * @param {companyActivitiesHistoryFindUniqueArgs} args - Arguments to find a CompanyActivitiesHistory
     * @example
     * // Get one CompanyActivitiesHistory
     * const companyActivitiesHistory = await prisma.companyActivitiesHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends companyActivitiesHistoryFindUniqueArgs>(args: SelectSubset<T, companyActivitiesHistoryFindUniqueArgs<ExtArgs>>): Prisma__companyActivitiesHistoryClient<$Result.GetResult<Prisma.$companyActivitiesHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CompanyActivitiesHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {companyActivitiesHistoryFindUniqueOrThrowArgs} args - Arguments to find a CompanyActivitiesHistory
     * @example
     * // Get one CompanyActivitiesHistory
     * const companyActivitiesHistory = await prisma.companyActivitiesHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends companyActivitiesHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, companyActivitiesHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__companyActivitiesHistoryClient<$Result.GetResult<Prisma.$companyActivitiesHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyActivitiesHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companyActivitiesHistoryFindFirstArgs} args - Arguments to find a CompanyActivitiesHistory
     * @example
     * // Get one CompanyActivitiesHistory
     * const companyActivitiesHistory = await prisma.companyActivitiesHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends companyActivitiesHistoryFindFirstArgs>(args?: SelectSubset<T, companyActivitiesHistoryFindFirstArgs<ExtArgs>>): Prisma__companyActivitiesHistoryClient<$Result.GetResult<Prisma.$companyActivitiesHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyActivitiesHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companyActivitiesHistoryFindFirstOrThrowArgs} args - Arguments to find a CompanyActivitiesHistory
     * @example
     * // Get one CompanyActivitiesHistory
     * const companyActivitiesHistory = await prisma.companyActivitiesHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends companyActivitiesHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, companyActivitiesHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__companyActivitiesHistoryClient<$Result.GetResult<Prisma.$companyActivitiesHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CompanyActivitiesHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companyActivitiesHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompanyActivitiesHistories
     * const companyActivitiesHistories = await prisma.companyActivitiesHistory.findMany()
     * 
     * // Get first 10 CompanyActivitiesHistories
     * const companyActivitiesHistories = await prisma.companyActivitiesHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyActivitiesHistoryWithIdOnly = await prisma.companyActivitiesHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends companyActivitiesHistoryFindManyArgs>(args?: SelectSubset<T, companyActivitiesHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companyActivitiesHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CompanyActivitiesHistory.
     * @param {companyActivitiesHistoryCreateArgs} args - Arguments to create a CompanyActivitiesHistory.
     * @example
     * // Create one CompanyActivitiesHistory
     * const CompanyActivitiesHistory = await prisma.companyActivitiesHistory.create({
     *   data: {
     *     // ... data to create a CompanyActivitiesHistory
     *   }
     * })
     * 
     */
    create<T extends companyActivitiesHistoryCreateArgs>(args: SelectSubset<T, companyActivitiesHistoryCreateArgs<ExtArgs>>): Prisma__companyActivitiesHistoryClient<$Result.GetResult<Prisma.$companyActivitiesHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CompanyActivitiesHistories.
     * @param {companyActivitiesHistoryCreateManyArgs} args - Arguments to create many CompanyActivitiesHistories.
     * @example
     * // Create many CompanyActivitiesHistories
     * const companyActivitiesHistory = await prisma.companyActivitiesHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends companyActivitiesHistoryCreateManyArgs>(args?: SelectSubset<T, companyActivitiesHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CompanyActivitiesHistories and returns the data saved in the database.
     * @param {companyActivitiesHistoryCreateManyAndReturnArgs} args - Arguments to create many CompanyActivitiesHistories.
     * @example
     * // Create many CompanyActivitiesHistories
     * const companyActivitiesHistory = await prisma.companyActivitiesHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CompanyActivitiesHistories and only return the `id`
     * const companyActivitiesHistoryWithIdOnly = await prisma.companyActivitiesHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends companyActivitiesHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, companyActivitiesHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companyActivitiesHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CompanyActivitiesHistory.
     * @param {companyActivitiesHistoryDeleteArgs} args - Arguments to delete one CompanyActivitiesHistory.
     * @example
     * // Delete one CompanyActivitiesHistory
     * const CompanyActivitiesHistory = await prisma.companyActivitiesHistory.delete({
     *   where: {
     *     // ... filter to delete one CompanyActivitiesHistory
     *   }
     * })
     * 
     */
    delete<T extends companyActivitiesHistoryDeleteArgs>(args: SelectSubset<T, companyActivitiesHistoryDeleteArgs<ExtArgs>>): Prisma__companyActivitiesHistoryClient<$Result.GetResult<Prisma.$companyActivitiesHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CompanyActivitiesHistory.
     * @param {companyActivitiesHistoryUpdateArgs} args - Arguments to update one CompanyActivitiesHistory.
     * @example
     * // Update one CompanyActivitiesHistory
     * const companyActivitiesHistory = await prisma.companyActivitiesHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends companyActivitiesHistoryUpdateArgs>(args: SelectSubset<T, companyActivitiesHistoryUpdateArgs<ExtArgs>>): Prisma__companyActivitiesHistoryClient<$Result.GetResult<Prisma.$companyActivitiesHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CompanyActivitiesHistories.
     * @param {companyActivitiesHistoryDeleteManyArgs} args - Arguments to filter CompanyActivitiesHistories to delete.
     * @example
     * // Delete a few CompanyActivitiesHistories
     * const { count } = await prisma.companyActivitiesHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends companyActivitiesHistoryDeleteManyArgs>(args?: SelectSubset<T, companyActivitiesHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyActivitiesHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companyActivitiesHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompanyActivitiesHistories
     * const companyActivitiesHistory = await prisma.companyActivitiesHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends companyActivitiesHistoryUpdateManyArgs>(args: SelectSubset<T, companyActivitiesHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyActivitiesHistories and returns the data updated in the database.
     * @param {companyActivitiesHistoryUpdateManyAndReturnArgs} args - Arguments to update many CompanyActivitiesHistories.
     * @example
     * // Update many CompanyActivitiesHistories
     * const companyActivitiesHistory = await prisma.companyActivitiesHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CompanyActivitiesHistories and only return the `id`
     * const companyActivitiesHistoryWithIdOnly = await prisma.companyActivitiesHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends companyActivitiesHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, companyActivitiesHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companyActivitiesHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CompanyActivitiesHistory.
     * @param {companyActivitiesHistoryUpsertArgs} args - Arguments to update or create a CompanyActivitiesHistory.
     * @example
     * // Update or create a CompanyActivitiesHistory
     * const companyActivitiesHistory = await prisma.companyActivitiesHistory.upsert({
     *   create: {
     *     // ... data to create a CompanyActivitiesHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompanyActivitiesHistory we want to update
     *   }
     * })
     */
    upsert<T extends companyActivitiesHistoryUpsertArgs>(args: SelectSubset<T, companyActivitiesHistoryUpsertArgs<ExtArgs>>): Prisma__companyActivitiesHistoryClient<$Result.GetResult<Prisma.$companyActivitiesHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CompanyActivitiesHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companyActivitiesHistoryCountArgs} args - Arguments to filter CompanyActivitiesHistories to count.
     * @example
     * // Count the number of CompanyActivitiesHistories
     * const count = await prisma.companyActivitiesHistory.count({
     *   where: {
     *     // ... the filter for the CompanyActivitiesHistories we want to count
     *   }
     * })
    **/
    count<T extends companyActivitiesHistoryCountArgs>(
      args?: Subset<T, companyActivitiesHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyActivitiesHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompanyActivitiesHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyActivitiesHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyActivitiesHistoryAggregateArgs>(args: Subset<T, CompanyActivitiesHistoryAggregateArgs>): Prisma.PrismaPromise<GetCompanyActivitiesHistoryAggregateType<T>>

    /**
     * Group by CompanyActivitiesHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companyActivitiesHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends companyActivitiesHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: companyActivitiesHistoryGroupByArgs['orderBy'] }
        : { orderBy?: companyActivitiesHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, companyActivitiesHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyActivitiesHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the companyActivitiesHistory model
   */
  readonly fields: companyActivitiesHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for companyActivitiesHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__companyActivitiesHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    companies<T extends companiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, companiesDefaultArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the companyActivitiesHistory model
   */
  interface companyActivitiesHistoryFieldRefs {
    readonly id: FieldRef<"companyActivitiesHistory", 'Int'>
    readonly activity_name: FieldRef<"companyActivitiesHistory", 'String'>
    readonly time: FieldRef<"companyActivitiesHistory", 'DateTime'>
    readonly company_id: FieldRef<"companyActivitiesHistory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * companyActivitiesHistory findUnique
   */
  export type companyActivitiesHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyActivitiesHistory
     */
    select?: companyActivitiesHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the companyActivitiesHistory
     */
    omit?: companyActivitiesHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyActivitiesHistoryInclude<ExtArgs> | null
    /**
     * Filter, which companyActivitiesHistory to fetch.
     */
    where: companyActivitiesHistoryWhereUniqueInput
  }

  /**
   * companyActivitiesHistory findUniqueOrThrow
   */
  export type companyActivitiesHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyActivitiesHistory
     */
    select?: companyActivitiesHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the companyActivitiesHistory
     */
    omit?: companyActivitiesHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyActivitiesHistoryInclude<ExtArgs> | null
    /**
     * Filter, which companyActivitiesHistory to fetch.
     */
    where: companyActivitiesHistoryWhereUniqueInput
  }

  /**
   * companyActivitiesHistory findFirst
   */
  export type companyActivitiesHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyActivitiesHistory
     */
    select?: companyActivitiesHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the companyActivitiesHistory
     */
    omit?: companyActivitiesHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyActivitiesHistoryInclude<ExtArgs> | null
    /**
     * Filter, which companyActivitiesHistory to fetch.
     */
    where?: companyActivitiesHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companyActivitiesHistories to fetch.
     */
    orderBy?: companyActivitiesHistoryOrderByWithRelationInput | companyActivitiesHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for companyActivitiesHistories.
     */
    cursor?: companyActivitiesHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companyActivitiesHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companyActivitiesHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of companyActivitiesHistories.
     */
    distinct?: CompanyActivitiesHistoryScalarFieldEnum | CompanyActivitiesHistoryScalarFieldEnum[]
  }

  /**
   * companyActivitiesHistory findFirstOrThrow
   */
  export type companyActivitiesHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyActivitiesHistory
     */
    select?: companyActivitiesHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the companyActivitiesHistory
     */
    omit?: companyActivitiesHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyActivitiesHistoryInclude<ExtArgs> | null
    /**
     * Filter, which companyActivitiesHistory to fetch.
     */
    where?: companyActivitiesHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companyActivitiesHistories to fetch.
     */
    orderBy?: companyActivitiesHistoryOrderByWithRelationInput | companyActivitiesHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for companyActivitiesHistories.
     */
    cursor?: companyActivitiesHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companyActivitiesHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companyActivitiesHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of companyActivitiesHistories.
     */
    distinct?: CompanyActivitiesHistoryScalarFieldEnum | CompanyActivitiesHistoryScalarFieldEnum[]
  }

  /**
   * companyActivitiesHistory findMany
   */
  export type companyActivitiesHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyActivitiesHistory
     */
    select?: companyActivitiesHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the companyActivitiesHistory
     */
    omit?: companyActivitiesHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyActivitiesHistoryInclude<ExtArgs> | null
    /**
     * Filter, which companyActivitiesHistories to fetch.
     */
    where?: companyActivitiesHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companyActivitiesHistories to fetch.
     */
    orderBy?: companyActivitiesHistoryOrderByWithRelationInput | companyActivitiesHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing companyActivitiesHistories.
     */
    cursor?: companyActivitiesHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companyActivitiesHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companyActivitiesHistories.
     */
    skip?: number
    distinct?: CompanyActivitiesHistoryScalarFieldEnum | CompanyActivitiesHistoryScalarFieldEnum[]
  }

  /**
   * companyActivitiesHistory create
   */
  export type companyActivitiesHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyActivitiesHistory
     */
    select?: companyActivitiesHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the companyActivitiesHistory
     */
    omit?: companyActivitiesHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyActivitiesHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a companyActivitiesHistory.
     */
    data: XOR<companyActivitiesHistoryCreateInput, companyActivitiesHistoryUncheckedCreateInput>
  }

  /**
   * companyActivitiesHistory createMany
   */
  export type companyActivitiesHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many companyActivitiesHistories.
     */
    data: companyActivitiesHistoryCreateManyInput | companyActivitiesHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * companyActivitiesHistory createManyAndReturn
   */
  export type companyActivitiesHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyActivitiesHistory
     */
    select?: companyActivitiesHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the companyActivitiesHistory
     */
    omit?: companyActivitiesHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many companyActivitiesHistories.
     */
    data: companyActivitiesHistoryCreateManyInput | companyActivitiesHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyActivitiesHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * companyActivitiesHistory update
   */
  export type companyActivitiesHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyActivitiesHistory
     */
    select?: companyActivitiesHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the companyActivitiesHistory
     */
    omit?: companyActivitiesHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyActivitiesHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a companyActivitiesHistory.
     */
    data: XOR<companyActivitiesHistoryUpdateInput, companyActivitiesHistoryUncheckedUpdateInput>
    /**
     * Choose, which companyActivitiesHistory to update.
     */
    where: companyActivitiesHistoryWhereUniqueInput
  }

  /**
   * companyActivitiesHistory updateMany
   */
  export type companyActivitiesHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update companyActivitiesHistories.
     */
    data: XOR<companyActivitiesHistoryUpdateManyMutationInput, companyActivitiesHistoryUncheckedUpdateManyInput>
    /**
     * Filter which companyActivitiesHistories to update
     */
    where?: companyActivitiesHistoryWhereInput
    /**
     * Limit how many companyActivitiesHistories to update.
     */
    limit?: number
  }

  /**
   * companyActivitiesHistory updateManyAndReturn
   */
  export type companyActivitiesHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyActivitiesHistory
     */
    select?: companyActivitiesHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the companyActivitiesHistory
     */
    omit?: companyActivitiesHistoryOmit<ExtArgs> | null
    /**
     * The data used to update companyActivitiesHistories.
     */
    data: XOR<companyActivitiesHistoryUpdateManyMutationInput, companyActivitiesHistoryUncheckedUpdateManyInput>
    /**
     * Filter which companyActivitiesHistories to update
     */
    where?: companyActivitiesHistoryWhereInput
    /**
     * Limit how many companyActivitiesHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyActivitiesHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * companyActivitiesHistory upsert
   */
  export type companyActivitiesHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyActivitiesHistory
     */
    select?: companyActivitiesHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the companyActivitiesHistory
     */
    omit?: companyActivitiesHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyActivitiesHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the companyActivitiesHistory to update in case it exists.
     */
    where: companyActivitiesHistoryWhereUniqueInput
    /**
     * In case the companyActivitiesHistory found by the `where` argument doesn't exist, create a new companyActivitiesHistory with this data.
     */
    create: XOR<companyActivitiesHistoryCreateInput, companyActivitiesHistoryUncheckedCreateInput>
    /**
     * In case the companyActivitiesHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<companyActivitiesHistoryUpdateInput, companyActivitiesHistoryUncheckedUpdateInput>
  }

  /**
   * companyActivitiesHistory delete
   */
  export type companyActivitiesHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyActivitiesHistory
     */
    select?: companyActivitiesHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the companyActivitiesHistory
     */
    omit?: companyActivitiesHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyActivitiesHistoryInclude<ExtArgs> | null
    /**
     * Filter which companyActivitiesHistory to delete.
     */
    where: companyActivitiesHistoryWhereUniqueInput
  }

  /**
   * companyActivitiesHistory deleteMany
   */
  export type companyActivitiesHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which companyActivitiesHistories to delete
     */
    where?: companyActivitiesHistoryWhereInput
    /**
     * Limit how many companyActivitiesHistories to delete.
     */
    limit?: number
  }

  /**
   * companyActivitiesHistory without action
   */
  export type companyActivitiesHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyActivitiesHistory
     */
    select?: companyActivitiesHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the companyActivitiesHistory
     */
    omit?: companyActivitiesHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyActivitiesHistoryInclude<ExtArgs> | null
  }


  /**
   * Model companyLabels
   */

  export type AggregateCompanyLabels = {
    _count: CompanyLabelsCountAggregateOutputType | null
    _avg: CompanyLabelsAvgAggregateOutputType | null
    _sum: CompanyLabelsSumAggregateOutputType | null
    _min: CompanyLabelsMinAggregateOutputType | null
    _max: CompanyLabelsMaxAggregateOutputType | null
  }

  export type CompanyLabelsAvgAggregateOutputType = {
    id: number | null
  }

  export type CompanyLabelsSumAggregateOutputType = {
    id: number | null
  }

  export type CompanyLabelsMinAggregateOutputType = {
    id: number | null
    label_name: string | null
  }

  export type CompanyLabelsMaxAggregateOutputType = {
    id: number | null
    label_name: string | null
  }

  export type CompanyLabelsCountAggregateOutputType = {
    id: number
    label_name: number
    _all: number
  }


  export type CompanyLabelsAvgAggregateInputType = {
    id?: true
  }

  export type CompanyLabelsSumAggregateInputType = {
    id?: true
  }

  export type CompanyLabelsMinAggregateInputType = {
    id?: true
    label_name?: true
  }

  export type CompanyLabelsMaxAggregateInputType = {
    id?: true
    label_name?: true
  }

  export type CompanyLabelsCountAggregateInputType = {
    id?: true
    label_name?: true
    _all?: true
  }

  export type CompanyLabelsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which companyLabels to aggregate.
     */
    where?: companyLabelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companyLabels to fetch.
     */
    orderBy?: companyLabelsOrderByWithRelationInput | companyLabelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: companyLabelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companyLabels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companyLabels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned companyLabels
    **/
    _count?: true | CompanyLabelsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompanyLabelsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompanyLabelsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyLabelsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyLabelsMaxAggregateInputType
  }

  export type GetCompanyLabelsAggregateType<T extends CompanyLabelsAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanyLabels]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanyLabels[P]>
      : GetScalarType<T[P], AggregateCompanyLabels[P]>
  }




  export type companyLabelsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: companyLabelsWhereInput
    orderBy?: companyLabelsOrderByWithAggregationInput | companyLabelsOrderByWithAggregationInput[]
    by: CompanyLabelsScalarFieldEnum[] | CompanyLabelsScalarFieldEnum
    having?: companyLabelsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyLabelsCountAggregateInputType | true
    _avg?: CompanyLabelsAvgAggregateInputType
    _sum?: CompanyLabelsSumAggregateInputType
    _min?: CompanyLabelsMinAggregateInputType
    _max?: CompanyLabelsMaxAggregateInputType
  }

  export type CompanyLabelsGroupByOutputType = {
    id: number
    label_name: string
    _count: CompanyLabelsCountAggregateOutputType | null
    _avg: CompanyLabelsAvgAggregateOutputType | null
    _sum: CompanyLabelsSumAggregateOutputType | null
    _min: CompanyLabelsMinAggregateOutputType | null
    _max: CompanyLabelsMaxAggregateOutputType | null
  }

  type GetCompanyLabelsGroupByPayload<T extends companyLabelsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyLabelsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyLabelsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyLabelsGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyLabelsGroupByOutputType[P]>
        }
      >
    >


  export type companyLabelsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label_name?: boolean
    companies?: boolean | companyLabels$companiesArgs<ExtArgs>
    _count?: boolean | CompanyLabelsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyLabels"]>

  export type companyLabelsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label_name?: boolean
  }, ExtArgs["result"]["companyLabels"]>

  export type companyLabelsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label_name?: boolean
  }, ExtArgs["result"]["companyLabels"]>

  export type companyLabelsSelectScalar = {
    id?: boolean
    label_name?: boolean
  }

  export type companyLabelsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "label_name", ExtArgs["result"]["companyLabels"]>
  export type companyLabelsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companies?: boolean | companyLabels$companiesArgs<ExtArgs>
    _count?: boolean | CompanyLabelsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type companyLabelsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type companyLabelsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $companyLabelsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "companyLabels"
    objects: {
      companies: Prisma.$companiesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      label_name: string
    }, ExtArgs["result"]["companyLabels"]>
    composites: {}
  }

  type companyLabelsGetPayload<S extends boolean | null | undefined | companyLabelsDefaultArgs> = $Result.GetResult<Prisma.$companyLabelsPayload, S>

  type companyLabelsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<companyLabelsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanyLabelsCountAggregateInputType | true
    }

  export interface companyLabelsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['companyLabels'], meta: { name: 'companyLabels' } }
    /**
     * Find zero or one CompanyLabels that matches the filter.
     * @param {companyLabelsFindUniqueArgs} args - Arguments to find a CompanyLabels
     * @example
     * // Get one CompanyLabels
     * const companyLabels = await prisma.companyLabels.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends companyLabelsFindUniqueArgs>(args: SelectSubset<T, companyLabelsFindUniqueArgs<ExtArgs>>): Prisma__companyLabelsClient<$Result.GetResult<Prisma.$companyLabelsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CompanyLabels that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {companyLabelsFindUniqueOrThrowArgs} args - Arguments to find a CompanyLabels
     * @example
     * // Get one CompanyLabels
     * const companyLabels = await prisma.companyLabels.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends companyLabelsFindUniqueOrThrowArgs>(args: SelectSubset<T, companyLabelsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__companyLabelsClient<$Result.GetResult<Prisma.$companyLabelsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyLabels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companyLabelsFindFirstArgs} args - Arguments to find a CompanyLabels
     * @example
     * // Get one CompanyLabels
     * const companyLabels = await prisma.companyLabels.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends companyLabelsFindFirstArgs>(args?: SelectSubset<T, companyLabelsFindFirstArgs<ExtArgs>>): Prisma__companyLabelsClient<$Result.GetResult<Prisma.$companyLabelsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyLabels that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companyLabelsFindFirstOrThrowArgs} args - Arguments to find a CompanyLabels
     * @example
     * // Get one CompanyLabels
     * const companyLabels = await prisma.companyLabels.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends companyLabelsFindFirstOrThrowArgs>(args?: SelectSubset<T, companyLabelsFindFirstOrThrowArgs<ExtArgs>>): Prisma__companyLabelsClient<$Result.GetResult<Prisma.$companyLabelsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CompanyLabels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companyLabelsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompanyLabels
     * const companyLabels = await prisma.companyLabels.findMany()
     * 
     * // Get first 10 CompanyLabels
     * const companyLabels = await prisma.companyLabels.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyLabelsWithIdOnly = await prisma.companyLabels.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends companyLabelsFindManyArgs>(args?: SelectSubset<T, companyLabelsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companyLabelsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CompanyLabels.
     * @param {companyLabelsCreateArgs} args - Arguments to create a CompanyLabels.
     * @example
     * // Create one CompanyLabels
     * const CompanyLabels = await prisma.companyLabels.create({
     *   data: {
     *     // ... data to create a CompanyLabels
     *   }
     * })
     * 
     */
    create<T extends companyLabelsCreateArgs>(args: SelectSubset<T, companyLabelsCreateArgs<ExtArgs>>): Prisma__companyLabelsClient<$Result.GetResult<Prisma.$companyLabelsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CompanyLabels.
     * @param {companyLabelsCreateManyArgs} args - Arguments to create many CompanyLabels.
     * @example
     * // Create many CompanyLabels
     * const companyLabels = await prisma.companyLabels.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends companyLabelsCreateManyArgs>(args?: SelectSubset<T, companyLabelsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CompanyLabels and returns the data saved in the database.
     * @param {companyLabelsCreateManyAndReturnArgs} args - Arguments to create many CompanyLabels.
     * @example
     * // Create many CompanyLabels
     * const companyLabels = await prisma.companyLabels.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CompanyLabels and only return the `id`
     * const companyLabelsWithIdOnly = await prisma.companyLabels.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends companyLabelsCreateManyAndReturnArgs>(args?: SelectSubset<T, companyLabelsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companyLabelsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CompanyLabels.
     * @param {companyLabelsDeleteArgs} args - Arguments to delete one CompanyLabels.
     * @example
     * // Delete one CompanyLabels
     * const CompanyLabels = await prisma.companyLabels.delete({
     *   where: {
     *     // ... filter to delete one CompanyLabels
     *   }
     * })
     * 
     */
    delete<T extends companyLabelsDeleteArgs>(args: SelectSubset<T, companyLabelsDeleteArgs<ExtArgs>>): Prisma__companyLabelsClient<$Result.GetResult<Prisma.$companyLabelsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CompanyLabels.
     * @param {companyLabelsUpdateArgs} args - Arguments to update one CompanyLabels.
     * @example
     * // Update one CompanyLabels
     * const companyLabels = await prisma.companyLabels.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends companyLabelsUpdateArgs>(args: SelectSubset<T, companyLabelsUpdateArgs<ExtArgs>>): Prisma__companyLabelsClient<$Result.GetResult<Prisma.$companyLabelsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CompanyLabels.
     * @param {companyLabelsDeleteManyArgs} args - Arguments to filter CompanyLabels to delete.
     * @example
     * // Delete a few CompanyLabels
     * const { count } = await prisma.companyLabels.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends companyLabelsDeleteManyArgs>(args?: SelectSubset<T, companyLabelsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyLabels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companyLabelsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompanyLabels
     * const companyLabels = await prisma.companyLabels.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends companyLabelsUpdateManyArgs>(args: SelectSubset<T, companyLabelsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyLabels and returns the data updated in the database.
     * @param {companyLabelsUpdateManyAndReturnArgs} args - Arguments to update many CompanyLabels.
     * @example
     * // Update many CompanyLabels
     * const companyLabels = await prisma.companyLabels.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CompanyLabels and only return the `id`
     * const companyLabelsWithIdOnly = await prisma.companyLabels.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends companyLabelsUpdateManyAndReturnArgs>(args: SelectSubset<T, companyLabelsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companyLabelsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CompanyLabels.
     * @param {companyLabelsUpsertArgs} args - Arguments to update or create a CompanyLabels.
     * @example
     * // Update or create a CompanyLabels
     * const companyLabels = await prisma.companyLabels.upsert({
     *   create: {
     *     // ... data to create a CompanyLabels
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompanyLabels we want to update
     *   }
     * })
     */
    upsert<T extends companyLabelsUpsertArgs>(args: SelectSubset<T, companyLabelsUpsertArgs<ExtArgs>>): Prisma__companyLabelsClient<$Result.GetResult<Prisma.$companyLabelsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CompanyLabels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companyLabelsCountArgs} args - Arguments to filter CompanyLabels to count.
     * @example
     * // Count the number of CompanyLabels
     * const count = await prisma.companyLabels.count({
     *   where: {
     *     // ... the filter for the CompanyLabels we want to count
     *   }
     * })
    **/
    count<T extends companyLabelsCountArgs>(
      args?: Subset<T, companyLabelsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyLabelsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompanyLabels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyLabelsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyLabelsAggregateArgs>(args: Subset<T, CompanyLabelsAggregateArgs>): Prisma.PrismaPromise<GetCompanyLabelsAggregateType<T>>

    /**
     * Group by CompanyLabels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companyLabelsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends companyLabelsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: companyLabelsGroupByArgs['orderBy'] }
        : { orderBy?: companyLabelsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, companyLabelsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyLabelsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the companyLabels model
   */
  readonly fields: companyLabelsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for companyLabels.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__companyLabelsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    companies<T extends companyLabels$companiesArgs<ExtArgs> = {}>(args?: Subset<T, companyLabels$companiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the companyLabels model
   */
  interface companyLabelsFieldRefs {
    readonly id: FieldRef<"companyLabels", 'Int'>
    readonly label_name: FieldRef<"companyLabels", 'String'>
  }
    

  // Custom InputTypes
  /**
   * companyLabels findUnique
   */
  export type companyLabelsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyLabels
     */
    select?: companyLabelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companyLabels
     */
    omit?: companyLabelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyLabelsInclude<ExtArgs> | null
    /**
     * Filter, which companyLabels to fetch.
     */
    where: companyLabelsWhereUniqueInput
  }

  /**
   * companyLabels findUniqueOrThrow
   */
  export type companyLabelsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyLabels
     */
    select?: companyLabelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companyLabels
     */
    omit?: companyLabelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyLabelsInclude<ExtArgs> | null
    /**
     * Filter, which companyLabels to fetch.
     */
    where: companyLabelsWhereUniqueInput
  }

  /**
   * companyLabels findFirst
   */
  export type companyLabelsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyLabels
     */
    select?: companyLabelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companyLabels
     */
    omit?: companyLabelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyLabelsInclude<ExtArgs> | null
    /**
     * Filter, which companyLabels to fetch.
     */
    where?: companyLabelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companyLabels to fetch.
     */
    orderBy?: companyLabelsOrderByWithRelationInput | companyLabelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for companyLabels.
     */
    cursor?: companyLabelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companyLabels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companyLabels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of companyLabels.
     */
    distinct?: CompanyLabelsScalarFieldEnum | CompanyLabelsScalarFieldEnum[]
  }

  /**
   * companyLabels findFirstOrThrow
   */
  export type companyLabelsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyLabels
     */
    select?: companyLabelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companyLabels
     */
    omit?: companyLabelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyLabelsInclude<ExtArgs> | null
    /**
     * Filter, which companyLabels to fetch.
     */
    where?: companyLabelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companyLabels to fetch.
     */
    orderBy?: companyLabelsOrderByWithRelationInput | companyLabelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for companyLabels.
     */
    cursor?: companyLabelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companyLabels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companyLabels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of companyLabels.
     */
    distinct?: CompanyLabelsScalarFieldEnum | CompanyLabelsScalarFieldEnum[]
  }

  /**
   * companyLabels findMany
   */
  export type companyLabelsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyLabels
     */
    select?: companyLabelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companyLabels
     */
    omit?: companyLabelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyLabelsInclude<ExtArgs> | null
    /**
     * Filter, which companyLabels to fetch.
     */
    where?: companyLabelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companyLabels to fetch.
     */
    orderBy?: companyLabelsOrderByWithRelationInput | companyLabelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing companyLabels.
     */
    cursor?: companyLabelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companyLabels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companyLabels.
     */
    skip?: number
    distinct?: CompanyLabelsScalarFieldEnum | CompanyLabelsScalarFieldEnum[]
  }

  /**
   * companyLabels create
   */
  export type companyLabelsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyLabels
     */
    select?: companyLabelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companyLabels
     */
    omit?: companyLabelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyLabelsInclude<ExtArgs> | null
    /**
     * The data needed to create a companyLabels.
     */
    data: XOR<companyLabelsCreateInput, companyLabelsUncheckedCreateInput>
  }

  /**
   * companyLabels createMany
   */
  export type companyLabelsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many companyLabels.
     */
    data: companyLabelsCreateManyInput | companyLabelsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * companyLabels createManyAndReturn
   */
  export type companyLabelsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyLabels
     */
    select?: companyLabelsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the companyLabels
     */
    omit?: companyLabelsOmit<ExtArgs> | null
    /**
     * The data used to create many companyLabels.
     */
    data: companyLabelsCreateManyInput | companyLabelsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * companyLabels update
   */
  export type companyLabelsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyLabels
     */
    select?: companyLabelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companyLabels
     */
    omit?: companyLabelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyLabelsInclude<ExtArgs> | null
    /**
     * The data needed to update a companyLabels.
     */
    data: XOR<companyLabelsUpdateInput, companyLabelsUncheckedUpdateInput>
    /**
     * Choose, which companyLabels to update.
     */
    where: companyLabelsWhereUniqueInput
  }

  /**
   * companyLabels updateMany
   */
  export type companyLabelsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update companyLabels.
     */
    data: XOR<companyLabelsUpdateManyMutationInput, companyLabelsUncheckedUpdateManyInput>
    /**
     * Filter which companyLabels to update
     */
    where?: companyLabelsWhereInput
    /**
     * Limit how many companyLabels to update.
     */
    limit?: number
  }

  /**
   * companyLabels updateManyAndReturn
   */
  export type companyLabelsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyLabels
     */
    select?: companyLabelsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the companyLabels
     */
    omit?: companyLabelsOmit<ExtArgs> | null
    /**
     * The data used to update companyLabels.
     */
    data: XOR<companyLabelsUpdateManyMutationInput, companyLabelsUncheckedUpdateManyInput>
    /**
     * Filter which companyLabels to update
     */
    where?: companyLabelsWhereInput
    /**
     * Limit how many companyLabels to update.
     */
    limit?: number
  }

  /**
   * companyLabels upsert
   */
  export type companyLabelsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyLabels
     */
    select?: companyLabelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companyLabels
     */
    omit?: companyLabelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyLabelsInclude<ExtArgs> | null
    /**
     * The filter to search for the companyLabels to update in case it exists.
     */
    where: companyLabelsWhereUniqueInput
    /**
     * In case the companyLabels found by the `where` argument doesn't exist, create a new companyLabels with this data.
     */
    create: XOR<companyLabelsCreateInput, companyLabelsUncheckedCreateInput>
    /**
     * In case the companyLabels was found with the provided `where` argument, update it with this data.
     */
    update: XOR<companyLabelsUpdateInput, companyLabelsUncheckedUpdateInput>
  }

  /**
   * companyLabels delete
   */
  export type companyLabelsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyLabels
     */
    select?: companyLabelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companyLabels
     */
    omit?: companyLabelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyLabelsInclude<ExtArgs> | null
    /**
     * Filter which companyLabels to delete.
     */
    where: companyLabelsWhereUniqueInput
  }

  /**
   * companyLabels deleteMany
   */
  export type companyLabelsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which companyLabels to delete
     */
    where?: companyLabelsWhereInput
    /**
     * Limit how many companyLabels to delete.
     */
    limit?: number
  }

  /**
   * companyLabels.companies
   */
  export type companyLabels$companiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    where?: companiesWhereInput
    orderBy?: companiesOrderByWithRelationInput | companiesOrderByWithRelationInput[]
    cursor?: companiesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompaniesScalarFieldEnum | CompaniesScalarFieldEnum[]
  }

  /**
   * companyLabels without action
   */
  export type companyLabelsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyLabels
     */
    select?: companyLabelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companyLabels
     */
    omit?: companyLabelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyLabelsInclude<ExtArgs> | null
  }


  /**
   * Model companyNotifications
   */

  export type AggregateCompanyNotifications = {
    _count: CompanyNotificationsCountAggregateOutputType | null
    _avg: CompanyNotificationsAvgAggregateOutputType | null
    _sum: CompanyNotificationsSumAggregateOutputType | null
    _min: CompanyNotificationsMinAggregateOutputType | null
    _max: CompanyNotificationsMaxAggregateOutputType | null
  }

  export type CompanyNotificationsAvgAggregateOutputType = {
    id: number | null
  }

  export type CompanyNotificationsSumAggregateOutputType = {
    id: number | null
  }

  export type CompanyNotificationsMinAggregateOutputType = {
    id: number | null
    company_id: string | null
    title: string | null
    content: string | null
    type: $Enums.NotificationsType | null
    is_read: boolean | null
    sent_at: Date | null
    read_at: Date | null
  }

  export type CompanyNotificationsMaxAggregateOutputType = {
    id: number | null
    company_id: string | null
    title: string | null
    content: string | null
    type: $Enums.NotificationsType | null
    is_read: boolean | null
    sent_at: Date | null
    read_at: Date | null
  }

  export type CompanyNotificationsCountAggregateOutputType = {
    id: number
    company_id: number
    title: number
    content: number
    type: number
    is_read: number
    sent_at: number
    read_at: number
    _all: number
  }


  export type CompanyNotificationsAvgAggregateInputType = {
    id?: true
  }

  export type CompanyNotificationsSumAggregateInputType = {
    id?: true
  }

  export type CompanyNotificationsMinAggregateInputType = {
    id?: true
    company_id?: true
    title?: true
    content?: true
    type?: true
    is_read?: true
    sent_at?: true
    read_at?: true
  }

  export type CompanyNotificationsMaxAggregateInputType = {
    id?: true
    company_id?: true
    title?: true
    content?: true
    type?: true
    is_read?: true
    sent_at?: true
    read_at?: true
  }

  export type CompanyNotificationsCountAggregateInputType = {
    id?: true
    company_id?: true
    title?: true
    content?: true
    type?: true
    is_read?: true
    sent_at?: true
    read_at?: true
    _all?: true
  }

  export type CompanyNotificationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which companyNotifications to aggregate.
     */
    where?: companyNotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companyNotifications to fetch.
     */
    orderBy?: companyNotificationsOrderByWithRelationInput | companyNotificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: companyNotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companyNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companyNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned companyNotifications
    **/
    _count?: true | CompanyNotificationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompanyNotificationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompanyNotificationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyNotificationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyNotificationsMaxAggregateInputType
  }

  export type GetCompanyNotificationsAggregateType<T extends CompanyNotificationsAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanyNotifications]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanyNotifications[P]>
      : GetScalarType<T[P], AggregateCompanyNotifications[P]>
  }




  export type companyNotificationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: companyNotificationsWhereInput
    orderBy?: companyNotificationsOrderByWithAggregationInput | companyNotificationsOrderByWithAggregationInput[]
    by: CompanyNotificationsScalarFieldEnum[] | CompanyNotificationsScalarFieldEnum
    having?: companyNotificationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyNotificationsCountAggregateInputType | true
    _avg?: CompanyNotificationsAvgAggregateInputType
    _sum?: CompanyNotificationsSumAggregateInputType
    _min?: CompanyNotificationsMinAggregateInputType
    _max?: CompanyNotificationsMaxAggregateInputType
  }

  export type CompanyNotificationsGroupByOutputType = {
    id: number
    company_id: string
    title: string
    content: string | null
    type: $Enums.NotificationsType
    is_read: boolean
    sent_at: Date
    read_at: Date | null
    _count: CompanyNotificationsCountAggregateOutputType | null
    _avg: CompanyNotificationsAvgAggregateOutputType | null
    _sum: CompanyNotificationsSumAggregateOutputType | null
    _min: CompanyNotificationsMinAggregateOutputType | null
    _max: CompanyNotificationsMaxAggregateOutputType | null
  }

  type GetCompanyNotificationsGroupByPayload<T extends companyNotificationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyNotificationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyNotificationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyNotificationsGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyNotificationsGroupByOutputType[P]>
        }
      >
    >


  export type companyNotificationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company_id?: boolean
    title?: boolean
    content?: boolean
    type?: boolean
    is_read?: boolean
    sent_at?: boolean
    read_at?: boolean
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyNotifications"]>

  export type companyNotificationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company_id?: boolean
    title?: boolean
    content?: boolean
    type?: boolean
    is_read?: boolean
    sent_at?: boolean
    read_at?: boolean
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyNotifications"]>

  export type companyNotificationsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company_id?: boolean
    title?: boolean
    content?: boolean
    type?: boolean
    is_read?: boolean
    sent_at?: boolean
    read_at?: boolean
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyNotifications"]>

  export type companyNotificationsSelectScalar = {
    id?: boolean
    company_id?: boolean
    title?: boolean
    content?: boolean
    type?: boolean
    is_read?: boolean
    sent_at?: boolean
    read_at?: boolean
  }

  export type companyNotificationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "company_id" | "title" | "content" | "type" | "is_read" | "sent_at" | "read_at", ExtArgs["result"]["companyNotifications"]>
  export type companyNotificationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }
  export type companyNotificationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }
  export type companyNotificationsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }

  export type $companyNotificationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "companyNotifications"
    objects: {
      companies: Prisma.$companiesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      company_id: string
      title: string
      content: string | null
      type: $Enums.NotificationsType
      is_read: boolean
      sent_at: Date
      read_at: Date | null
    }, ExtArgs["result"]["companyNotifications"]>
    composites: {}
  }

  type companyNotificationsGetPayload<S extends boolean | null | undefined | companyNotificationsDefaultArgs> = $Result.GetResult<Prisma.$companyNotificationsPayload, S>

  type companyNotificationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<companyNotificationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanyNotificationsCountAggregateInputType | true
    }

  export interface companyNotificationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['companyNotifications'], meta: { name: 'companyNotifications' } }
    /**
     * Find zero or one CompanyNotifications that matches the filter.
     * @param {companyNotificationsFindUniqueArgs} args - Arguments to find a CompanyNotifications
     * @example
     * // Get one CompanyNotifications
     * const companyNotifications = await prisma.companyNotifications.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends companyNotificationsFindUniqueArgs>(args: SelectSubset<T, companyNotificationsFindUniqueArgs<ExtArgs>>): Prisma__companyNotificationsClient<$Result.GetResult<Prisma.$companyNotificationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CompanyNotifications that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {companyNotificationsFindUniqueOrThrowArgs} args - Arguments to find a CompanyNotifications
     * @example
     * // Get one CompanyNotifications
     * const companyNotifications = await prisma.companyNotifications.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends companyNotificationsFindUniqueOrThrowArgs>(args: SelectSubset<T, companyNotificationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__companyNotificationsClient<$Result.GetResult<Prisma.$companyNotificationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyNotifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companyNotificationsFindFirstArgs} args - Arguments to find a CompanyNotifications
     * @example
     * // Get one CompanyNotifications
     * const companyNotifications = await prisma.companyNotifications.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends companyNotificationsFindFirstArgs>(args?: SelectSubset<T, companyNotificationsFindFirstArgs<ExtArgs>>): Prisma__companyNotificationsClient<$Result.GetResult<Prisma.$companyNotificationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyNotifications that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companyNotificationsFindFirstOrThrowArgs} args - Arguments to find a CompanyNotifications
     * @example
     * // Get one CompanyNotifications
     * const companyNotifications = await prisma.companyNotifications.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends companyNotificationsFindFirstOrThrowArgs>(args?: SelectSubset<T, companyNotificationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__companyNotificationsClient<$Result.GetResult<Prisma.$companyNotificationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CompanyNotifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companyNotificationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompanyNotifications
     * const companyNotifications = await prisma.companyNotifications.findMany()
     * 
     * // Get first 10 CompanyNotifications
     * const companyNotifications = await prisma.companyNotifications.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyNotificationsWithIdOnly = await prisma.companyNotifications.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends companyNotificationsFindManyArgs>(args?: SelectSubset<T, companyNotificationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companyNotificationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CompanyNotifications.
     * @param {companyNotificationsCreateArgs} args - Arguments to create a CompanyNotifications.
     * @example
     * // Create one CompanyNotifications
     * const CompanyNotifications = await prisma.companyNotifications.create({
     *   data: {
     *     // ... data to create a CompanyNotifications
     *   }
     * })
     * 
     */
    create<T extends companyNotificationsCreateArgs>(args: SelectSubset<T, companyNotificationsCreateArgs<ExtArgs>>): Prisma__companyNotificationsClient<$Result.GetResult<Prisma.$companyNotificationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CompanyNotifications.
     * @param {companyNotificationsCreateManyArgs} args - Arguments to create many CompanyNotifications.
     * @example
     * // Create many CompanyNotifications
     * const companyNotifications = await prisma.companyNotifications.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends companyNotificationsCreateManyArgs>(args?: SelectSubset<T, companyNotificationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CompanyNotifications and returns the data saved in the database.
     * @param {companyNotificationsCreateManyAndReturnArgs} args - Arguments to create many CompanyNotifications.
     * @example
     * // Create many CompanyNotifications
     * const companyNotifications = await prisma.companyNotifications.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CompanyNotifications and only return the `id`
     * const companyNotificationsWithIdOnly = await prisma.companyNotifications.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends companyNotificationsCreateManyAndReturnArgs>(args?: SelectSubset<T, companyNotificationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companyNotificationsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CompanyNotifications.
     * @param {companyNotificationsDeleteArgs} args - Arguments to delete one CompanyNotifications.
     * @example
     * // Delete one CompanyNotifications
     * const CompanyNotifications = await prisma.companyNotifications.delete({
     *   where: {
     *     // ... filter to delete one CompanyNotifications
     *   }
     * })
     * 
     */
    delete<T extends companyNotificationsDeleteArgs>(args: SelectSubset<T, companyNotificationsDeleteArgs<ExtArgs>>): Prisma__companyNotificationsClient<$Result.GetResult<Prisma.$companyNotificationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CompanyNotifications.
     * @param {companyNotificationsUpdateArgs} args - Arguments to update one CompanyNotifications.
     * @example
     * // Update one CompanyNotifications
     * const companyNotifications = await prisma.companyNotifications.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends companyNotificationsUpdateArgs>(args: SelectSubset<T, companyNotificationsUpdateArgs<ExtArgs>>): Prisma__companyNotificationsClient<$Result.GetResult<Prisma.$companyNotificationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CompanyNotifications.
     * @param {companyNotificationsDeleteManyArgs} args - Arguments to filter CompanyNotifications to delete.
     * @example
     * // Delete a few CompanyNotifications
     * const { count } = await prisma.companyNotifications.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends companyNotificationsDeleteManyArgs>(args?: SelectSubset<T, companyNotificationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companyNotificationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompanyNotifications
     * const companyNotifications = await prisma.companyNotifications.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends companyNotificationsUpdateManyArgs>(args: SelectSubset<T, companyNotificationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyNotifications and returns the data updated in the database.
     * @param {companyNotificationsUpdateManyAndReturnArgs} args - Arguments to update many CompanyNotifications.
     * @example
     * // Update many CompanyNotifications
     * const companyNotifications = await prisma.companyNotifications.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CompanyNotifications and only return the `id`
     * const companyNotificationsWithIdOnly = await prisma.companyNotifications.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends companyNotificationsUpdateManyAndReturnArgs>(args: SelectSubset<T, companyNotificationsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companyNotificationsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CompanyNotifications.
     * @param {companyNotificationsUpsertArgs} args - Arguments to update or create a CompanyNotifications.
     * @example
     * // Update or create a CompanyNotifications
     * const companyNotifications = await prisma.companyNotifications.upsert({
     *   create: {
     *     // ... data to create a CompanyNotifications
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompanyNotifications we want to update
     *   }
     * })
     */
    upsert<T extends companyNotificationsUpsertArgs>(args: SelectSubset<T, companyNotificationsUpsertArgs<ExtArgs>>): Prisma__companyNotificationsClient<$Result.GetResult<Prisma.$companyNotificationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CompanyNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companyNotificationsCountArgs} args - Arguments to filter CompanyNotifications to count.
     * @example
     * // Count the number of CompanyNotifications
     * const count = await prisma.companyNotifications.count({
     *   where: {
     *     // ... the filter for the CompanyNotifications we want to count
     *   }
     * })
    **/
    count<T extends companyNotificationsCountArgs>(
      args?: Subset<T, companyNotificationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyNotificationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompanyNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyNotificationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyNotificationsAggregateArgs>(args: Subset<T, CompanyNotificationsAggregateArgs>): Prisma.PrismaPromise<GetCompanyNotificationsAggregateType<T>>

    /**
     * Group by CompanyNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companyNotificationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends companyNotificationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: companyNotificationsGroupByArgs['orderBy'] }
        : { orderBy?: companyNotificationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, companyNotificationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyNotificationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the companyNotifications model
   */
  readonly fields: companyNotificationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for companyNotifications.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__companyNotificationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    companies<T extends companiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, companiesDefaultArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the companyNotifications model
   */
  interface companyNotificationsFieldRefs {
    readonly id: FieldRef<"companyNotifications", 'Int'>
    readonly company_id: FieldRef<"companyNotifications", 'String'>
    readonly title: FieldRef<"companyNotifications", 'String'>
    readonly content: FieldRef<"companyNotifications", 'String'>
    readonly type: FieldRef<"companyNotifications", 'NotificationsType'>
    readonly is_read: FieldRef<"companyNotifications", 'Boolean'>
    readonly sent_at: FieldRef<"companyNotifications", 'DateTime'>
    readonly read_at: FieldRef<"companyNotifications", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * companyNotifications findUnique
   */
  export type companyNotificationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyNotifications
     */
    select?: companyNotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companyNotifications
     */
    omit?: companyNotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyNotificationsInclude<ExtArgs> | null
    /**
     * Filter, which companyNotifications to fetch.
     */
    where: companyNotificationsWhereUniqueInput
  }

  /**
   * companyNotifications findUniqueOrThrow
   */
  export type companyNotificationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyNotifications
     */
    select?: companyNotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companyNotifications
     */
    omit?: companyNotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyNotificationsInclude<ExtArgs> | null
    /**
     * Filter, which companyNotifications to fetch.
     */
    where: companyNotificationsWhereUniqueInput
  }

  /**
   * companyNotifications findFirst
   */
  export type companyNotificationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyNotifications
     */
    select?: companyNotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companyNotifications
     */
    omit?: companyNotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyNotificationsInclude<ExtArgs> | null
    /**
     * Filter, which companyNotifications to fetch.
     */
    where?: companyNotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companyNotifications to fetch.
     */
    orderBy?: companyNotificationsOrderByWithRelationInput | companyNotificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for companyNotifications.
     */
    cursor?: companyNotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companyNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companyNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of companyNotifications.
     */
    distinct?: CompanyNotificationsScalarFieldEnum | CompanyNotificationsScalarFieldEnum[]
  }

  /**
   * companyNotifications findFirstOrThrow
   */
  export type companyNotificationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyNotifications
     */
    select?: companyNotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companyNotifications
     */
    omit?: companyNotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyNotificationsInclude<ExtArgs> | null
    /**
     * Filter, which companyNotifications to fetch.
     */
    where?: companyNotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companyNotifications to fetch.
     */
    orderBy?: companyNotificationsOrderByWithRelationInput | companyNotificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for companyNotifications.
     */
    cursor?: companyNotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companyNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companyNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of companyNotifications.
     */
    distinct?: CompanyNotificationsScalarFieldEnum | CompanyNotificationsScalarFieldEnum[]
  }

  /**
   * companyNotifications findMany
   */
  export type companyNotificationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyNotifications
     */
    select?: companyNotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companyNotifications
     */
    omit?: companyNotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyNotificationsInclude<ExtArgs> | null
    /**
     * Filter, which companyNotifications to fetch.
     */
    where?: companyNotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companyNotifications to fetch.
     */
    orderBy?: companyNotificationsOrderByWithRelationInput | companyNotificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing companyNotifications.
     */
    cursor?: companyNotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companyNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companyNotifications.
     */
    skip?: number
    distinct?: CompanyNotificationsScalarFieldEnum | CompanyNotificationsScalarFieldEnum[]
  }

  /**
   * companyNotifications create
   */
  export type companyNotificationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyNotifications
     */
    select?: companyNotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companyNotifications
     */
    omit?: companyNotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyNotificationsInclude<ExtArgs> | null
    /**
     * The data needed to create a companyNotifications.
     */
    data: XOR<companyNotificationsCreateInput, companyNotificationsUncheckedCreateInput>
  }

  /**
   * companyNotifications createMany
   */
  export type companyNotificationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many companyNotifications.
     */
    data: companyNotificationsCreateManyInput | companyNotificationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * companyNotifications createManyAndReturn
   */
  export type companyNotificationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyNotifications
     */
    select?: companyNotificationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the companyNotifications
     */
    omit?: companyNotificationsOmit<ExtArgs> | null
    /**
     * The data used to create many companyNotifications.
     */
    data: companyNotificationsCreateManyInput | companyNotificationsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyNotificationsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * companyNotifications update
   */
  export type companyNotificationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyNotifications
     */
    select?: companyNotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companyNotifications
     */
    omit?: companyNotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyNotificationsInclude<ExtArgs> | null
    /**
     * The data needed to update a companyNotifications.
     */
    data: XOR<companyNotificationsUpdateInput, companyNotificationsUncheckedUpdateInput>
    /**
     * Choose, which companyNotifications to update.
     */
    where: companyNotificationsWhereUniqueInput
  }

  /**
   * companyNotifications updateMany
   */
  export type companyNotificationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update companyNotifications.
     */
    data: XOR<companyNotificationsUpdateManyMutationInput, companyNotificationsUncheckedUpdateManyInput>
    /**
     * Filter which companyNotifications to update
     */
    where?: companyNotificationsWhereInput
    /**
     * Limit how many companyNotifications to update.
     */
    limit?: number
  }

  /**
   * companyNotifications updateManyAndReturn
   */
  export type companyNotificationsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyNotifications
     */
    select?: companyNotificationsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the companyNotifications
     */
    omit?: companyNotificationsOmit<ExtArgs> | null
    /**
     * The data used to update companyNotifications.
     */
    data: XOR<companyNotificationsUpdateManyMutationInput, companyNotificationsUncheckedUpdateManyInput>
    /**
     * Filter which companyNotifications to update
     */
    where?: companyNotificationsWhereInput
    /**
     * Limit how many companyNotifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyNotificationsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * companyNotifications upsert
   */
  export type companyNotificationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyNotifications
     */
    select?: companyNotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companyNotifications
     */
    omit?: companyNotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyNotificationsInclude<ExtArgs> | null
    /**
     * The filter to search for the companyNotifications to update in case it exists.
     */
    where: companyNotificationsWhereUniqueInput
    /**
     * In case the companyNotifications found by the `where` argument doesn't exist, create a new companyNotifications with this data.
     */
    create: XOR<companyNotificationsCreateInput, companyNotificationsUncheckedCreateInput>
    /**
     * In case the companyNotifications was found with the provided `where` argument, update it with this data.
     */
    update: XOR<companyNotificationsUpdateInput, companyNotificationsUncheckedUpdateInput>
  }

  /**
   * companyNotifications delete
   */
  export type companyNotificationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyNotifications
     */
    select?: companyNotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companyNotifications
     */
    omit?: companyNotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyNotificationsInclude<ExtArgs> | null
    /**
     * Filter which companyNotifications to delete.
     */
    where: companyNotificationsWhereUniqueInput
  }

  /**
   * companyNotifications deleteMany
   */
  export type companyNotificationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which companyNotifications to delete
     */
    where?: companyNotificationsWhereInput
    /**
     * Limit how many companyNotifications to delete.
     */
    limit?: number
  }

  /**
   * companyNotifications without action
   */
  export type companyNotificationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companyNotifications
     */
    select?: companyNotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companyNotifications
     */
    omit?: companyNotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companyNotificationsInclude<ExtArgs> | null
  }


  /**
   * Model cvs
   */

  export type AggregateCvs = {
    _count: CvsCountAggregateOutputType | null
    _avg: CvsAvgAggregateOutputType | null
    _sum: CvsSumAggregateOutputType | null
    _min: CvsMinAggregateOutputType | null
    _max: CvsMaxAggregateOutputType | null
  }

  export type CvsAvgAggregateOutputType = {
    id: number | null
    age: number | null
  }

  export type CvsSumAggregateOutputType = {
    id: number | null
    age: number | null
  }

  export type CvsMinAggregateOutputType = {
    id: number | null
    fullname: string | null
    age: number | null
    gender: string | null
    address: string | null
    email: string | null
    introduction: string | null
    phone: string | null
    hobbies: string | null
    others: string | null
  }

  export type CvsMaxAggregateOutputType = {
    id: number | null
    fullname: string | null
    age: number | null
    gender: string | null
    address: string | null
    email: string | null
    introduction: string | null
    phone: string | null
    hobbies: string | null
    others: string | null
  }

  export type CvsCountAggregateOutputType = {
    id: number
    fullname: number
    age: number
    gender: number
    address: number
    email: number
    introduction: number
    soft_skills: number
    primary_skills: number
    phone: number
    hobbies: number
    others: number
    _all: number
  }


  export type CvsAvgAggregateInputType = {
    id?: true
    age?: true
  }

  export type CvsSumAggregateInputType = {
    id?: true
    age?: true
  }

  export type CvsMinAggregateInputType = {
    id?: true
    fullname?: true
    age?: true
    gender?: true
    address?: true
    email?: true
    introduction?: true
    phone?: true
    hobbies?: true
    others?: true
  }

  export type CvsMaxAggregateInputType = {
    id?: true
    fullname?: true
    age?: true
    gender?: true
    address?: true
    email?: true
    introduction?: true
    phone?: true
    hobbies?: true
    others?: true
  }

  export type CvsCountAggregateInputType = {
    id?: true
    fullname?: true
    age?: true
    gender?: true
    address?: true
    email?: true
    introduction?: true
    soft_skills?: true
    primary_skills?: true
    phone?: true
    hobbies?: true
    others?: true
    _all?: true
  }

  export type CvsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cvs to aggregate.
     */
    where?: cvsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cvs to fetch.
     */
    orderBy?: cvsOrderByWithRelationInput | cvsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: cvsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cvs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cvs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned cvs
    **/
    _count?: true | CvsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CvsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CvsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CvsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CvsMaxAggregateInputType
  }

  export type GetCvsAggregateType<T extends CvsAggregateArgs> = {
        [P in keyof T & keyof AggregateCvs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCvs[P]>
      : GetScalarType<T[P], AggregateCvs[P]>
  }




  export type cvsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cvsWhereInput
    orderBy?: cvsOrderByWithAggregationInput | cvsOrderByWithAggregationInput[]
    by: CvsScalarFieldEnum[] | CvsScalarFieldEnum
    having?: cvsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CvsCountAggregateInputType | true
    _avg?: CvsAvgAggregateInputType
    _sum?: CvsSumAggregateInputType
    _min?: CvsMinAggregateInputType
    _max?: CvsMaxAggregateInputType
  }

  export type CvsGroupByOutputType = {
    id: number
    fullname: string
    age: number | null
    gender: string | null
    address: string | null
    email: string | null
    introduction: string | null
    soft_skills: string[]
    primary_skills: string[]
    phone: string | null
    hobbies: string | null
    others: string | null
    _count: CvsCountAggregateOutputType | null
    _avg: CvsAvgAggregateOutputType | null
    _sum: CvsSumAggregateOutputType | null
    _min: CvsMinAggregateOutputType | null
    _max: CvsMaxAggregateOutputType | null
  }

  type GetCvsGroupByPayload<T extends cvsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CvsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CvsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CvsGroupByOutputType[P]>
            : GetScalarType<T[P], CvsGroupByOutputType[P]>
        }
      >
    >


  export type cvsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fullname?: boolean
    age?: boolean
    gender?: boolean
    address?: boolean
    email?: boolean
    introduction?: boolean
    soft_skills?: boolean
    primary_skills?: boolean
    phone?: boolean
    hobbies?: boolean
    others?: boolean
    applicants?: boolean | cvs$applicantsArgs<ExtArgs>
    awards?: boolean | cvs$awardsArgs<ExtArgs>
    certificates?: boolean | cvs$certificatesArgs<ExtArgs>
    educations?: boolean | cvs$educationsArgs<ExtArgs>
    experiences?: boolean | cvs$experiencesArgs<ExtArgs>
    projects?: boolean | cvs$projectsArgs<ExtArgs>
    references?: boolean | cvs$referencesArgs<ExtArgs>
    _count?: boolean | CvsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cvs"]>

  export type cvsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fullname?: boolean
    age?: boolean
    gender?: boolean
    address?: boolean
    email?: boolean
    introduction?: boolean
    soft_skills?: boolean
    primary_skills?: boolean
    phone?: boolean
    hobbies?: boolean
    others?: boolean
  }, ExtArgs["result"]["cvs"]>

  export type cvsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fullname?: boolean
    age?: boolean
    gender?: boolean
    address?: boolean
    email?: boolean
    introduction?: boolean
    soft_skills?: boolean
    primary_skills?: boolean
    phone?: boolean
    hobbies?: boolean
    others?: boolean
  }, ExtArgs["result"]["cvs"]>

  export type cvsSelectScalar = {
    id?: boolean
    fullname?: boolean
    age?: boolean
    gender?: boolean
    address?: boolean
    email?: boolean
    introduction?: boolean
    soft_skills?: boolean
    primary_skills?: boolean
    phone?: boolean
    hobbies?: boolean
    others?: boolean
  }

  export type cvsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "fullname" | "age" | "gender" | "address" | "email" | "introduction" | "soft_skills" | "primary_skills" | "phone" | "hobbies" | "others", ExtArgs["result"]["cvs"]>
  export type cvsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applicants?: boolean | cvs$applicantsArgs<ExtArgs>
    awards?: boolean | cvs$awardsArgs<ExtArgs>
    certificates?: boolean | cvs$certificatesArgs<ExtArgs>
    educations?: boolean | cvs$educationsArgs<ExtArgs>
    experiences?: boolean | cvs$experiencesArgs<ExtArgs>
    projects?: boolean | cvs$projectsArgs<ExtArgs>
    references?: boolean | cvs$referencesArgs<ExtArgs>
    _count?: boolean | CvsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type cvsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type cvsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $cvsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "cvs"
    objects: {
      applicants: Prisma.$applicantsPayload<ExtArgs>[]
      awards: Prisma.$awardsPayload<ExtArgs>[]
      certificates: Prisma.$certificatesPayload<ExtArgs>[]
      educations: Prisma.$educationsPayload<ExtArgs>[]
      experiences: Prisma.$experiencesPayload<ExtArgs>[]
      projects: Prisma.$projectsPayload<ExtArgs>[]
      references: Prisma.$referencesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      fullname: string
      age: number | null
      gender: string | null
      address: string | null
      email: string | null
      introduction: string | null
      soft_skills: string[]
      primary_skills: string[]
      phone: string | null
      hobbies: string | null
      others: string | null
    }, ExtArgs["result"]["cvs"]>
    composites: {}
  }

  type cvsGetPayload<S extends boolean | null | undefined | cvsDefaultArgs> = $Result.GetResult<Prisma.$cvsPayload, S>

  type cvsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<cvsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CvsCountAggregateInputType | true
    }

  export interface cvsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['cvs'], meta: { name: 'cvs' } }
    /**
     * Find zero or one Cvs that matches the filter.
     * @param {cvsFindUniqueArgs} args - Arguments to find a Cvs
     * @example
     * // Get one Cvs
     * const cvs = await prisma.cvs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends cvsFindUniqueArgs>(args: SelectSubset<T, cvsFindUniqueArgs<ExtArgs>>): Prisma__cvsClient<$Result.GetResult<Prisma.$cvsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Cvs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {cvsFindUniqueOrThrowArgs} args - Arguments to find a Cvs
     * @example
     * // Get one Cvs
     * const cvs = await prisma.cvs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends cvsFindUniqueOrThrowArgs>(args: SelectSubset<T, cvsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__cvsClient<$Result.GetResult<Prisma.$cvsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cvs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cvsFindFirstArgs} args - Arguments to find a Cvs
     * @example
     * // Get one Cvs
     * const cvs = await prisma.cvs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends cvsFindFirstArgs>(args?: SelectSubset<T, cvsFindFirstArgs<ExtArgs>>): Prisma__cvsClient<$Result.GetResult<Prisma.$cvsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cvs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cvsFindFirstOrThrowArgs} args - Arguments to find a Cvs
     * @example
     * // Get one Cvs
     * const cvs = await prisma.cvs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends cvsFindFirstOrThrowArgs>(args?: SelectSubset<T, cvsFindFirstOrThrowArgs<ExtArgs>>): Prisma__cvsClient<$Result.GetResult<Prisma.$cvsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Cvs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cvsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cvs
     * const cvs = await prisma.cvs.findMany()
     * 
     * // Get first 10 Cvs
     * const cvs = await prisma.cvs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cvsWithIdOnly = await prisma.cvs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends cvsFindManyArgs>(args?: SelectSubset<T, cvsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cvsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Cvs.
     * @param {cvsCreateArgs} args - Arguments to create a Cvs.
     * @example
     * // Create one Cvs
     * const Cvs = await prisma.cvs.create({
     *   data: {
     *     // ... data to create a Cvs
     *   }
     * })
     * 
     */
    create<T extends cvsCreateArgs>(args: SelectSubset<T, cvsCreateArgs<ExtArgs>>): Prisma__cvsClient<$Result.GetResult<Prisma.$cvsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Cvs.
     * @param {cvsCreateManyArgs} args - Arguments to create many Cvs.
     * @example
     * // Create many Cvs
     * const cvs = await prisma.cvs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends cvsCreateManyArgs>(args?: SelectSubset<T, cvsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Cvs and returns the data saved in the database.
     * @param {cvsCreateManyAndReturnArgs} args - Arguments to create many Cvs.
     * @example
     * // Create many Cvs
     * const cvs = await prisma.cvs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Cvs and only return the `id`
     * const cvsWithIdOnly = await prisma.cvs.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends cvsCreateManyAndReturnArgs>(args?: SelectSubset<T, cvsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cvsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Cvs.
     * @param {cvsDeleteArgs} args - Arguments to delete one Cvs.
     * @example
     * // Delete one Cvs
     * const Cvs = await prisma.cvs.delete({
     *   where: {
     *     // ... filter to delete one Cvs
     *   }
     * })
     * 
     */
    delete<T extends cvsDeleteArgs>(args: SelectSubset<T, cvsDeleteArgs<ExtArgs>>): Prisma__cvsClient<$Result.GetResult<Prisma.$cvsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Cvs.
     * @param {cvsUpdateArgs} args - Arguments to update one Cvs.
     * @example
     * // Update one Cvs
     * const cvs = await prisma.cvs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends cvsUpdateArgs>(args: SelectSubset<T, cvsUpdateArgs<ExtArgs>>): Prisma__cvsClient<$Result.GetResult<Prisma.$cvsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Cvs.
     * @param {cvsDeleteManyArgs} args - Arguments to filter Cvs to delete.
     * @example
     * // Delete a few Cvs
     * const { count } = await prisma.cvs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends cvsDeleteManyArgs>(args?: SelectSubset<T, cvsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cvs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cvsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cvs
     * const cvs = await prisma.cvs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends cvsUpdateManyArgs>(args: SelectSubset<T, cvsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cvs and returns the data updated in the database.
     * @param {cvsUpdateManyAndReturnArgs} args - Arguments to update many Cvs.
     * @example
     * // Update many Cvs
     * const cvs = await prisma.cvs.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Cvs and only return the `id`
     * const cvsWithIdOnly = await prisma.cvs.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends cvsUpdateManyAndReturnArgs>(args: SelectSubset<T, cvsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cvsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Cvs.
     * @param {cvsUpsertArgs} args - Arguments to update or create a Cvs.
     * @example
     * // Update or create a Cvs
     * const cvs = await prisma.cvs.upsert({
     *   create: {
     *     // ... data to create a Cvs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cvs we want to update
     *   }
     * })
     */
    upsert<T extends cvsUpsertArgs>(args: SelectSubset<T, cvsUpsertArgs<ExtArgs>>): Prisma__cvsClient<$Result.GetResult<Prisma.$cvsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Cvs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cvsCountArgs} args - Arguments to filter Cvs to count.
     * @example
     * // Count the number of Cvs
     * const count = await prisma.cvs.count({
     *   where: {
     *     // ... the filter for the Cvs we want to count
     *   }
     * })
    **/
    count<T extends cvsCountArgs>(
      args?: Subset<T, cvsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CvsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cvs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CvsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CvsAggregateArgs>(args: Subset<T, CvsAggregateArgs>): Prisma.PrismaPromise<GetCvsAggregateType<T>>

    /**
     * Group by Cvs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cvsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends cvsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: cvsGroupByArgs['orderBy'] }
        : { orderBy?: cvsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, cvsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCvsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the cvs model
   */
  readonly fields: cvsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for cvs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__cvsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    applicants<T extends cvs$applicantsArgs<ExtArgs> = {}>(args?: Subset<T, cvs$applicantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$applicantsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    awards<T extends cvs$awardsArgs<ExtArgs> = {}>(args?: Subset<T, cvs$awardsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$awardsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    certificates<T extends cvs$certificatesArgs<ExtArgs> = {}>(args?: Subset<T, cvs$certificatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$certificatesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    educations<T extends cvs$educationsArgs<ExtArgs> = {}>(args?: Subset<T, cvs$educationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$educationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    experiences<T extends cvs$experiencesArgs<ExtArgs> = {}>(args?: Subset<T, cvs$experiencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$experiencesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    projects<T extends cvs$projectsArgs<ExtArgs> = {}>(args?: Subset<T, cvs$projectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projectsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    references<T extends cvs$referencesArgs<ExtArgs> = {}>(args?: Subset<T, cvs$referencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$referencesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the cvs model
   */
  interface cvsFieldRefs {
    readonly id: FieldRef<"cvs", 'Int'>
    readonly fullname: FieldRef<"cvs", 'String'>
    readonly age: FieldRef<"cvs", 'Int'>
    readonly gender: FieldRef<"cvs", 'String'>
    readonly address: FieldRef<"cvs", 'String'>
    readonly email: FieldRef<"cvs", 'String'>
    readonly introduction: FieldRef<"cvs", 'String'>
    readonly soft_skills: FieldRef<"cvs", 'String[]'>
    readonly primary_skills: FieldRef<"cvs", 'String[]'>
    readonly phone: FieldRef<"cvs", 'String'>
    readonly hobbies: FieldRef<"cvs", 'String'>
    readonly others: FieldRef<"cvs", 'String'>
  }
    

  // Custom InputTypes
  /**
   * cvs findUnique
   */
  export type cvsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cvs
     */
    select?: cvsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cvs
     */
    omit?: cvsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cvsInclude<ExtArgs> | null
    /**
     * Filter, which cvs to fetch.
     */
    where: cvsWhereUniqueInput
  }

  /**
   * cvs findUniqueOrThrow
   */
  export type cvsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cvs
     */
    select?: cvsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cvs
     */
    omit?: cvsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cvsInclude<ExtArgs> | null
    /**
     * Filter, which cvs to fetch.
     */
    where: cvsWhereUniqueInput
  }

  /**
   * cvs findFirst
   */
  export type cvsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cvs
     */
    select?: cvsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cvs
     */
    omit?: cvsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cvsInclude<ExtArgs> | null
    /**
     * Filter, which cvs to fetch.
     */
    where?: cvsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cvs to fetch.
     */
    orderBy?: cvsOrderByWithRelationInput | cvsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cvs.
     */
    cursor?: cvsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cvs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cvs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cvs.
     */
    distinct?: CvsScalarFieldEnum | CvsScalarFieldEnum[]
  }

  /**
   * cvs findFirstOrThrow
   */
  export type cvsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cvs
     */
    select?: cvsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cvs
     */
    omit?: cvsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cvsInclude<ExtArgs> | null
    /**
     * Filter, which cvs to fetch.
     */
    where?: cvsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cvs to fetch.
     */
    orderBy?: cvsOrderByWithRelationInput | cvsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cvs.
     */
    cursor?: cvsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cvs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cvs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cvs.
     */
    distinct?: CvsScalarFieldEnum | CvsScalarFieldEnum[]
  }

  /**
   * cvs findMany
   */
  export type cvsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cvs
     */
    select?: cvsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cvs
     */
    omit?: cvsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cvsInclude<ExtArgs> | null
    /**
     * Filter, which cvs to fetch.
     */
    where?: cvsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cvs to fetch.
     */
    orderBy?: cvsOrderByWithRelationInput | cvsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing cvs.
     */
    cursor?: cvsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cvs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cvs.
     */
    skip?: number
    distinct?: CvsScalarFieldEnum | CvsScalarFieldEnum[]
  }

  /**
   * cvs create
   */
  export type cvsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cvs
     */
    select?: cvsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cvs
     */
    omit?: cvsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cvsInclude<ExtArgs> | null
    /**
     * The data needed to create a cvs.
     */
    data: XOR<cvsCreateInput, cvsUncheckedCreateInput>
  }

  /**
   * cvs createMany
   */
  export type cvsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many cvs.
     */
    data: cvsCreateManyInput | cvsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * cvs createManyAndReturn
   */
  export type cvsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cvs
     */
    select?: cvsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the cvs
     */
    omit?: cvsOmit<ExtArgs> | null
    /**
     * The data used to create many cvs.
     */
    data: cvsCreateManyInput | cvsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * cvs update
   */
  export type cvsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cvs
     */
    select?: cvsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cvs
     */
    omit?: cvsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cvsInclude<ExtArgs> | null
    /**
     * The data needed to update a cvs.
     */
    data: XOR<cvsUpdateInput, cvsUncheckedUpdateInput>
    /**
     * Choose, which cvs to update.
     */
    where: cvsWhereUniqueInput
  }

  /**
   * cvs updateMany
   */
  export type cvsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update cvs.
     */
    data: XOR<cvsUpdateManyMutationInput, cvsUncheckedUpdateManyInput>
    /**
     * Filter which cvs to update
     */
    where?: cvsWhereInput
    /**
     * Limit how many cvs to update.
     */
    limit?: number
  }

  /**
   * cvs updateManyAndReturn
   */
  export type cvsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cvs
     */
    select?: cvsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the cvs
     */
    omit?: cvsOmit<ExtArgs> | null
    /**
     * The data used to update cvs.
     */
    data: XOR<cvsUpdateManyMutationInput, cvsUncheckedUpdateManyInput>
    /**
     * Filter which cvs to update
     */
    where?: cvsWhereInput
    /**
     * Limit how many cvs to update.
     */
    limit?: number
  }

  /**
   * cvs upsert
   */
  export type cvsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cvs
     */
    select?: cvsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cvs
     */
    omit?: cvsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cvsInclude<ExtArgs> | null
    /**
     * The filter to search for the cvs to update in case it exists.
     */
    where: cvsWhereUniqueInput
    /**
     * In case the cvs found by the `where` argument doesn't exist, create a new cvs with this data.
     */
    create: XOR<cvsCreateInput, cvsUncheckedCreateInput>
    /**
     * In case the cvs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<cvsUpdateInput, cvsUncheckedUpdateInput>
  }

  /**
   * cvs delete
   */
  export type cvsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cvs
     */
    select?: cvsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cvs
     */
    omit?: cvsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cvsInclude<ExtArgs> | null
    /**
     * Filter which cvs to delete.
     */
    where: cvsWhereUniqueInput
  }

  /**
   * cvs deleteMany
   */
  export type cvsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cvs to delete
     */
    where?: cvsWhereInput
    /**
     * Limit how many cvs to delete.
     */
    limit?: number
  }

  /**
   * cvs.applicants
   */
  export type cvs$applicantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicants
     */
    select?: applicantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applicants
     */
    omit?: applicantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicantsInclude<ExtArgs> | null
    where?: applicantsWhereInput
    orderBy?: applicantsOrderByWithRelationInput | applicantsOrderByWithRelationInput[]
    cursor?: applicantsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApplicantsScalarFieldEnum | ApplicantsScalarFieldEnum[]
  }

  /**
   * cvs.awards
   */
  export type cvs$awardsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the awards
     */
    select?: awardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the awards
     */
    omit?: awardsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: awardsInclude<ExtArgs> | null
    where?: awardsWhereInput
    orderBy?: awardsOrderByWithRelationInput | awardsOrderByWithRelationInput[]
    cursor?: awardsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AwardsScalarFieldEnum | AwardsScalarFieldEnum[]
  }

  /**
   * cvs.certificates
   */
  export type cvs$certificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the certificates
     */
    select?: certificatesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the certificates
     */
    omit?: certificatesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: certificatesInclude<ExtArgs> | null
    where?: certificatesWhereInput
    orderBy?: certificatesOrderByWithRelationInput | certificatesOrderByWithRelationInput[]
    cursor?: certificatesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CertificatesScalarFieldEnum | CertificatesScalarFieldEnum[]
  }

  /**
   * cvs.educations
   */
  export type cvs$educationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the educations
     */
    select?: educationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the educations
     */
    omit?: educationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: educationsInclude<ExtArgs> | null
    where?: educationsWhereInput
    orderBy?: educationsOrderByWithRelationInput | educationsOrderByWithRelationInput[]
    cursor?: educationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EducationsScalarFieldEnum | EducationsScalarFieldEnum[]
  }

  /**
   * cvs.experiences
   */
  export type cvs$experiencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the experiences
     */
    select?: experiencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the experiences
     */
    omit?: experiencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: experiencesInclude<ExtArgs> | null
    where?: experiencesWhereInput
    orderBy?: experiencesOrderByWithRelationInput | experiencesOrderByWithRelationInput[]
    cursor?: experiencesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExperiencesScalarFieldEnum | ExperiencesScalarFieldEnum[]
  }

  /**
   * cvs.projects
   */
  export type cvs$projectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projects
     */
    select?: projectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projects
     */
    omit?: projectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectsInclude<ExtArgs> | null
    where?: projectsWhereInput
    orderBy?: projectsOrderByWithRelationInput | projectsOrderByWithRelationInput[]
    cursor?: projectsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectsScalarFieldEnum | ProjectsScalarFieldEnum[]
  }

  /**
   * cvs.references
   */
  export type cvs$referencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the references
     */
    select?: referencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the references
     */
    omit?: referencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: referencesInclude<ExtArgs> | null
    where?: referencesWhereInput
    orderBy?: referencesOrderByWithRelationInput | referencesOrderByWithRelationInput[]
    cursor?: referencesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReferencesScalarFieldEnum | ReferencesScalarFieldEnum[]
  }

  /**
   * cvs without action
   */
  export type cvsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cvs
     */
    select?: cvsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cvs
     */
    omit?: cvsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: cvsInclude<ExtArgs> | null
  }


  /**
   * Model educations
   */

  export type AggregateEducations = {
    _count: EducationsCountAggregateOutputType | null
    _avg: EducationsAvgAggregateOutputType | null
    _sum: EducationsSumAggregateOutputType | null
    _min: EducationsMinAggregateOutputType | null
    _max: EducationsMaxAggregateOutputType | null
  }

  export type EducationsAvgAggregateOutputType = {
    id: number | null
    gpa: number | null
    cv_id: number | null
  }

  export type EducationsSumAggregateOutputType = {
    id: number | null
    gpa: number | null
    cv_id: number | null
  }

  export type EducationsMinAggregateOutputType = {
    id: number | null
    school: string | null
    graduated_type: string | null
    gpa: number | null
    start_date: Date | null
    end_date: Date | null
    cv_id: number | null
  }

  export type EducationsMaxAggregateOutputType = {
    id: number | null
    school: string | null
    graduated_type: string | null
    gpa: number | null
    start_date: Date | null
    end_date: Date | null
    cv_id: number | null
  }

  export type EducationsCountAggregateOutputType = {
    id: number
    school: number
    graduated_type: number
    gpa: number
    start_date: number
    end_date: number
    cv_id: number
    _all: number
  }


  export type EducationsAvgAggregateInputType = {
    id?: true
    gpa?: true
    cv_id?: true
  }

  export type EducationsSumAggregateInputType = {
    id?: true
    gpa?: true
    cv_id?: true
  }

  export type EducationsMinAggregateInputType = {
    id?: true
    school?: true
    graduated_type?: true
    gpa?: true
    start_date?: true
    end_date?: true
    cv_id?: true
  }

  export type EducationsMaxAggregateInputType = {
    id?: true
    school?: true
    graduated_type?: true
    gpa?: true
    start_date?: true
    end_date?: true
    cv_id?: true
  }

  export type EducationsCountAggregateInputType = {
    id?: true
    school?: true
    graduated_type?: true
    gpa?: true
    start_date?: true
    end_date?: true
    cv_id?: true
    _all?: true
  }

  export type EducationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which educations to aggregate.
     */
    where?: educationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of educations to fetch.
     */
    orderBy?: educationsOrderByWithRelationInput | educationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: educationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` educations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` educations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned educations
    **/
    _count?: true | EducationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EducationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EducationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EducationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EducationsMaxAggregateInputType
  }

  export type GetEducationsAggregateType<T extends EducationsAggregateArgs> = {
        [P in keyof T & keyof AggregateEducations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEducations[P]>
      : GetScalarType<T[P], AggregateEducations[P]>
  }




  export type educationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: educationsWhereInput
    orderBy?: educationsOrderByWithAggregationInput | educationsOrderByWithAggregationInput[]
    by: EducationsScalarFieldEnum[] | EducationsScalarFieldEnum
    having?: educationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EducationsCountAggregateInputType | true
    _avg?: EducationsAvgAggregateInputType
    _sum?: EducationsSumAggregateInputType
    _min?: EducationsMinAggregateInputType
    _max?: EducationsMaxAggregateInputType
  }

  export type EducationsGroupByOutputType = {
    id: number
    school: string
    graduated_type: string | null
    gpa: number | null
    start_date: Date | null
    end_date: Date | null
    cv_id: number
    _count: EducationsCountAggregateOutputType | null
    _avg: EducationsAvgAggregateOutputType | null
    _sum: EducationsSumAggregateOutputType | null
    _min: EducationsMinAggregateOutputType | null
    _max: EducationsMaxAggregateOutputType | null
  }

  type GetEducationsGroupByPayload<T extends educationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EducationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EducationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EducationsGroupByOutputType[P]>
            : GetScalarType<T[P], EducationsGroupByOutputType[P]>
        }
      >
    >


  export type educationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    school?: boolean
    graduated_type?: boolean
    gpa?: boolean
    start_date?: boolean
    end_date?: boolean
    cv_id?: boolean
    cvs?: boolean | cvsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["educations"]>

  export type educationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    school?: boolean
    graduated_type?: boolean
    gpa?: boolean
    start_date?: boolean
    end_date?: boolean
    cv_id?: boolean
    cvs?: boolean | cvsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["educations"]>

  export type educationsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    school?: boolean
    graduated_type?: boolean
    gpa?: boolean
    start_date?: boolean
    end_date?: boolean
    cv_id?: boolean
    cvs?: boolean | cvsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["educations"]>

  export type educationsSelectScalar = {
    id?: boolean
    school?: boolean
    graduated_type?: boolean
    gpa?: boolean
    start_date?: boolean
    end_date?: boolean
    cv_id?: boolean
  }

  export type educationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "school" | "graduated_type" | "gpa" | "start_date" | "end_date" | "cv_id", ExtArgs["result"]["educations"]>
  export type educationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cvs?: boolean | cvsDefaultArgs<ExtArgs>
  }
  export type educationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cvs?: boolean | cvsDefaultArgs<ExtArgs>
  }
  export type educationsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cvs?: boolean | cvsDefaultArgs<ExtArgs>
  }

  export type $educationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "educations"
    objects: {
      cvs: Prisma.$cvsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      school: string
      graduated_type: string | null
      gpa: number | null
      start_date: Date | null
      end_date: Date | null
      cv_id: number
    }, ExtArgs["result"]["educations"]>
    composites: {}
  }

  type educationsGetPayload<S extends boolean | null | undefined | educationsDefaultArgs> = $Result.GetResult<Prisma.$educationsPayload, S>

  type educationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<educationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EducationsCountAggregateInputType | true
    }

  export interface educationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['educations'], meta: { name: 'educations' } }
    /**
     * Find zero or one Educations that matches the filter.
     * @param {educationsFindUniqueArgs} args - Arguments to find a Educations
     * @example
     * // Get one Educations
     * const educations = await prisma.educations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends educationsFindUniqueArgs>(args: SelectSubset<T, educationsFindUniqueArgs<ExtArgs>>): Prisma__educationsClient<$Result.GetResult<Prisma.$educationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Educations that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {educationsFindUniqueOrThrowArgs} args - Arguments to find a Educations
     * @example
     * // Get one Educations
     * const educations = await prisma.educations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends educationsFindUniqueOrThrowArgs>(args: SelectSubset<T, educationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__educationsClient<$Result.GetResult<Prisma.$educationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Educations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {educationsFindFirstArgs} args - Arguments to find a Educations
     * @example
     * // Get one Educations
     * const educations = await prisma.educations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends educationsFindFirstArgs>(args?: SelectSubset<T, educationsFindFirstArgs<ExtArgs>>): Prisma__educationsClient<$Result.GetResult<Prisma.$educationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Educations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {educationsFindFirstOrThrowArgs} args - Arguments to find a Educations
     * @example
     * // Get one Educations
     * const educations = await prisma.educations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends educationsFindFirstOrThrowArgs>(args?: SelectSubset<T, educationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__educationsClient<$Result.GetResult<Prisma.$educationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Educations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {educationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Educations
     * const educations = await prisma.educations.findMany()
     * 
     * // Get first 10 Educations
     * const educations = await prisma.educations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const educationsWithIdOnly = await prisma.educations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends educationsFindManyArgs>(args?: SelectSubset<T, educationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$educationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Educations.
     * @param {educationsCreateArgs} args - Arguments to create a Educations.
     * @example
     * // Create one Educations
     * const Educations = await prisma.educations.create({
     *   data: {
     *     // ... data to create a Educations
     *   }
     * })
     * 
     */
    create<T extends educationsCreateArgs>(args: SelectSubset<T, educationsCreateArgs<ExtArgs>>): Prisma__educationsClient<$Result.GetResult<Prisma.$educationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Educations.
     * @param {educationsCreateManyArgs} args - Arguments to create many Educations.
     * @example
     * // Create many Educations
     * const educations = await prisma.educations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends educationsCreateManyArgs>(args?: SelectSubset<T, educationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Educations and returns the data saved in the database.
     * @param {educationsCreateManyAndReturnArgs} args - Arguments to create many Educations.
     * @example
     * // Create many Educations
     * const educations = await prisma.educations.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Educations and only return the `id`
     * const educationsWithIdOnly = await prisma.educations.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends educationsCreateManyAndReturnArgs>(args?: SelectSubset<T, educationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$educationsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Educations.
     * @param {educationsDeleteArgs} args - Arguments to delete one Educations.
     * @example
     * // Delete one Educations
     * const Educations = await prisma.educations.delete({
     *   where: {
     *     // ... filter to delete one Educations
     *   }
     * })
     * 
     */
    delete<T extends educationsDeleteArgs>(args: SelectSubset<T, educationsDeleteArgs<ExtArgs>>): Prisma__educationsClient<$Result.GetResult<Prisma.$educationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Educations.
     * @param {educationsUpdateArgs} args - Arguments to update one Educations.
     * @example
     * // Update one Educations
     * const educations = await prisma.educations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends educationsUpdateArgs>(args: SelectSubset<T, educationsUpdateArgs<ExtArgs>>): Prisma__educationsClient<$Result.GetResult<Prisma.$educationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Educations.
     * @param {educationsDeleteManyArgs} args - Arguments to filter Educations to delete.
     * @example
     * // Delete a few Educations
     * const { count } = await prisma.educations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends educationsDeleteManyArgs>(args?: SelectSubset<T, educationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Educations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {educationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Educations
     * const educations = await prisma.educations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends educationsUpdateManyArgs>(args: SelectSubset<T, educationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Educations and returns the data updated in the database.
     * @param {educationsUpdateManyAndReturnArgs} args - Arguments to update many Educations.
     * @example
     * // Update many Educations
     * const educations = await prisma.educations.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Educations and only return the `id`
     * const educationsWithIdOnly = await prisma.educations.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends educationsUpdateManyAndReturnArgs>(args: SelectSubset<T, educationsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$educationsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Educations.
     * @param {educationsUpsertArgs} args - Arguments to update or create a Educations.
     * @example
     * // Update or create a Educations
     * const educations = await prisma.educations.upsert({
     *   create: {
     *     // ... data to create a Educations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Educations we want to update
     *   }
     * })
     */
    upsert<T extends educationsUpsertArgs>(args: SelectSubset<T, educationsUpsertArgs<ExtArgs>>): Prisma__educationsClient<$Result.GetResult<Prisma.$educationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Educations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {educationsCountArgs} args - Arguments to filter Educations to count.
     * @example
     * // Count the number of Educations
     * const count = await prisma.educations.count({
     *   where: {
     *     // ... the filter for the Educations we want to count
     *   }
     * })
    **/
    count<T extends educationsCountArgs>(
      args?: Subset<T, educationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EducationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Educations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EducationsAggregateArgs>(args: Subset<T, EducationsAggregateArgs>): Prisma.PrismaPromise<GetEducationsAggregateType<T>>

    /**
     * Group by Educations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {educationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends educationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: educationsGroupByArgs['orderBy'] }
        : { orderBy?: educationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, educationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEducationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the educations model
   */
  readonly fields: educationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for educations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__educationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cvs<T extends cvsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, cvsDefaultArgs<ExtArgs>>): Prisma__cvsClient<$Result.GetResult<Prisma.$cvsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the educations model
   */
  interface educationsFieldRefs {
    readonly id: FieldRef<"educations", 'Int'>
    readonly school: FieldRef<"educations", 'String'>
    readonly graduated_type: FieldRef<"educations", 'String'>
    readonly gpa: FieldRef<"educations", 'Float'>
    readonly start_date: FieldRef<"educations", 'DateTime'>
    readonly end_date: FieldRef<"educations", 'DateTime'>
    readonly cv_id: FieldRef<"educations", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * educations findUnique
   */
  export type educationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the educations
     */
    select?: educationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the educations
     */
    omit?: educationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: educationsInclude<ExtArgs> | null
    /**
     * Filter, which educations to fetch.
     */
    where: educationsWhereUniqueInput
  }

  /**
   * educations findUniqueOrThrow
   */
  export type educationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the educations
     */
    select?: educationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the educations
     */
    omit?: educationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: educationsInclude<ExtArgs> | null
    /**
     * Filter, which educations to fetch.
     */
    where: educationsWhereUniqueInput
  }

  /**
   * educations findFirst
   */
  export type educationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the educations
     */
    select?: educationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the educations
     */
    omit?: educationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: educationsInclude<ExtArgs> | null
    /**
     * Filter, which educations to fetch.
     */
    where?: educationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of educations to fetch.
     */
    orderBy?: educationsOrderByWithRelationInput | educationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for educations.
     */
    cursor?: educationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` educations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` educations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of educations.
     */
    distinct?: EducationsScalarFieldEnum | EducationsScalarFieldEnum[]
  }

  /**
   * educations findFirstOrThrow
   */
  export type educationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the educations
     */
    select?: educationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the educations
     */
    omit?: educationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: educationsInclude<ExtArgs> | null
    /**
     * Filter, which educations to fetch.
     */
    where?: educationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of educations to fetch.
     */
    orderBy?: educationsOrderByWithRelationInput | educationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for educations.
     */
    cursor?: educationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` educations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` educations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of educations.
     */
    distinct?: EducationsScalarFieldEnum | EducationsScalarFieldEnum[]
  }

  /**
   * educations findMany
   */
  export type educationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the educations
     */
    select?: educationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the educations
     */
    omit?: educationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: educationsInclude<ExtArgs> | null
    /**
     * Filter, which educations to fetch.
     */
    where?: educationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of educations to fetch.
     */
    orderBy?: educationsOrderByWithRelationInput | educationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing educations.
     */
    cursor?: educationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` educations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` educations.
     */
    skip?: number
    distinct?: EducationsScalarFieldEnum | EducationsScalarFieldEnum[]
  }

  /**
   * educations create
   */
  export type educationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the educations
     */
    select?: educationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the educations
     */
    omit?: educationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: educationsInclude<ExtArgs> | null
    /**
     * The data needed to create a educations.
     */
    data: XOR<educationsCreateInput, educationsUncheckedCreateInput>
  }

  /**
   * educations createMany
   */
  export type educationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many educations.
     */
    data: educationsCreateManyInput | educationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * educations createManyAndReturn
   */
  export type educationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the educations
     */
    select?: educationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the educations
     */
    omit?: educationsOmit<ExtArgs> | null
    /**
     * The data used to create many educations.
     */
    data: educationsCreateManyInput | educationsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: educationsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * educations update
   */
  export type educationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the educations
     */
    select?: educationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the educations
     */
    omit?: educationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: educationsInclude<ExtArgs> | null
    /**
     * The data needed to update a educations.
     */
    data: XOR<educationsUpdateInput, educationsUncheckedUpdateInput>
    /**
     * Choose, which educations to update.
     */
    where: educationsWhereUniqueInput
  }

  /**
   * educations updateMany
   */
  export type educationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update educations.
     */
    data: XOR<educationsUpdateManyMutationInput, educationsUncheckedUpdateManyInput>
    /**
     * Filter which educations to update
     */
    where?: educationsWhereInput
    /**
     * Limit how many educations to update.
     */
    limit?: number
  }

  /**
   * educations updateManyAndReturn
   */
  export type educationsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the educations
     */
    select?: educationsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the educations
     */
    omit?: educationsOmit<ExtArgs> | null
    /**
     * The data used to update educations.
     */
    data: XOR<educationsUpdateManyMutationInput, educationsUncheckedUpdateManyInput>
    /**
     * Filter which educations to update
     */
    where?: educationsWhereInput
    /**
     * Limit how many educations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: educationsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * educations upsert
   */
  export type educationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the educations
     */
    select?: educationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the educations
     */
    omit?: educationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: educationsInclude<ExtArgs> | null
    /**
     * The filter to search for the educations to update in case it exists.
     */
    where: educationsWhereUniqueInput
    /**
     * In case the educations found by the `where` argument doesn't exist, create a new educations with this data.
     */
    create: XOR<educationsCreateInput, educationsUncheckedCreateInput>
    /**
     * In case the educations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<educationsUpdateInput, educationsUncheckedUpdateInput>
  }

  /**
   * educations delete
   */
  export type educationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the educations
     */
    select?: educationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the educations
     */
    omit?: educationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: educationsInclude<ExtArgs> | null
    /**
     * Filter which educations to delete.
     */
    where: educationsWhereUniqueInput
  }

  /**
   * educations deleteMany
   */
  export type educationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which educations to delete
     */
    where?: educationsWhereInput
    /**
     * Limit how many educations to delete.
     */
    limit?: number
  }

  /**
   * educations without action
   */
  export type educationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the educations
     */
    select?: educationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the educations
     */
    omit?: educationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: educationsInclude<ExtArgs> | null
  }


  /**
   * Model experiences
   */

  export type AggregateExperiences = {
    _count: ExperiencesCountAggregateOutputType | null
    _avg: ExperiencesAvgAggregateOutputType | null
    _sum: ExperiencesSumAggregateOutputType | null
    _min: ExperiencesMinAggregateOutputType | null
    _max: ExperiencesMaxAggregateOutputType | null
  }

  export type ExperiencesAvgAggregateOutputType = {
    id: number | null
    cv_id: number | null
  }

  export type ExperiencesSumAggregateOutputType = {
    id: number | null
    cv_id: number | null
  }

  export type ExperiencesMinAggregateOutputType = {
    id: number | null
    company_name: string | null
    title: string | null
    description: string | null
    start_date: Date | null
    end_date: Date | null
    cv_id: number | null
  }

  export type ExperiencesMaxAggregateOutputType = {
    id: number | null
    company_name: string | null
    title: string | null
    description: string | null
    start_date: Date | null
    end_date: Date | null
    cv_id: number | null
  }

  export type ExperiencesCountAggregateOutputType = {
    id: number
    company_name: number
    title: number
    description: number
    start_date: number
    end_date: number
    cv_id: number
    _all: number
  }


  export type ExperiencesAvgAggregateInputType = {
    id?: true
    cv_id?: true
  }

  export type ExperiencesSumAggregateInputType = {
    id?: true
    cv_id?: true
  }

  export type ExperiencesMinAggregateInputType = {
    id?: true
    company_name?: true
    title?: true
    description?: true
    start_date?: true
    end_date?: true
    cv_id?: true
  }

  export type ExperiencesMaxAggregateInputType = {
    id?: true
    company_name?: true
    title?: true
    description?: true
    start_date?: true
    end_date?: true
    cv_id?: true
  }

  export type ExperiencesCountAggregateInputType = {
    id?: true
    company_name?: true
    title?: true
    description?: true
    start_date?: true
    end_date?: true
    cv_id?: true
    _all?: true
  }

  export type ExperiencesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which experiences to aggregate.
     */
    where?: experiencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of experiences to fetch.
     */
    orderBy?: experiencesOrderByWithRelationInput | experiencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: experiencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` experiences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` experiences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned experiences
    **/
    _count?: true | ExperiencesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExperiencesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExperiencesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExperiencesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExperiencesMaxAggregateInputType
  }

  export type GetExperiencesAggregateType<T extends ExperiencesAggregateArgs> = {
        [P in keyof T & keyof AggregateExperiences]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExperiences[P]>
      : GetScalarType<T[P], AggregateExperiences[P]>
  }




  export type experiencesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: experiencesWhereInput
    orderBy?: experiencesOrderByWithAggregationInput | experiencesOrderByWithAggregationInput[]
    by: ExperiencesScalarFieldEnum[] | ExperiencesScalarFieldEnum
    having?: experiencesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExperiencesCountAggregateInputType | true
    _avg?: ExperiencesAvgAggregateInputType
    _sum?: ExperiencesSumAggregateInputType
    _min?: ExperiencesMinAggregateInputType
    _max?: ExperiencesMaxAggregateInputType
  }

  export type ExperiencesGroupByOutputType = {
    id: number
    company_name: string | null
    title: string | null
    description: string | null
    start_date: Date | null
    end_date: Date | null
    cv_id: number
    _count: ExperiencesCountAggregateOutputType | null
    _avg: ExperiencesAvgAggregateOutputType | null
    _sum: ExperiencesSumAggregateOutputType | null
    _min: ExperiencesMinAggregateOutputType | null
    _max: ExperiencesMaxAggregateOutputType | null
  }

  type GetExperiencesGroupByPayload<T extends experiencesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExperiencesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExperiencesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExperiencesGroupByOutputType[P]>
            : GetScalarType<T[P], ExperiencesGroupByOutputType[P]>
        }
      >
    >


  export type experiencesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company_name?: boolean
    title?: boolean
    description?: boolean
    start_date?: boolean
    end_date?: boolean
    cv_id?: boolean
    cvs?: boolean | cvsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["experiences"]>

  export type experiencesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company_name?: boolean
    title?: boolean
    description?: boolean
    start_date?: boolean
    end_date?: boolean
    cv_id?: boolean
    cvs?: boolean | cvsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["experiences"]>

  export type experiencesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company_name?: boolean
    title?: boolean
    description?: boolean
    start_date?: boolean
    end_date?: boolean
    cv_id?: boolean
    cvs?: boolean | cvsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["experiences"]>

  export type experiencesSelectScalar = {
    id?: boolean
    company_name?: boolean
    title?: boolean
    description?: boolean
    start_date?: boolean
    end_date?: boolean
    cv_id?: boolean
  }

  export type experiencesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "company_name" | "title" | "description" | "start_date" | "end_date" | "cv_id", ExtArgs["result"]["experiences"]>
  export type experiencesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cvs?: boolean | cvsDefaultArgs<ExtArgs>
  }
  export type experiencesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cvs?: boolean | cvsDefaultArgs<ExtArgs>
  }
  export type experiencesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cvs?: boolean | cvsDefaultArgs<ExtArgs>
  }

  export type $experiencesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "experiences"
    objects: {
      cvs: Prisma.$cvsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      company_name: string | null
      title: string | null
      description: string | null
      start_date: Date | null
      end_date: Date | null
      cv_id: number
    }, ExtArgs["result"]["experiences"]>
    composites: {}
  }

  type experiencesGetPayload<S extends boolean | null | undefined | experiencesDefaultArgs> = $Result.GetResult<Prisma.$experiencesPayload, S>

  type experiencesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<experiencesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExperiencesCountAggregateInputType | true
    }

  export interface experiencesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['experiences'], meta: { name: 'experiences' } }
    /**
     * Find zero or one Experiences that matches the filter.
     * @param {experiencesFindUniqueArgs} args - Arguments to find a Experiences
     * @example
     * // Get one Experiences
     * const experiences = await prisma.experiences.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends experiencesFindUniqueArgs>(args: SelectSubset<T, experiencesFindUniqueArgs<ExtArgs>>): Prisma__experiencesClient<$Result.GetResult<Prisma.$experiencesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Experiences that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {experiencesFindUniqueOrThrowArgs} args - Arguments to find a Experiences
     * @example
     * // Get one Experiences
     * const experiences = await prisma.experiences.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends experiencesFindUniqueOrThrowArgs>(args: SelectSubset<T, experiencesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__experiencesClient<$Result.GetResult<Prisma.$experiencesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Experiences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {experiencesFindFirstArgs} args - Arguments to find a Experiences
     * @example
     * // Get one Experiences
     * const experiences = await prisma.experiences.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends experiencesFindFirstArgs>(args?: SelectSubset<T, experiencesFindFirstArgs<ExtArgs>>): Prisma__experiencesClient<$Result.GetResult<Prisma.$experiencesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Experiences that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {experiencesFindFirstOrThrowArgs} args - Arguments to find a Experiences
     * @example
     * // Get one Experiences
     * const experiences = await prisma.experiences.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends experiencesFindFirstOrThrowArgs>(args?: SelectSubset<T, experiencesFindFirstOrThrowArgs<ExtArgs>>): Prisma__experiencesClient<$Result.GetResult<Prisma.$experiencesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Experiences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {experiencesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Experiences
     * const experiences = await prisma.experiences.findMany()
     * 
     * // Get first 10 Experiences
     * const experiences = await prisma.experiences.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const experiencesWithIdOnly = await prisma.experiences.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends experiencesFindManyArgs>(args?: SelectSubset<T, experiencesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$experiencesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Experiences.
     * @param {experiencesCreateArgs} args - Arguments to create a Experiences.
     * @example
     * // Create one Experiences
     * const Experiences = await prisma.experiences.create({
     *   data: {
     *     // ... data to create a Experiences
     *   }
     * })
     * 
     */
    create<T extends experiencesCreateArgs>(args: SelectSubset<T, experiencesCreateArgs<ExtArgs>>): Prisma__experiencesClient<$Result.GetResult<Prisma.$experiencesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Experiences.
     * @param {experiencesCreateManyArgs} args - Arguments to create many Experiences.
     * @example
     * // Create many Experiences
     * const experiences = await prisma.experiences.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends experiencesCreateManyArgs>(args?: SelectSubset<T, experiencesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Experiences and returns the data saved in the database.
     * @param {experiencesCreateManyAndReturnArgs} args - Arguments to create many Experiences.
     * @example
     * // Create many Experiences
     * const experiences = await prisma.experiences.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Experiences and only return the `id`
     * const experiencesWithIdOnly = await prisma.experiences.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends experiencesCreateManyAndReturnArgs>(args?: SelectSubset<T, experiencesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$experiencesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Experiences.
     * @param {experiencesDeleteArgs} args - Arguments to delete one Experiences.
     * @example
     * // Delete one Experiences
     * const Experiences = await prisma.experiences.delete({
     *   where: {
     *     // ... filter to delete one Experiences
     *   }
     * })
     * 
     */
    delete<T extends experiencesDeleteArgs>(args: SelectSubset<T, experiencesDeleteArgs<ExtArgs>>): Prisma__experiencesClient<$Result.GetResult<Prisma.$experiencesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Experiences.
     * @param {experiencesUpdateArgs} args - Arguments to update one Experiences.
     * @example
     * // Update one Experiences
     * const experiences = await prisma.experiences.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends experiencesUpdateArgs>(args: SelectSubset<T, experiencesUpdateArgs<ExtArgs>>): Prisma__experiencesClient<$Result.GetResult<Prisma.$experiencesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Experiences.
     * @param {experiencesDeleteManyArgs} args - Arguments to filter Experiences to delete.
     * @example
     * // Delete a few Experiences
     * const { count } = await prisma.experiences.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends experiencesDeleteManyArgs>(args?: SelectSubset<T, experiencesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Experiences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {experiencesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Experiences
     * const experiences = await prisma.experiences.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends experiencesUpdateManyArgs>(args: SelectSubset<T, experiencesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Experiences and returns the data updated in the database.
     * @param {experiencesUpdateManyAndReturnArgs} args - Arguments to update many Experiences.
     * @example
     * // Update many Experiences
     * const experiences = await prisma.experiences.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Experiences and only return the `id`
     * const experiencesWithIdOnly = await prisma.experiences.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends experiencesUpdateManyAndReturnArgs>(args: SelectSubset<T, experiencesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$experiencesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Experiences.
     * @param {experiencesUpsertArgs} args - Arguments to update or create a Experiences.
     * @example
     * // Update or create a Experiences
     * const experiences = await prisma.experiences.upsert({
     *   create: {
     *     // ... data to create a Experiences
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Experiences we want to update
     *   }
     * })
     */
    upsert<T extends experiencesUpsertArgs>(args: SelectSubset<T, experiencesUpsertArgs<ExtArgs>>): Prisma__experiencesClient<$Result.GetResult<Prisma.$experiencesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Experiences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {experiencesCountArgs} args - Arguments to filter Experiences to count.
     * @example
     * // Count the number of Experiences
     * const count = await prisma.experiences.count({
     *   where: {
     *     // ... the filter for the Experiences we want to count
     *   }
     * })
    **/
    count<T extends experiencesCountArgs>(
      args?: Subset<T, experiencesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExperiencesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Experiences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExperiencesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExperiencesAggregateArgs>(args: Subset<T, ExperiencesAggregateArgs>): Prisma.PrismaPromise<GetExperiencesAggregateType<T>>

    /**
     * Group by Experiences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {experiencesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends experiencesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: experiencesGroupByArgs['orderBy'] }
        : { orderBy?: experiencesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, experiencesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExperiencesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the experiences model
   */
  readonly fields: experiencesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for experiences.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__experiencesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cvs<T extends cvsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, cvsDefaultArgs<ExtArgs>>): Prisma__cvsClient<$Result.GetResult<Prisma.$cvsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the experiences model
   */
  interface experiencesFieldRefs {
    readonly id: FieldRef<"experiences", 'Int'>
    readonly company_name: FieldRef<"experiences", 'String'>
    readonly title: FieldRef<"experiences", 'String'>
    readonly description: FieldRef<"experiences", 'String'>
    readonly start_date: FieldRef<"experiences", 'DateTime'>
    readonly end_date: FieldRef<"experiences", 'DateTime'>
    readonly cv_id: FieldRef<"experiences", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * experiences findUnique
   */
  export type experiencesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the experiences
     */
    select?: experiencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the experiences
     */
    omit?: experiencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: experiencesInclude<ExtArgs> | null
    /**
     * Filter, which experiences to fetch.
     */
    where: experiencesWhereUniqueInput
  }

  /**
   * experiences findUniqueOrThrow
   */
  export type experiencesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the experiences
     */
    select?: experiencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the experiences
     */
    omit?: experiencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: experiencesInclude<ExtArgs> | null
    /**
     * Filter, which experiences to fetch.
     */
    where: experiencesWhereUniqueInput
  }

  /**
   * experiences findFirst
   */
  export type experiencesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the experiences
     */
    select?: experiencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the experiences
     */
    omit?: experiencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: experiencesInclude<ExtArgs> | null
    /**
     * Filter, which experiences to fetch.
     */
    where?: experiencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of experiences to fetch.
     */
    orderBy?: experiencesOrderByWithRelationInput | experiencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for experiences.
     */
    cursor?: experiencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` experiences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` experiences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of experiences.
     */
    distinct?: ExperiencesScalarFieldEnum | ExperiencesScalarFieldEnum[]
  }

  /**
   * experiences findFirstOrThrow
   */
  export type experiencesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the experiences
     */
    select?: experiencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the experiences
     */
    omit?: experiencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: experiencesInclude<ExtArgs> | null
    /**
     * Filter, which experiences to fetch.
     */
    where?: experiencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of experiences to fetch.
     */
    orderBy?: experiencesOrderByWithRelationInput | experiencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for experiences.
     */
    cursor?: experiencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` experiences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` experiences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of experiences.
     */
    distinct?: ExperiencesScalarFieldEnum | ExperiencesScalarFieldEnum[]
  }

  /**
   * experiences findMany
   */
  export type experiencesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the experiences
     */
    select?: experiencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the experiences
     */
    omit?: experiencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: experiencesInclude<ExtArgs> | null
    /**
     * Filter, which experiences to fetch.
     */
    where?: experiencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of experiences to fetch.
     */
    orderBy?: experiencesOrderByWithRelationInput | experiencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing experiences.
     */
    cursor?: experiencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` experiences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` experiences.
     */
    skip?: number
    distinct?: ExperiencesScalarFieldEnum | ExperiencesScalarFieldEnum[]
  }

  /**
   * experiences create
   */
  export type experiencesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the experiences
     */
    select?: experiencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the experiences
     */
    omit?: experiencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: experiencesInclude<ExtArgs> | null
    /**
     * The data needed to create a experiences.
     */
    data: XOR<experiencesCreateInput, experiencesUncheckedCreateInput>
  }

  /**
   * experiences createMany
   */
  export type experiencesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many experiences.
     */
    data: experiencesCreateManyInput | experiencesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * experiences createManyAndReturn
   */
  export type experiencesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the experiences
     */
    select?: experiencesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the experiences
     */
    omit?: experiencesOmit<ExtArgs> | null
    /**
     * The data used to create many experiences.
     */
    data: experiencesCreateManyInput | experiencesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: experiencesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * experiences update
   */
  export type experiencesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the experiences
     */
    select?: experiencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the experiences
     */
    omit?: experiencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: experiencesInclude<ExtArgs> | null
    /**
     * The data needed to update a experiences.
     */
    data: XOR<experiencesUpdateInput, experiencesUncheckedUpdateInput>
    /**
     * Choose, which experiences to update.
     */
    where: experiencesWhereUniqueInput
  }

  /**
   * experiences updateMany
   */
  export type experiencesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update experiences.
     */
    data: XOR<experiencesUpdateManyMutationInput, experiencesUncheckedUpdateManyInput>
    /**
     * Filter which experiences to update
     */
    where?: experiencesWhereInput
    /**
     * Limit how many experiences to update.
     */
    limit?: number
  }

  /**
   * experiences updateManyAndReturn
   */
  export type experiencesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the experiences
     */
    select?: experiencesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the experiences
     */
    omit?: experiencesOmit<ExtArgs> | null
    /**
     * The data used to update experiences.
     */
    data: XOR<experiencesUpdateManyMutationInput, experiencesUncheckedUpdateManyInput>
    /**
     * Filter which experiences to update
     */
    where?: experiencesWhereInput
    /**
     * Limit how many experiences to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: experiencesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * experiences upsert
   */
  export type experiencesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the experiences
     */
    select?: experiencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the experiences
     */
    omit?: experiencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: experiencesInclude<ExtArgs> | null
    /**
     * The filter to search for the experiences to update in case it exists.
     */
    where: experiencesWhereUniqueInput
    /**
     * In case the experiences found by the `where` argument doesn't exist, create a new experiences with this data.
     */
    create: XOR<experiencesCreateInput, experiencesUncheckedCreateInput>
    /**
     * In case the experiences was found with the provided `where` argument, update it with this data.
     */
    update: XOR<experiencesUpdateInput, experiencesUncheckedUpdateInput>
  }

  /**
   * experiences delete
   */
  export type experiencesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the experiences
     */
    select?: experiencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the experiences
     */
    omit?: experiencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: experiencesInclude<ExtArgs> | null
    /**
     * Filter which experiences to delete.
     */
    where: experiencesWhereUniqueInput
  }

  /**
   * experiences deleteMany
   */
  export type experiencesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which experiences to delete
     */
    where?: experiencesWhereInput
    /**
     * Limit how many experiences to delete.
     */
    limit?: number
  }

  /**
   * experiences without action
   */
  export type experiencesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the experiences
     */
    select?: experiencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the experiences
     */
    omit?: experiencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: experiencesInclude<ExtArgs> | null
  }


  /**
   * Model features
   */

  export type AggregateFeatures = {
    _count: FeaturesCountAggregateOutputType | null
    _avg: FeaturesAvgAggregateOutputType | null
    _sum: FeaturesSumAggregateOutputType | null
    _min: FeaturesMinAggregateOutputType | null
    _max: FeaturesMaxAggregateOutputType | null
  }

  export type FeaturesAvgAggregateOutputType = {
    id: number | null
    plan_id: number | null
  }

  export type FeaturesSumAggregateOutputType = {
    id: number | null
    plan_id: number | null
  }

  export type FeaturesMinAggregateOutputType = {
    id: number | null
    feature_name: string | null
    description: string | null
    plan_id: number | null
  }

  export type FeaturesMaxAggregateOutputType = {
    id: number | null
    feature_name: string | null
    description: string | null
    plan_id: number | null
  }

  export type FeaturesCountAggregateOutputType = {
    id: number
    feature_name: number
    description: number
    plan_id: number
    _all: number
  }


  export type FeaturesAvgAggregateInputType = {
    id?: true
    plan_id?: true
  }

  export type FeaturesSumAggregateInputType = {
    id?: true
    plan_id?: true
  }

  export type FeaturesMinAggregateInputType = {
    id?: true
    feature_name?: true
    description?: true
    plan_id?: true
  }

  export type FeaturesMaxAggregateInputType = {
    id?: true
    feature_name?: true
    description?: true
    plan_id?: true
  }

  export type FeaturesCountAggregateInputType = {
    id?: true
    feature_name?: true
    description?: true
    plan_id?: true
    _all?: true
  }

  export type FeaturesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which features to aggregate.
     */
    where?: featuresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of features to fetch.
     */
    orderBy?: featuresOrderByWithRelationInput | featuresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: featuresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` features from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` features.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned features
    **/
    _count?: true | FeaturesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeaturesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeaturesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeaturesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeaturesMaxAggregateInputType
  }

  export type GetFeaturesAggregateType<T extends FeaturesAggregateArgs> = {
        [P in keyof T & keyof AggregateFeatures]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeatures[P]>
      : GetScalarType<T[P], AggregateFeatures[P]>
  }




  export type featuresGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: featuresWhereInput
    orderBy?: featuresOrderByWithAggregationInput | featuresOrderByWithAggregationInput[]
    by: FeaturesScalarFieldEnum[] | FeaturesScalarFieldEnum
    having?: featuresScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeaturesCountAggregateInputType | true
    _avg?: FeaturesAvgAggregateInputType
    _sum?: FeaturesSumAggregateInputType
    _min?: FeaturesMinAggregateInputType
    _max?: FeaturesMaxAggregateInputType
  }

  export type FeaturesGroupByOutputType = {
    id: number
    feature_name: string
    description: string | null
    plan_id: number | null
    _count: FeaturesCountAggregateOutputType | null
    _avg: FeaturesAvgAggregateOutputType | null
    _sum: FeaturesSumAggregateOutputType | null
    _min: FeaturesMinAggregateOutputType | null
    _max: FeaturesMaxAggregateOutputType | null
  }

  type GetFeaturesGroupByPayload<T extends featuresGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeaturesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeaturesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeaturesGroupByOutputType[P]>
            : GetScalarType<T[P], FeaturesGroupByOutputType[P]>
        }
      >
    >


  export type featuresSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    feature_name?: boolean
    description?: boolean
    plan_id?: boolean
    membershipPlans?: boolean | features$membershipPlansArgs<ExtArgs>
  }, ExtArgs["result"]["features"]>

  export type featuresSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    feature_name?: boolean
    description?: boolean
    plan_id?: boolean
    membershipPlans?: boolean | features$membershipPlansArgs<ExtArgs>
  }, ExtArgs["result"]["features"]>

  export type featuresSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    feature_name?: boolean
    description?: boolean
    plan_id?: boolean
    membershipPlans?: boolean | features$membershipPlansArgs<ExtArgs>
  }, ExtArgs["result"]["features"]>

  export type featuresSelectScalar = {
    id?: boolean
    feature_name?: boolean
    description?: boolean
    plan_id?: boolean
  }

  export type featuresOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "feature_name" | "description" | "plan_id", ExtArgs["result"]["features"]>
  export type featuresInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    membershipPlans?: boolean | features$membershipPlansArgs<ExtArgs>
  }
  export type featuresIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    membershipPlans?: boolean | features$membershipPlansArgs<ExtArgs>
  }
  export type featuresIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    membershipPlans?: boolean | features$membershipPlansArgs<ExtArgs>
  }

  export type $featuresPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "features"
    objects: {
      membershipPlans: Prisma.$membershipPlansPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      feature_name: string
      description: string | null
      plan_id: number | null
    }, ExtArgs["result"]["features"]>
    composites: {}
  }

  type featuresGetPayload<S extends boolean | null | undefined | featuresDefaultArgs> = $Result.GetResult<Prisma.$featuresPayload, S>

  type featuresCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<featuresFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FeaturesCountAggregateInputType | true
    }

  export interface featuresDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['features'], meta: { name: 'features' } }
    /**
     * Find zero or one Features that matches the filter.
     * @param {featuresFindUniqueArgs} args - Arguments to find a Features
     * @example
     * // Get one Features
     * const features = await prisma.features.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends featuresFindUniqueArgs>(args: SelectSubset<T, featuresFindUniqueArgs<ExtArgs>>): Prisma__featuresClient<$Result.GetResult<Prisma.$featuresPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Features that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {featuresFindUniqueOrThrowArgs} args - Arguments to find a Features
     * @example
     * // Get one Features
     * const features = await prisma.features.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends featuresFindUniqueOrThrowArgs>(args: SelectSubset<T, featuresFindUniqueOrThrowArgs<ExtArgs>>): Prisma__featuresClient<$Result.GetResult<Prisma.$featuresPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Features that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {featuresFindFirstArgs} args - Arguments to find a Features
     * @example
     * // Get one Features
     * const features = await prisma.features.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends featuresFindFirstArgs>(args?: SelectSubset<T, featuresFindFirstArgs<ExtArgs>>): Prisma__featuresClient<$Result.GetResult<Prisma.$featuresPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Features that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {featuresFindFirstOrThrowArgs} args - Arguments to find a Features
     * @example
     * // Get one Features
     * const features = await prisma.features.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends featuresFindFirstOrThrowArgs>(args?: SelectSubset<T, featuresFindFirstOrThrowArgs<ExtArgs>>): Prisma__featuresClient<$Result.GetResult<Prisma.$featuresPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Features that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {featuresFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Features
     * const features = await prisma.features.findMany()
     * 
     * // Get first 10 Features
     * const features = await prisma.features.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const featuresWithIdOnly = await prisma.features.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends featuresFindManyArgs>(args?: SelectSubset<T, featuresFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$featuresPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Features.
     * @param {featuresCreateArgs} args - Arguments to create a Features.
     * @example
     * // Create one Features
     * const Features = await prisma.features.create({
     *   data: {
     *     // ... data to create a Features
     *   }
     * })
     * 
     */
    create<T extends featuresCreateArgs>(args: SelectSubset<T, featuresCreateArgs<ExtArgs>>): Prisma__featuresClient<$Result.GetResult<Prisma.$featuresPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Features.
     * @param {featuresCreateManyArgs} args - Arguments to create many Features.
     * @example
     * // Create many Features
     * const features = await prisma.features.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends featuresCreateManyArgs>(args?: SelectSubset<T, featuresCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Features and returns the data saved in the database.
     * @param {featuresCreateManyAndReturnArgs} args - Arguments to create many Features.
     * @example
     * // Create many Features
     * const features = await prisma.features.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Features and only return the `id`
     * const featuresWithIdOnly = await prisma.features.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends featuresCreateManyAndReturnArgs>(args?: SelectSubset<T, featuresCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$featuresPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Features.
     * @param {featuresDeleteArgs} args - Arguments to delete one Features.
     * @example
     * // Delete one Features
     * const Features = await prisma.features.delete({
     *   where: {
     *     // ... filter to delete one Features
     *   }
     * })
     * 
     */
    delete<T extends featuresDeleteArgs>(args: SelectSubset<T, featuresDeleteArgs<ExtArgs>>): Prisma__featuresClient<$Result.GetResult<Prisma.$featuresPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Features.
     * @param {featuresUpdateArgs} args - Arguments to update one Features.
     * @example
     * // Update one Features
     * const features = await prisma.features.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends featuresUpdateArgs>(args: SelectSubset<T, featuresUpdateArgs<ExtArgs>>): Prisma__featuresClient<$Result.GetResult<Prisma.$featuresPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Features.
     * @param {featuresDeleteManyArgs} args - Arguments to filter Features to delete.
     * @example
     * // Delete a few Features
     * const { count } = await prisma.features.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends featuresDeleteManyArgs>(args?: SelectSubset<T, featuresDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Features.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {featuresUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Features
     * const features = await prisma.features.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends featuresUpdateManyArgs>(args: SelectSubset<T, featuresUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Features and returns the data updated in the database.
     * @param {featuresUpdateManyAndReturnArgs} args - Arguments to update many Features.
     * @example
     * // Update many Features
     * const features = await prisma.features.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Features and only return the `id`
     * const featuresWithIdOnly = await prisma.features.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends featuresUpdateManyAndReturnArgs>(args: SelectSubset<T, featuresUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$featuresPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Features.
     * @param {featuresUpsertArgs} args - Arguments to update or create a Features.
     * @example
     * // Update or create a Features
     * const features = await prisma.features.upsert({
     *   create: {
     *     // ... data to create a Features
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Features we want to update
     *   }
     * })
     */
    upsert<T extends featuresUpsertArgs>(args: SelectSubset<T, featuresUpsertArgs<ExtArgs>>): Prisma__featuresClient<$Result.GetResult<Prisma.$featuresPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Features.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {featuresCountArgs} args - Arguments to filter Features to count.
     * @example
     * // Count the number of Features
     * const count = await prisma.features.count({
     *   where: {
     *     // ... the filter for the Features we want to count
     *   }
     * })
    **/
    count<T extends featuresCountArgs>(
      args?: Subset<T, featuresCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeaturesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Features.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeaturesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeaturesAggregateArgs>(args: Subset<T, FeaturesAggregateArgs>): Prisma.PrismaPromise<GetFeaturesAggregateType<T>>

    /**
     * Group by Features.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {featuresGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends featuresGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: featuresGroupByArgs['orderBy'] }
        : { orderBy?: featuresGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, featuresGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeaturesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the features model
   */
  readonly fields: featuresFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for features.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__featuresClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    membershipPlans<T extends features$membershipPlansArgs<ExtArgs> = {}>(args?: Subset<T, features$membershipPlansArgs<ExtArgs>>): Prisma__membershipPlansClient<$Result.GetResult<Prisma.$membershipPlansPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the features model
   */
  interface featuresFieldRefs {
    readonly id: FieldRef<"features", 'Int'>
    readonly feature_name: FieldRef<"features", 'String'>
    readonly description: FieldRef<"features", 'String'>
    readonly plan_id: FieldRef<"features", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * features findUnique
   */
  export type featuresFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the features
     */
    select?: featuresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the features
     */
    omit?: featuresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: featuresInclude<ExtArgs> | null
    /**
     * Filter, which features to fetch.
     */
    where: featuresWhereUniqueInput
  }

  /**
   * features findUniqueOrThrow
   */
  export type featuresFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the features
     */
    select?: featuresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the features
     */
    omit?: featuresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: featuresInclude<ExtArgs> | null
    /**
     * Filter, which features to fetch.
     */
    where: featuresWhereUniqueInput
  }

  /**
   * features findFirst
   */
  export type featuresFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the features
     */
    select?: featuresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the features
     */
    omit?: featuresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: featuresInclude<ExtArgs> | null
    /**
     * Filter, which features to fetch.
     */
    where?: featuresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of features to fetch.
     */
    orderBy?: featuresOrderByWithRelationInput | featuresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for features.
     */
    cursor?: featuresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` features from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` features.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of features.
     */
    distinct?: FeaturesScalarFieldEnum | FeaturesScalarFieldEnum[]
  }

  /**
   * features findFirstOrThrow
   */
  export type featuresFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the features
     */
    select?: featuresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the features
     */
    omit?: featuresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: featuresInclude<ExtArgs> | null
    /**
     * Filter, which features to fetch.
     */
    where?: featuresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of features to fetch.
     */
    orderBy?: featuresOrderByWithRelationInput | featuresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for features.
     */
    cursor?: featuresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` features from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` features.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of features.
     */
    distinct?: FeaturesScalarFieldEnum | FeaturesScalarFieldEnum[]
  }

  /**
   * features findMany
   */
  export type featuresFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the features
     */
    select?: featuresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the features
     */
    omit?: featuresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: featuresInclude<ExtArgs> | null
    /**
     * Filter, which features to fetch.
     */
    where?: featuresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of features to fetch.
     */
    orderBy?: featuresOrderByWithRelationInput | featuresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing features.
     */
    cursor?: featuresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` features from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` features.
     */
    skip?: number
    distinct?: FeaturesScalarFieldEnum | FeaturesScalarFieldEnum[]
  }

  /**
   * features create
   */
  export type featuresCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the features
     */
    select?: featuresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the features
     */
    omit?: featuresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: featuresInclude<ExtArgs> | null
    /**
     * The data needed to create a features.
     */
    data: XOR<featuresCreateInput, featuresUncheckedCreateInput>
  }

  /**
   * features createMany
   */
  export type featuresCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many features.
     */
    data: featuresCreateManyInput | featuresCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * features createManyAndReturn
   */
  export type featuresCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the features
     */
    select?: featuresSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the features
     */
    omit?: featuresOmit<ExtArgs> | null
    /**
     * The data used to create many features.
     */
    data: featuresCreateManyInput | featuresCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: featuresIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * features update
   */
  export type featuresUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the features
     */
    select?: featuresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the features
     */
    omit?: featuresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: featuresInclude<ExtArgs> | null
    /**
     * The data needed to update a features.
     */
    data: XOR<featuresUpdateInput, featuresUncheckedUpdateInput>
    /**
     * Choose, which features to update.
     */
    where: featuresWhereUniqueInput
  }

  /**
   * features updateMany
   */
  export type featuresUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update features.
     */
    data: XOR<featuresUpdateManyMutationInput, featuresUncheckedUpdateManyInput>
    /**
     * Filter which features to update
     */
    where?: featuresWhereInput
    /**
     * Limit how many features to update.
     */
    limit?: number
  }

  /**
   * features updateManyAndReturn
   */
  export type featuresUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the features
     */
    select?: featuresSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the features
     */
    omit?: featuresOmit<ExtArgs> | null
    /**
     * The data used to update features.
     */
    data: XOR<featuresUpdateManyMutationInput, featuresUncheckedUpdateManyInput>
    /**
     * Filter which features to update
     */
    where?: featuresWhereInput
    /**
     * Limit how many features to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: featuresIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * features upsert
   */
  export type featuresUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the features
     */
    select?: featuresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the features
     */
    omit?: featuresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: featuresInclude<ExtArgs> | null
    /**
     * The filter to search for the features to update in case it exists.
     */
    where: featuresWhereUniqueInput
    /**
     * In case the features found by the `where` argument doesn't exist, create a new features with this data.
     */
    create: XOR<featuresCreateInput, featuresUncheckedCreateInput>
    /**
     * In case the features was found with the provided `where` argument, update it with this data.
     */
    update: XOR<featuresUpdateInput, featuresUncheckedUpdateInput>
  }

  /**
   * features delete
   */
  export type featuresDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the features
     */
    select?: featuresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the features
     */
    omit?: featuresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: featuresInclude<ExtArgs> | null
    /**
     * Filter which features to delete.
     */
    where: featuresWhereUniqueInput
  }

  /**
   * features deleteMany
   */
  export type featuresDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which features to delete
     */
    where?: featuresWhereInput
    /**
     * Limit how many features to delete.
     */
    limit?: number
  }

  /**
   * features.membershipPlans
   */
  export type features$membershipPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the membershipPlans
     */
    select?: membershipPlansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the membershipPlans
     */
    omit?: membershipPlansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: membershipPlansInclude<ExtArgs> | null
    where?: membershipPlansWhereInput
  }

  /**
   * features without action
   */
  export type featuresDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the features
     */
    select?: featuresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the features
     */
    omit?: featuresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: featuresInclude<ExtArgs> | null
  }


  /**
   * Model feedbacks
   */

  export type AggregateFeedbacks = {
    _count: FeedbacksCountAggregateOutputType | null
    _avg: FeedbacksAvgAggregateOutputType | null
    _sum: FeedbacksSumAggregateOutputType | null
    _min: FeedbacksMinAggregateOutputType | null
    _max: FeedbacksMaxAggregateOutputType | null
  }

  export type FeedbacksAvgAggregateOutputType = {
    stars: number | null
  }

  export type FeedbacksSumAggregateOutputType = {
    stars: number | null
  }

  export type FeedbacksMinAggregateOutputType = {
    user_id: string | null
    company_id: string | null
    description: string | null
    stars: number | null
    work_environment: string | null
    benefit: string | null
    created_at: Date | null
  }

  export type FeedbacksMaxAggregateOutputType = {
    user_id: string | null
    company_id: string | null
    description: string | null
    stars: number | null
    work_environment: string | null
    benefit: string | null
    created_at: Date | null
  }

  export type FeedbacksCountAggregateOutputType = {
    user_id: number
    company_id: number
    description: number
    stars: number
    work_environment: number
    benefit: number
    created_at: number
    _all: number
  }


  export type FeedbacksAvgAggregateInputType = {
    stars?: true
  }

  export type FeedbacksSumAggregateInputType = {
    stars?: true
  }

  export type FeedbacksMinAggregateInputType = {
    user_id?: true
    company_id?: true
    description?: true
    stars?: true
    work_environment?: true
    benefit?: true
    created_at?: true
  }

  export type FeedbacksMaxAggregateInputType = {
    user_id?: true
    company_id?: true
    description?: true
    stars?: true
    work_environment?: true
    benefit?: true
    created_at?: true
  }

  export type FeedbacksCountAggregateInputType = {
    user_id?: true
    company_id?: true
    description?: true
    stars?: true
    work_environment?: true
    benefit?: true
    created_at?: true
    _all?: true
  }

  export type FeedbacksAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which feedbacks to aggregate.
     */
    where?: feedbacksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of feedbacks to fetch.
     */
    orderBy?: feedbacksOrderByWithRelationInput | feedbacksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: feedbacksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned feedbacks
    **/
    _count?: true | FeedbacksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeedbacksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeedbacksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeedbacksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeedbacksMaxAggregateInputType
  }

  export type GetFeedbacksAggregateType<T extends FeedbacksAggregateArgs> = {
        [P in keyof T & keyof AggregateFeedbacks]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeedbacks[P]>
      : GetScalarType<T[P], AggregateFeedbacks[P]>
  }




  export type feedbacksGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: feedbacksWhereInput
    orderBy?: feedbacksOrderByWithAggregationInput | feedbacksOrderByWithAggregationInput[]
    by: FeedbacksScalarFieldEnum[] | FeedbacksScalarFieldEnum
    having?: feedbacksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeedbacksCountAggregateInputType | true
    _avg?: FeedbacksAvgAggregateInputType
    _sum?: FeedbacksSumAggregateInputType
    _min?: FeedbacksMinAggregateInputType
    _max?: FeedbacksMaxAggregateInputType
  }

  export type FeedbacksGroupByOutputType = {
    user_id: string
    company_id: string
    description: string
    stars: number
    work_environment: string | null
    benefit: string | null
    created_at: Date
    _count: FeedbacksCountAggregateOutputType | null
    _avg: FeedbacksAvgAggregateOutputType | null
    _sum: FeedbacksSumAggregateOutputType | null
    _min: FeedbacksMinAggregateOutputType | null
    _max: FeedbacksMaxAggregateOutputType | null
  }

  type GetFeedbacksGroupByPayload<T extends feedbacksGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeedbacksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeedbacksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeedbacksGroupByOutputType[P]>
            : GetScalarType<T[P], FeedbacksGroupByOutputType[P]>
        }
      >
    >


  export type feedbacksSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    company_id?: boolean
    description?: boolean
    stars?: boolean
    work_environment?: boolean
    benefit?: boolean
    created_at?: boolean
    companies?: boolean | companiesDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feedbacks"]>

  export type feedbacksSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    company_id?: boolean
    description?: boolean
    stars?: boolean
    work_environment?: boolean
    benefit?: boolean
    created_at?: boolean
    companies?: boolean | companiesDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feedbacks"]>

  export type feedbacksSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    company_id?: boolean
    description?: boolean
    stars?: boolean
    work_environment?: boolean
    benefit?: boolean
    created_at?: boolean
    companies?: boolean | companiesDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feedbacks"]>

  export type feedbacksSelectScalar = {
    user_id?: boolean
    company_id?: boolean
    description?: boolean
    stars?: boolean
    work_environment?: boolean
    benefit?: boolean
    created_at?: boolean
  }

  export type feedbacksOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"user_id" | "company_id" | "description" | "stars" | "work_environment" | "benefit" | "created_at", ExtArgs["result"]["feedbacks"]>
  export type feedbacksInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companies?: boolean | companiesDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type feedbacksIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companies?: boolean | companiesDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type feedbacksIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companies?: boolean | companiesDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $feedbacksPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "feedbacks"
    objects: {
      companies: Prisma.$companiesPayload<ExtArgs>
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      user_id: string
      company_id: string
      description: string
      stars: number
      work_environment: string | null
      benefit: string | null
      created_at: Date
    }, ExtArgs["result"]["feedbacks"]>
    composites: {}
  }

  type feedbacksGetPayload<S extends boolean | null | undefined | feedbacksDefaultArgs> = $Result.GetResult<Prisma.$feedbacksPayload, S>

  type feedbacksCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<feedbacksFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FeedbacksCountAggregateInputType | true
    }

  export interface feedbacksDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['feedbacks'], meta: { name: 'feedbacks' } }
    /**
     * Find zero or one Feedbacks that matches the filter.
     * @param {feedbacksFindUniqueArgs} args - Arguments to find a Feedbacks
     * @example
     * // Get one Feedbacks
     * const feedbacks = await prisma.feedbacks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends feedbacksFindUniqueArgs>(args: SelectSubset<T, feedbacksFindUniqueArgs<ExtArgs>>): Prisma__feedbacksClient<$Result.GetResult<Prisma.$feedbacksPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Feedbacks that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {feedbacksFindUniqueOrThrowArgs} args - Arguments to find a Feedbacks
     * @example
     * // Get one Feedbacks
     * const feedbacks = await prisma.feedbacks.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends feedbacksFindUniqueOrThrowArgs>(args: SelectSubset<T, feedbacksFindUniqueOrThrowArgs<ExtArgs>>): Prisma__feedbacksClient<$Result.GetResult<Prisma.$feedbacksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Feedbacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {feedbacksFindFirstArgs} args - Arguments to find a Feedbacks
     * @example
     * // Get one Feedbacks
     * const feedbacks = await prisma.feedbacks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends feedbacksFindFirstArgs>(args?: SelectSubset<T, feedbacksFindFirstArgs<ExtArgs>>): Prisma__feedbacksClient<$Result.GetResult<Prisma.$feedbacksPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Feedbacks that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {feedbacksFindFirstOrThrowArgs} args - Arguments to find a Feedbacks
     * @example
     * // Get one Feedbacks
     * const feedbacks = await prisma.feedbacks.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends feedbacksFindFirstOrThrowArgs>(args?: SelectSubset<T, feedbacksFindFirstOrThrowArgs<ExtArgs>>): Prisma__feedbacksClient<$Result.GetResult<Prisma.$feedbacksPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Feedbacks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {feedbacksFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Feedbacks
     * const feedbacks = await prisma.feedbacks.findMany()
     * 
     * // Get first 10 Feedbacks
     * const feedbacks = await prisma.feedbacks.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const feedbacksWithUser_idOnly = await prisma.feedbacks.findMany({ select: { user_id: true } })
     * 
     */
    findMany<T extends feedbacksFindManyArgs>(args?: SelectSubset<T, feedbacksFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$feedbacksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Feedbacks.
     * @param {feedbacksCreateArgs} args - Arguments to create a Feedbacks.
     * @example
     * // Create one Feedbacks
     * const Feedbacks = await prisma.feedbacks.create({
     *   data: {
     *     // ... data to create a Feedbacks
     *   }
     * })
     * 
     */
    create<T extends feedbacksCreateArgs>(args: SelectSubset<T, feedbacksCreateArgs<ExtArgs>>): Prisma__feedbacksClient<$Result.GetResult<Prisma.$feedbacksPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Feedbacks.
     * @param {feedbacksCreateManyArgs} args - Arguments to create many Feedbacks.
     * @example
     * // Create many Feedbacks
     * const feedbacks = await prisma.feedbacks.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends feedbacksCreateManyArgs>(args?: SelectSubset<T, feedbacksCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Feedbacks and returns the data saved in the database.
     * @param {feedbacksCreateManyAndReturnArgs} args - Arguments to create many Feedbacks.
     * @example
     * // Create many Feedbacks
     * const feedbacks = await prisma.feedbacks.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Feedbacks and only return the `user_id`
     * const feedbacksWithUser_idOnly = await prisma.feedbacks.createManyAndReturn({
     *   select: { user_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends feedbacksCreateManyAndReturnArgs>(args?: SelectSubset<T, feedbacksCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$feedbacksPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Feedbacks.
     * @param {feedbacksDeleteArgs} args - Arguments to delete one Feedbacks.
     * @example
     * // Delete one Feedbacks
     * const Feedbacks = await prisma.feedbacks.delete({
     *   where: {
     *     // ... filter to delete one Feedbacks
     *   }
     * })
     * 
     */
    delete<T extends feedbacksDeleteArgs>(args: SelectSubset<T, feedbacksDeleteArgs<ExtArgs>>): Prisma__feedbacksClient<$Result.GetResult<Prisma.$feedbacksPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Feedbacks.
     * @param {feedbacksUpdateArgs} args - Arguments to update one Feedbacks.
     * @example
     * // Update one Feedbacks
     * const feedbacks = await prisma.feedbacks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends feedbacksUpdateArgs>(args: SelectSubset<T, feedbacksUpdateArgs<ExtArgs>>): Prisma__feedbacksClient<$Result.GetResult<Prisma.$feedbacksPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Feedbacks.
     * @param {feedbacksDeleteManyArgs} args - Arguments to filter Feedbacks to delete.
     * @example
     * // Delete a few Feedbacks
     * const { count } = await prisma.feedbacks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends feedbacksDeleteManyArgs>(args?: SelectSubset<T, feedbacksDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Feedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {feedbacksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Feedbacks
     * const feedbacks = await prisma.feedbacks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends feedbacksUpdateManyArgs>(args: SelectSubset<T, feedbacksUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Feedbacks and returns the data updated in the database.
     * @param {feedbacksUpdateManyAndReturnArgs} args - Arguments to update many Feedbacks.
     * @example
     * // Update many Feedbacks
     * const feedbacks = await prisma.feedbacks.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Feedbacks and only return the `user_id`
     * const feedbacksWithUser_idOnly = await prisma.feedbacks.updateManyAndReturn({
     *   select: { user_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends feedbacksUpdateManyAndReturnArgs>(args: SelectSubset<T, feedbacksUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$feedbacksPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Feedbacks.
     * @param {feedbacksUpsertArgs} args - Arguments to update or create a Feedbacks.
     * @example
     * // Update or create a Feedbacks
     * const feedbacks = await prisma.feedbacks.upsert({
     *   create: {
     *     // ... data to create a Feedbacks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Feedbacks we want to update
     *   }
     * })
     */
    upsert<T extends feedbacksUpsertArgs>(args: SelectSubset<T, feedbacksUpsertArgs<ExtArgs>>): Prisma__feedbacksClient<$Result.GetResult<Prisma.$feedbacksPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Feedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {feedbacksCountArgs} args - Arguments to filter Feedbacks to count.
     * @example
     * // Count the number of Feedbacks
     * const count = await prisma.feedbacks.count({
     *   where: {
     *     // ... the filter for the Feedbacks we want to count
     *   }
     * })
    **/
    count<T extends feedbacksCountArgs>(
      args?: Subset<T, feedbacksCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeedbacksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Feedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbacksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeedbacksAggregateArgs>(args: Subset<T, FeedbacksAggregateArgs>): Prisma.PrismaPromise<GetFeedbacksAggregateType<T>>

    /**
     * Group by Feedbacks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {feedbacksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends feedbacksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: feedbacksGroupByArgs['orderBy'] }
        : { orderBy?: feedbacksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, feedbacksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeedbacksGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the feedbacks model
   */
  readonly fields: feedbacksFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for feedbacks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__feedbacksClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    companies<T extends companiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, companiesDefaultArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the feedbacks model
   */
  interface feedbacksFieldRefs {
    readonly user_id: FieldRef<"feedbacks", 'String'>
    readonly company_id: FieldRef<"feedbacks", 'String'>
    readonly description: FieldRef<"feedbacks", 'String'>
    readonly stars: FieldRef<"feedbacks", 'Float'>
    readonly work_environment: FieldRef<"feedbacks", 'String'>
    readonly benefit: FieldRef<"feedbacks", 'String'>
    readonly created_at: FieldRef<"feedbacks", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * feedbacks findUnique
   */
  export type feedbacksFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feedbacks
     */
    select?: feedbacksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the feedbacks
     */
    omit?: feedbacksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feedbacksInclude<ExtArgs> | null
    /**
     * Filter, which feedbacks to fetch.
     */
    where: feedbacksWhereUniqueInput
  }

  /**
   * feedbacks findUniqueOrThrow
   */
  export type feedbacksFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feedbacks
     */
    select?: feedbacksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the feedbacks
     */
    omit?: feedbacksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feedbacksInclude<ExtArgs> | null
    /**
     * Filter, which feedbacks to fetch.
     */
    where: feedbacksWhereUniqueInput
  }

  /**
   * feedbacks findFirst
   */
  export type feedbacksFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feedbacks
     */
    select?: feedbacksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the feedbacks
     */
    omit?: feedbacksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feedbacksInclude<ExtArgs> | null
    /**
     * Filter, which feedbacks to fetch.
     */
    where?: feedbacksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of feedbacks to fetch.
     */
    orderBy?: feedbacksOrderByWithRelationInput | feedbacksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for feedbacks.
     */
    cursor?: feedbacksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of feedbacks.
     */
    distinct?: FeedbacksScalarFieldEnum | FeedbacksScalarFieldEnum[]
  }

  /**
   * feedbacks findFirstOrThrow
   */
  export type feedbacksFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feedbacks
     */
    select?: feedbacksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the feedbacks
     */
    omit?: feedbacksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feedbacksInclude<ExtArgs> | null
    /**
     * Filter, which feedbacks to fetch.
     */
    where?: feedbacksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of feedbacks to fetch.
     */
    orderBy?: feedbacksOrderByWithRelationInput | feedbacksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for feedbacks.
     */
    cursor?: feedbacksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` feedbacks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of feedbacks.
     */
    distinct?: FeedbacksScalarFieldEnum | FeedbacksScalarFieldEnum[]
  }

  /**
   * feedbacks findMany
   */
  export type feedbacksFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feedbacks
     */
    select?: feedbacksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the feedbacks
     */
    omit?: feedbacksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feedbacksInclude<ExtArgs> | null
    /**
     * Filter, which feedbacks to fetch.
     */
    where?: feedbacksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of feedbacks to fetch.
     */
    orderBy?: feedbacksOrderByWithRelationInput | feedbacksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing feedbacks.
     */
    cursor?: feedbacksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` feedbacks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` feedbacks.
     */
    skip?: number
    distinct?: FeedbacksScalarFieldEnum | FeedbacksScalarFieldEnum[]
  }

  /**
   * feedbacks create
   */
  export type feedbacksCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feedbacks
     */
    select?: feedbacksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the feedbacks
     */
    omit?: feedbacksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feedbacksInclude<ExtArgs> | null
    /**
     * The data needed to create a feedbacks.
     */
    data: XOR<feedbacksCreateInput, feedbacksUncheckedCreateInput>
  }

  /**
   * feedbacks createMany
   */
  export type feedbacksCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many feedbacks.
     */
    data: feedbacksCreateManyInput | feedbacksCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * feedbacks createManyAndReturn
   */
  export type feedbacksCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feedbacks
     */
    select?: feedbacksSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the feedbacks
     */
    omit?: feedbacksOmit<ExtArgs> | null
    /**
     * The data used to create many feedbacks.
     */
    data: feedbacksCreateManyInput | feedbacksCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feedbacksIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * feedbacks update
   */
  export type feedbacksUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feedbacks
     */
    select?: feedbacksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the feedbacks
     */
    omit?: feedbacksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feedbacksInclude<ExtArgs> | null
    /**
     * The data needed to update a feedbacks.
     */
    data: XOR<feedbacksUpdateInput, feedbacksUncheckedUpdateInput>
    /**
     * Choose, which feedbacks to update.
     */
    where: feedbacksWhereUniqueInput
  }

  /**
   * feedbacks updateMany
   */
  export type feedbacksUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update feedbacks.
     */
    data: XOR<feedbacksUpdateManyMutationInput, feedbacksUncheckedUpdateManyInput>
    /**
     * Filter which feedbacks to update
     */
    where?: feedbacksWhereInput
    /**
     * Limit how many feedbacks to update.
     */
    limit?: number
  }

  /**
   * feedbacks updateManyAndReturn
   */
  export type feedbacksUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feedbacks
     */
    select?: feedbacksSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the feedbacks
     */
    omit?: feedbacksOmit<ExtArgs> | null
    /**
     * The data used to update feedbacks.
     */
    data: XOR<feedbacksUpdateManyMutationInput, feedbacksUncheckedUpdateManyInput>
    /**
     * Filter which feedbacks to update
     */
    where?: feedbacksWhereInput
    /**
     * Limit how many feedbacks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feedbacksIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * feedbacks upsert
   */
  export type feedbacksUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feedbacks
     */
    select?: feedbacksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the feedbacks
     */
    omit?: feedbacksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feedbacksInclude<ExtArgs> | null
    /**
     * The filter to search for the feedbacks to update in case it exists.
     */
    where: feedbacksWhereUniqueInput
    /**
     * In case the feedbacks found by the `where` argument doesn't exist, create a new feedbacks with this data.
     */
    create: XOR<feedbacksCreateInput, feedbacksUncheckedCreateInput>
    /**
     * In case the feedbacks was found with the provided `where` argument, update it with this data.
     */
    update: XOR<feedbacksUpdateInput, feedbacksUncheckedUpdateInput>
  }

  /**
   * feedbacks delete
   */
  export type feedbacksDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feedbacks
     */
    select?: feedbacksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the feedbacks
     */
    omit?: feedbacksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feedbacksInclude<ExtArgs> | null
    /**
     * Filter which feedbacks to delete.
     */
    where: feedbacksWhereUniqueInput
  }

  /**
   * feedbacks deleteMany
   */
  export type feedbacksDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which feedbacks to delete
     */
    where?: feedbacksWhereInput
    /**
     * Limit how many feedbacks to delete.
     */
    limit?: number
  }

  /**
   * feedbacks without action
   */
  export type feedbacksDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feedbacks
     */
    select?: feedbacksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the feedbacks
     */
    omit?: feedbacksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feedbacksInclude<ExtArgs> | null
  }


  /**
   * Model fields
   */

  export type AggregateFields = {
    _count: FieldsCountAggregateOutputType | null
    _avg: FieldsAvgAggregateOutputType | null
    _sum: FieldsSumAggregateOutputType | null
    _min: FieldsMinAggregateOutputType | null
    _max: FieldsMaxAggregateOutputType | null
  }

  export type FieldsAvgAggregateOutputType = {
    id: number | null
  }

  export type FieldsSumAggregateOutputType = {
    id: number | null
  }

  export type FieldsMinAggregateOutputType = {
    id: number | null
    field_name: string | null
  }

  export type FieldsMaxAggregateOutputType = {
    id: number | null
    field_name: string | null
  }

  export type FieldsCountAggregateOutputType = {
    id: number
    field_name: number
    _all: number
  }


  export type FieldsAvgAggregateInputType = {
    id?: true
  }

  export type FieldsSumAggregateInputType = {
    id?: true
  }

  export type FieldsMinAggregateInputType = {
    id?: true
    field_name?: true
  }

  export type FieldsMaxAggregateInputType = {
    id?: true
    field_name?: true
  }

  export type FieldsCountAggregateInputType = {
    id?: true
    field_name?: true
    _all?: true
  }

  export type FieldsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which fields to aggregate.
     */
    where?: fieldsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fields to fetch.
     */
    orderBy?: fieldsOrderByWithRelationInput | fieldsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: fieldsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned fields
    **/
    _count?: true | FieldsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FieldsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FieldsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FieldsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FieldsMaxAggregateInputType
  }

  export type GetFieldsAggregateType<T extends FieldsAggregateArgs> = {
        [P in keyof T & keyof AggregateFields]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFields[P]>
      : GetScalarType<T[P], AggregateFields[P]>
  }




  export type fieldsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: fieldsWhereInput
    orderBy?: fieldsOrderByWithAggregationInput | fieldsOrderByWithAggregationInput[]
    by: FieldsScalarFieldEnum[] | FieldsScalarFieldEnum
    having?: fieldsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FieldsCountAggregateInputType | true
    _avg?: FieldsAvgAggregateInputType
    _sum?: FieldsSumAggregateInputType
    _min?: FieldsMinAggregateInputType
    _max?: FieldsMaxAggregateInputType
  }

  export type FieldsGroupByOutputType = {
    id: number
    field_name: string
    _count: FieldsCountAggregateOutputType | null
    _avg: FieldsAvgAggregateOutputType | null
    _sum: FieldsSumAggregateOutputType | null
    _min: FieldsMinAggregateOutputType | null
    _max: FieldsMaxAggregateOutputType | null
  }

  type GetFieldsGroupByPayload<T extends fieldsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FieldsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FieldsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FieldsGroupByOutputType[P]>
            : GetScalarType<T[P], FieldsGroupByOutputType[P]>
        }
      >
    >


  export type fieldsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    field_name?: boolean
    companies?: boolean | fields$companiesArgs<ExtArgs>
    _count?: boolean | FieldsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fields"]>

  export type fieldsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    field_name?: boolean
  }, ExtArgs["result"]["fields"]>

  export type fieldsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    field_name?: boolean
  }, ExtArgs["result"]["fields"]>

  export type fieldsSelectScalar = {
    id?: boolean
    field_name?: boolean
  }

  export type fieldsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "field_name", ExtArgs["result"]["fields"]>
  export type fieldsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companies?: boolean | fields$companiesArgs<ExtArgs>
    _count?: boolean | FieldsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type fieldsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type fieldsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $fieldsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "fields"
    objects: {
      companies: Prisma.$companiesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      field_name: string
    }, ExtArgs["result"]["fields"]>
    composites: {}
  }

  type fieldsGetPayload<S extends boolean | null | undefined | fieldsDefaultArgs> = $Result.GetResult<Prisma.$fieldsPayload, S>

  type fieldsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<fieldsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FieldsCountAggregateInputType | true
    }

  export interface fieldsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['fields'], meta: { name: 'fields' } }
    /**
     * Find zero or one Fields that matches the filter.
     * @param {fieldsFindUniqueArgs} args - Arguments to find a Fields
     * @example
     * // Get one Fields
     * const fields = await prisma.fields.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends fieldsFindUniqueArgs>(args: SelectSubset<T, fieldsFindUniqueArgs<ExtArgs>>): Prisma__fieldsClient<$Result.GetResult<Prisma.$fieldsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Fields that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {fieldsFindUniqueOrThrowArgs} args - Arguments to find a Fields
     * @example
     * // Get one Fields
     * const fields = await prisma.fields.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends fieldsFindUniqueOrThrowArgs>(args: SelectSubset<T, fieldsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__fieldsClient<$Result.GetResult<Prisma.$fieldsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Fields that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fieldsFindFirstArgs} args - Arguments to find a Fields
     * @example
     * // Get one Fields
     * const fields = await prisma.fields.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends fieldsFindFirstArgs>(args?: SelectSubset<T, fieldsFindFirstArgs<ExtArgs>>): Prisma__fieldsClient<$Result.GetResult<Prisma.$fieldsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Fields that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fieldsFindFirstOrThrowArgs} args - Arguments to find a Fields
     * @example
     * // Get one Fields
     * const fields = await prisma.fields.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends fieldsFindFirstOrThrowArgs>(args?: SelectSubset<T, fieldsFindFirstOrThrowArgs<ExtArgs>>): Prisma__fieldsClient<$Result.GetResult<Prisma.$fieldsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Fields that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fieldsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fields
     * const fields = await prisma.fields.findMany()
     * 
     * // Get first 10 Fields
     * const fields = await prisma.fields.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fieldsWithIdOnly = await prisma.fields.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends fieldsFindManyArgs>(args?: SelectSubset<T, fieldsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$fieldsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Fields.
     * @param {fieldsCreateArgs} args - Arguments to create a Fields.
     * @example
     * // Create one Fields
     * const Fields = await prisma.fields.create({
     *   data: {
     *     // ... data to create a Fields
     *   }
     * })
     * 
     */
    create<T extends fieldsCreateArgs>(args: SelectSubset<T, fieldsCreateArgs<ExtArgs>>): Prisma__fieldsClient<$Result.GetResult<Prisma.$fieldsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Fields.
     * @param {fieldsCreateManyArgs} args - Arguments to create many Fields.
     * @example
     * // Create many Fields
     * const fields = await prisma.fields.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends fieldsCreateManyArgs>(args?: SelectSubset<T, fieldsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Fields and returns the data saved in the database.
     * @param {fieldsCreateManyAndReturnArgs} args - Arguments to create many Fields.
     * @example
     * // Create many Fields
     * const fields = await prisma.fields.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Fields and only return the `id`
     * const fieldsWithIdOnly = await prisma.fields.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends fieldsCreateManyAndReturnArgs>(args?: SelectSubset<T, fieldsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$fieldsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Fields.
     * @param {fieldsDeleteArgs} args - Arguments to delete one Fields.
     * @example
     * // Delete one Fields
     * const Fields = await prisma.fields.delete({
     *   where: {
     *     // ... filter to delete one Fields
     *   }
     * })
     * 
     */
    delete<T extends fieldsDeleteArgs>(args: SelectSubset<T, fieldsDeleteArgs<ExtArgs>>): Prisma__fieldsClient<$Result.GetResult<Prisma.$fieldsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Fields.
     * @param {fieldsUpdateArgs} args - Arguments to update one Fields.
     * @example
     * // Update one Fields
     * const fields = await prisma.fields.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends fieldsUpdateArgs>(args: SelectSubset<T, fieldsUpdateArgs<ExtArgs>>): Prisma__fieldsClient<$Result.GetResult<Prisma.$fieldsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Fields.
     * @param {fieldsDeleteManyArgs} args - Arguments to filter Fields to delete.
     * @example
     * // Delete a few Fields
     * const { count } = await prisma.fields.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends fieldsDeleteManyArgs>(args?: SelectSubset<T, fieldsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fieldsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fields
     * const fields = await prisma.fields.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends fieldsUpdateManyArgs>(args: SelectSubset<T, fieldsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fields and returns the data updated in the database.
     * @param {fieldsUpdateManyAndReturnArgs} args - Arguments to update many Fields.
     * @example
     * // Update many Fields
     * const fields = await prisma.fields.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Fields and only return the `id`
     * const fieldsWithIdOnly = await prisma.fields.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends fieldsUpdateManyAndReturnArgs>(args: SelectSubset<T, fieldsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$fieldsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Fields.
     * @param {fieldsUpsertArgs} args - Arguments to update or create a Fields.
     * @example
     * // Update or create a Fields
     * const fields = await prisma.fields.upsert({
     *   create: {
     *     // ... data to create a Fields
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fields we want to update
     *   }
     * })
     */
    upsert<T extends fieldsUpsertArgs>(args: SelectSubset<T, fieldsUpsertArgs<ExtArgs>>): Prisma__fieldsClient<$Result.GetResult<Prisma.$fieldsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Fields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fieldsCountArgs} args - Arguments to filter Fields to count.
     * @example
     * // Count the number of Fields
     * const count = await prisma.fields.count({
     *   where: {
     *     // ... the filter for the Fields we want to count
     *   }
     * })
    **/
    count<T extends fieldsCountArgs>(
      args?: Subset<T, fieldsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FieldsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Fields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FieldsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FieldsAggregateArgs>(args: Subset<T, FieldsAggregateArgs>): Prisma.PrismaPromise<GetFieldsAggregateType<T>>

    /**
     * Group by Fields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fieldsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends fieldsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: fieldsGroupByArgs['orderBy'] }
        : { orderBy?: fieldsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, fieldsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFieldsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the fields model
   */
  readonly fields: fieldsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for fields.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__fieldsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    companies<T extends fields$companiesArgs<ExtArgs> = {}>(args?: Subset<T, fields$companiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the fields model
   */
  interface fieldsFieldRefs {
    readonly id: FieldRef<"fields", 'Int'>
    readonly field_name: FieldRef<"fields", 'String'>
  }
    

  // Custom InputTypes
  /**
   * fields findUnique
   */
  export type fieldsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fields
     */
    select?: fieldsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fields
     */
    omit?: fieldsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fieldsInclude<ExtArgs> | null
    /**
     * Filter, which fields to fetch.
     */
    where: fieldsWhereUniqueInput
  }

  /**
   * fields findUniqueOrThrow
   */
  export type fieldsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fields
     */
    select?: fieldsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fields
     */
    omit?: fieldsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fieldsInclude<ExtArgs> | null
    /**
     * Filter, which fields to fetch.
     */
    where: fieldsWhereUniqueInput
  }

  /**
   * fields findFirst
   */
  export type fieldsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fields
     */
    select?: fieldsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fields
     */
    omit?: fieldsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fieldsInclude<ExtArgs> | null
    /**
     * Filter, which fields to fetch.
     */
    where?: fieldsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fields to fetch.
     */
    orderBy?: fieldsOrderByWithRelationInput | fieldsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for fields.
     */
    cursor?: fieldsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of fields.
     */
    distinct?: FieldsScalarFieldEnum | FieldsScalarFieldEnum[]
  }

  /**
   * fields findFirstOrThrow
   */
  export type fieldsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fields
     */
    select?: fieldsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fields
     */
    omit?: fieldsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fieldsInclude<ExtArgs> | null
    /**
     * Filter, which fields to fetch.
     */
    where?: fieldsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fields to fetch.
     */
    orderBy?: fieldsOrderByWithRelationInput | fieldsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for fields.
     */
    cursor?: fieldsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of fields.
     */
    distinct?: FieldsScalarFieldEnum | FieldsScalarFieldEnum[]
  }

  /**
   * fields findMany
   */
  export type fieldsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fields
     */
    select?: fieldsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fields
     */
    omit?: fieldsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fieldsInclude<ExtArgs> | null
    /**
     * Filter, which fields to fetch.
     */
    where?: fieldsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fields to fetch.
     */
    orderBy?: fieldsOrderByWithRelationInput | fieldsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing fields.
     */
    cursor?: fieldsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fields.
     */
    skip?: number
    distinct?: FieldsScalarFieldEnum | FieldsScalarFieldEnum[]
  }

  /**
   * fields create
   */
  export type fieldsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fields
     */
    select?: fieldsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fields
     */
    omit?: fieldsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fieldsInclude<ExtArgs> | null
    /**
     * The data needed to create a fields.
     */
    data: XOR<fieldsCreateInput, fieldsUncheckedCreateInput>
  }

  /**
   * fields createMany
   */
  export type fieldsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many fields.
     */
    data: fieldsCreateManyInput | fieldsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * fields createManyAndReturn
   */
  export type fieldsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fields
     */
    select?: fieldsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the fields
     */
    omit?: fieldsOmit<ExtArgs> | null
    /**
     * The data used to create many fields.
     */
    data: fieldsCreateManyInput | fieldsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * fields update
   */
  export type fieldsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fields
     */
    select?: fieldsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fields
     */
    omit?: fieldsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fieldsInclude<ExtArgs> | null
    /**
     * The data needed to update a fields.
     */
    data: XOR<fieldsUpdateInput, fieldsUncheckedUpdateInput>
    /**
     * Choose, which fields to update.
     */
    where: fieldsWhereUniqueInput
  }

  /**
   * fields updateMany
   */
  export type fieldsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update fields.
     */
    data: XOR<fieldsUpdateManyMutationInput, fieldsUncheckedUpdateManyInput>
    /**
     * Filter which fields to update
     */
    where?: fieldsWhereInput
    /**
     * Limit how many fields to update.
     */
    limit?: number
  }

  /**
   * fields updateManyAndReturn
   */
  export type fieldsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fields
     */
    select?: fieldsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the fields
     */
    omit?: fieldsOmit<ExtArgs> | null
    /**
     * The data used to update fields.
     */
    data: XOR<fieldsUpdateManyMutationInput, fieldsUncheckedUpdateManyInput>
    /**
     * Filter which fields to update
     */
    where?: fieldsWhereInput
    /**
     * Limit how many fields to update.
     */
    limit?: number
  }

  /**
   * fields upsert
   */
  export type fieldsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fields
     */
    select?: fieldsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fields
     */
    omit?: fieldsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fieldsInclude<ExtArgs> | null
    /**
     * The filter to search for the fields to update in case it exists.
     */
    where: fieldsWhereUniqueInput
    /**
     * In case the fields found by the `where` argument doesn't exist, create a new fields with this data.
     */
    create: XOR<fieldsCreateInput, fieldsUncheckedCreateInput>
    /**
     * In case the fields was found with the provided `where` argument, update it with this data.
     */
    update: XOR<fieldsUpdateInput, fieldsUncheckedUpdateInput>
  }

  /**
   * fields delete
   */
  export type fieldsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fields
     */
    select?: fieldsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fields
     */
    omit?: fieldsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fieldsInclude<ExtArgs> | null
    /**
     * Filter which fields to delete.
     */
    where: fieldsWhereUniqueInput
  }

  /**
   * fields deleteMany
   */
  export type fieldsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which fields to delete
     */
    where?: fieldsWhereInput
    /**
     * Limit how many fields to delete.
     */
    limit?: number
  }

  /**
   * fields.companies
   */
  export type fields$companiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    where?: companiesWhereInput
    orderBy?: companiesOrderByWithRelationInput | companiesOrderByWithRelationInput[]
    cursor?: companiesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompaniesScalarFieldEnum | CompaniesScalarFieldEnum[]
  }

  /**
   * fields without action
   */
  export type fieldsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fields
     */
    select?: fieldsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fields
     */
    omit?: fieldsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fieldsInclude<ExtArgs> | null
  }


  /**
   * Model followedCompanies
   */

  export type AggregateFollowedCompanies = {
    _count: FollowedCompaniesCountAggregateOutputType | null
    _min: FollowedCompaniesMinAggregateOutputType | null
    _max: FollowedCompaniesMaxAggregateOutputType | null
  }

  export type FollowedCompaniesMinAggregateOutputType = {
    user_id: string | null
    company_id: string | null
    followed_at: Date | null
    is_notified: boolean | null
  }

  export type FollowedCompaniesMaxAggregateOutputType = {
    user_id: string | null
    company_id: string | null
    followed_at: Date | null
    is_notified: boolean | null
  }

  export type FollowedCompaniesCountAggregateOutputType = {
    user_id: number
    company_id: number
    followed_at: number
    is_notified: number
    _all: number
  }


  export type FollowedCompaniesMinAggregateInputType = {
    user_id?: true
    company_id?: true
    followed_at?: true
    is_notified?: true
  }

  export type FollowedCompaniesMaxAggregateInputType = {
    user_id?: true
    company_id?: true
    followed_at?: true
    is_notified?: true
  }

  export type FollowedCompaniesCountAggregateInputType = {
    user_id?: true
    company_id?: true
    followed_at?: true
    is_notified?: true
    _all?: true
  }

  export type FollowedCompaniesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which followedCompanies to aggregate.
     */
    where?: followedCompaniesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of followedCompanies to fetch.
     */
    orderBy?: followedCompaniesOrderByWithRelationInput | followedCompaniesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: followedCompaniesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` followedCompanies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` followedCompanies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned followedCompanies
    **/
    _count?: true | FollowedCompaniesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FollowedCompaniesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FollowedCompaniesMaxAggregateInputType
  }

  export type GetFollowedCompaniesAggregateType<T extends FollowedCompaniesAggregateArgs> = {
        [P in keyof T & keyof AggregateFollowedCompanies]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFollowedCompanies[P]>
      : GetScalarType<T[P], AggregateFollowedCompanies[P]>
  }




  export type followedCompaniesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: followedCompaniesWhereInput
    orderBy?: followedCompaniesOrderByWithAggregationInput | followedCompaniesOrderByWithAggregationInput[]
    by: FollowedCompaniesScalarFieldEnum[] | FollowedCompaniesScalarFieldEnum
    having?: followedCompaniesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FollowedCompaniesCountAggregateInputType | true
    _min?: FollowedCompaniesMinAggregateInputType
    _max?: FollowedCompaniesMaxAggregateInputType
  }

  export type FollowedCompaniesGroupByOutputType = {
    user_id: string
    company_id: string
    followed_at: Date
    is_notified: boolean
    _count: FollowedCompaniesCountAggregateOutputType | null
    _min: FollowedCompaniesMinAggregateOutputType | null
    _max: FollowedCompaniesMaxAggregateOutputType | null
  }

  type GetFollowedCompaniesGroupByPayload<T extends followedCompaniesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FollowedCompaniesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FollowedCompaniesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FollowedCompaniesGroupByOutputType[P]>
            : GetScalarType<T[P], FollowedCompaniesGroupByOutputType[P]>
        }
      >
    >


  export type followedCompaniesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    company_id?: boolean
    followed_at?: boolean
    is_notified?: boolean
    companies?: boolean | companiesDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["followedCompanies"]>

  export type followedCompaniesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    company_id?: boolean
    followed_at?: boolean
    is_notified?: boolean
    companies?: boolean | companiesDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["followedCompanies"]>

  export type followedCompaniesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    company_id?: boolean
    followed_at?: boolean
    is_notified?: boolean
    companies?: boolean | companiesDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["followedCompanies"]>

  export type followedCompaniesSelectScalar = {
    user_id?: boolean
    company_id?: boolean
    followed_at?: boolean
    is_notified?: boolean
  }

  export type followedCompaniesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"user_id" | "company_id" | "followed_at" | "is_notified", ExtArgs["result"]["followedCompanies"]>
  export type followedCompaniesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companies?: boolean | companiesDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type followedCompaniesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companies?: boolean | companiesDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type followedCompaniesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companies?: boolean | companiesDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $followedCompaniesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "followedCompanies"
    objects: {
      companies: Prisma.$companiesPayload<ExtArgs>
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      user_id: string
      company_id: string
      followed_at: Date
      is_notified: boolean
    }, ExtArgs["result"]["followedCompanies"]>
    composites: {}
  }

  type followedCompaniesGetPayload<S extends boolean | null | undefined | followedCompaniesDefaultArgs> = $Result.GetResult<Prisma.$followedCompaniesPayload, S>

  type followedCompaniesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<followedCompaniesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FollowedCompaniesCountAggregateInputType | true
    }

  export interface followedCompaniesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['followedCompanies'], meta: { name: 'followedCompanies' } }
    /**
     * Find zero or one FollowedCompanies that matches the filter.
     * @param {followedCompaniesFindUniqueArgs} args - Arguments to find a FollowedCompanies
     * @example
     * // Get one FollowedCompanies
     * const followedCompanies = await prisma.followedCompanies.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends followedCompaniesFindUniqueArgs>(args: SelectSubset<T, followedCompaniesFindUniqueArgs<ExtArgs>>): Prisma__followedCompaniesClient<$Result.GetResult<Prisma.$followedCompaniesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FollowedCompanies that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {followedCompaniesFindUniqueOrThrowArgs} args - Arguments to find a FollowedCompanies
     * @example
     * // Get one FollowedCompanies
     * const followedCompanies = await prisma.followedCompanies.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends followedCompaniesFindUniqueOrThrowArgs>(args: SelectSubset<T, followedCompaniesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__followedCompaniesClient<$Result.GetResult<Prisma.$followedCompaniesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FollowedCompanies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {followedCompaniesFindFirstArgs} args - Arguments to find a FollowedCompanies
     * @example
     * // Get one FollowedCompanies
     * const followedCompanies = await prisma.followedCompanies.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends followedCompaniesFindFirstArgs>(args?: SelectSubset<T, followedCompaniesFindFirstArgs<ExtArgs>>): Prisma__followedCompaniesClient<$Result.GetResult<Prisma.$followedCompaniesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FollowedCompanies that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {followedCompaniesFindFirstOrThrowArgs} args - Arguments to find a FollowedCompanies
     * @example
     * // Get one FollowedCompanies
     * const followedCompanies = await prisma.followedCompanies.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends followedCompaniesFindFirstOrThrowArgs>(args?: SelectSubset<T, followedCompaniesFindFirstOrThrowArgs<ExtArgs>>): Prisma__followedCompaniesClient<$Result.GetResult<Prisma.$followedCompaniesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FollowedCompanies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {followedCompaniesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FollowedCompanies
     * const followedCompanies = await prisma.followedCompanies.findMany()
     * 
     * // Get first 10 FollowedCompanies
     * const followedCompanies = await prisma.followedCompanies.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const followedCompaniesWithUser_idOnly = await prisma.followedCompanies.findMany({ select: { user_id: true } })
     * 
     */
    findMany<T extends followedCompaniesFindManyArgs>(args?: SelectSubset<T, followedCompaniesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$followedCompaniesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FollowedCompanies.
     * @param {followedCompaniesCreateArgs} args - Arguments to create a FollowedCompanies.
     * @example
     * // Create one FollowedCompanies
     * const FollowedCompanies = await prisma.followedCompanies.create({
     *   data: {
     *     // ... data to create a FollowedCompanies
     *   }
     * })
     * 
     */
    create<T extends followedCompaniesCreateArgs>(args: SelectSubset<T, followedCompaniesCreateArgs<ExtArgs>>): Prisma__followedCompaniesClient<$Result.GetResult<Prisma.$followedCompaniesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FollowedCompanies.
     * @param {followedCompaniesCreateManyArgs} args - Arguments to create many FollowedCompanies.
     * @example
     * // Create many FollowedCompanies
     * const followedCompanies = await prisma.followedCompanies.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends followedCompaniesCreateManyArgs>(args?: SelectSubset<T, followedCompaniesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FollowedCompanies and returns the data saved in the database.
     * @param {followedCompaniesCreateManyAndReturnArgs} args - Arguments to create many FollowedCompanies.
     * @example
     * // Create many FollowedCompanies
     * const followedCompanies = await prisma.followedCompanies.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FollowedCompanies and only return the `user_id`
     * const followedCompaniesWithUser_idOnly = await prisma.followedCompanies.createManyAndReturn({
     *   select: { user_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends followedCompaniesCreateManyAndReturnArgs>(args?: SelectSubset<T, followedCompaniesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$followedCompaniesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FollowedCompanies.
     * @param {followedCompaniesDeleteArgs} args - Arguments to delete one FollowedCompanies.
     * @example
     * // Delete one FollowedCompanies
     * const FollowedCompanies = await prisma.followedCompanies.delete({
     *   where: {
     *     // ... filter to delete one FollowedCompanies
     *   }
     * })
     * 
     */
    delete<T extends followedCompaniesDeleteArgs>(args: SelectSubset<T, followedCompaniesDeleteArgs<ExtArgs>>): Prisma__followedCompaniesClient<$Result.GetResult<Prisma.$followedCompaniesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FollowedCompanies.
     * @param {followedCompaniesUpdateArgs} args - Arguments to update one FollowedCompanies.
     * @example
     * // Update one FollowedCompanies
     * const followedCompanies = await prisma.followedCompanies.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends followedCompaniesUpdateArgs>(args: SelectSubset<T, followedCompaniesUpdateArgs<ExtArgs>>): Prisma__followedCompaniesClient<$Result.GetResult<Prisma.$followedCompaniesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FollowedCompanies.
     * @param {followedCompaniesDeleteManyArgs} args - Arguments to filter FollowedCompanies to delete.
     * @example
     * // Delete a few FollowedCompanies
     * const { count } = await prisma.followedCompanies.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends followedCompaniesDeleteManyArgs>(args?: SelectSubset<T, followedCompaniesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FollowedCompanies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {followedCompaniesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FollowedCompanies
     * const followedCompanies = await prisma.followedCompanies.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends followedCompaniesUpdateManyArgs>(args: SelectSubset<T, followedCompaniesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FollowedCompanies and returns the data updated in the database.
     * @param {followedCompaniesUpdateManyAndReturnArgs} args - Arguments to update many FollowedCompanies.
     * @example
     * // Update many FollowedCompanies
     * const followedCompanies = await prisma.followedCompanies.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FollowedCompanies and only return the `user_id`
     * const followedCompaniesWithUser_idOnly = await prisma.followedCompanies.updateManyAndReturn({
     *   select: { user_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends followedCompaniesUpdateManyAndReturnArgs>(args: SelectSubset<T, followedCompaniesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$followedCompaniesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FollowedCompanies.
     * @param {followedCompaniesUpsertArgs} args - Arguments to update or create a FollowedCompanies.
     * @example
     * // Update or create a FollowedCompanies
     * const followedCompanies = await prisma.followedCompanies.upsert({
     *   create: {
     *     // ... data to create a FollowedCompanies
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FollowedCompanies we want to update
     *   }
     * })
     */
    upsert<T extends followedCompaniesUpsertArgs>(args: SelectSubset<T, followedCompaniesUpsertArgs<ExtArgs>>): Prisma__followedCompaniesClient<$Result.GetResult<Prisma.$followedCompaniesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FollowedCompanies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {followedCompaniesCountArgs} args - Arguments to filter FollowedCompanies to count.
     * @example
     * // Count the number of FollowedCompanies
     * const count = await prisma.followedCompanies.count({
     *   where: {
     *     // ... the filter for the FollowedCompanies we want to count
     *   }
     * })
    **/
    count<T extends followedCompaniesCountArgs>(
      args?: Subset<T, followedCompaniesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FollowedCompaniesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FollowedCompanies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FollowedCompaniesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FollowedCompaniesAggregateArgs>(args: Subset<T, FollowedCompaniesAggregateArgs>): Prisma.PrismaPromise<GetFollowedCompaniesAggregateType<T>>

    /**
     * Group by FollowedCompanies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {followedCompaniesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends followedCompaniesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: followedCompaniesGroupByArgs['orderBy'] }
        : { orderBy?: followedCompaniesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, followedCompaniesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFollowedCompaniesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the followedCompanies model
   */
  readonly fields: followedCompaniesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for followedCompanies.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__followedCompaniesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    companies<T extends companiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, companiesDefaultArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the followedCompanies model
   */
  interface followedCompaniesFieldRefs {
    readonly user_id: FieldRef<"followedCompanies", 'String'>
    readonly company_id: FieldRef<"followedCompanies", 'String'>
    readonly followed_at: FieldRef<"followedCompanies", 'DateTime'>
    readonly is_notified: FieldRef<"followedCompanies", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * followedCompanies findUnique
   */
  export type followedCompaniesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the followedCompanies
     */
    select?: followedCompaniesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the followedCompanies
     */
    omit?: followedCompaniesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: followedCompaniesInclude<ExtArgs> | null
    /**
     * Filter, which followedCompanies to fetch.
     */
    where: followedCompaniesWhereUniqueInput
  }

  /**
   * followedCompanies findUniqueOrThrow
   */
  export type followedCompaniesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the followedCompanies
     */
    select?: followedCompaniesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the followedCompanies
     */
    omit?: followedCompaniesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: followedCompaniesInclude<ExtArgs> | null
    /**
     * Filter, which followedCompanies to fetch.
     */
    where: followedCompaniesWhereUniqueInput
  }

  /**
   * followedCompanies findFirst
   */
  export type followedCompaniesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the followedCompanies
     */
    select?: followedCompaniesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the followedCompanies
     */
    omit?: followedCompaniesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: followedCompaniesInclude<ExtArgs> | null
    /**
     * Filter, which followedCompanies to fetch.
     */
    where?: followedCompaniesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of followedCompanies to fetch.
     */
    orderBy?: followedCompaniesOrderByWithRelationInput | followedCompaniesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for followedCompanies.
     */
    cursor?: followedCompaniesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` followedCompanies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` followedCompanies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of followedCompanies.
     */
    distinct?: FollowedCompaniesScalarFieldEnum | FollowedCompaniesScalarFieldEnum[]
  }

  /**
   * followedCompanies findFirstOrThrow
   */
  export type followedCompaniesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the followedCompanies
     */
    select?: followedCompaniesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the followedCompanies
     */
    omit?: followedCompaniesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: followedCompaniesInclude<ExtArgs> | null
    /**
     * Filter, which followedCompanies to fetch.
     */
    where?: followedCompaniesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of followedCompanies to fetch.
     */
    orderBy?: followedCompaniesOrderByWithRelationInput | followedCompaniesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for followedCompanies.
     */
    cursor?: followedCompaniesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` followedCompanies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` followedCompanies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of followedCompanies.
     */
    distinct?: FollowedCompaniesScalarFieldEnum | FollowedCompaniesScalarFieldEnum[]
  }

  /**
   * followedCompanies findMany
   */
  export type followedCompaniesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the followedCompanies
     */
    select?: followedCompaniesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the followedCompanies
     */
    omit?: followedCompaniesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: followedCompaniesInclude<ExtArgs> | null
    /**
     * Filter, which followedCompanies to fetch.
     */
    where?: followedCompaniesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of followedCompanies to fetch.
     */
    orderBy?: followedCompaniesOrderByWithRelationInput | followedCompaniesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing followedCompanies.
     */
    cursor?: followedCompaniesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` followedCompanies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` followedCompanies.
     */
    skip?: number
    distinct?: FollowedCompaniesScalarFieldEnum | FollowedCompaniesScalarFieldEnum[]
  }

  /**
   * followedCompanies create
   */
  export type followedCompaniesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the followedCompanies
     */
    select?: followedCompaniesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the followedCompanies
     */
    omit?: followedCompaniesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: followedCompaniesInclude<ExtArgs> | null
    /**
     * The data needed to create a followedCompanies.
     */
    data: XOR<followedCompaniesCreateInput, followedCompaniesUncheckedCreateInput>
  }

  /**
   * followedCompanies createMany
   */
  export type followedCompaniesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many followedCompanies.
     */
    data: followedCompaniesCreateManyInput | followedCompaniesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * followedCompanies createManyAndReturn
   */
  export type followedCompaniesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the followedCompanies
     */
    select?: followedCompaniesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the followedCompanies
     */
    omit?: followedCompaniesOmit<ExtArgs> | null
    /**
     * The data used to create many followedCompanies.
     */
    data: followedCompaniesCreateManyInput | followedCompaniesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: followedCompaniesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * followedCompanies update
   */
  export type followedCompaniesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the followedCompanies
     */
    select?: followedCompaniesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the followedCompanies
     */
    omit?: followedCompaniesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: followedCompaniesInclude<ExtArgs> | null
    /**
     * The data needed to update a followedCompanies.
     */
    data: XOR<followedCompaniesUpdateInput, followedCompaniesUncheckedUpdateInput>
    /**
     * Choose, which followedCompanies to update.
     */
    where: followedCompaniesWhereUniqueInput
  }

  /**
   * followedCompanies updateMany
   */
  export type followedCompaniesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update followedCompanies.
     */
    data: XOR<followedCompaniesUpdateManyMutationInput, followedCompaniesUncheckedUpdateManyInput>
    /**
     * Filter which followedCompanies to update
     */
    where?: followedCompaniesWhereInput
    /**
     * Limit how many followedCompanies to update.
     */
    limit?: number
  }

  /**
   * followedCompanies updateManyAndReturn
   */
  export type followedCompaniesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the followedCompanies
     */
    select?: followedCompaniesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the followedCompanies
     */
    omit?: followedCompaniesOmit<ExtArgs> | null
    /**
     * The data used to update followedCompanies.
     */
    data: XOR<followedCompaniesUpdateManyMutationInput, followedCompaniesUncheckedUpdateManyInput>
    /**
     * Filter which followedCompanies to update
     */
    where?: followedCompaniesWhereInput
    /**
     * Limit how many followedCompanies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: followedCompaniesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * followedCompanies upsert
   */
  export type followedCompaniesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the followedCompanies
     */
    select?: followedCompaniesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the followedCompanies
     */
    omit?: followedCompaniesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: followedCompaniesInclude<ExtArgs> | null
    /**
     * The filter to search for the followedCompanies to update in case it exists.
     */
    where: followedCompaniesWhereUniqueInput
    /**
     * In case the followedCompanies found by the `where` argument doesn't exist, create a new followedCompanies with this data.
     */
    create: XOR<followedCompaniesCreateInput, followedCompaniesUncheckedCreateInput>
    /**
     * In case the followedCompanies was found with the provided `where` argument, update it with this data.
     */
    update: XOR<followedCompaniesUpdateInput, followedCompaniesUncheckedUpdateInput>
  }

  /**
   * followedCompanies delete
   */
  export type followedCompaniesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the followedCompanies
     */
    select?: followedCompaniesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the followedCompanies
     */
    omit?: followedCompaniesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: followedCompaniesInclude<ExtArgs> | null
    /**
     * Filter which followedCompanies to delete.
     */
    where: followedCompaniesWhereUniqueInput
  }

  /**
   * followedCompanies deleteMany
   */
  export type followedCompaniesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which followedCompanies to delete
     */
    where?: followedCompaniesWhereInput
    /**
     * Limit how many followedCompanies to delete.
     */
    limit?: number
  }

  /**
   * followedCompanies without action
   */
  export type followedCompaniesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the followedCompanies
     */
    select?: followedCompaniesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the followedCompanies
     */
    omit?: followedCompaniesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: followedCompaniesInclude<ExtArgs> | null
  }


  /**
   * Model jobCategories
   */

  export type AggregateJobCategories = {
    _count: JobCategoriesCountAggregateOutputType | null
    _avg: JobCategoriesAvgAggregateOutputType | null
    _sum: JobCategoriesSumAggregateOutputType | null
    _min: JobCategoriesMinAggregateOutputType | null
    _max: JobCategoriesMaxAggregateOutputType | null
  }

  export type JobCategoriesAvgAggregateOutputType = {
    id: number | null
  }

  export type JobCategoriesSumAggregateOutputType = {
    id: number | null
  }

  export type JobCategoriesMinAggregateOutputType = {
    id: number | null
    job_category: string | null
    description: string | null
  }

  export type JobCategoriesMaxAggregateOutputType = {
    id: number | null
    job_category: string | null
    description: string | null
  }

  export type JobCategoriesCountAggregateOutputType = {
    id: number
    job_category: number
    description: number
    _all: number
  }


  export type JobCategoriesAvgAggregateInputType = {
    id?: true
  }

  export type JobCategoriesSumAggregateInputType = {
    id?: true
  }

  export type JobCategoriesMinAggregateInputType = {
    id?: true
    job_category?: true
    description?: true
  }

  export type JobCategoriesMaxAggregateInputType = {
    id?: true
    job_category?: true
    description?: true
  }

  export type JobCategoriesCountAggregateInputType = {
    id?: true
    job_category?: true
    description?: true
    _all?: true
  }

  export type JobCategoriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which jobCategories to aggregate.
     */
    where?: jobCategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jobCategories to fetch.
     */
    orderBy?: jobCategoriesOrderByWithRelationInput | jobCategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: jobCategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jobCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jobCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned jobCategories
    **/
    _count?: true | JobCategoriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobCategoriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobCategoriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobCategoriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobCategoriesMaxAggregateInputType
  }

  export type GetJobCategoriesAggregateType<T extends JobCategoriesAggregateArgs> = {
        [P in keyof T & keyof AggregateJobCategories]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobCategories[P]>
      : GetScalarType<T[P], AggregateJobCategories[P]>
  }




  export type jobCategoriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: jobCategoriesWhereInput
    orderBy?: jobCategoriesOrderByWithAggregationInput | jobCategoriesOrderByWithAggregationInput[]
    by: JobCategoriesScalarFieldEnum[] | JobCategoriesScalarFieldEnum
    having?: jobCategoriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobCategoriesCountAggregateInputType | true
    _avg?: JobCategoriesAvgAggregateInputType
    _sum?: JobCategoriesSumAggregateInputType
    _min?: JobCategoriesMinAggregateInputType
    _max?: JobCategoriesMaxAggregateInputType
  }

  export type JobCategoriesGroupByOutputType = {
    id: number
    job_category: string
    description: string | null
    _count: JobCategoriesCountAggregateOutputType | null
    _avg: JobCategoriesAvgAggregateOutputType | null
    _sum: JobCategoriesSumAggregateOutputType | null
    _min: JobCategoriesMinAggregateOutputType | null
    _max: JobCategoriesMaxAggregateOutputType | null
  }

  type GetJobCategoriesGroupByPayload<T extends jobCategoriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobCategoriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobCategoriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobCategoriesGroupByOutputType[P]>
            : GetScalarType<T[P], JobCategoriesGroupByOutputType[P]>
        }
      >
    >


  export type jobCategoriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    job_category?: boolean
    description?: boolean
    jobSpecialized?: boolean | jobCategories$jobSpecializedArgs<ExtArgs>
    _count?: boolean | JobCategoriesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobCategories"]>

  export type jobCategoriesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    job_category?: boolean
    description?: boolean
  }, ExtArgs["result"]["jobCategories"]>

  export type jobCategoriesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    job_category?: boolean
    description?: boolean
  }, ExtArgs["result"]["jobCategories"]>

  export type jobCategoriesSelectScalar = {
    id?: boolean
    job_category?: boolean
    description?: boolean
  }

  export type jobCategoriesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "job_category" | "description", ExtArgs["result"]["jobCategories"]>
  export type jobCategoriesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobSpecialized?: boolean | jobCategories$jobSpecializedArgs<ExtArgs>
    _count?: boolean | JobCategoriesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type jobCategoriesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type jobCategoriesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $jobCategoriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "jobCategories"
    objects: {
      jobSpecialized: Prisma.$jobSpecializedPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      job_category: string
      description: string | null
    }, ExtArgs["result"]["jobCategories"]>
    composites: {}
  }

  type jobCategoriesGetPayload<S extends boolean | null | undefined | jobCategoriesDefaultArgs> = $Result.GetResult<Prisma.$jobCategoriesPayload, S>

  type jobCategoriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<jobCategoriesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JobCategoriesCountAggregateInputType | true
    }

  export interface jobCategoriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['jobCategories'], meta: { name: 'jobCategories' } }
    /**
     * Find zero or one JobCategories that matches the filter.
     * @param {jobCategoriesFindUniqueArgs} args - Arguments to find a JobCategories
     * @example
     * // Get one JobCategories
     * const jobCategories = await prisma.jobCategories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends jobCategoriesFindUniqueArgs>(args: SelectSubset<T, jobCategoriesFindUniqueArgs<ExtArgs>>): Prisma__jobCategoriesClient<$Result.GetResult<Prisma.$jobCategoriesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one JobCategories that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {jobCategoriesFindUniqueOrThrowArgs} args - Arguments to find a JobCategories
     * @example
     * // Get one JobCategories
     * const jobCategories = await prisma.jobCategories.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends jobCategoriesFindUniqueOrThrowArgs>(args: SelectSubset<T, jobCategoriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__jobCategoriesClient<$Result.GetResult<Prisma.$jobCategoriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobCategoriesFindFirstArgs} args - Arguments to find a JobCategories
     * @example
     * // Get one JobCategories
     * const jobCategories = await prisma.jobCategories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends jobCategoriesFindFirstArgs>(args?: SelectSubset<T, jobCategoriesFindFirstArgs<ExtArgs>>): Prisma__jobCategoriesClient<$Result.GetResult<Prisma.$jobCategoriesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobCategories that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobCategoriesFindFirstOrThrowArgs} args - Arguments to find a JobCategories
     * @example
     * // Get one JobCategories
     * const jobCategories = await prisma.jobCategories.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends jobCategoriesFindFirstOrThrowArgs>(args?: SelectSubset<T, jobCategoriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__jobCategoriesClient<$Result.GetResult<Prisma.$jobCategoriesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more JobCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobCategoriesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JobCategories
     * const jobCategories = await prisma.jobCategories.findMany()
     * 
     * // Get first 10 JobCategories
     * const jobCategories = await prisma.jobCategories.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobCategoriesWithIdOnly = await prisma.jobCategories.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends jobCategoriesFindManyArgs>(args?: SelectSubset<T, jobCategoriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$jobCategoriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a JobCategories.
     * @param {jobCategoriesCreateArgs} args - Arguments to create a JobCategories.
     * @example
     * // Create one JobCategories
     * const JobCategories = await prisma.jobCategories.create({
     *   data: {
     *     // ... data to create a JobCategories
     *   }
     * })
     * 
     */
    create<T extends jobCategoriesCreateArgs>(args: SelectSubset<T, jobCategoriesCreateArgs<ExtArgs>>): Prisma__jobCategoriesClient<$Result.GetResult<Prisma.$jobCategoriesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many JobCategories.
     * @param {jobCategoriesCreateManyArgs} args - Arguments to create many JobCategories.
     * @example
     * // Create many JobCategories
     * const jobCategories = await prisma.jobCategories.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends jobCategoriesCreateManyArgs>(args?: SelectSubset<T, jobCategoriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JobCategories and returns the data saved in the database.
     * @param {jobCategoriesCreateManyAndReturnArgs} args - Arguments to create many JobCategories.
     * @example
     * // Create many JobCategories
     * const jobCategories = await prisma.jobCategories.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JobCategories and only return the `id`
     * const jobCategoriesWithIdOnly = await prisma.jobCategories.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends jobCategoriesCreateManyAndReturnArgs>(args?: SelectSubset<T, jobCategoriesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$jobCategoriesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a JobCategories.
     * @param {jobCategoriesDeleteArgs} args - Arguments to delete one JobCategories.
     * @example
     * // Delete one JobCategories
     * const JobCategories = await prisma.jobCategories.delete({
     *   where: {
     *     // ... filter to delete one JobCategories
     *   }
     * })
     * 
     */
    delete<T extends jobCategoriesDeleteArgs>(args: SelectSubset<T, jobCategoriesDeleteArgs<ExtArgs>>): Prisma__jobCategoriesClient<$Result.GetResult<Prisma.$jobCategoriesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one JobCategories.
     * @param {jobCategoriesUpdateArgs} args - Arguments to update one JobCategories.
     * @example
     * // Update one JobCategories
     * const jobCategories = await prisma.jobCategories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends jobCategoriesUpdateArgs>(args: SelectSubset<T, jobCategoriesUpdateArgs<ExtArgs>>): Prisma__jobCategoriesClient<$Result.GetResult<Prisma.$jobCategoriesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more JobCategories.
     * @param {jobCategoriesDeleteManyArgs} args - Arguments to filter JobCategories to delete.
     * @example
     * // Delete a few JobCategories
     * const { count } = await prisma.jobCategories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends jobCategoriesDeleteManyArgs>(args?: SelectSubset<T, jobCategoriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobCategoriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JobCategories
     * const jobCategories = await prisma.jobCategories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends jobCategoriesUpdateManyArgs>(args: SelectSubset<T, jobCategoriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobCategories and returns the data updated in the database.
     * @param {jobCategoriesUpdateManyAndReturnArgs} args - Arguments to update many JobCategories.
     * @example
     * // Update many JobCategories
     * const jobCategories = await prisma.jobCategories.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more JobCategories and only return the `id`
     * const jobCategoriesWithIdOnly = await prisma.jobCategories.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends jobCategoriesUpdateManyAndReturnArgs>(args: SelectSubset<T, jobCategoriesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$jobCategoriesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one JobCategories.
     * @param {jobCategoriesUpsertArgs} args - Arguments to update or create a JobCategories.
     * @example
     * // Update or create a JobCategories
     * const jobCategories = await prisma.jobCategories.upsert({
     *   create: {
     *     // ... data to create a JobCategories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JobCategories we want to update
     *   }
     * })
     */
    upsert<T extends jobCategoriesUpsertArgs>(args: SelectSubset<T, jobCategoriesUpsertArgs<ExtArgs>>): Prisma__jobCategoriesClient<$Result.GetResult<Prisma.$jobCategoriesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of JobCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobCategoriesCountArgs} args - Arguments to filter JobCategories to count.
     * @example
     * // Count the number of JobCategories
     * const count = await prisma.jobCategories.count({
     *   where: {
     *     // ... the filter for the JobCategories we want to count
     *   }
     * })
    **/
    count<T extends jobCategoriesCountArgs>(
      args?: Subset<T, jobCategoriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobCategoriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JobCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobCategoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobCategoriesAggregateArgs>(args: Subset<T, JobCategoriesAggregateArgs>): Prisma.PrismaPromise<GetJobCategoriesAggregateType<T>>

    /**
     * Group by JobCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobCategoriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends jobCategoriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: jobCategoriesGroupByArgs['orderBy'] }
        : { orderBy?: jobCategoriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, jobCategoriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobCategoriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the jobCategories model
   */
  readonly fields: jobCategoriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for jobCategories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__jobCategoriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    jobSpecialized<T extends jobCategories$jobSpecializedArgs<ExtArgs> = {}>(args?: Subset<T, jobCategories$jobSpecializedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$jobSpecializedPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the jobCategories model
   */
  interface jobCategoriesFieldRefs {
    readonly id: FieldRef<"jobCategories", 'Int'>
    readonly job_category: FieldRef<"jobCategories", 'String'>
    readonly description: FieldRef<"jobCategories", 'String'>
  }
    

  // Custom InputTypes
  /**
   * jobCategories findUnique
   */
  export type jobCategoriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobCategories
     */
    select?: jobCategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobCategories
     */
    omit?: jobCategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobCategoriesInclude<ExtArgs> | null
    /**
     * Filter, which jobCategories to fetch.
     */
    where: jobCategoriesWhereUniqueInput
  }

  /**
   * jobCategories findUniqueOrThrow
   */
  export type jobCategoriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobCategories
     */
    select?: jobCategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobCategories
     */
    omit?: jobCategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobCategoriesInclude<ExtArgs> | null
    /**
     * Filter, which jobCategories to fetch.
     */
    where: jobCategoriesWhereUniqueInput
  }

  /**
   * jobCategories findFirst
   */
  export type jobCategoriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobCategories
     */
    select?: jobCategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobCategories
     */
    omit?: jobCategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobCategoriesInclude<ExtArgs> | null
    /**
     * Filter, which jobCategories to fetch.
     */
    where?: jobCategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jobCategories to fetch.
     */
    orderBy?: jobCategoriesOrderByWithRelationInput | jobCategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for jobCategories.
     */
    cursor?: jobCategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jobCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jobCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of jobCategories.
     */
    distinct?: JobCategoriesScalarFieldEnum | JobCategoriesScalarFieldEnum[]
  }

  /**
   * jobCategories findFirstOrThrow
   */
  export type jobCategoriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobCategories
     */
    select?: jobCategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobCategories
     */
    omit?: jobCategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobCategoriesInclude<ExtArgs> | null
    /**
     * Filter, which jobCategories to fetch.
     */
    where?: jobCategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jobCategories to fetch.
     */
    orderBy?: jobCategoriesOrderByWithRelationInput | jobCategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for jobCategories.
     */
    cursor?: jobCategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jobCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jobCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of jobCategories.
     */
    distinct?: JobCategoriesScalarFieldEnum | JobCategoriesScalarFieldEnum[]
  }

  /**
   * jobCategories findMany
   */
  export type jobCategoriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobCategories
     */
    select?: jobCategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobCategories
     */
    omit?: jobCategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobCategoriesInclude<ExtArgs> | null
    /**
     * Filter, which jobCategories to fetch.
     */
    where?: jobCategoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jobCategories to fetch.
     */
    orderBy?: jobCategoriesOrderByWithRelationInput | jobCategoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing jobCategories.
     */
    cursor?: jobCategoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jobCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jobCategories.
     */
    skip?: number
    distinct?: JobCategoriesScalarFieldEnum | JobCategoriesScalarFieldEnum[]
  }

  /**
   * jobCategories create
   */
  export type jobCategoriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobCategories
     */
    select?: jobCategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobCategories
     */
    omit?: jobCategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobCategoriesInclude<ExtArgs> | null
    /**
     * The data needed to create a jobCategories.
     */
    data: XOR<jobCategoriesCreateInput, jobCategoriesUncheckedCreateInput>
  }

  /**
   * jobCategories createMany
   */
  export type jobCategoriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many jobCategories.
     */
    data: jobCategoriesCreateManyInput | jobCategoriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * jobCategories createManyAndReturn
   */
  export type jobCategoriesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobCategories
     */
    select?: jobCategoriesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the jobCategories
     */
    omit?: jobCategoriesOmit<ExtArgs> | null
    /**
     * The data used to create many jobCategories.
     */
    data: jobCategoriesCreateManyInput | jobCategoriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * jobCategories update
   */
  export type jobCategoriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobCategories
     */
    select?: jobCategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobCategories
     */
    omit?: jobCategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobCategoriesInclude<ExtArgs> | null
    /**
     * The data needed to update a jobCategories.
     */
    data: XOR<jobCategoriesUpdateInput, jobCategoriesUncheckedUpdateInput>
    /**
     * Choose, which jobCategories to update.
     */
    where: jobCategoriesWhereUniqueInput
  }

  /**
   * jobCategories updateMany
   */
  export type jobCategoriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update jobCategories.
     */
    data: XOR<jobCategoriesUpdateManyMutationInput, jobCategoriesUncheckedUpdateManyInput>
    /**
     * Filter which jobCategories to update
     */
    where?: jobCategoriesWhereInput
    /**
     * Limit how many jobCategories to update.
     */
    limit?: number
  }

  /**
   * jobCategories updateManyAndReturn
   */
  export type jobCategoriesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobCategories
     */
    select?: jobCategoriesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the jobCategories
     */
    omit?: jobCategoriesOmit<ExtArgs> | null
    /**
     * The data used to update jobCategories.
     */
    data: XOR<jobCategoriesUpdateManyMutationInput, jobCategoriesUncheckedUpdateManyInput>
    /**
     * Filter which jobCategories to update
     */
    where?: jobCategoriesWhereInput
    /**
     * Limit how many jobCategories to update.
     */
    limit?: number
  }

  /**
   * jobCategories upsert
   */
  export type jobCategoriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobCategories
     */
    select?: jobCategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobCategories
     */
    omit?: jobCategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobCategoriesInclude<ExtArgs> | null
    /**
     * The filter to search for the jobCategories to update in case it exists.
     */
    where: jobCategoriesWhereUniqueInput
    /**
     * In case the jobCategories found by the `where` argument doesn't exist, create a new jobCategories with this data.
     */
    create: XOR<jobCategoriesCreateInput, jobCategoriesUncheckedCreateInput>
    /**
     * In case the jobCategories was found with the provided `where` argument, update it with this data.
     */
    update: XOR<jobCategoriesUpdateInput, jobCategoriesUncheckedUpdateInput>
  }

  /**
   * jobCategories delete
   */
  export type jobCategoriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobCategories
     */
    select?: jobCategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobCategories
     */
    omit?: jobCategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobCategoriesInclude<ExtArgs> | null
    /**
     * Filter which jobCategories to delete.
     */
    where: jobCategoriesWhereUniqueInput
  }

  /**
   * jobCategories deleteMany
   */
  export type jobCategoriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which jobCategories to delete
     */
    where?: jobCategoriesWhereInput
    /**
     * Limit how many jobCategories to delete.
     */
    limit?: number
  }

  /**
   * jobCategories.jobSpecialized
   */
  export type jobCategories$jobSpecializedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobSpecialized
     */
    select?: jobSpecializedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobSpecialized
     */
    omit?: jobSpecializedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobSpecializedInclude<ExtArgs> | null
    where?: jobSpecializedWhereInput
    orderBy?: jobSpecializedOrderByWithRelationInput | jobSpecializedOrderByWithRelationInput[]
    cursor?: jobSpecializedWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobSpecializedScalarFieldEnum | JobSpecializedScalarFieldEnum[]
  }

  /**
   * jobCategories without action
   */
  export type jobCategoriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobCategories
     */
    select?: jobCategoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobCategories
     */
    omit?: jobCategoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobCategoriesInclude<ExtArgs> | null
  }


  /**
   * Model jobLabels
   */

  export type AggregateJobLabels = {
    _count: JobLabelsCountAggregateOutputType | null
    _avg: JobLabelsAvgAggregateOutputType | null
    _sum: JobLabelsSumAggregateOutputType | null
    _min: JobLabelsMinAggregateOutputType | null
    _max: JobLabelsMaxAggregateOutputType | null
  }

  export type JobLabelsAvgAggregateOutputType = {
    id: number | null
  }

  export type JobLabelsSumAggregateOutputType = {
    id: number | null
  }

  export type JobLabelsMinAggregateOutputType = {
    id: number | null
    label_name: string | null
  }

  export type JobLabelsMaxAggregateOutputType = {
    id: number | null
    label_name: string | null
  }

  export type JobLabelsCountAggregateOutputType = {
    id: number
    label_name: number
    _all: number
  }


  export type JobLabelsAvgAggregateInputType = {
    id?: true
  }

  export type JobLabelsSumAggregateInputType = {
    id?: true
  }

  export type JobLabelsMinAggregateInputType = {
    id?: true
    label_name?: true
  }

  export type JobLabelsMaxAggregateInputType = {
    id?: true
    label_name?: true
  }

  export type JobLabelsCountAggregateInputType = {
    id?: true
    label_name?: true
    _all?: true
  }

  export type JobLabelsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which jobLabels to aggregate.
     */
    where?: jobLabelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jobLabels to fetch.
     */
    orderBy?: jobLabelsOrderByWithRelationInput | jobLabelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: jobLabelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jobLabels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jobLabels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned jobLabels
    **/
    _count?: true | JobLabelsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobLabelsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobLabelsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobLabelsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobLabelsMaxAggregateInputType
  }

  export type GetJobLabelsAggregateType<T extends JobLabelsAggregateArgs> = {
        [P in keyof T & keyof AggregateJobLabels]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobLabels[P]>
      : GetScalarType<T[P], AggregateJobLabels[P]>
  }




  export type jobLabelsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: jobLabelsWhereInput
    orderBy?: jobLabelsOrderByWithAggregationInput | jobLabelsOrderByWithAggregationInput[]
    by: JobLabelsScalarFieldEnum[] | JobLabelsScalarFieldEnum
    having?: jobLabelsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobLabelsCountAggregateInputType | true
    _avg?: JobLabelsAvgAggregateInputType
    _sum?: JobLabelsSumAggregateInputType
    _min?: JobLabelsMinAggregateInputType
    _max?: JobLabelsMaxAggregateInputType
  }

  export type JobLabelsGroupByOutputType = {
    id: number
    label_name: string
    _count: JobLabelsCountAggregateOutputType | null
    _avg: JobLabelsAvgAggregateOutputType | null
    _sum: JobLabelsSumAggregateOutputType | null
    _min: JobLabelsMinAggregateOutputType | null
    _max: JobLabelsMaxAggregateOutputType | null
  }

  type GetJobLabelsGroupByPayload<T extends jobLabelsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobLabelsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobLabelsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobLabelsGroupByOutputType[P]>
            : GetScalarType<T[P], JobLabelsGroupByOutputType[P]>
        }
      >
    >


  export type jobLabelsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label_name?: boolean
    jobs?: boolean | jobLabels$jobsArgs<ExtArgs>
    _count?: boolean | JobLabelsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobLabels"]>

  export type jobLabelsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label_name?: boolean
  }, ExtArgs["result"]["jobLabels"]>

  export type jobLabelsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label_name?: boolean
  }, ExtArgs["result"]["jobLabels"]>

  export type jobLabelsSelectScalar = {
    id?: boolean
    label_name?: boolean
  }

  export type jobLabelsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "label_name", ExtArgs["result"]["jobLabels"]>
  export type jobLabelsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobs?: boolean | jobLabels$jobsArgs<ExtArgs>
    _count?: boolean | JobLabelsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type jobLabelsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type jobLabelsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $jobLabelsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "jobLabels"
    objects: {
      jobs: Prisma.$jobsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      label_name: string
    }, ExtArgs["result"]["jobLabels"]>
    composites: {}
  }

  type jobLabelsGetPayload<S extends boolean | null | undefined | jobLabelsDefaultArgs> = $Result.GetResult<Prisma.$jobLabelsPayload, S>

  type jobLabelsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<jobLabelsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JobLabelsCountAggregateInputType | true
    }

  export interface jobLabelsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['jobLabels'], meta: { name: 'jobLabels' } }
    /**
     * Find zero or one JobLabels that matches the filter.
     * @param {jobLabelsFindUniqueArgs} args - Arguments to find a JobLabels
     * @example
     * // Get one JobLabels
     * const jobLabels = await prisma.jobLabels.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends jobLabelsFindUniqueArgs>(args: SelectSubset<T, jobLabelsFindUniqueArgs<ExtArgs>>): Prisma__jobLabelsClient<$Result.GetResult<Prisma.$jobLabelsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one JobLabels that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {jobLabelsFindUniqueOrThrowArgs} args - Arguments to find a JobLabels
     * @example
     * // Get one JobLabels
     * const jobLabels = await prisma.jobLabels.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends jobLabelsFindUniqueOrThrowArgs>(args: SelectSubset<T, jobLabelsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__jobLabelsClient<$Result.GetResult<Prisma.$jobLabelsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobLabels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobLabelsFindFirstArgs} args - Arguments to find a JobLabels
     * @example
     * // Get one JobLabels
     * const jobLabels = await prisma.jobLabels.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends jobLabelsFindFirstArgs>(args?: SelectSubset<T, jobLabelsFindFirstArgs<ExtArgs>>): Prisma__jobLabelsClient<$Result.GetResult<Prisma.$jobLabelsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobLabels that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobLabelsFindFirstOrThrowArgs} args - Arguments to find a JobLabels
     * @example
     * // Get one JobLabels
     * const jobLabels = await prisma.jobLabels.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends jobLabelsFindFirstOrThrowArgs>(args?: SelectSubset<T, jobLabelsFindFirstOrThrowArgs<ExtArgs>>): Prisma__jobLabelsClient<$Result.GetResult<Prisma.$jobLabelsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more JobLabels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobLabelsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JobLabels
     * const jobLabels = await prisma.jobLabels.findMany()
     * 
     * // Get first 10 JobLabels
     * const jobLabels = await prisma.jobLabels.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobLabelsWithIdOnly = await prisma.jobLabels.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends jobLabelsFindManyArgs>(args?: SelectSubset<T, jobLabelsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$jobLabelsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a JobLabels.
     * @param {jobLabelsCreateArgs} args - Arguments to create a JobLabels.
     * @example
     * // Create one JobLabels
     * const JobLabels = await prisma.jobLabels.create({
     *   data: {
     *     // ... data to create a JobLabels
     *   }
     * })
     * 
     */
    create<T extends jobLabelsCreateArgs>(args: SelectSubset<T, jobLabelsCreateArgs<ExtArgs>>): Prisma__jobLabelsClient<$Result.GetResult<Prisma.$jobLabelsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many JobLabels.
     * @param {jobLabelsCreateManyArgs} args - Arguments to create many JobLabels.
     * @example
     * // Create many JobLabels
     * const jobLabels = await prisma.jobLabels.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends jobLabelsCreateManyArgs>(args?: SelectSubset<T, jobLabelsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JobLabels and returns the data saved in the database.
     * @param {jobLabelsCreateManyAndReturnArgs} args - Arguments to create many JobLabels.
     * @example
     * // Create many JobLabels
     * const jobLabels = await prisma.jobLabels.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JobLabels and only return the `id`
     * const jobLabelsWithIdOnly = await prisma.jobLabels.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends jobLabelsCreateManyAndReturnArgs>(args?: SelectSubset<T, jobLabelsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$jobLabelsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a JobLabels.
     * @param {jobLabelsDeleteArgs} args - Arguments to delete one JobLabels.
     * @example
     * // Delete one JobLabels
     * const JobLabels = await prisma.jobLabels.delete({
     *   where: {
     *     // ... filter to delete one JobLabels
     *   }
     * })
     * 
     */
    delete<T extends jobLabelsDeleteArgs>(args: SelectSubset<T, jobLabelsDeleteArgs<ExtArgs>>): Prisma__jobLabelsClient<$Result.GetResult<Prisma.$jobLabelsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one JobLabels.
     * @param {jobLabelsUpdateArgs} args - Arguments to update one JobLabels.
     * @example
     * // Update one JobLabels
     * const jobLabels = await prisma.jobLabels.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends jobLabelsUpdateArgs>(args: SelectSubset<T, jobLabelsUpdateArgs<ExtArgs>>): Prisma__jobLabelsClient<$Result.GetResult<Prisma.$jobLabelsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more JobLabels.
     * @param {jobLabelsDeleteManyArgs} args - Arguments to filter JobLabels to delete.
     * @example
     * // Delete a few JobLabels
     * const { count } = await prisma.jobLabels.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends jobLabelsDeleteManyArgs>(args?: SelectSubset<T, jobLabelsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobLabels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobLabelsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JobLabels
     * const jobLabels = await prisma.jobLabels.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends jobLabelsUpdateManyArgs>(args: SelectSubset<T, jobLabelsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobLabels and returns the data updated in the database.
     * @param {jobLabelsUpdateManyAndReturnArgs} args - Arguments to update many JobLabels.
     * @example
     * // Update many JobLabels
     * const jobLabels = await prisma.jobLabels.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more JobLabels and only return the `id`
     * const jobLabelsWithIdOnly = await prisma.jobLabels.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends jobLabelsUpdateManyAndReturnArgs>(args: SelectSubset<T, jobLabelsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$jobLabelsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one JobLabels.
     * @param {jobLabelsUpsertArgs} args - Arguments to update or create a JobLabels.
     * @example
     * // Update or create a JobLabels
     * const jobLabels = await prisma.jobLabels.upsert({
     *   create: {
     *     // ... data to create a JobLabels
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JobLabels we want to update
     *   }
     * })
     */
    upsert<T extends jobLabelsUpsertArgs>(args: SelectSubset<T, jobLabelsUpsertArgs<ExtArgs>>): Prisma__jobLabelsClient<$Result.GetResult<Prisma.$jobLabelsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of JobLabels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobLabelsCountArgs} args - Arguments to filter JobLabels to count.
     * @example
     * // Count the number of JobLabels
     * const count = await prisma.jobLabels.count({
     *   where: {
     *     // ... the filter for the JobLabels we want to count
     *   }
     * })
    **/
    count<T extends jobLabelsCountArgs>(
      args?: Subset<T, jobLabelsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobLabelsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JobLabels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobLabelsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobLabelsAggregateArgs>(args: Subset<T, JobLabelsAggregateArgs>): Prisma.PrismaPromise<GetJobLabelsAggregateType<T>>

    /**
     * Group by JobLabels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobLabelsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends jobLabelsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: jobLabelsGroupByArgs['orderBy'] }
        : { orderBy?: jobLabelsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, jobLabelsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobLabelsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the jobLabels model
   */
  readonly fields: jobLabelsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for jobLabels.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__jobLabelsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    jobs<T extends jobLabels$jobsArgs<ExtArgs> = {}>(args?: Subset<T, jobLabels$jobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$jobsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the jobLabels model
   */
  interface jobLabelsFieldRefs {
    readonly id: FieldRef<"jobLabels", 'Int'>
    readonly label_name: FieldRef<"jobLabels", 'String'>
  }
    

  // Custom InputTypes
  /**
   * jobLabels findUnique
   */
  export type jobLabelsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobLabels
     */
    select?: jobLabelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobLabels
     */
    omit?: jobLabelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobLabelsInclude<ExtArgs> | null
    /**
     * Filter, which jobLabels to fetch.
     */
    where: jobLabelsWhereUniqueInput
  }

  /**
   * jobLabels findUniqueOrThrow
   */
  export type jobLabelsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobLabels
     */
    select?: jobLabelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobLabels
     */
    omit?: jobLabelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobLabelsInclude<ExtArgs> | null
    /**
     * Filter, which jobLabels to fetch.
     */
    where: jobLabelsWhereUniqueInput
  }

  /**
   * jobLabels findFirst
   */
  export type jobLabelsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobLabels
     */
    select?: jobLabelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobLabels
     */
    omit?: jobLabelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobLabelsInclude<ExtArgs> | null
    /**
     * Filter, which jobLabels to fetch.
     */
    where?: jobLabelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jobLabels to fetch.
     */
    orderBy?: jobLabelsOrderByWithRelationInput | jobLabelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for jobLabels.
     */
    cursor?: jobLabelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jobLabels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jobLabels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of jobLabels.
     */
    distinct?: JobLabelsScalarFieldEnum | JobLabelsScalarFieldEnum[]
  }

  /**
   * jobLabels findFirstOrThrow
   */
  export type jobLabelsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobLabels
     */
    select?: jobLabelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobLabels
     */
    omit?: jobLabelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobLabelsInclude<ExtArgs> | null
    /**
     * Filter, which jobLabels to fetch.
     */
    where?: jobLabelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jobLabels to fetch.
     */
    orderBy?: jobLabelsOrderByWithRelationInput | jobLabelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for jobLabels.
     */
    cursor?: jobLabelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jobLabels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jobLabels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of jobLabels.
     */
    distinct?: JobLabelsScalarFieldEnum | JobLabelsScalarFieldEnum[]
  }

  /**
   * jobLabels findMany
   */
  export type jobLabelsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobLabels
     */
    select?: jobLabelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobLabels
     */
    omit?: jobLabelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobLabelsInclude<ExtArgs> | null
    /**
     * Filter, which jobLabels to fetch.
     */
    where?: jobLabelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jobLabels to fetch.
     */
    orderBy?: jobLabelsOrderByWithRelationInput | jobLabelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing jobLabels.
     */
    cursor?: jobLabelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jobLabels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jobLabels.
     */
    skip?: number
    distinct?: JobLabelsScalarFieldEnum | JobLabelsScalarFieldEnum[]
  }

  /**
   * jobLabels create
   */
  export type jobLabelsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobLabels
     */
    select?: jobLabelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobLabels
     */
    omit?: jobLabelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobLabelsInclude<ExtArgs> | null
    /**
     * The data needed to create a jobLabels.
     */
    data: XOR<jobLabelsCreateInput, jobLabelsUncheckedCreateInput>
  }

  /**
   * jobLabels createMany
   */
  export type jobLabelsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many jobLabels.
     */
    data: jobLabelsCreateManyInput | jobLabelsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * jobLabels createManyAndReturn
   */
  export type jobLabelsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobLabels
     */
    select?: jobLabelsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the jobLabels
     */
    omit?: jobLabelsOmit<ExtArgs> | null
    /**
     * The data used to create many jobLabels.
     */
    data: jobLabelsCreateManyInput | jobLabelsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * jobLabels update
   */
  export type jobLabelsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobLabels
     */
    select?: jobLabelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobLabels
     */
    omit?: jobLabelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobLabelsInclude<ExtArgs> | null
    /**
     * The data needed to update a jobLabels.
     */
    data: XOR<jobLabelsUpdateInput, jobLabelsUncheckedUpdateInput>
    /**
     * Choose, which jobLabels to update.
     */
    where: jobLabelsWhereUniqueInput
  }

  /**
   * jobLabels updateMany
   */
  export type jobLabelsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update jobLabels.
     */
    data: XOR<jobLabelsUpdateManyMutationInput, jobLabelsUncheckedUpdateManyInput>
    /**
     * Filter which jobLabels to update
     */
    where?: jobLabelsWhereInput
    /**
     * Limit how many jobLabels to update.
     */
    limit?: number
  }

  /**
   * jobLabels updateManyAndReturn
   */
  export type jobLabelsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobLabels
     */
    select?: jobLabelsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the jobLabels
     */
    omit?: jobLabelsOmit<ExtArgs> | null
    /**
     * The data used to update jobLabels.
     */
    data: XOR<jobLabelsUpdateManyMutationInput, jobLabelsUncheckedUpdateManyInput>
    /**
     * Filter which jobLabels to update
     */
    where?: jobLabelsWhereInput
    /**
     * Limit how many jobLabels to update.
     */
    limit?: number
  }

  /**
   * jobLabels upsert
   */
  export type jobLabelsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobLabels
     */
    select?: jobLabelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobLabels
     */
    omit?: jobLabelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobLabelsInclude<ExtArgs> | null
    /**
     * The filter to search for the jobLabels to update in case it exists.
     */
    where: jobLabelsWhereUniqueInput
    /**
     * In case the jobLabels found by the `where` argument doesn't exist, create a new jobLabels with this data.
     */
    create: XOR<jobLabelsCreateInput, jobLabelsUncheckedCreateInput>
    /**
     * In case the jobLabels was found with the provided `where` argument, update it with this data.
     */
    update: XOR<jobLabelsUpdateInput, jobLabelsUncheckedUpdateInput>
  }

  /**
   * jobLabels delete
   */
  export type jobLabelsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobLabels
     */
    select?: jobLabelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobLabels
     */
    omit?: jobLabelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobLabelsInclude<ExtArgs> | null
    /**
     * Filter which jobLabels to delete.
     */
    where: jobLabelsWhereUniqueInput
  }

  /**
   * jobLabels deleteMany
   */
  export type jobLabelsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which jobLabels to delete
     */
    where?: jobLabelsWhereInput
    /**
     * Limit how many jobLabels to delete.
     */
    limit?: number
  }

  /**
   * jobLabels.jobs
   */
  export type jobLabels$jobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobs
     */
    select?: jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobs
     */
    omit?: jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobsInclude<ExtArgs> | null
    where?: jobsWhereInput
    orderBy?: jobsOrderByWithRelationInput | jobsOrderByWithRelationInput[]
    cursor?: jobsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JobsScalarFieldEnum | JobsScalarFieldEnum[]
  }

  /**
   * jobLabels without action
   */
  export type jobLabelsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobLabels
     */
    select?: jobLabelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobLabels
     */
    omit?: jobLabelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobLabelsInclude<ExtArgs> | null
  }


  /**
   * Model jobSpecialized
   */

  export type AggregateJobSpecialized = {
    _count: JobSpecializedCountAggregateOutputType | null
    _avg: JobSpecializedAvgAggregateOutputType | null
    _sum: JobSpecializedSumAggregateOutputType | null
    _min: JobSpecializedMinAggregateOutputType | null
    _max: JobSpecializedMaxAggregateOutputType | null
  }

  export type JobSpecializedAvgAggregateOutputType = {
    id: number | null
    jobcategory_id: number | null
  }

  export type JobSpecializedSumAggregateOutputType = {
    id: number | null
    jobcategory_id: number | null
  }

  export type JobSpecializedMinAggregateOutputType = {
    id: number | null
    job_type: string | null
    description: string | null
    jobcategory_id: number | null
  }

  export type JobSpecializedMaxAggregateOutputType = {
    id: number | null
    job_type: string | null
    description: string | null
    jobcategory_id: number | null
  }

  export type JobSpecializedCountAggregateOutputType = {
    id: number
    job_type: number
    description: number
    jobcategory_id: number
    _all: number
  }


  export type JobSpecializedAvgAggregateInputType = {
    id?: true
    jobcategory_id?: true
  }

  export type JobSpecializedSumAggregateInputType = {
    id?: true
    jobcategory_id?: true
  }

  export type JobSpecializedMinAggregateInputType = {
    id?: true
    job_type?: true
    description?: true
    jobcategory_id?: true
  }

  export type JobSpecializedMaxAggregateInputType = {
    id?: true
    job_type?: true
    description?: true
    jobcategory_id?: true
  }

  export type JobSpecializedCountAggregateInputType = {
    id?: true
    job_type?: true
    description?: true
    jobcategory_id?: true
    _all?: true
  }

  export type JobSpecializedAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which jobSpecialized to aggregate.
     */
    where?: jobSpecializedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jobSpecializeds to fetch.
     */
    orderBy?: jobSpecializedOrderByWithRelationInput | jobSpecializedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: jobSpecializedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jobSpecializeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jobSpecializeds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned jobSpecializeds
    **/
    _count?: true | JobSpecializedCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobSpecializedAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobSpecializedSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobSpecializedMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobSpecializedMaxAggregateInputType
  }

  export type GetJobSpecializedAggregateType<T extends JobSpecializedAggregateArgs> = {
        [P in keyof T & keyof AggregateJobSpecialized]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobSpecialized[P]>
      : GetScalarType<T[P], AggregateJobSpecialized[P]>
  }




  export type jobSpecializedGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: jobSpecializedWhereInput
    orderBy?: jobSpecializedOrderByWithAggregationInput | jobSpecializedOrderByWithAggregationInput[]
    by: JobSpecializedScalarFieldEnum[] | JobSpecializedScalarFieldEnum
    having?: jobSpecializedScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobSpecializedCountAggregateInputType | true
    _avg?: JobSpecializedAvgAggregateInputType
    _sum?: JobSpecializedSumAggregateInputType
    _min?: JobSpecializedMinAggregateInputType
    _max?: JobSpecializedMaxAggregateInputType
  }

  export type JobSpecializedGroupByOutputType = {
    id: number
    job_type: string
    description: string | null
    jobcategory_id: number
    _count: JobSpecializedCountAggregateOutputType | null
    _avg: JobSpecializedAvgAggregateOutputType | null
    _sum: JobSpecializedSumAggregateOutputType | null
    _min: JobSpecializedMinAggregateOutputType | null
    _max: JobSpecializedMaxAggregateOutputType | null
  }

  type GetJobSpecializedGroupByPayload<T extends jobSpecializedGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobSpecializedGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobSpecializedGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobSpecializedGroupByOutputType[P]>
            : GetScalarType<T[P], JobSpecializedGroupByOutputType[P]>
        }
      >
    >


  export type jobSpecializedSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    job_type?: boolean
    description?: boolean
    jobcategory_id?: boolean
    careerPaths?: boolean | jobSpecialized$careerPathsArgs<ExtArgs>
    jobCategories?: boolean | jobCategoriesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobSpecialized"]>

  export type jobSpecializedSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    job_type?: boolean
    description?: boolean
    jobcategory_id?: boolean
    jobCategories?: boolean | jobCategoriesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobSpecialized"]>

  export type jobSpecializedSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    job_type?: boolean
    description?: boolean
    jobcategory_id?: boolean
    jobCategories?: boolean | jobCategoriesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobSpecialized"]>

  export type jobSpecializedSelectScalar = {
    id?: boolean
    job_type?: boolean
    description?: boolean
    jobcategory_id?: boolean
  }

  export type jobSpecializedOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "job_type" | "description" | "jobcategory_id", ExtArgs["result"]["jobSpecialized"]>
  export type jobSpecializedInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    careerPaths?: boolean | jobSpecialized$careerPathsArgs<ExtArgs>
    jobCategories?: boolean | jobCategoriesDefaultArgs<ExtArgs>
  }
  export type jobSpecializedIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobCategories?: boolean | jobCategoriesDefaultArgs<ExtArgs>
  }
  export type jobSpecializedIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobCategories?: boolean | jobCategoriesDefaultArgs<ExtArgs>
  }

  export type $jobSpecializedPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "jobSpecialized"
    objects: {
      careerPaths: Prisma.$careerPathsPayload<ExtArgs> | null
      jobCategories: Prisma.$jobCategoriesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      job_type: string
      description: string | null
      jobcategory_id: number
    }, ExtArgs["result"]["jobSpecialized"]>
    composites: {}
  }

  type jobSpecializedGetPayload<S extends boolean | null | undefined | jobSpecializedDefaultArgs> = $Result.GetResult<Prisma.$jobSpecializedPayload, S>

  type jobSpecializedCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<jobSpecializedFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JobSpecializedCountAggregateInputType | true
    }

  export interface jobSpecializedDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['jobSpecialized'], meta: { name: 'jobSpecialized' } }
    /**
     * Find zero or one JobSpecialized that matches the filter.
     * @param {jobSpecializedFindUniqueArgs} args - Arguments to find a JobSpecialized
     * @example
     * // Get one JobSpecialized
     * const jobSpecialized = await prisma.jobSpecialized.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends jobSpecializedFindUniqueArgs>(args: SelectSubset<T, jobSpecializedFindUniqueArgs<ExtArgs>>): Prisma__jobSpecializedClient<$Result.GetResult<Prisma.$jobSpecializedPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one JobSpecialized that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {jobSpecializedFindUniqueOrThrowArgs} args - Arguments to find a JobSpecialized
     * @example
     * // Get one JobSpecialized
     * const jobSpecialized = await prisma.jobSpecialized.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends jobSpecializedFindUniqueOrThrowArgs>(args: SelectSubset<T, jobSpecializedFindUniqueOrThrowArgs<ExtArgs>>): Prisma__jobSpecializedClient<$Result.GetResult<Prisma.$jobSpecializedPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobSpecialized that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobSpecializedFindFirstArgs} args - Arguments to find a JobSpecialized
     * @example
     * // Get one JobSpecialized
     * const jobSpecialized = await prisma.jobSpecialized.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends jobSpecializedFindFirstArgs>(args?: SelectSubset<T, jobSpecializedFindFirstArgs<ExtArgs>>): Prisma__jobSpecializedClient<$Result.GetResult<Prisma.$jobSpecializedPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JobSpecialized that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobSpecializedFindFirstOrThrowArgs} args - Arguments to find a JobSpecialized
     * @example
     * // Get one JobSpecialized
     * const jobSpecialized = await prisma.jobSpecialized.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends jobSpecializedFindFirstOrThrowArgs>(args?: SelectSubset<T, jobSpecializedFindFirstOrThrowArgs<ExtArgs>>): Prisma__jobSpecializedClient<$Result.GetResult<Prisma.$jobSpecializedPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more JobSpecializeds that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobSpecializedFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JobSpecializeds
     * const jobSpecializeds = await prisma.jobSpecialized.findMany()
     * 
     * // Get first 10 JobSpecializeds
     * const jobSpecializeds = await prisma.jobSpecialized.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobSpecializedWithIdOnly = await prisma.jobSpecialized.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends jobSpecializedFindManyArgs>(args?: SelectSubset<T, jobSpecializedFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$jobSpecializedPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a JobSpecialized.
     * @param {jobSpecializedCreateArgs} args - Arguments to create a JobSpecialized.
     * @example
     * // Create one JobSpecialized
     * const JobSpecialized = await prisma.jobSpecialized.create({
     *   data: {
     *     // ... data to create a JobSpecialized
     *   }
     * })
     * 
     */
    create<T extends jobSpecializedCreateArgs>(args: SelectSubset<T, jobSpecializedCreateArgs<ExtArgs>>): Prisma__jobSpecializedClient<$Result.GetResult<Prisma.$jobSpecializedPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many JobSpecializeds.
     * @param {jobSpecializedCreateManyArgs} args - Arguments to create many JobSpecializeds.
     * @example
     * // Create many JobSpecializeds
     * const jobSpecialized = await prisma.jobSpecialized.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends jobSpecializedCreateManyArgs>(args?: SelectSubset<T, jobSpecializedCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JobSpecializeds and returns the data saved in the database.
     * @param {jobSpecializedCreateManyAndReturnArgs} args - Arguments to create many JobSpecializeds.
     * @example
     * // Create many JobSpecializeds
     * const jobSpecialized = await prisma.jobSpecialized.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JobSpecializeds and only return the `id`
     * const jobSpecializedWithIdOnly = await prisma.jobSpecialized.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends jobSpecializedCreateManyAndReturnArgs>(args?: SelectSubset<T, jobSpecializedCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$jobSpecializedPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a JobSpecialized.
     * @param {jobSpecializedDeleteArgs} args - Arguments to delete one JobSpecialized.
     * @example
     * // Delete one JobSpecialized
     * const JobSpecialized = await prisma.jobSpecialized.delete({
     *   where: {
     *     // ... filter to delete one JobSpecialized
     *   }
     * })
     * 
     */
    delete<T extends jobSpecializedDeleteArgs>(args: SelectSubset<T, jobSpecializedDeleteArgs<ExtArgs>>): Prisma__jobSpecializedClient<$Result.GetResult<Prisma.$jobSpecializedPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one JobSpecialized.
     * @param {jobSpecializedUpdateArgs} args - Arguments to update one JobSpecialized.
     * @example
     * // Update one JobSpecialized
     * const jobSpecialized = await prisma.jobSpecialized.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends jobSpecializedUpdateArgs>(args: SelectSubset<T, jobSpecializedUpdateArgs<ExtArgs>>): Prisma__jobSpecializedClient<$Result.GetResult<Prisma.$jobSpecializedPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more JobSpecializeds.
     * @param {jobSpecializedDeleteManyArgs} args - Arguments to filter JobSpecializeds to delete.
     * @example
     * // Delete a few JobSpecializeds
     * const { count } = await prisma.jobSpecialized.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends jobSpecializedDeleteManyArgs>(args?: SelectSubset<T, jobSpecializedDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobSpecializeds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobSpecializedUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JobSpecializeds
     * const jobSpecialized = await prisma.jobSpecialized.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends jobSpecializedUpdateManyArgs>(args: SelectSubset<T, jobSpecializedUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JobSpecializeds and returns the data updated in the database.
     * @param {jobSpecializedUpdateManyAndReturnArgs} args - Arguments to update many JobSpecializeds.
     * @example
     * // Update many JobSpecializeds
     * const jobSpecialized = await prisma.jobSpecialized.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more JobSpecializeds and only return the `id`
     * const jobSpecializedWithIdOnly = await prisma.jobSpecialized.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends jobSpecializedUpdateManyAndReturnArgs>(args: SelectSubset<T, jobSpecializedUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$jobSpecializedPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one JobSpecialized.
     * @param {jobSpecializedUpsertArgs} args - Arguments to update or create a JobSpecialized.
     * @example
     * // Update or create a JobSpecialized
     * const jobSpecialized = await prisma.jobSpecialized.upsert({
     *   create: {
     *     // ... data to create a JobSpecialized
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JobSpecialized we want to update
     *   }
     * })
     */
    upsert<T extends jobSpecializedUpsertArgs>(args: SelectSubset<T, jobSpecializedUpsertArgs<ExtArgs>>): Prisma__jobSpecializedClient<$Result.GetResult<Prisma.$jobSpecializedPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of JobSpecializeds.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobSpecializedCountArgs} args - Arguments to filter JobSpecializeds to count.
     * @example
     * // Count the number of JobSpecializeds
     * const count = await prisma.jobSpecialized.count({
     *   where: {
     *     // ... the filter for the JobSpecializeds we want to count
     *   }
     * })
    **/
    count<T extends jobSpecializedCountArgs>(
      args?: Subset<T, jobSpecializedCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobSpecializedCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JobSpecialized.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobSpecializedAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobSpecializedAggregateArgs>(args: Subset<T, JobSpecializedAggregateArgs>): Prisma.PrismaPromise<GetJobSpecializedAggregateType<T>>

    /**
     * Group by JobSpecialized.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobSpecializedGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends jobSpecializedGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: jobSpecializedGroupByArgs['orderBy'] }
        : { orderBy?: jobSpecializedGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, jobSpecializedGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobSpecializedGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the jobSpecialized model
   */
  readonly fields: jobSpecializedFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for jobSpecialized.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__jobSpecializedClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    careerPaths<T extends jobSpecialized$careerPathsArgs<ExtArgs> = {}>(args?: Subset<T, jobSpecialized$careerPathsArgs<ExtArgs>>): Prisma__careerPathsClient<$Result.GetResult<Prisma.$careerPathsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    jobCategories<T extends jobCategoriesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, jobCategoriesDefaultArgs<ExtArgs>>): Prisma__jobCategoriesClient<$Result.GetResult<Prisma.$jobCategoriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the jobSpecialized model
   */
  interface jobSpecializedFieldRefs {
    readonly id: FieldRef<"jobSpecialized", 'Int'>
    readonly job_type: FieldRef<"jobSpecialized", 'String'>
    readonly description: FieldRef<"jobSpecialized", 'String'>
    readonly jobcategory_id: FieldRef<"jobSpecialized", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * jobSpecialized findUnique
   */
  export type jobSpecializedFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobSpecialized
     */
    select?: jobSpecializedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobSpecialized
     */
    omit?: jobSpecializedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobSpecializedInclude<ExtArgs> | null
    /**
     * Filter, which jobSpecialized to fetch.
     */
    where: jobSpecializedWhereUniqueInput
  }

  /**
   * jobSpecialized findUniqueOrThrow
   */
  export type jobSpecializedFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobSpecialized
     */
    select?: jobSpecializedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobSpecialized
     */
    omit?: jobSpecializedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobSpecializedInclude<ExtArgs> | null
    /**
     * Filter, which jobSpecialized to fetch.
     */
    where: jobSpecializedWhereUniqueInput
  }

  /**
   * jobSpecialized findFirst
   */
  export type jobSpecializedFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobSpecialized
     */
    select?: jobSpecializedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobSpecialized
     */
    omit?: jobSpecializedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobSpecializedInclude<ExtArgs> | null
    /**
     * Filter, which jobSpecialized to fetch.
     */
    where?: jobSpecializedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jobSpecializeds to fetch.
     */
    orderBy?: jobSpecializedOrderByWithRelationInput | jobSpecializedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for jobSpecializeds.
     */
    cursor?: jobSpecializedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jobSpecializeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jobSpecializeds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of jobSpecializeds.
     */
    distinct?: JobSpecializedScalarFieldEnum | JobSpecializedScalarFieldEnum[]
  }

  /**
   * jobSpecialized findFirstOrThrow
   */
  export type jobSpecializedFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobSpecialized
     */
    select?: jobSpecializedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobSpecialized
     */
    omit?: jobSpecializedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobSpecializedInclude<ExtArgs> | null
    /**
     * Filter, which jobSpecialized to fetch.
     */
    where?: jobSpecializedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jobSpecializeds to fetch.
     */
    orderBy?: jobSpecializedOrderByWithRelationInput | jobSpecializedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for jobSpecializeds.
     */
    cursor?: jobSpecializedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jobSpecializeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jobSpecializeds.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of jobSpecializeds.
     */
    distinct?: JobSpecializedScalarFieldEnum | JobSpecializedScalarFieldEnum[]
  }

  /**
   * jobSpecialized findMany
   */
  export type jobSpecializedFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobSpecialized
     */
    select?: jobSpecializedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobSpecialized
     */
    omit?: jobSpecializedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobSpecializedInclude<ExtArgs> | null
    /**
     * Filter, which jobSpecializeds to fetch.
     */
    where?: jobSpecializedWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jobSpecializeds to fetch.
     */
    orderBy?: jobSpecializedOrderByWithRelationInput | jobSpecializedOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing jobSpecializeds.
     */
    cursor?: jobSpecializedWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jobSpecializeds from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jobSpecializeds.
     */
    skip?: number
    distinct?: JobSpecializedScalarFieldEnum | JobSpecializedScalarFieldEnum[]
  }

  /**
   * jobSpecialized create
   */
  export type jobSpecializedCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobSpecialized
     */
    select?: jobSpecializedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobSpecialized
     */
    omit?: jobSpecializedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobSpecializedInclude<ExtArgs> | null
    /**
     * The data needed to create a jobSpecialized.
     */
    data: XOR<jobSpecializedCreateInput, jobSpecializedUncheckedCreateInput>
  }

  /**
   * jobSpecialized createMany
   */
  export type jobSpecializedCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many jobSpecializeds.
     */
    data: jobSpecializedCreateManyInput | jobSpecializedCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * jobSpecialized createManyAndReturn
   */
  export type jobSpecializedCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobSpecialized
     */
    select?: jobSpecializedSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the jobSpecialized
     */
    omit?: jobSpecializedOmit<ExtArgs> | null
    /**
     * The data used to create many jobSpecializeds.
     */
    data: jobSpecializedCreateManyInput | jobSpecializedCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobSpecializedIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * jobSpecialized update
   */
  export type jobSpecializedUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobSpecialized
     */
    select?: jobSpecializedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobSpecialized
     */
    omit?: jobSpecializedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobSpecializedInclude<ExtArgs> | null
    /**
     * The data needed to update a jobSpecialized.
     */
    data: XOR<jobSpecializedUpdateInput, jobSpecializedUncheckedUpdateInput>
    /**
     * Choose, which jobSpecialized to update.
     */
    where: jobSpecializedWhereUniqueInput
  }

  /**
   * jobSpecialized updateMany
   */
  export type jobSpecializedUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update jobSpecializeds.
     */
    data: XOR<jobSpecializedUpdateManyMutationInput, jobSpecializedUncheckedUpdateManyInput>
    /**
     * Filter which jobSpecializeds to update
     */
    where?: jobSpecializedWhereInput
    /**
     * Limit how many jobSpecializeds to update.
     */
    limit?: number
  }

  /**
   * jobSpecialized updateManyAndReturn
   */
  export type jobSpecializedUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobSpecialized
     */
    select?: jobSpecializedSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the jobSpecialized
     */
    omit?: jobSpecializedOmit<ExtArgs> | null
    /**
     * The data used to update jobSpecializeds.
     */
    data: XOR<jobSpecializedUpdateManyMutationInput, jobSpecializedUncheckedUpdateManyInput>
    /**
     * Filter which jobSpecializeds to update
     */
    where?: jobSpecializedWhereInput
    /**
     * Limit how many jobSpecializeds to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobSpecializedIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * jobSpecialized upsert
   */
  export type jobSpecializedUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobSpecialized
     */
    select?: jobSpecializedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobSpecialized
     */
    omit?: jobSpecializedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobSpecializedInclude<ExtArgs> | null
    /**
     * The filter to search for the jobSpecialized to update in case it exists.
     */
    where: jobSpecializedWhereUniqueInput
    /**
     * In case the jobSpecialized found by the `where` argument doesn't exist, create a new jobSpecialized with this data.
     */
    create: XOR<jobSpecializedCreateInput, jobSpecializedUncheckedCreateInput>
    /**
     * In case the jobSpecialized was found with the provided `where` argument, update it with this data.
     */
    update: XOR<jobSpecializedUpdateInput, jobSpecializedUncheckedUpdateInput>
  }

  /**
   * jobSpecialized delete
   */
  export type jobSpecializedDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobSpecialized
     */
    select?: jobSpecializedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobSpecialized
     */
    omit?: jobSpecializedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobSpecializedInclude<ExtArgs> | null
    /**
     * Filter which jobSpecialized to delete.
     */
    where: jobSpecializedWhereUniqueInput
  }

  /**
   * jobSpecialized deleteMany
   */
  export type jobSpecializedDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which jobSpecializeds to delete
     */
    where?: jobSpecializedWhereInput
    /**
     * Limit how many jobSpecializeds to delete.
     */
    limit?: number
  }

  /**
   * jobSpecialized.careerPaths
   */
  export type jobSpecialized$careerPathsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the careerPaths
     */
    select?: careerPathsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the careerPaths
     */
    omit?: careerPathsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: careerPathsInclude<ExtArgs> | null
    where?: careerPathsWhereInput
  }

  /**
   * jobSpecialized without action
   */
  export type jobSpecializedDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobSpecialized
     */
    select?: jobSpecializedSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobSpecialized
     */
    omit?: jobSpecializedOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobSpecializedInclude<ExtArgs> | null
  }


  /**
   * Model jobs
   */

  export type AggregateJobs = {
    _count: JobsCountAggregateOutputType | null
    _avg: JobsAvgAggregateOutputType | null
    _sum: JobsSumAggregateOutputType | null
    _min: JobsMinAggregateOutputType | null
    _max: JobsMaxAggregateOutputType | null
  }

  export type JobsAvgAggregateOutputType = {
    quantity: number | null
    category_id: number | null
    label_id: number | null
  }

  export type JobsSumAggregateOutputType = {
    quantity: number | null
    category_id: number | null
    label_id: number | null
  }

  export type JobsMinAggregateOutputType = {
    id: string | null
    job_title: string | null
    description: string | null
    location: string | null
    benefit: string | null
    working_time: string | null
    currency: string | null
    job_type: $Enums.Job_Type | null
    status: $Enums.Job_Status | null
    job_level: string | null
    quantity: number | null
    education: $Enums.Education | null
    experience: string | null
    start_date: Date | null
    end_date: Date | null
    created_at: Date | null
    updated_at: Date | null
    category_id: number | null
    label_id: number | null
  }

  export type JobsMaxAggregateOutputType = {
    id: string | null
    job_title: string | null
    description: string | null
    location: string | null
    benefit: string | null
    working_time: string | null
    currency: string | null
    job_type: $Enums.Job_Type | null
    status: $Enums.Job_Status | null
    job_level: string | null
    quantity: number | null
    education: $Enums.Education | null
    experience: string | null
    start_date: Date | null
    end_date: Date | null
    created_at: Date | null
    updated_at: Date | null
    category_id: number | null
    label_id: number | null
  }

  export type JobsCountAggregateOutputType = {
    id: number
    job_title: number
    description: number
    location: number
    benefit: number
    working_time: number
    salary: number
    currency: number
    job_type: number
    status: number
    job_level: number
    quantity: number
    skill_tags: number
    education: number
    experience: number
    start_date: number
    end_date: number
    created_at: number
    updated_at: number
    category_id: number
    label_id: number
    _all: number
  }


  export type JobsAvgAggregateInputType = {
    quantity?: true
    category_id?: true
    label_id?: true
  }

  export type JobsSumAggregateInputType = {
    quantity?: true
    category_id?: true
    label_id?: true
  }

  export type JobsMinAggregateInputType = {
    id?: true
    job_title?: true
    description?: true
    location?: true
    benefit?: true
    working_time?: true
    currency?: true
    job_type?: true
    status?: true
    job_level?: true
    quantity?: true
    education?: true
    experience?: true
    start_date?: true
    end_date?: true
    created_at?: true
    updated_at?: true
    category_id?: true
    label_id?: true
  }

  export type JobsMaxAggregateInputType = {
    id?: true
    job_title?: true
    description?: true
    location?: true
    benefit?: true
    working_time?: true
    currency?: true
    job_type?: true
    status?: true
    job_level?: true
    quantity?: true
    education?: true
    experience?: true
    start_date?: true
    end_date?: true
    created_at?: true
    updated_at?: true
    category_id?: true
    label_id?: true
  }

  export type JobsCountAggregateInputType = {
    id?: true
    job_title?: true
    description?: true
    location?: true
    benefit?: true
    working_time?: true
    salary?: true
    currency?: true
    job_type?: true
    status?: true
    job_level?: true
    quantity?: true
    skill_tags?: true
    education?: true
    experience?: true
    start_date?: true
    end_date?: true
    created_at?: true
    updated_at?: true
    category_id?: true
    label_id?: true
    _all?: true
  }

  export type JobsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which jobs to aggregate.
     */
    where?: jobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jobs to fetch.
     */
    orderBy?: jobsOrderByWithRelationInput | jobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: jobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned jobs
    **/
    _count?: true | JobsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobsMaxAggregateInputType
  }

  export type GetJobsAggregateType<T extends JobsAggregateArgs> = {
        [P in keyof T & keyof AggregateJobs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobs[P]>
      : GetScalarType<T[P], AggregateJobs[P]>
  }




  export type jobsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: jobsWhereInput
    orderBy?: jobsOrderByWithAggregationInput | jobsOrderByWithAggregationInput[]
    by: JobsScalarFieldEnum[] | JobsScalarFieldEnum
    having?: jobsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobsCountAggregateInputType | true
    _avg?: JobsAvgAggregateInputType
    _sum?: JobsSumAggregateInputType
    _min?: JobsMinAggregateInputType
    _max?: JobsMaxAggregateInputType
  }

  export type JobsGroupByOutputType = {
    id: string
    job_title: string
    description: string
    location: string | null
    benefit: string | null
    working_time: string | null
    salary: string[]
    currency: string | null
    job_type: $Enums.Job_Type | null
    status: $Enums.Job_Status | null
    job_level: string
    quantity: number | null
    skill_tags: string[]
    education: $Enums.Education | null
    experience: string | null
    start_date: Date
    end_date: Date | null
    created_at: Date
    updated_at: Date
    category_id: number | null
    label_id: number | null
    _count: JobsCountAggregateOutputType | null
    _avg: JobsAvgAggregateOutputType | null
    _sum: JobsSumAggregateOutputType | null
    _min: JobsMinAggregateOutputType | null
    _max: JobsMaxAggregateOutputType | null
  }

  type GetJobsGroupByPayload<T extends jobsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobsGroupByOutputType[P]>
            : GetScalarType<T[P], JobsGroupByOutputType[P]>
        }
      >
    >


  export type jobsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    job_title?: boolean
    description?: boolean
    location?: boolean
    benefit?: boolean
    working_time?: boolean
    salary?: boolean
    currency?: boolean
    job_type?: boolean
    status?: boolean
    job_level?: boolean
    quantity?: boolean
    skill_tags?: boolean
    education?: boolean
    experience?: boolean
    start_date?: boolean
    end_date?: boolean
    created_at?: boolean
    updated_at?: boolean
    category_id?: boolean
    label_id?: boolean
    applicants?: boolean | jobs$applicantsArgs<ExtArgs>
    categories?: boolean | jobs$categoriesArgs<ExtArgs>
    jobLabels?: boolean | jobs$jobLabelsArgs<ExtArgs>
    savedJobs?: boolean | jobs$savedJobsArgs<ExtArgs>
    _count?: boolean | JobsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jobs"]>

  export type jobsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    job_title?: boolean
    description?: boolean
    location?: boolean
    benefit?: boolean
    working_time?: boolean
    salary?: boolean
    currency?: boolean
    job_type?: boolean
    status?: boolean
    job_level?: boolean
    quantity?: boolean
    skill_tags?: boolean
    education?: boolean
    experience?: boolean
    start_date?: boolean
    end_date?: boolean
    created_at?: boolean
    updated_at?: boolean
    category_id?: boolean
    label_id?: boolean
    categories?: boolean | jobs$categoriesArgs<ExtArgs>
    jobLabels?: boolean | jobs$jobLabelsArgs<ExtArgs>
  }, ExtArgs["result"]["jobs"]>

  export type jobsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    job_title?: boolean
    description?: boolean
    location?: boolean
    benefit?: boolean
    working_time?: boolean
    salary?: boolean
    currency?: boolean
    job_type?: boolean
    status?: boolean
    job_level?: boolean
    quantity?: boolean
    skill_tags?: boolean
    education?: boolean
    experience?: boolean
    start_date?: boolean
    end_date?: boolean
    created_at?: boolean
    updated_at?: boolean
    category_id?: boolean
    label_id?: boolean
    categories?: boolean | jobs$categoriesArgs<ExtArgs>
    jobLabels?: boolean | jobs$jobLabelsArgs<ExtArgs>
  }, ExtArgs["result"]["jobs"]>

  export type jobsSelectScalar = {
    id?: boolean
    job_title?: boolean
    description?: boolean
    location?: boolean
    benefit?: boolean
    working_time?: boolean
    salary?: boolean
    currency?: boolean
    job_type?: boolean
    status?: boolean
    job_level?: boolean
    quantity?: boolean
    skill_tags?: boolean
    education?: boolean
    experience?: boolean
    start_date?: boolean
    end_date?: boolean
    created_at?: boolean
    updated_at?: boolean
    category_id?: boolean
    label_id?: boolean
  }

  export type jobsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "job_title" | "description" | "location" | "benefit" | "working_time" | "salary" | "currency" | "job_type" | "status" | "job_level" | "quantity" | "skill_tags" | "education" | "experience" | "start_date" | "end_date" | "created_at" | "updated_at" | "category_id" | "label_id", ExtArgs["result"]["jobs"]>
  export type jobsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    applicants?: boolean | jobs$applicantsArgs<ExtArgs>
    categories?: boolean | jobs$categoriesArgs<ExtArgs>
    jobLabels?: boolean | jobs$jobLabelsArgs<ExtArgs>
    savedJobs?: boolean | jobs$savedJobsArgs<ExtArgs>
    _count?: boolean | JobsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type jobsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | jobs$categoriesArgs<ExtArgs>
    jobLabels?: boolean | jobs$jobLabelsArgs<ExtArgs>
  }
  export type jobsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | jobs$categoriesArgs<ExtArgs>
    jobLabels?: boolean | jobs$jobLabelsArgs<ExtArgs>
  }

  export type $jobsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "jobs"
    objects: {
      applicants: Prisma.$applicantsPayload<ExtArgs>[]
      categories: Prisma.$categoriesPayload<ExtArgs> | null
      jobLabels: Prisma.$jobLabelsPayload<ExtArgs> | null
      savedJobs: Prisma.$savedJobsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      job_title: string
      description: string
      location: string | null
      benefit: string | null
      working_time: string | null
      salary: string[]
      currency: string | null
      job_type: $Enums.Job_Type | null
      status: $Enums.Job_Status | null
      job_level: string
      quantity: number | null
      skill_tags: string[]
      education: $Enums.Education | null
      experience: string | null
      start_date: Date
      end_date: Date | null
      created_at: Date
      updated_at: Date
      category_id: number | null
      label_id: number | null
    }, ExtArgs["result"]["jobs"]>
    composites: {}
  }

  type jobsGetPayload<S extends boolean | null | undefined | jobsDefaultArgs> = $Result.GetResult<Prisma.$jobsPayload, S>

  type jobsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<jobsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JobsCountAggregateInputType | true
    }

  export interface jobsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['jobs'], meta: { name: 'jobs' } }
    /**
     * Find zero or one Jobs that matches the filter.
     * @param {jobsFindUniqueArgs} args - Arguments to find a Jobs
     * @example
     * // Get one Jobs
     * const jobs = await prisma.jobs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends jobsFindUniqueArgs>(args: SelectSubset<T, jobsFindUniqueArgs<ExtArgs>>): Prisma__jobsClient<$Result.GetResult<Prisma.$jobsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Jobs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {jobsFindUniqueOrThrowArgs} args - Arguments to find a Jobs
     * @example
     * // Get one Jobs
     * const jobs = await prisma.jobs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends jobsFindUniqueOrThrowArgs>(args: SelectSubset<T, jobsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__jobsClient<$Result.GetResult<Prisma.$jobsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Jobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobsFindFirstArgs} args - Arguments to find a Jobs
     * @example
     * // Get one Jobs
     * const jobs = await prisma.jobs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends jobsFindFirstArgs>(args?: SelectSubset<T, jobsFindFirstArgs<ExtArgs>>): Prisma__jobsClient<$Result.GetResult<Prisma.$jobsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Jobs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobsFindFirstOrThrowArgs} args - Arguments to find a Jobs
     * @example
     * // Get one Jobs
     * const jobs = await prisma.jobs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends jobsFindFirstOrThrowArgs>(args?: SelectSubset<T, jobsFindFirstOrThrowArgs<ExtArgs>>): Prisma__jobsClient<$Result.GetResult<Prisma.$jobsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Jobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Jobs
     * const jobs = await prisma.jobs.findMany()
     * 
     * // Get first 10 Jobs
     * const jobs = await prisma.jobs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobsWithIdOnly = await prisma.jobs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends jobsFindManyArgs>(args?: SelectSubset<T, jobsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$jobsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Jobs.
     * @param {jobsCreateArgs} args - Arguments to create a Jobs.
     * @example
     * // Create one Jobs
     * const Jobs = await prisma.jobs.create({
     *   data: {
     *     // ... data to create a Jobs
     *   }
     * })
     * 
     */
    create<T extends jobsCreateArgs>(args: SelectSubset<T, jobsCreateArgs<ExtArgs>>): Prisma__jobsClient<$Result.GetResult<Prisma.$jobsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Jobs.
     * @param {jobsCreateManyArgs} args - Arguments to create many Jobs.
     * @example
     * // Create many Jobs
     * const jobs = await prisma.jobs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends jobsCreateManyArgs>(args?: SelectSubset<T, jobsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Jobs and returns the data saved in the database.
     * @param {jobsCreateManyAndReturnArgs} args - Arguments to create many Jobs.
     * @example
     * // Create many Jobs
     * const jobs = await prisma.jobs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Jobs and only return the `id`
     * const jobsWithIdOnly = await prisma.jobs.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends jobsCreateManyAndReturnArgs>(args?: SelectSubset<T, jobsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$jobsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Jobs.
     * @param {jobsDeleteArgs} args - Arguments to delete one Jobs.
     * @example
     * // Delete one Jobs
     * const Jobs = await prisma.jobs.delete({
     *   where: {
     *     // ... filter to delete one Jobs
     *   }
     * })
     * 
     */
    delete<T extends jobsDeleteArgs>(args: SelectSubset<T, jobsDeleteArgs<ExtArgs>>): Prisma__jobsClient<$Result.GetResult<Prisma.$jobsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Jobs.
     * @param {jobsUpdateArgs} args - Arguments to update one Jobs.
     * @example
     * // Update one Jobs
     * const jobs = await prisma.jobs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends jobsUpdateArgs>(args: SelectSubset<T, jobsUpdateArgs<ExtArgs>>): Prisma__jobsClient<$Result.GetResult<Prisma.$jobsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Jobs.
     * @param {jobsDeleteManyArgs} args - Arguments to filter Jobs to delete.
     * @example
     * // Delete a few Jobs
     * const { count } = await prisma.jobs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends jobsDeleteManyArgs>(args?: SelectSubset<T, jobsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Jobs
     * const jobs = await prisma.jobs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends jobsUpdateManyArgs>(args: SelectSubset<T, jobsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Jobs and returns the data updated in the database.
     * @param {jobsUpdateManyAndReturnArgs} args - Arguments to update many Jobs.
     * @example
     * // Update many Jobs
     * const jobs = await prisma.jobs.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Jobs and only return the `id`
     * const jobsWithIdOnly = await prisma.jobs.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends jobsUpdateManyAndReturnArgs>(args: SelectSubset<T, jobsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$jobsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Jobs.
     * @param {jobsUpsertArgs} args - Arguments to update or create a Jobs.
     * @example
     * // Update or create a Jobs
     * const jobs = await prisma.jobs.upsert({
     *   create: {
     *     // ... data to create a Jobs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Jobs we want to update
     *   }
     * })
     */
    upsert<T extends jobsUpsertArgs>(args: SelectSubset<T, jobsUpsertArgs<ExtArgs>>): Prisma__jobsClient<$Result.GetResult<Prisma.$jobsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobsCountArgs} args - Arguments to filter Jobs to count.
     * @example
     * // Count the number of Jobs
     * const count = await prisma.jobs.count({
     *   where: {
     *     // ... the filter for the Jobs we want to count
     *   }
     * })
    **/
    count<T extends jobsCountArgs>(
      args?: Subset<T, jobsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobsAggregateArgs>(args: Subset<T, JobsAggregateArgs>): Prisma.PrismaPromise<GetJobsAggregateType<T>>

    /**
     * Group by Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends jobsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: jobsGroupByArgs['orderBy'] }
        : { orderBy?: jobsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, jobsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the jobs model
   */
  readonly fields: jobsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for jobs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__jobsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    applicants<T extends jobs$applicantsArgs<ExtArgs> = {}>(args?: Subset<T, jobs$applicantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$applicantsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    categories<T extends jobs$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, jobs$categoriesArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    jobLabels<T extends jobs$jobLabelsArgs<ExtArgs> = {}>(args?: Subset<T, jobs$jobLabelsArgs<ExtArgs>>): Prisma__jobLabelsClient<$Result.GetResult<Prisma.$jobLabelsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    savedJobs<T extends jobs$savedJobsArgs<ExtArgs> = {}>(args?: Subset<T, jobs$savedJobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$savedJobsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the jobs model
   */
  interface jobsFieldRefs {
    readonly id: FieldRef<"jobs", 'String'>
    readonly job_title: FieldRef<"jobs", 'String'>
    readonly description: FieldRef<"jobs", 'String'>
    readonly location: FieldRef<"jobs", 'String'>
    readonly benefit: FieldRef<"jobs", 'String'>
    readonly working_time: FieldRef<"jobs", 'String'>
    readonly salary: FieldRef<"jobs", 'String[]'>
    readonly currency: FieldRef<"jobs", 'String'>
    readonly job_type: FieldRef<"jobs", 'Job_Type'>
    readonly status: FieldRef<"jobs", 'Job_Status'>
    readonly job_level: FieldRef<"jobs", 'String'>
    readonly quantity: FieldRef<"jobs", 'Int'>
    readonly skill_tags: FieldRef<"jobs", 'String[]'>
    readonly education: FieldRef<"jobs", 'Education'>
    readonly experience: FieldRef<"jobs", 'String'>
    readonly start_date: FieldRef<"jobs", 'DateTime'>
    readonly end_date: FieldRef<"jobs", 'DateTime'>
    readonly created_at: FieldRef<"jobs", 'DateTime'>
    readonly updated_at: FieldRef<"jobs", 'DateTime'>
    readonly category_id: FieldRef<"jobs", 'Int'>
    readonly label_id: FieldRef<"jobs", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * jobs findUnique
   */
  export type jobsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobs
     */
    select?: jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobs
     */
    omit?: jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobsInclude<ExtArgs> | null
    /**
     * Filter, which jobs to fetch.
     */
    where: jobsWhereUniqueInput
  }

  /**
   * jobs findUniqueOrThrow
   */
  export type jobsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobs
     */
    select?: jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobs
     */
    omit?: jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobsInclude<ExtArgs> | null
    /**
     * Filter, which jobs to fetch.
     */
    where: jobsWhereUniqueInput
  }

  /**
   * jobs findFirst
   */
  export type jobsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobs
     */
    select?: jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobs
     */
    omit?: jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobsInclude<ExtArgs> | null
    /**
     * Filter, which jobs to fetch.
     */
    where?: jobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jobs to fetch.
     */
    orderBy?: jobsOrderByWithRelationInput | jobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for jobs.
     */
    cursor?: jobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of jobs.
     */
    distinct?: JobsScalarFieldEnum | JobsScalarFieldEnum[]
  }

  /**
   * jobs findFirstOrThrow
   */
  export type jobsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobs
     */
    select?: jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobs
     */
    omit?: jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobsInclude<ExtArgs> | null
    /**
     * Filter, which jobs to fetch.
     */
    where?: jobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jobs to fetch.
     */
    orderBy?: jobsOrderByWithRelationInput | jobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for jobs.
     */
    cursor?: jobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of jobs.
     */
    distinct?: JobsScalarFieldEnum | JobsScalarFieldEnum[]
  }

  /**
   * jobs findMany
   */
  export type jobsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobs
     */
    select?: jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobs
     */
    omit?: jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobsInclude<ExtArgs> | null
    /**
     * Filter, which jobs to fetch.
     */
    where?: jobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jobs to fetch.
     */
    orderBy?: jobsOrderByWithRelationInput | jobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing jobs.
     */
    cursor?: jobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jobs.
     */
    skip?: number
    distinct?: JobsScalarFieldEnum | JobsScalarFieldEnum[]
  }

  /**
   * jobs create
   */
  export type jobsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobs
     */
    select?: jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobs
     */
    omit?: jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobsInclude<ExtArgs> | null
    /**
     * The data needed to create a jobs.
     */
    data: XOR<jobsCreateInput, jobsUncheckedCreateInput>
  }

  /**
   * jobs createMany
   */
  export type jobsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many jobs.
     */
    data: jobsCreateManyInput | jobsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * jobs createManyAndReturn
   */
  export type jobsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobs
     */
    select?: jobsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the jobs
     */
    omit?: jobsOmit<ExtArgs> | null
    /**
     * The data used to create many jobs.
     */
    data: jobsCreateManyInput | jobsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * jobs update
   */
  export type jobsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobs
     */
    select?: jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobs
     */
    omit?: jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobsInclude<ExtArgs> | null
    /**
     * The data needed to update a jobs.
     */
    data: XOR<jobsUpdateInput, jobsUncheckedUpdateInput>
    /**
     * Choose, which jobs to update.
     */
    where: jobsWhereUniqueInput
  }

  /**
   * jobs updateMany
   */
  export type jobsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update jobs.
     */
    data: XOR<jobsUpdateManyMutationInput, jobsUncheckedUpdateManyInput>
    /**
     * Filter which jobs to update
     */
    where?: jobsWhereInput
    /**
     * Limit how many jobs to update.
     */
    limit?: number
  }

  /**
   * jobs updateManyAndReturn
   */
  export type jobsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobs
     */
    select?: jobsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the jobs
     */
    omit?: jobsOmit<ExtArgs> | null
    /**
     * The data used to update jobs.
     */
    data: XOR<jobsUpdateManyMutationInput, jobsUncheckedUpdateManyInput>
    /**
     * Filter which jobs to update
     */
    where?: jobsWhereInput
    /**
     * Limit how many jobs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * jobs upsert
   */
  export type jobsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobs
     */
    select?: jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobs
     */
    omit?: jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobsInclude<ExtArgs> | null
    /**
     * The filter to search for the jobs to update in case it exists.
     */
    where: jobsWhereUniqueInput
    /**
     * In case the jobs found by the `where` argument doesn't exist, create a new jobs with this data.
     */
    create: XOR<jobsCreateInput, jobsUncheckedCreateInput>
    /**
     * In case the jobs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<jobsUpdateInput, jobsUncheckedUpdateInput>
  }

  /**
   * jobs delete
   */
  export type jobsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobs
     */
    select?: jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobs
     */
    omit?: jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobsInclude<ExtArgs> | null
    /**
     * Filter which jobs to delete.
     */
    where: jobsWhereUniqueInput
  }

  /**
   * jobs deleteMany
   */
  export type jobsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which jobs to delete
     */
    where?: jobsWhereInput
    /**
     * Limit how many jobs to delete.
     */
    limit?: number
  }

  /**
   * jobs.applicants
   */
  export type jobs$applicantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the applicants
     */
    select?: applicantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the applicants
     */
    omit?: applicantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: applicantsInclude<ExtArgs> | null
    where?: applicantsWhereInput
    orderBy?: applicantsOrderByWithRelationInput | applicantsOrderByWithRelationInput[]
    cursor?: applicantsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ApplicantsScalarFieldEnum | ApplicantsScalarFieldEnum[]
  }

  /**
   * jobs.categories
   */
  export type jobs$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    where?: categoriesWhereInput
  }

  /**
   * jobs.jobLabels
   */
  export type jobs$jobLabelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobLabels
     */
    select?: jobLabelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobLabels
     */
    omit?: jobLabelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobLabelsInclude<ExtArgs> | null
    where?: jobLabelsWhereInput
  }

  /**
   * jobs.savedJobs
   */
  export type jobs$savedJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the savedJobs
     */
    select?: savedJobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the savedJobs
     */
    omit?: savedJobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: savedJobsInclude<ExtArgs> | null
    where?: savedJobsWhereInput
    orderBy?: savedJobsOrderByWithRelationInput | savedJobsOrderByWithRelationInput[]
    cursor?: savedJobsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SavedJobsScalarFieldEnum | SavedJobsScalarFieldEnum[]
  }

  /**
   * jobs without action
   */
  export type jobsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobs
     */
    select?: jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobs
     */
    omit?: jobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: jobsInclude<ExtArgs> | null
  }


  /**
   * Model membershipPlans
   */

  export type AggregateMembershipPlans = {
    _count: MembershipPlansCountAggregateOutputType | null
    _avg: MembershipPlansAvgAggregateOutputType | null
    _sum: MembershipPlansSumAggregateOutputType | null
    _min: MembershipPlansMinAggregateOutputType | null
    _max: MembershipPlansMaxAggregateOutputType | null
  }

  export type MembershipPlansAvgAggregateOutputType = {
    id: number | null
    price: number | null
    duration_days: number | null
  }

  export type MembershipPlansSumAggregateOutputType = {
    id: number | null
    price: bigint | null
    duration_days: number | null
  }

  export type MembershipPlansMinAggregateOutputType = {
    id: number | null
    plan_name: string | null
    description: string | null
    price: bigint | null
    duration_days: number | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type MembershipPlansMaxAggregateOutputType = {
    id: number | null
    plan_name: string | null
    description: string | null
    price: bigint | null
    duration_days: number | null
    is_active: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type MembershipPlansCountAggregateOutputType = {
    id: number
    plan_name: number
    description: number
    price: number
    duration_days: number
    is_active: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type MembershipPlansAvgAggregateInputType = {
    id?: true
    price?: true
    duration_days?: true
  }

  export type MembershipPlansSumAggregateInputType = {
    id?: true
    price?: true
    duration_days?: true
  }

  export type MembershipPlansMinAggregateInputType = {
    id?: true
    plan_name?: true
    description?: true
    price?: true
    duration_days?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type MembershipPlansMaxAggregateInputType = {
    id?: true
    plan_name?: true
    description?: true
    price?: true
    duration_days?: true
    is_active?: true
    created_at?: true
    updated_at?: true
  }

  export type MembershipPlansCountAggregateInputType = {
    id?: true
    plan_name?: true
    description?: true
    price?: true
    duration_days?: true
    is_active?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type MembershipPlansAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which membershipPlans to aggregate.
     */
    where?: membershipPlansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of membershipPlans to fetch.
     */
    orderBy?: membershipPlansOrderByWithRelationInput | membershipPlansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: membershipPlansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` membershipPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` membershipPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned membershipPlans
    **/
    _count?: true | MembershipPlansCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MembershipPlansAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MembershipPlansSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MembershipPlansMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MembershipPlansMaxAggregateInputType
  }

  export type GetMembershipPlansAggregateType<T extends MembershipPlansAggregateArgs> = {
        [P in keyof T & keyof AggregateMembershipPlans]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMembershipPlans[P]>
      : GetScalarType<T[P], AggregateMembershipPlans[P]>
  }




  export type membershipPlansGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: membershipPlansWhereInput
    orderBy?: membershipPlansOrderByWithAggregationInput | membershipPlansOrderByWithAggregationInput[]
    by: MembershipPlansScalarFieldEnum[] | MembershipPlansScalarFieldEnum
    having?: membershipPlansScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MembershipPlansCountAggregateInputType | true
    _avg?: MembershipPlansAvgAggregateInputType
    _sum?: MembershipPlansSumAggregateInputType
    _min?: MembershipPlansMinAggregateInputType
    _max?: MembershipPlansMaxAggregateInputType
  }

  export type MembershipPlansGroupByOutputType = {
    id: number
    plan_name: string
    description: string | null
    price: bigint
    duration_days: number
    is_active: boolean
    created_at: Date
    updated_at: Date
    _count: MembershipPlansCountAggregateOutputType | null
    _avg: MembershipPlansAvgAggregateOutputType | null
    _sum: MembershipPlansSumAggregateOutputType | null
    _min: MembershipPlansMinAggregateOutputType | null
    _max: MembershipPlansMaxAggregateOutputType | null
  }

  type GetMembershipPlansGroupByPayload<T extends membershipPlansGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MembershipPlansGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MembershipPlansGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MembershipPlansGroupByOutputType[P]>
            : GetScalarType<T[P], MembershipPlansGroupByOutputType[P]>
        }
      >
    >


  export type membershipPlansSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    plan_name?: boolean
    description?: boolean
    price?: boolean
    duration_days?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
    features?: boolean | membershipPlans$featuresArgs<ExtArgs>
    subscriptions?: boolean | membershipPlans$subscriptionsArgs<ExtArgs>
    _count?: boolean | MembershipPlansCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["membershipPlans"]>

  export type membershipPlansSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    plan_name?: boolean
    description?: boolean
    price?: boolean
    duration_days?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["membershipPlans"]>

  export type membershipPlansSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    plan_name?: boolean
    description?: boolean
    price?: boolean
    duration_days?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["membershipPlans"]>

  export type membershipPlansSelectScalar = {
    id?: boolean
    plan_name?: boolean
    description?: boolean
    price?: boolean
    duration_days?: boolean
    is_active?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type membershipPlansOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "plan_name" | "description" | "price" | "duration_days" | "is_active" | "created_at" | "updated_at", ExtArgs["result"]["membershipPlans"]>
  export type membershipPlansInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    features?: boolean | membershipPlans$featuresArgs<ExtArgs>
    subscriptions?: boolean | membershipPlans$subscriptionsArgs<ExtArgs>
    _count?: boolean | MembershipPlansCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type membershipPlansIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type membershipPlansIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $membershipPlansPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "membershipPlans"
    objects: {
      features: Prisma.$featuresPayload<ExtArgs>[]
      subscriptions: Prisma.$subscriptionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      plan_name: string
      description: string | null
      price: bigint
      duration_days: number
      is_active: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["membershipPlans"]>
    composites: {}
  }

  type membershipPlansGetPayload<S extends boolean | null | undefined | membershipPlansDefaultArgs> = $Result.GetResult<Prisma.$membershipPlansPayload, S>

  type membershipPlansCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<membershipPlansFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MembershipPlansCountAggregateInputType | true
    }

  export interface membershipPlansDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['membershipPlans'], meta: { name: 'membershipPlans' } }
    /**
     * Find zero or one MembershipPlans that matches the filter.
     * @param {membershipPlansFindUniqueArgs} args - Arguments to find a MembershipPlans
     * @example
     * // Get one MembershipPlans
     * const membershipPlans = await prisma.membershipPlans.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends membershipPlansFindUniqueArgs>(args: SelectSubset<T, membershipPlansFindUniqueArgs<ExtArgs>>): Prisma__membershipPlansClient<$Result.GetResult<Prisma.$membershipPlansPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MembershipPlans that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {membershipPlansFindUniqueOrThrowArgs} args - Arguments to find a MembershipPlans
     * @example
     * // Get one MembershipPlans
     * const membershipPlans = await prisma.membershipPlans.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends membershipPlansFindUniqueOrThrowArgs>(args: SelectSubset<T, membershipPlansFindUniqueOrThrowArgs<ExtArgs>>): Prisma__membershipPlansClient<$Result.GetResult<Prisma.$membershipPlansPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MembershipPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {membershipPlansFindFirstArgs} args - Arguments to find a MembershipPlans
     * @example
     * // Get one MembershipPlans
     * const membershipPlans = await prisma.membershipPlans.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends membershipPlansFindFirstArgs>(args?: SelectSubset<T, membershipPlansFindFirstArgs<ExtArgs>>): Prisma__membershipPlansClient<$Result.GetResult<Prisma.$membershipPlansPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MembershipPlans that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {membershipPlansFindFirstOrThrowArgs} args - Arguments to find a MembershipPlans
     * @example
     * // Get one MembershipPlans
     * const membershipPlans = await prisma.membershipPlans.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends membershipPlansFindFirstOrThrowArgs>(args?: SelectSubset<T, membershipPlansFindFirstOrThrowArgs<ExtArgs>>): Prisma__membershipPlansClient<$Result.GetResult<Prisma.$membershipPlansPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MembershipPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {membershipPlansFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MembershipPlans
     * const membershipPlans = await prisma.membershipPlans.findMany()
     * 
     * // Get first 10 MembershipPlans
     * const membershipPlans = await prisma.membershipPlans.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const membershipPlansWithIdOnly = await prisma.membershipPlans.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends membershipPlansFindManyArgs>(args?: SelectSubset<T, membershipPlansFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$membershipPlansPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MembershipPlans.
     * @param {membershipPlansCreateArgs} args - Arguments to create a MembershipPlans.
     * @example
     * // Create one MembershipPlans
     * const MembershipPlans = await prisma.membershipPlans.create({
     *   data: {
     *     // ... data to create a MembershipPlans
     *   }
     * })
     * 
     */
    create<T extends membershipPlansCreateArgs>(args: SelectSubset<T, membershipPlansCreateArgs<ExtArgs>>): Prisma__membershipPlansClient<$Result.GetResult<Prisma.$membershipPlansPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MembershipPlans.
     * @param {membershipPlansCreateManyArgs} args - Arguments to create many MembershipPlans.
     * @example
     * // Create many MembershipPlans
     * const membershipPlans = await prisma.membershipPlans.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends membershipPlansCreateManyArgs>(args?: SelectSubset<T, membershipPlansCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MembershipPlans and returns the data saved in the database.
     * @param {membershipPlansCreateManyAndReturnArgs} args - Arguments to create many MembershipPlans.
     * @example
     * // Create many MembershipPlans
     * const membershipPlans = await prisma.membershipPlans.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MembershipPlans and only return the `id`
     * const membershipPlansWithIdOnly = await prisma.membershipPlans.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends membershipPlansCreateManyAndReturnArgs>(args?: SelectSubset<T, membershipPlansCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$membershipPlansPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MembershipPlans.
     * @param {membershipPlansDeleteArgs} args - Arguments to delete one MembershipPlans.
     * @example
     * // Delete one MembershipPlans
     * const MembershipPlans = await prisma.membershipPlans.delete({
     *   where: {
     *     // ... filter to delete one MembershipPlans
     *   }
     * })
     * 
     */
    delete<T extends membershipPlansDeleteArgs>(args: SelectSubset<T, membershipPlansDeleteArgs<ExtArgs>>): Prisma__membershipPlansClient<$Result.GetResult<Prisma.$membershipPlansPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MembershipPlans.
     * @param {membershipPlansUpdateArgs} args - Arguments to update one MembershipPlans.
     * @example
     * // Update one MembershipPlans
     * const membershipPlans = await prisma.membershipPlans.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends membershipPlansUpdateArgs>(args: SelectSubset<T, membershipPlansUpdateArgs<ExtArgs>>): Prisma__membershipPlansClient<$Result.GetResult<Prisma.$membershipPlansPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MembershipPlans.
     * @param {membershipPlansDeleteManyArgs} args - Arguments to filter MembershipPlans to delete.
     * @example
     * // Delete a few MembershipPlans
     * const { count } = await prisma.membershipPlans.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends membershipPlansDeleteManyArgs>(args?: SelectSubset<T, membershipPlansDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MembershipPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {membershipPlansUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MembershipPlans
     * const membershipPlans = await prisma.membershipPlans.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends membershipPlansUpdateManyArgs>(args: SelectSubset<T, membershipPlansUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MembershipPlans and returns the data updated in the database.
     * @param {membershipPlansUpdateManyAndReturnArgs} args - Arguments to update many MembershipPlans.
     * @example
     * // Update many MembershipPlans
     * const membershipPlans = await prisma.membershipPlans.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MembershipPlans and only return the `id`
     * const membershipPlansWithIdOnly = await prisma.membershipPlans.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends membershipPlansUpdateManyAndReturnArgs>(args: SelectSubset<T, membershipPlansUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$membershipPlansPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MembershipPlans.
     * @param {membershipPlansUpsertArgs} args - Arguments to update or create a MembershipPlans.
     * @example
     * // Update or create a MembershipPlans
     * const membershipPlans = await prisma.membershipPlans.upsert({
     *   create: {
     *     // ... data to create a MembershipPlans
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MembershipPlans we want to update
     *   }
     * })
     */
    upsert<T extends membershipPlansUpsertArgs>(args: SelectSubset<T, membershipPlansUpsertArgs<ExtArgs>>): Prisma__membershipPlansClient<$Result.GetResult<Prisma.$membershipPlansPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MembershipPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {membershipPlansCountArgs} args - Arguments to filter MembershipPlans to count.
     * @example
     * // Count the number of MembershipPlans
     * const count = await prisma.membershipPlans.count({
     *   where: {
     *     // ... the filter for the MembershipPlans we want to count
     *   }
     * })
    **/
    count<T extends membershipPlansCountArgs>(
      args?: Subset<T, membershipPlansCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MembershipPlansCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MembershipPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MembershipPlansAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MembershipPlansAggregateArgs>(args: Subset<T, MembershipPlansAggregateArgs>): Prisma.PrismaPromise<GetMembershipPlansAggregateType<T>>

    /**
     * Group by MembershipPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {membershipPlansGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends membershipPlansGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: membershipPlansGroupByArgs['orderBy'] }
        : { orderBy?: membershipPlansGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, membershipPlansGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMembershipPlansGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the membershipPlans model
   */
  readonly fields: membershipPlansFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for membershipPlans.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__membershipPlansClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    features<T extends membershipPlans$featuresArgs<ExtArgs> = {}>(args?: Subset<T, membershipPlans$featuresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$featuresPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subscriptions<T extends membershipPlans$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, membershipPlans$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the membershipPlans model
   */
  interface membershipPlansFieldRefs {
    readonly id: FieldRef<"membershipPlans", 'Int'>
    readonly plan_name: FieldRef<"membershipPlans", 'String'>
    readonly description: FieldRef<"membershipPlans", 'String'>
    readonly price: FieldRef<"membershipPlans", 'BigInt'>
    readonly duration_days: FieldRef<"membershipPlans", 'Int'>
    readonly is_active: FieldRef<"membershipPlans", 'Boolean'>
    readonly created_at: FieldRef<"membershipPlans", 'DateTime'>
    readonly updated_at: FieldRef<"membershipPlans", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * membershipPlans findUnique
   */
  export type membershipPlansFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the membershipPlans
     */
    select?: membershipPlansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the membershipPlans
     */
    omit?: membershipPlansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: membershipPlansInclude<ExtArgs> | null
    /**
     * Filter, which membershipPlans to fetch.
     */
    where: membershipPlansWhereUniqueInput
  }

  /**
   * membershipPlans findUniqueOrThrow
   */
  export type membershipPlansFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the membershipPlans
     */
    select?: membershipPlansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the membershipPlans
     */
    omit?: membershipPlansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: membershipPlansInclude<ExtArgs> | null
    /**
     * Filter, which membershipPlans to fetch.
     */
    where: membershipPlansWhereUniqueInput
  }

  /**
   * membershipPlans findFirst
   */
  export type membershipPlansFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the membershipPlans
     */
    select?: membershipPlansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the membershipPlans
     */
    omit?: membershipPlansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: membershipPlansInclude<ExtArgs> | null
    /**
     * Filter, which membershipPlans to fetch.
     */
    where?: membershipPlansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of membershipPlans to fetch.
     */
    orderBy?: membershipPlansOrderByWithRelationInput | membershipPlansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for membershipPlans.
     */
    cursor?: membershipPlansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` membershipPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` membershipPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of membershipPlans.
     */
    distinct?: MembershipPlansScalarFieldEnum | MembershipPlansScalarFieldEnum[]
  }

  /**
   * membershipPlans findFirstOrThrow
   */
  export type membershipPlansFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the membershipPlans
     */
    select?: membershipPlansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the membershipPlans
     */
    omit?: membershipPlansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: membershipPlansInclude<ExtArgs> | null
    /**
     * Filter, which membershipPlans to fetch.
     */
    where?: membershipPlansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of membershipPlans to fetch.
     */
    orderBy?: membershipPlansOrderByWithRelationInput | membershipPlansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for membershipPlans.
     */
    cursor?: membershipPlansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` membershipPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` membershipPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of membershipPlans.
     */
    distinct?: MembershipPlansScalarFieldEnum | MembershipPlansScalarFieldEnum[]
  }

  /**
   * membershipPlans findMany
   */
  export type membershipPlansFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the membershipPlans
     */
    select?: membershipPlansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the membershipPlans
     */
    omit?: membershipPlansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: membershipPlansInclude<ExtArgs> | null
    /**
     * Filter, which membershipPlans to fetch.
     */
    where?: membershipPlansWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of membershipPlans to fetch.
     */
    orderBy?: membershipPlansOrderByWithRelationInput | membershipPlansOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing membershipPlans.
     */
    cursor?: membershipPlansWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` membershipPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` membershipPlans.
     */
    skip?: number
    distinct?: MembershipPlansScalarFieldEnum | MembershipPlansScalarFieldEnum[]
  }

  /**
   * membershipPlans create
   */
  export type membershipPlansCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the membershipPlans
     */
    select?: membershipPlansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the membershipPlans
     */
    omit?: membershipPlansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: membershipPlansInclude<ExtArgs> | null
    /**
     * The data needed to create a membershipPlans.
     */
    data: XOR<membershipPlansCreateInput, membershipPlansUncheckedCreateInput>
  }

  /**
   * membershipPlans createMany
   */
  export type membershipPlansCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many membershipPlans.
     */
    data: membershipPlansCreateManyInput | membershipPlansCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * membershipPlans createManyAndReturn
   */
  export type membershipPlansCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the membershipPlans
     */
    select?: membershipPlansSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the membershipPlans
     */
    omit?: membershipPlansOmit<ExtArgs> | null
    /**
     * The data used to create many membershipPlans.
     */
    data: membershipPlansCreateManyInput | membershipPlansCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * membershipPlans update
   */
  export type membershipPlansUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the membershipPlans
     */
    select?: membershipPlansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the membershipPlans
     */
    omit?: membershipPlansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: membershipPlansInclude<ExtArgs> | null
    /**
     * The data needed to update a membershipPlans.
     */
    data: XOR<membershipPlansUpdateInput, membershipPlansUncheckedUpdateInput>
    /**
     * Choose, which membershipPlans to update.
     */
    where: membershipPlansWhereUniqueInput
  }

  /**
   * membershipPlans updateMany
   */
  export type membershipPlansUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update membershipPlans.
     */
    data: XOR<membershipPlansUpdateManyMutationInput, membershipPlansUncheckedUpdateManyInput>
    /**
     * Filter which membershipPlans to update
     */
    where?: membershipPlansWhereInput
    /**
     * Limit how many membershipPlans to update.
     */
    limit?: number
  }

  /**
   * membershipPlans updateManyAndReturn
   */
  export type membershipPlansUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the membershipPlans
     */
    select?: membershipPlansSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the membershipPlans
     */
    omit?: membershipPlansOmit<ExtArgs> | null
    /**
     * The data used to update membershipPlans.
     */
    data: XOR<membershipPlansUpdateManyMutationInput, membershipPlansUncheckedUpdateManyInput>
    /**
     * Filter which membershipPlans to update
     */
    where?: membershipPlansWhereInput
    /**
     * Limit how many membershipPlans to update.
     */
    limit?: number
  }

  /**
   * membershipPlans upsert
   */
  export type membershipPlansUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the membershipPlans
     */
    select?: membershipPlansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the membershipPlans
     */
    omit?: membershipPlansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: membershipPlansInclude<ExtArgs> | null
    /**
     * The filter to search for the membershipPlans to update in case it exists.
     */
    where: membershipPlansWhereUniqueInput
    /**
     * In case the membershipPlans found by the `where` argument doesn't exist, create a new membershipPlans with this data.
     */
    create: XOR<membershipPlansCreateInput, membershipPlansUncheckedCreateInput>
    /**
     * In case the membershipPlans was found with the provided `where` argument, update it with this data.
     */
    update: XOR<membershipPlansUpdateInput, membershipPlansUncheckedUpdateInput>
  }

  /**
   * membershipPlans delete
   */
  export type membershipPlansDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the membershipPlans
     */
    select?: membershipPlansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the membershipPlans
     */
    omit?: membershipPlansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: membershipPlansInclude<ExtArgs> | null
    /**
     * Filter which membershipPlans to delete.
     */
    where: membershipPlansWhereUniqueInput
  }

  /**
   * membershipPlans deleteMany
   */
  export type membershipPlansDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which membershipPlans to delete
     */
    where?: membershipPlansWhereInput
    /**
     * Limit how many membershipPlans to delete.
     */
    limit?: number
  }

  /**
   * membershipPlans.features
   */
  export type membershipPlans$featuresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the features
     */
    select?: featuresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the features
     */
    omit?: featuresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: featuresInclude<ExtArgs> | null
    where?: featuresWhereInput
    orderBy?: featuresOrderByWithRelationInput | featuresOrderByWithRelationInput[]
    cursor?: featuresWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeaturesScalarFieldEnum | FeaturesScalarFieldEnum[]
  }

  /**
   * membershipPlans.subscriptions
   */
  export type membershipPlans$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscriptions
     */
    omit?: subscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsInclude<ExtArgs> | null
    where?: subscriptionsWhereInput
    orderBy?: subscriptionsOrderByWithRelationInput | subscriptionsOrderByWithRelationInput[]
    cursor?: subscriptionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionsScalarFieldEnum | SubscriptionsScalarFieldEnum[]
  }

  /**
   * membershipPlans without action
   */
  export type membershipPlansDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the membershipPlans
     */
    select?: membershipPlansSelect<ExtArgs> | null
    /**
     * Omit specific fields from the membershipPlans
     */
    omit?: membershipPlansOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: membershipPlansInclude<ExtArgs> | null
  }


  /**
   * Model messages
   */

  export type AggregateMessages = {
    _count: MessagesCountAggregateOutputType | null
    _avg: MessagesAvgAggregateOutputType | null
    _sum: MessagesSumAggregateOutputType | null
    _min: MessagesMinAggregateOutputType | null
    _max: MessagesMaxAggregateOutputType | null
  }

  export type MessagesAvgAggregateOutputType = {
    id: number | null
  }

  export type MessagesSumAggregateOutputType = {
    id: number | null
  }

  export type MessagesMinAggregateOutputType = {
    id: number | null
    message_content: string | null
    response_content: string | null
    created_at: Date | null
    user_id: string | null
  }

  export type MessagesMaxAggregateOutputType = {
    id: number | null
    message_content: string | null
    response_content: string | null
    created_at: Date | null
    user_id: string | null
  }

  export type MessagesCountAggregateOutputType = {
    id: number
    message_content: number
    response_content: number
    created_at: number
    user_id: number
    _all: number
  }


  export type MessagesAvgAggregateInputType = {
    id?: true
  }

  export type MessagesSumAggregateInputType = {
    id?: true
  }

  export type MessagesMinAggregateInputType = {
    id?: true
    message_content?: true
    response_content?: true
    created_at?: true
    user_id?: true
  }

  export type MessagesMaxAggregateInputType = {
    id?: true
    message_content?: true
    response_content?: true
    created_at?: true
    user_id?: true
  }

  export type MessagesCountAggregateInputType = {
    id?: true
    message_content?: true
    response_content?: true
    created_at?: true
    user_id?: true
    _all?: true
  }

  export type MessagesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which messages to aggregate.
     */
    where?: messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messages to fetch.
     */
    orderBy?: messagesOrderByWithRelationInput | messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned messages
    **/
    _count?: true | MessagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MessagesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MessagesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessagesMaxAggregateInputType
  }

  export type GetMessagesAggregateType<T extends MessagesAggregateArgs> = {
        [P in keyof T & keyof AggregateMessages]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessages[P]>
      : GetScalarType<T[P], AggregateMessages[P]>
  }




  export type messagesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: messagesWhereInput
    orderBy?: messagesOrderByWithAggregationInput | messagesOrderByWithAggregationInput[]
    by: MessagesScalarFieldEnum[] | MessagesScalarFieldEnum
    having?: messagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessagesCountAggregateInputType | true
    _avg?: MessagesAvgAggregateInputType
    _sum?: MessagesSumAggregateInputType
    _min?: MessagesMinAggregateInputType
    _max?: MessagesMaxAggregateInputType
  }

  export type MessagesGroupByOutputType = {
    id: number
    message_content: string | null
    response_content: string | null
    created_at: Date
    user_id: string
    _count: MessagesCountAggregateOutputType | null
    _avg: MessagesAvgAggregateOutputType | null
    _sum: MessagesSumAggregateOutputType | null
    _min: MessagesMinAggregateOutputType | null
    _max: MessagesMaxAggregateOutputType | null
  }

  type GetMessagesGroupByPayload<T extends messagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessagesGroupByOutputType[P]>
            : GetScalarType<T[P], MessagesGroupByOutputType[P]>
        }
      >
    >


  export type messagesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    message_content?: boolean
    response_content?: boolean
    created_at?: boolean
    user_id?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messages"]>

  export type messagesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    message_content?: boolean
    response_content?: boolean
    created_at?: boolean
    user_id?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messages"]>

  export type messagesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    message_content?: boolean
    response_content?: boolean
    created_at?: boolean
    user_id?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messages"]>

  export type messagesSelectScalar = {
    id?: boolean
    message_content?: boolean
    response_content?: boolean
    created_at?: boolean
    user_id?: boolean
  }

  export type messagesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "message_content" | "response_content" | "created_at" | "user_id", ExtArgs["result"]["messages"]>
  export type messagesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type messagesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type messagesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $messagesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "messages"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      message_content: string | null
      response_content: string | null
      created_at: Date
      user_id: string
    }, ExtArgs["result"]["messages"]>
    composites: {}
  }

  type messagesGetPayload<S extends boolean | null | undefined | messagesDefaultArgs> = $Result.GetResult<Prisma.$messagesPayload, S>

  type messagesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<messagesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessagesCountAggregateInputType | true
    }

  export interface messagesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['messages'], meta: { name: 'messages' } }
    /**
     * Find zero or one Messages that matches the filter.
     * @param {messagesFindUniqueArgs} args - Arguments to find a Messages
     * @example
     * // Get one Messages
     * const messages = await prisma.messages.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends messagesFindUniqueArgs>(args: SelectSubset<T, messagesFindUniqueArgs<ExtArgs>>): Prisma__messagesClient<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Messages that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {messagesFindUniqueOrThrowArgs} args - Arguments to find a Messages
     * @example
     * // Get one Messages
     * const messages = await prisma.messages.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends messagesFindUniqueOrThrowArgs>(args: SelectSubset<T, messagesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__messagesClient<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messagesFindFirstArgs} args - Arguments to find a Messages
     * @example
     * // Get one Messages
     * const messages = await prisma.messages.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends messagesFindFirstArgs>(args?: SelectSubset<T, messagesFindFirstArgs<ExtArgs>>): Prisma__messagesClient<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Messages that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messagesFindFirstOrThrowArgs} args - Arguments to find a Messages
     * @example
     * // Get one Messages
     * const messages = await prisma.messages.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends messagesFindFirstOrThrowArgs>(args?: SelectSubset<T, messagesFindFirstOrThrowArgs<ExtArgs>>): Prisma__messagesClient<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messagesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.messages.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.messages.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messagesWithIdOnly = await prisma.messages.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends messagesFindManyArgs>(args?: SelectSubset<T, messagesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Messages.
     * @param {messagesCreateArgs} args - Arguments to create a Messages.
     * @example
     * // Create one Messages
     * const Messages = await prisma.messages.create({
     *   data: {
     *     // ... data to create a Messages
     *   }
     * })
     * 
     */
    create<T extends messagesCreateArgs>(args: SelectSubset<T, messagesCreateArgs<ExtArgs>>): Prisma__messagesClient<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Messages.
     * @param {messagesCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const messages = await prisma.messages.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends messagesCreateManyArgs>(args?: SelectSubset<T, messagesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {messagesCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const messages = await prisma.messages.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messagesWithIdOnly = await prisma.messages.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends messagesCreateManyAndReturnArgs>(args?: SelectSubset<T, messagesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Messages.
     * @param {messagesDeleteArgs} args - Arguments to delete one Messages.
     * @example
     * // Delete one Messages
     * const Messages = await prisma.messages.delete({
     *   where: {
     *     // ... filter to delete one Messages
     *   }
     * })
     * 
     */
    delete<T extends messagesDeleteArgs>(args: SelectSubset<T, messagesDeleteArgs<ExtArgs>>): Prisma__messagesClient<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Messages.
     * @param {messagesUpdateArgs} args - Arguments to update one Messages.
     * @example
     * // Update one Messages
     * const messages = await prisma.messages.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends messagesUpdateArgs>(args: SelectSubset<T, messagesUpdateArgs<ExtArgs>>): Prisma__messagesClient<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Messages.
     * @param {messagesDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.messages.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends messagesDeleteManyArgs>(args?: SelectSubset<T, messagesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const messages = await prisma.messages.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends messagesUpdateManyArgs>(args: SelectSubset<T, messagesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages and returns the data updated in the database.
     * @param {messagesUpdateManyAndReturnArgs} args - Arguments to update many Messages.
     * @example
     * // Update many Messages
     * const messages = await prisma.messages.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Messages and only return the `id`
     * const messagesWithIdOnly = await prisma.messages.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends messagesUpdateManyAndReturnArgs>(args: SelectSubset<T, messagesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Messages.
     * @param {messagesUpsertArgs} args - Arguments to update or create a Messages.
     * @example
     * // Update or create a Messages
     * const messages = await prisma.messages.upsert({
     *   create: {
     *     // ... data to create a Messages
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Messages we want to update
     *   }
     * })
     */
    upsert<T extends messagesUpsertArgs>(args: SelectSubset<T, messagesUpsertArgs<ExtArgs>>): Prisma__messagesClient<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messagesCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.messages.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends messagesCountArgs>(
      args?: Subset<T, messagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessagesAggregateArgs>(args: Subset<T, MessagesAggregateArgs>): Prisma.PrismaPromise<GetMessagesAggregateType<T>>

    /**
     * Group by Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {messagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends messagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: messagesGroupByArgs['orderBy'] }
        : { orderBy?: messagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, messagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the messages model
   */
  readonly fields: messagesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for messages.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__messagesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the messages model
   */
  interface messagesFieldRefs {
    readonly id: FieldRef<"messages", 'Int'>
    readonly message_content: FieldRef<"messages", 'String'>
    readonly response_content: FieldRef<"messages", 'String'>
    readonly created_at: FieldRef<"messages", 'DateTime'>
    readonly user_id: FieldRef<"messages", 'String'>
  }
    

  // Custom InputTypes
  /**
   * messages findUnique
   */
  export type messagesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    /**
     * Filter, which messages to fetch.
     */
    where: messagesWhereUniqueInput
  }

  /**
   * messages findUniqueOrThrow
   */
  export type messagesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    /**
     * Filter, which messages to fetch.
     */
    where: messagesWhereUniqueInput
  }

  /**
   * messages findFirst
   */
  export type messagesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    /**
     * Filter, which messages to fetch.
     */
    where?: messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messages to fetch.
     */
    orderBy?: messagesOrderByWithRelationInput | messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for messages.
     */
    cursor?: messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of messages.
     */
    distinct?: MessagesScalarFieldEnum | MessagesScalarFieldEnum[]
  }

  /**
   * messages findFirstOrThrow
   */
  export type messagesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    /**
     * Filter, which messages to fetch.
     */
    where?: messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messages to fetch.
     */
    orderBy?: messagesOrderByWithRelationInput | messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for messages.
     */
    cursor?: messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of messages.
     */
    distinct?: MessagesScalarFieldEnum | MessagesScalarFieldEnum[]
  }

  /**
   * messages findMany
   */
  export type messagesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    /**
     * Filter, which messages to fetch.
     */
    where?: messagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of messages to fetch.
     */
    orderBy?: messagesOrderByWithRelationInput | messagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing messages.
     */
    cursor?: messagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` messages.
     */
    skip?: number
    distinct?: MessagesScalarFieldEnum | MessagesScalarFieldEnum[]
  }

  /**
   * messages create
   */
  export type messagesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    /**
     * The data needed to create a messages.
     */
    data: XOR<messagesCreateInput, messagesUncheckedCreateInput>
  }

  /**
   * messages createMany
   */
  export type messagesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many messages.
     */
    data: messagesCreateManyInput | messagesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * messages createManyAndReturn
   */
  export type messagesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * The data used to create many messages.
     */
    data: messagesCreateManyInput | messagesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * messages update
   */
  export type messagesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    /**
     * The data needed to update a messages.
     */
    data: XOR<messagesUpdateInput, messagesUncheckedUpdateInput>
    /**
     * Choose, which messages to update.
     */
    where: messagesWhereUniqueInput
  }

  /**
   * messages updateMany
   */
  export type messagesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update messages.
     */
    data: XOR<messagesUpdateManyMutationInput, messagesUncheckedUpdateManyInput>
    /**
     * Filter which messages to update
     */
    where?: messagesWhereInput
    /**
     * Limit how many messages to update.
     */
    limit?: number
  }

  /**
   * messages updateManyAndReturn
   */
  export type messagesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * The data used to update messages.
     */
    data: XOR<messagesUpdateManyMutationInput, messagesUncheckedUpdateManyInput>
    /**
     * Filter which messages to update
     */
    where?: messagesWhereInput
    /**
     * Limit how many messages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * messages upsert
   */
  export type messagesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    /**
     * The filter to search for the messages to update in case it exists.
     */
    where: messagesWhereUniqueInput
    /**
     * In case the messages found by the `where` argument doesn't exist, create a new messages with this data.
     */
    create: XOR<messagesCreateInput, messagesUncheckedCreateInput>
    /**
     * In case the messages was found with the provided `where` argument, update it with this data.
     */
    update: XOR<messagesUpdateInput, messagesUncheckedUpdateInput>
  }

  /**
   * messages delete
   */
  export type messagesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    /**
     * Filter which messages to delete.
     */
    where: messagesWhereUniqueInput
  }

  /**
   * messages deleteMany
   */
  export type messagesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which messages to delete
     */
    where?: messagesWhereInput
    /**
     * Limit how many messages to delete.
     */
    limit?: number
  }

  /**
   * messages without action
   */
  export type messagesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
  }


  /**
   * Model payments
   */

  export type AggregatePayments = {
    _count: PaymentsCountAggregateOutputType | null
    _avg: PaymentsAvgAggregateOutputType | null
    _sum: PaymentsSumAggregateOutputType | null
    _min: PaymentsMinAggregateOutputType | null
    _max: PaymentsMaxAggregateOutputType | null
  }

  export type PaymentsAvgAggregateOutputType = {
    amount: number | null
  }

  export type PaymentsSumAggregateOutputType = {
    amount: bigint | null
  }

  export type PaymentsMinAggregateOutputType = {
    id: string | null
    amount: bigint | null
    currency: string | null
    payment_gateway: $Enums.PaymentGateway | null
    payment_method: $Enums.PaymentMethod | null
    transaction_id: string | null
    status: $Enums.PaymentStatus | null
    created_at: Date | null
    user_id: string | null
  }

  export type PaymentsMaxAggregateOutputType = {
    id: string | null
    amount: bigint | null
    currency: string | null
    payment_gateway: $Enums.PaymentGateway | null
    payment_method: $Enums.PaymentMethod | null
    transaction_id: string | null
    status: $Enums.PaymentStatus | null
    created_at: Date | null
    user_id: string | null
  }

  export type PaymentsCountAggregateOutputType = {
    id: number
    amount: number
    currency: number
    payment_gateway: number
    payment_method: number
    transaction_id: number
    status: number
    created_at: number
    user_id: number
    _all: number
  }


  export type PaymentsAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentsSumAggregateInputType = {
    amount?: true
  }

  export type PaymentsMinAggregateInputType = {
    id?: true
    amount?: true
    currency?: true
    payment_gateway?: true
    payment_method?: true
    transaction_id?: true
    status?: true
    created_at?: true
    user_id?: true
  }

  export type PaymentsMaxAggregateInputType = {
    id?: true
    amount?: true
    currency?: true
    payment_gateway?: true
    payment_method?: true
    transaction_id?: true
    status?: true
    created_at?: true
    user_id?: true
  }

  export type PaymentsCountAggregateInputType = {
    id?: true
    amount?: true
    currency?: true
    payment_gateway?: true
    payment_method?: true
    transaction_id?: true
    status?: true
    created_at?: true
    user_id?: true
    _all?: true
  }

  export type PaymentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payments to aggregate.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned payments
    **/
    _count?: true | PaymentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentsMaxAggregateInputType
  }

  export type GetPaymentsAggregateType<T extends PaymentsAggregateArgs> = {
        [P in keyof T & keyof AggregatePayments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayments[P]>
      : GetScalarType<T[P], AggregatePayments[P]>
  }




  export type paymentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paymentsWhereInput
    orderBy?: paymentsOrderByWithAggregationInput | paymentsOrderByWithAggregationInput[]
    by: PaymentsScalarFieldEnum[] | PaymentsScalarFieldEnum
    having?: paymentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentsCountAggregateInputType | true
    _avg?: PaymentsAvgAggregateInputType
    _sum?: PaymentsSumAggregateInputType
    _min?: PaymentsMinAggregateInputType
    _max?: PaymentsMaxAggregateInputType
  }

  export type PaymentsGroupByOutputType = {
    id: string
    amount: bigint
    currency: string | null
    payment_gateway: $Enums.PaymentGateway
    payment_method: $Enums.PaymentMethod
    transaction_id: string | null
    status: $Enums.PaymentStatus
    created_at: Date
    user_id: string
    _count: PaymentsCountAggregateOutputType | null
    _avg: PaymentsAvgAggregateOutputType | null
    _sum: PaymentsSumAggregateOutputType | null
    _min: PaymentsMinAggregateOutputType | null
    _max: PaymentsMaxAggregateOutputType | null
  }

  type GetPaymentsGroupByPayload<T extends paymentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentsGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentsGroupByOutputType[P]>
        }
      >
    >


  export type paymentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    currency?: boolean
    payment_gateway?: boolean
    payment_method?: boolean
    transaction_id?: boolean
    status?: boolean
    created_at?: boolean
    user_id?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
    subscriptions?: boolean | payments$subscriptionsArgs<ExtArgs>
  }, ExtArgs["result"]["payments"]>

  export type paymentsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    currency?: boolean
    payment_gateway?: boolean
    payment_method?: boolean
    transaction_id?: boolean
    status?: boolean
    created_at?: boolean
    user_id?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payments"]>

  export type paymentsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    currency?: boolean
    payment_gateway?: boolean
    payment_method?: boolean
    transaction_id?: boolean
    status?: boolean
    created_at?: boolean
    user_id?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payments"]>

  export type paymentsSelectScalar = {
    id?: boolean
    amount?: boolean
    currency?: boolean
    payment_gateway?: boolean
    payment_method?: boolean
    transaction_id?: boolean
    status?: boolean
    created_at?: boolean
    user_id?: boolean
  }

  export type paymentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "amount" | "currency" | "payment_gateway" | "payment_method" | "transaction_id" | "status" | "created_at" | "user_id", ExtArgs["result"]["payments"]>
  export type paymentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
    subscriptions?: boolean | payments$subscriptionsArgs<ExtArgs>
  }
  export type paymentsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type paymentsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $paymentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "payments"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
      subscriptions: Prisma.$subscriptionsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      amount: bigint
      currency: string | null
      payment_gateway: $Enums.PaymentGateway
      payment_method: $Enums.PaymentMethod
      transaction_id: string | null
      status: $Enums.PaymentStatus
      created_at: Date
      user_id: string
    }, ExtArgs["result"]["payments"]>
    composites: {}
  }

  type paymentsGetPayload<S extends boolean | null | undefined | paymentsDefaultArgs> = $Result.GetResult<Prisma.$paymentsPayload, S>

  type paymentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<paymentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentsCountAggregateInputType | true
    }

  export interface paymentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['payments'], meta: { name: 'payments' } }
    /**
     * Find zero or one Payments that matches the filter.
     * @param {paymentsFindUniqueArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends paymentsFindUniqueArgs>(args: SelectSubset<T, paymentsFindUniqueArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payments that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {paymentsFindUniqueOrThrowArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends paymentsFindUniqueOrThrowArgs>(args: SelectSubset<T, paymentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsFindFirstArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends paymentsFindFirstArgs>(args?: SelectSubset<T, paymentsFindFirstArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsFindFirstOrThrowArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends paymentsFindFirstOrThrowArgs>(args?: SelectSubset<T, paymentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payments.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentsWithIdOnly = await prisma.payments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends paymentsFindManyArgs>(args?: SelectSubset<T, paymentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payments.
     * @param {paymentsCreateArgs} args - Arguments to create a Payments.
     * @example
     * // Create one Payments
     * const Payments = await prisma.payments.create({
     *   data: {
     *     // ... data to create a Payments
     *   }
     * })
     * 
     */
    create<T extends paymentsCreateArgs>(args: SelectSubset<T, paymentsCreateArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {paymentsCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payments = await prisma.payments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends paymentsCreateManyArgs>(args?: SelectSubset<T, paymentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {paymentsCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payments = await prisma.payments.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentsWithIdOnly = await prisma.payments.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends paymentsCreateManyAndReturnArgs>(args?: SelectSubset<T, paymentsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payments.
     * @param {paymentsDeleteArgs} args - Arguments to delete one Payments.
     * @example
     * // Delete one Payments
     * const Payments = await prisma.payments.delete({
     *   where: {
     *     // ... filter to delete one Payments
     *   }
     * })
     * 
     */
    delete<T extends paymentsDeleteArgs>(args: SelectSubset<T, paymentsDeleteArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payments.
     * @param {paymentsUpdateArgs} args - Arguments to update one Payments.
     * @example
     * // Update one Payments
     * const payments = await prisma.payments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends paymentsUpdateArgs>(args: SelectSubset<T, paymentsUpdateArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {paymentsDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends paymentsDeleteManyArgs>(args?: SelectSubset<T, paymentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payments = await prisma.payments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends paymentsUpdateManyArgs>(args: SelectSubset<T, paymentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {paymentsUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payments = await prisma.payments.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentsWithIdOnly = await prisma.payments.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends paymentsUpdateManyAndReturnArgs>(args: SelectSubset<T, paymentsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payments.
     * @param {paymentsUpsertArgs} args - Arguments to update or create a Payments.
     * @example
     * // Update or create a Payments
     * const payments = await prisma.payments.upsert({
     *   create: {
     *     // ... data to create a Payments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payments we want to update
     *   }
     * })
     */
    upsert<T extends paymentsUpsertArgs>(args: SelectSubset<T, paymentsUpsertArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payments.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends paymentsCountArgs>(
      args?: Subset<T, paymentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentsAggregateArgs>(args: Subset<T, PaymentsAggregateArgs>): Prisma.PrismaPromise<GetPaymentsAggregateType<T>>

    /**
     * Group by Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends paymentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: paymentsGroupByArgs['orderBy'] }
        : { orderBy?: paymentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, paymentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the payments model
   */
  readonly fields: paymentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for payments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__paymentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subscriptions<T extends payments$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, payments$subscriptionsArgs<ExtArgs>>): Prisma__subscriptionsClient<$Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the payments model
   */
  interface paymentsFieldRefs {
    readonly id: FieldRef<"payments", 'String'>
    readonly amount: FieldRef<"payments", 'BigInt'>
    readonly currency: FieldRef<"payments", 'String'>
    readonly payment_gateway: FieldRef<"payments", 'PaymentGateway'>
    readonly payment_method: FieldRef<"payments", 'PaymentMethod'>
    readonly transaction_id: FieldRef<"payments", 'String'>
    readonly status: FieldRef<"payments", 'PaymentStatus'>
    readonly created_at: FieldRef<"payments", 'DateTime'>
    readonly user_id: FieldRef<"payments", 'String'>
  }
    

  // Custom InputTypes
  /**
   * payments findUnique
   */
  export type paymentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments findUniqueOrThrow
   */
  export type paymentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments findFirst
   */
  export type paymentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payments.
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payments.
     */
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * payments findFirstOrThrow
   */
  export type paymentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payments.
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payments.
     */
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * payments findMany
   */
  export type paymentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing payments.
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * payments create
   */
  export type paymentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * The data needed to create a payments.
     */
    data: XOR<paymentsCreateInput, paymentsUncheckedCreateInput>
  }

  /**
   * payments createMany
   */
  export type paymentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many payments.
     */
    data: paymentsCreateManyInput | paymentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * payments createManyAndReturn
   */
  export type paymentsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * The data used to create many payments.
     */
    data: paymentsCreateManyInput | paymentsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * payments update
   */
  export type paymentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * The data needed to update a payments.
     */
    data: XOR<paymentsUpdateInput, paymentsUncheckedUpdateInput>
    /**
     * Choose, which payments to update.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments updateMany
   */
  export type paymentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update payments.
     */
    data: XOR<paymentsUpdateManyMutationInput, paymentsUncheckedUpdateManyInput>
    /**
     * Filter which payments to update
     */
    where?: paymentsWhereInput
    /**
     * Limit how many payments to update.
     */
    limit?: number
  }

  /**
   * payments updateManyAndReturn
   */
  export type paymentsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * The data used to update payments.
     */
    data: XOR<paymentsUpdateManyMutationInput, paymentsUncheckedUpdateManyInput>
    /**
     * Filter which payments to update
     */
    where?: paymentsWhereInput
    /**
     * Limit how many payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * payments upsert
   */
  export type paymentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * The filter to search for the payments to update in case it exists.
     */
    where: paymentsWhereUniqueInput
    /**
     * In case the payments found by the `where` argument doesn't exist, create a new payments with this data.
     */
    create: XOR<paymentsCreateInput, paymentsUncheckedCreateInput>
    /**
     * In case the payments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<paymentsUpdateInput, paymentsUncheckedUpdateInput>
  }

  /**
   * payments delete
   */
  export type paymentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter which payments to delete.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments deleteMany
   */
  export type paymentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payments to delete
     */
    where?: paymentsWhereInput
    /**
     * Limit how many payments to delete.
     */
    limit?: number
  }

  /**
   * payments.subscriptions
   */
  export type payments$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscriptions
     */
    omit?: subscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsInclude<ExtArgs> | null
    where?: subscriptionsWhereInput
  }

  /**
   * payments without action
   */
  export type paymentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
  }


  /**
   * Model personalityTestResults
   */

  export type AggregatePersonalityTestResults = {
    _count: PersonalityTestResultsCountAggregateOutputType | null
    _avg: PersonalityTestResultsAvgAggregateOutputType | null
    _sum: PersonalityTestResultsSumAggregateOutputType | null
    _min: PersonalityTestResultsMinAggregateOutputType | null
    _max: PersonalityTestResultsMaxAggregateOutputType | null
  }

  export type PersonalityTestResultsAvgAggregateOutputType = {
    question_id: number | null
    answer_id: number | null
  }

  export type PersonalityTestResultsSumAggregateOutputType = {
    question_id: number | null
    answer_id: number | null
  }

  export type PersonalityTestResultsMinAggregateOutputType = {
    user_id: string | null
    question_id: number | null
    answer_id: number | null
  }

  export type PersonalityTestResultsMaxAggregateOutputType = {
    user_id: string | null
    question_id: number | null
    answer_id: number | null
  }

  export type PersonalityTestResultsCountAggregateOutputType = {
    user_id: number
    question_id: number
    answer_id: number
    _all: number
  }


  export type PersonalityTestResultsAvgAggregateInputType = {
    question_id?: true
    answer_id?: true
  }

  export type PersonalityTestResultsSumAggregateInputType = {
    question_id?: true
    answer_id?: true
  }

  export type PersonalityTestResultsMinAggregateInputType = {
    user_id?: true
    question_id?: true
    answer_id?: true
  }

  export type PersonalityTestResultsMaxAggregateInputType = {
    user_id?: true
    question_id?: true
    answer_id?: true
  }

  export type PersonalityTestResultsCountAggregateInputType = {
    user_id?: true
    question_id?: true
    answer_id?: true
    _all?: true
  }

  export type PersonalityTestResultsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which personalityTestResults to aggregate.
     */
    where?: personalityTestResultsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of personalityTestResults to fetch.
     */
    orderBy?: personalityTestResultsOrderByWithRelationInput | personalityTestResultsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: personalityTestResultsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` personalityTestResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` personalityTestResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned personalityTestResults
    **/
    _count?: true | PersonalityTestResultsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PersonalityTestResultsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PersonalityTestResultsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PersonalityTestResultsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PersonalityTestResultsMaxAggregateInputType
  }

  export type GetPersonalityTestResultsAggregateType<T extends PersonalityTestResultsAggregateArgs> = {
        [P in keyof T & keyof AggregatePersonalityTestResults]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePersonalityTestResults[P]>
      : GetScalarType<T[P], AggregatePersonalityTestResults[P]>
  }




  export type personalityTestResultsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: personalityTestResultsWhereInput
    orderBy?: personalityTestResultsOrderByWithAggregationInput | personalityTestResultsOrderByWithAggregationInput[]
    by: PersonalityTestResultsScalarFieldEnum[] | PersonalityTestResultsScalarFieldEnum
    having?: personalityTestResultsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PersonalityTestResultsCountAggregateInputType | true
    _avg?: PersonalityTestResultsAvgAggregateInputType
    _sum?: PersonalityTestResultsSumAggregateInputType
    _min?: PersonalityTestResultsMinAggregateInputType
    _max?: PersonalityTestResultsMaxAggregateInputType
  }

  export type PersonalityTestResultsGroupByOutputType = {
    user_id: string
    question_id: number
    answer_id: number
    _count: PersonalityTestResultsCountAggregateOutputType | null
    _avg: PersonalityTestResultsAvgAggregateOutputType | null
    _sum: PersonalityTestResultsSumAggregateOutputType | null
    _min: PersonalityTestResultsMinAggregateOutputType | null
    _max: PersonalityTestResultsMaxAggregateOutputType | null
  }

  type GetPersonalityTestResultsGroupByPayload<T extends personalityTestResultsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PersonalityTestResultsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PersonalityTestResultsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PersonalityTestResultsGroupByOutputType[P]>
            : GetScalarType<T[P], PersonalityTestResultsGroupByOutputType[P]>
        }
      >
    >


  export type personalityTestResultsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    question_id?: boolean
    answer_id?: boolean
    answers?: boolean | answersDefaultArgs<ExtArgs>
    questions?: boolean | questionsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["personalityTestResults"]>

  export type personalityTestResultsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    question_id?: boolean
    answer_id?: boolean
    answers?: boolean | answersDefaultArgs<ExtArgs>
    questions?: boolean | questionsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["personalityTestResults"]>

  export type personalityTestResultsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    question_id?: boolean
    answer_id?: boolean
    answers?: boolean | answersDefaultArgs<ExtArgs>
    questions?: boolean | questionsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["personalityTestResults"]>

  export type personalityTestResultsSelectScalar = {
    user_id?: boolean
    question_id?: boolean
    answer_id?: boolean
  }

  export type personalityTestResultsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"user_id" | "question_id" | "answer_id", ExtArgs["result"]["personalityTestResults"]>
  export type personalityTestResultsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    answers?: boolean | answersDefaultArgs<ExtArgs>
    questions?: boolean | questionsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type personalityTestResultsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    answers?: boolean | answersDefaultArgs<ExtArgs>
    questions?: boolean | questionsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type personalityTestResultsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    answers?: boolean | answersDefaultArgs<ExtArgs>
    questions?: boolean | questionsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $personalityTestResultsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "personalityTestResults"
    objects: {
      answers: Prisma.$answersPayload<ExtArgs>
      questions: Prisma.$questionsPayload<ExtArgs>
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      user_id: string
      question_id: number
      answer_id: number
    }, ExtArgs["result"]["personalityTestResults"]>
    composites: {}
  }

  type personalityTestResultsGetPayload<S extends boolean | null | undefined | personalityTestResultsDefaultArgs> = $Result.GetResult<Prisma.$personalityTestResultsPayload, S>

  type personalityTestResultsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<personalityTestResultsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PersonalityTestResultsCountAggregateInputType | true
    }

  export interface personalityTestResultsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['personalityTestResults'], meta: { name: 'personalityTestResults' } }
    /**
     * Find zero or one PersonalityTestResults that matches the filter.
     * @param {personalityTestResultsFindUniqueArgs} args - Arguments to find a PersonalityTestResults
     * @example
     * // Get one PersonalityTestResults
     * const personalityTestResults = await prisma.personalityTestResults.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends personalityTestResultsFindUniqueArgs>(args: SelectSubset<T, personalityTestResultsFindUniqueArgs<ExtArgs>>): Prisma__personalityTestResultsClient<$Result.GetResult<Prisma.$personalityTestResultsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PersonalityTestResults that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {personalityTestResultsFindUniqueOrThrowArgs} args - Arguments to find a PersonalityTestResults
     * @example
     * // Get one PersonalityTestResults
     * const personalityTestResults = await prisma.personalityTestResults.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends personalityTestResultsFindUniqueOrThrowArgs>(args: SelectSubset<T, personalityTestResultsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__personalityTestResultsClient<$Result.GetResult<Prisma.$personalityTestResultsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PersonalityTestResults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {personalityTestResultsFindFirstArgs} args - Arguments to find a PersonalityTestResults
     * @example
     * // Get one PersonalityTestResults
     * const personalityTestResults = await prisma.personalityTestResults.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends personalityTestResultsFindFirstArgs>(args?: SelectSubset<T, personalityTestResultsFindFirstArgs<ExtArgs>>): Prisma__personalityTestResultsClient<$Result.GetResult<Prisma.$personalityTestResultsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PersonalityTestResults that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {personalityTestResultsFindFirstOrThrowArgs} args - Arguments to find a PersonalityTestResults
     * @example
     * // Get one PersonalityTestResults
     * const personalityTestResults = await prisma.personalityTestResults.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends personalityTestResultsFindFirstOrThrowArgs>(args?: SelectSubset<T, personalityTestResultsFindFirstOrThrowArgs<ExtArgs>>): Prisma__personalityTestResultsClient<$Result.GetResult<Prisma.$personalityTestResultsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PersonalityTestResults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {personalityTestResultsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PersonalityTestResults
     * const personalityTestResults = await prisma.personalityTestResults.findMany()
     * 
     * // Get first 10 PersonalityTestResults
     * const personalityTestResults = await prisma.personalityTestResults.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const personalityTestResultsWithUser_idOnly = await prisma.personalityTestResults.findMany({ select: { user_id: true } })
     * 
     */
    findMany<T extends personalityTestResultsFindManyArgs>(args?: SelectSubset<T, personalityTestResultsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$personalityTestResultsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PersonalityTestResults.
     * @param {personalityTestResultsCreateArgs} args - Arguments to create a PersonalityTestResults.
     * @example
     * // Create one PersonalityTestResults
     * const PersonalityTestResults = await prisma.personalityTestResults.create({
     *   data: {
     *     // ... data to create a PersonalityTestResults
     *   }
     * })
     * 
     */
    create<T extends personalityTestResultsCreateArgs>(args: SelectSubset<T, personalityTestResultsCreateArgs<ExtArgs>>): Prisma__personalityTestResultsClient<$Result.GetResult<Prisma.$personalityTestResultsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PersonalityTestResults.
     * @param {personalityTestResultsCreateManyArgs} args - Arguments to create many PersonalityTestResults.
     * @example
     * // Create many PersonalityTestResults
     * const personalityTestResults = await prisma.personalityTestResults.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends personalityTestResultsCreateManyArgs>(args?: SelectSubset<T, personalityTestResultsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PersonalityTestResults and returns the data saved in the database.
     * @param {personalityTestResultsCreateManyAndReturnArgs} args - Arguments to create many PersonalityTestResults.
     * @example
     * // Create many PersonalityTestResults
     * const personalityTestResults = await prisma.personalityTestResults.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PersonalityTestResults and only return the `user_id`
     * const personalityTestResultsWithUser_idOnly = await prisma.personalityTestResults.createManyAndReturn({
     *   select: { user_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends personalityTestResultsCreateManyAndReturnArgs>(args?: SelectSubset<T, personalityTestResultsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$personalityTestResultsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PersonalityTestResults.
     * @param {personalityTestResultsDeleteArgs} args - Arguments to delete one PersonalityTestResults.
     * @example
     * // Delete one PersonalityTestResults
     * const PersonalityTestResults = await prisma.personalityTestResults.delete({
     *   where: {
     *     // ... filter to delete one PersonalityTestResults
     *   }
     * })
     * 
     */
    delete<T extends personalityTestResultsDeleteArgs>(args: SelectSubset<T, personalityTestResultsDeleteArgs<ExtArgs>>): Prisma__personalityTestResultsClient<$Result.GetResult<Prisma.$personalityTestResultsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PersonalityTestResults.
     * @param {personalityTestResultsUpdateArgs} args - Arguments to update one PersonalityTestResults.
     * @example
     * // Update one PersonalityTestResults
     * const personalityTestResults = await prisma.personalityTestResults.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends personalityTestResultsUpdateArgs>(args: SelectSubset<T, personalityTestResultsUpdateArgs<ExtArgs>>): Prisma__personalityTestResultsClient<$Result.GetResult<Prisma.$personalityTestResultsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PersonalityTestResults.
     * @param {personalityTestResultsDeleteManyArgs} args - Arguments to filter PersonalityTestResults to delete.
     * @example
     * // Delete a few PersonalityTestResults
     * const { count } = await prisma.personalityTestResults.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends personalityTestResultsDeleteManyArgs>(args?: SelectSubset<T, personalityTestResultsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PersonalityTestResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {personalityTestResultsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PersonalityTestResults
     * const personalityTestResults = await prisma.personalityTestResults.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends personalityTestResultsUpdateManyArgs>(args: SelectSubset<T, personalityTestResultsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PersonalityTestResults and returns the data updated in the database.
     * @param {personalityTestResultsUpdateManyAndReturnArgs} args - Arguments to update many PersonalityTestResults.
     * @example
     * // Update many PersonalityTestResults
     * const personalityTestResults = await prisma.personalityTestResults.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PersonalityTestResults and only return the `user_id`
     * const personalityTestResultsWithUser_idOnly = await prisma.personalityTestResults.updateManyAndReturn({
     *   select: { user_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends personalityTestResultsUpdateManyAndReturnArgs>(args: SelectSubset<T, personalityTestResultsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$personalityTestResultsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PersonalityTestResults.
     * @param {personalityTestResultsUpsertArgs} args - Arguments to update or create a PersonalityTestResults.
     * @example
     * // Update or create a PersonalityTestResults
     * const personalityTestResults = await prisma.personalityTestResults.upsert({
     *   create: {
     *     // ... data to create a PersonalityTestResults
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PersonalityTestResults we want to update
     *   }
     * })
     */
    upsert<T extends personalityTestResultsUpsertArgs>(args: SelectSubset<T, personalityTestResultsUpsertArgs<ExtArgs>>): Prisma__personalityTestResultsClient<$Result.GetResult<Prisma.$personalityTestResultsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PersonalityTestResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {personalityTestResultsCountArgs} args - Arguments to filter PersonalityTestResults to count.
     * @example
     * // Count the number of PersonalityTestResults
     * const count = await prisma.personalityTestResults.count({
     *   where: {
     *     // ... the filter for the PersonalityTestResults we want to count
     *   }
     * })
    **/
    count<T extends personalityTestResultsCountArgs>(
      args?: Subset<T, personalityTestResultsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PersonalityTestResultsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PersonalityTestResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalityTestResultsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PersonalityTestResultsAggregateArgs>(args: Subset<T, PersonalityTestResultsAggregateArgs>): Prisma.PrismaPromise<GetPersonalityTestResultsAggregateType<T>>

    /**
     * Group by PersonalityTestResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {personalityTestResultsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends personalityTestResultsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: personalityTestResultsGroupByArgs['orderBy'] }
        : { orderBy?: personalityTestResultsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, personalityTestResultsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersonalityTestResultsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the personalityTestResults model
   */
  readonly fields: personalityTestResultsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for personalityTestResults.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__personalityTestResultsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    answers<T extends answersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, answersDefaultArgs<ExtArgs>>): Prisma__answersClient<$Result.GetResult<Prisma.$answersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    questions<T extends questionsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, questionsDefaultArgs<ExtArgs>>): Prisma__questionsClient<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the personalityTestResults model
   */
  interface personalityTestResultsFieldRefs {
    readonly user_id: FieldRef<"personalityTestResults", 'String'>
    readonly question_id: FieldRef<"personalityTestResults", 'Int'>
    readonly answer_id: FieldRef<"personalityTestResults", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * personalityTestResults findUnique
   */
  export type personalityTestResultsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the personalityTestResults
     */
    select?: personalityTestResultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the personalityTestResults
     */
    omit?: personalityTestResultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: personalityTestResultsInclude<ExtArgs> | null
    /**
     * Filter, which personalityTestResults to fetch.
     */
    where: personalityTestResultsWhereUniqueInput
  }

  /**
   * personalityTestResults findUniqueOrThrow
   */
  export type personalityTestResultsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the personalityTestResults
     */
    select?: personalityTestResultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the personalityTestResults
     */
    omit?: personalityTestResultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: personalityTestResultsInclude<ExtArgs> | null
    /**
     * Filter, which personalityTestResults to fetch.
     */
    where: personalityTestResultsWhereUniqueInput
  }

  /**
   * personalityTestResults findFirst
   */
  export type personalityTestResultsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the personalityTestResults
     */
    select?: personalityTestResultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the personalityTestResults
     */
    omit?: personalityTestResultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: personalityTestResultsInclude<ExtArgs> | null
    /**
     * Filter, which personalityTestResults to fetch.
     */
    where?: personalityTestResultsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of personalityTestResults to fetch.
     */
    orderBy?: personalityTestResultsOrderByWithRelationInput | personalityTestResultsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for personalityTestResults.
     */
    cursor?: personalityTestResultsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` personalityTestResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` personalityTestResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of personalityTestResults.
     */
    distinct?: PersonalityTestResultsScalarFieldEnum | PersonalityTestResultsScalarFieldEnum[]
  }

  /**
   * personalityTestResults findFirstOrThrow
   */
  export type personalityTestResultsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the personalityTestResults
     */
    select?: personalityTestResultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the personalityTestResults
     */
    omit?: personalityTestResultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: personalityTestResultsInclude<ExtArgs> | null
    /**
     * Filter, which personalityTestResults to fetch.
     */
    where?: personalityTestResultsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of personalityTestResults to fetch.
     */
    orderBy?: personalityTestResultsOrderByWithRelationInput | personalityTestResultsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for personalityTestResults.
     */
    cursor?: personalityTestResultsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` personalityTestResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` personalityTestResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of personalityTestResults.
     */
    distinct?: PersonalityTestResultsScalarFieldEnum | PersonalityTestResultsScalarFieldEnum[]
  }

  /**
   * personalityTestResults findMany
   */
  export type personalityTestResultsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the personalityTestResults
     */
    select?: personalityTestResultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the personalityTestResults
     */
    omit?: personalityTestResultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: personalityTestResultsInclude<ExtArgs> | null
    /**
     * Filter, which personalityTestResults to fetch.
     */
    where?: personalityTestResultsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of personalityTestResults to fetch.
     */
    orderBy?: personalityTestResultsOrderByWithRelationInput | personalityTestResultsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing personalityTestResults.
     */
    cursor?: personalityTestResultsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` personalityTestResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` personalityTestResults.
     */
    skip?: number
    distinct?: PersonalityTestResultsScalarFieldEnum | PersonalityTestResultsScalarFieldEnum[]
  }

  /**
   * personalityTestResults create
   */
  export type personalityTestResultsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the personalityTestResults
     */
    select?: personalityTestResultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the personalityTestResults
     */
    omit?: personalityTestResultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: personalityTestResultsInclude<ExtArgs> | null
    /**
     * The data needed to create a personalityTestResults.
     */
    data: XOR<personalityTestResultsCreateInput, personalityTestResultsUncheckedCreateInput>
  }

  /**
   * personalityTestResults createMany
   */
  export type personalityTestResultsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many personalityTestResults.
     */
    data: personalityTestResultsCreateManyInput | personalityTestResultsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * personalityTestResults createManyAndReturn
   */
  export type personalityTestResultsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the personalityTestResults
     */
    select?: personalityTestResultsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the personalityTestResults
     */
    omit?: personalityTestResultsOmit<ExtArgs> | null
    /**
     * The data used to create many personalityTestResults.
     */
    data: personalityTestResultsCreateManyInput | personalityTestResultsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: personalityTestResultsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * personalityTestResults update
   */
  export type personalityTestResultsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the personalityTestResults
     */
    select?: personalityTestResultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the personalityTestResults
     */
    omit?: personalityTestResultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: personalityTestResultsInclude<ExtArgs> | null
    /**
     * The data needed to update a personalityTestResults.
     */
    data: XOR<personalityTestResultsUpdateInput, personalityTestResultsUncheckedUpdateInput>
    /**
     * Choose, which personalityTestResults to update.
     */
    where: personalityTestResultsWhereUniqueInput
  }

  /**
   * personalityTestResults updateMany
   */
  export type personalityTestResultsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update personalityTestResults.
     */
    data: XOR<personalityTestResultsUpdateManyMutationInput, personalityTestResultsUncheckedUpdateManyInput>
    /**
     * Filter which personalityTestResults to update
     */
    where?: personalityTestResultsWhereInput
    /**
     * Limit how many personalityTestResults to update.
     */
    limit?: number
  }

  /**
   * personalityTestResults updateManyAndReturn
   */
  export type personalityTestResultsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the personalityTestResults
     */
    select?: personalityTestResultsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the personalityTestResults
     */
    omit?: personalityTestResultsOmit<ExtArgs> | null
    /**
     * The data used to update personalityTestResults.
     */
    data: XOR<personalityTestResultsUpdateManyMutationInput, personalityTestResultsUncheckedUpdateManyInput>
    /**
     * Filter which personalityTestResults to update
     */
    where?: personalityTestResultsWhereInput
    /**
     * Limit how many personalityTestResults to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: personalityTestResultsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * personalityTestResults upsert
   */
  export type personalityTestResultsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the personalityTestResults
     */
    select?: personalityTestResultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the personalityTestResults
     */
    omit?: personalityTestResultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: personalityTestResultsInclude<ExtArgs> | null
    /**
     * The filter to search for the personalityTestResults to update in case it exists.
     */
    where: personalityTestResultsWhereUniqueInput
    /**
     * In case the personalityTestResults found by the `where` argument doesn't exist, create a new personalityTestResults with this data.
     */
    create: XOR<personalityTestResultsCreateInput, personalityTestResultsUncheckedCreateInput>
    /**
     * In case the personalityTestResults was found with the provided `where` argument, update it with this data.
     */
    update: XOR<personalityTestResultsUpdateInput, personalityTestResultsUncheckedUpdateInput>
  }

  /**
   * personalityTestResults delete
   */
  export type personalityTestResultsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the personalityTestResults
     */
    select?: personalityTestResultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the personalityTestResults
     */
    omit?: personalityTestResultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: personalityTestResultsInclude<ExtArgs> | null
    /**
     * Filter which personalityTestResults to delete.
     */
    where: personalityTestResultsWhereUniqueInput
  }

  /**
   * personalityTestResults deleteMany
   */
  export type personalityTestResultsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which personalityTestResults to delete
     */
    where?: personalityTestResultsWhereInput
    /**
     * Limit how many personalityTestResults to delete.
     */
    limit?: number
  }

  /**
   * personalityTestResults without action
   */
  export type personalityTestResultsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the personalityTestResults
     */
    select?: personalityTestResultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the personalityTestResults
     */
    omit?: personalityTestResultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: personalityTestResultsInclude<ExtArgs> | null
  }


  /**
   * Model projects
   */

  export type AggregateProjects = {
    _count: ProjectsCountAggregateOutputType | null
    _avg: ProjectsAvgAggregateOutputType | null
    _sum: ProjectsSumAggregateOutputType | null
    _min: ProjectsMinAggregateOutputType | null
    _max: ProjectsMaxAggregateOutputType | null
  }

  export type ProjectsAvgAggregateOutputType = {
    id: number | null
    cv_id: number | null
  }

  export type ProjectsSumAggregateOutputType = {
    id: number | null
    cv_id: number | null
  }

  export type ProjectsMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    start_date: Date | null
    end_date: Date | null
    cv_id: number | null
  }

  export type ProjectsMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    start_date: Date | null
    end_date: Date | null
    cv_id: number | null
  }

  export type ProjectsCountAggregateOutputType = {
    id: number
    title: number
    description: number
    start_date: number
    end_date: number
    cv_id: number
    _all: number
  }


  export type ProjectsAvgAggregateInputType = {
    id?: true
    cv_id?: true
  }

  export type ProjectsSumAggregateInputType = {
    id?: true
    cv_id?: true
  }

  export type ProjectsMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    start_date?: true
    end_date?: true
    cv_id?: true
  }

  export type ProjectsMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    start_date?: true
    end_date?: true
    cv_id?: true
  }

  export type ProjectsCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    start_date?: true
    end_date?: true
    cv_id?: true
    _all?: true
  }

  export type ProjectsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which projects to aggregate.
     */
    where?: projectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projects to fetch.
     */
    orderBy?: projectsOrderByWithRelationInput | projectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: projectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned projects
    **/
    _count?: true | ProjectsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectsMaxAggregateInputType
  }

  export type GetProjectsAggregateType<T extends ProjectsAggregateArgs> = {
        [P in keyof T & keyof AggregateProjects]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjects[P]>
      : GetScalarType<T[P], AggregateProjects[P]>
  }




  export type projectsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: projectsWhereInput
    orderBy?: projectsOrderByWithAggregationInput | projectsOrderByWithAggregationInput[]
    by: ProjectsScalarFieldEnum[] | ProjectsScalarFieldEnum
    having?: projectsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectsCountAggregateInputType | true
    _avg?: ProjectsAvgAggregateInputType
    _sum?: ProjectsSumAggregateInputType
    _min?: ProjectsMinAggregateInputType
    _max?: ProjectsMaxAggregateInputType
  }

  export type ProjectsGroupByOutputType = {
    id: number
    title: string
    description: string | null
    start_date: Date | null
    end_date: Date | null
    cv_id: number
    _count: ProjectsCountAggregateOutputType | null
    _avg: ProjectsAvgAggregateOutputType | null
    _sum: ProjectsSumAggregateOutputType | null
    _min: ProjectsMinAggregateOutputType | null
    _max: ProjectsMaxAggregateOutputType | null
  }

  type GetProjectsGroupByPayload<T extends projectsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectsGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectsGroupByOutputType[P]>
        }
      >
    >


  export type projectsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    start_date?: boolean
    end_date?: boolean
    cv_id?: boolean
    cvs?: boolean | cvsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projects"]>

  export type projectsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    start_date?: boolean
    end_date?: boolean
    cv_id?: boolean
    cvs?: boolean | cvsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projects"]>

  export type projectsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    start_date?: boolean
    end_date?: boolean
    cv_id?: boolean
    cvs?: boolean | cvsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projects"]>

  export type projectsSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    start_date?: boolean
    end_date?: boolean
    cv_id?: boolean
  }

  export type projectsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "start_date" | "end_date" | "cv_id", ExtArgs["result"]["projects"]>
  export type projectsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cvs?: boolean | cvsDefaultArgs<ExtArgs>
  }
  export type projectsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cvs?: boolean | cvsDefaultArgs<ExtArgs>
  }
  export type projectsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cvs?: boolean | cvsDefaultArgs<ExtArgs>
  }

  export type $projectsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "projects"
    objects: {
      cvs: Prisma.$cvsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      description: string | null
      start_date: Date | null
      end_date: Date | null
      cv_id: number
    }, ExtArgs["result"]["projects"]>
    composites: {}
  }

  type projectsGetPayload<S extends boolean | null | undefined | projectsDefaultArgs> = $Result.GetResult<Prisma.$projectsPayload, S>

  type projectsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<projectsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectsCountAggregateInputType | true
    }

  export interface projectsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['projects'], meta: { name: 'projects' } }
    /**
     * Find zero or one Projects that matches the filter.
     * @param {projectsFindUniqueArgs} args - Arguments to find a Projects
     * @example
     * // Get one Projects
     * const projects = await prisma.projects.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends projectsFindUniqueArgs>(args: SelectSubset<T, projectsFindUniqueArgs<ExtArgs>>): Prisma__projectsClient<$Result.GetResult<Prisma.$projectsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Projects that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {projectsFindUniqueOrThrowArgs} args - Arguments to find a Projects
     * @example
     * // Get one Projects
     * const projects = await prisma.projects.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends projectsFindUniqueOrThrowArgs>(args: SelectSubset<T, projectsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__projectsClient<$Result.GetResult<Prisma.$projectsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projectsFindFirstArgs} args - Arguments to find a Projects
     * @example
     * // Get one Projects
     * const projects = await prisma.projects.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends projectsFindFirstArgs>(args?: SelectSubset<T, projectsFindFirstArgs<ExtArgs>>): Prisma__projectsClient<$Result.GetResult<Prisma.$projectsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Projects that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projectsFindFirstOrThrowArgs} args - Arguments to find a Projects
     * @example
     * // Get one Projects
     * const projects = await prisma.projects.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends projectsFindFirstOrThrowArgs>(args?: SelectSubset<T, projectsFindFirstOrThrowArgs<ExtArgs>>): Prisma__projectsClient<$Result.GetResult<Prisma.$projectsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projectsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.projects.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.projects.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectsWithIdOnly = await prisma.projects.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends projectsFindManyArgs>(args?: SelectSubset<T, projectsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projectsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Projects.
     * @param {projectsCreateArgs} args - Arguments to create a Projects.
     * @example
     * // Create one Projects
     * const Projects = await prisma.projects.create({
     *   data: {
     *     // ... data to create a Projects
     *   }
     * })
     * 
     */
    create<T extends projectsCreateArgs>(args: SelectSubset<T, projectsCreateArgs<ExtArgs>>): Prisma__projectsClient<$Result.GetResult<Prisma.$projectsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Projects.
     * @param {projectsCreateManyArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const projects = await prisma.projects.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends projectsCreateManyArgs>(args?: SelectSubset<T, projectsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Projects and returns the data saved in the database.
     * @param {projectsCreateManyAndReturnArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const projects = await prisma.projects.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Projects and only return the `id`
     * const projectsWithIdOnly = await prisma.projects.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends projectsCreateManyAndReturnArgs>(args?: SelectSubset<T, projectsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projectsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Projects.
     * @param {projectsDeleteArgs} args - Arguments to delete one Projects.
     * @example
     * // Delete one Projects
     * const Projects = await prisma.projects.delete({
     *   where: {
     *     // ... filter to delete one Projects
     *   }
     * })
     * 
     */
    delete<T extends projectsDeleteArgs>(args: SelectSubset<T, projectsDeleteArgs<ExtArgs>>): Prisma__projectsClient<$Result.GetResult<Prisma.$projectsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Projects.
     * @param {projectsUpdateArgs} args - Arguments to update one Projects.
     * @example
     * // Update one Projects
     * const projects = await prisma.projects.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends projectsUpdateArgs>(args: SelectSubset<T, projectsUpdateArgs<ExtArgs>>): Prisma__projectsClient<$Result.GetResult<Prisma.$projectsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Projects.
     * @param {projectsDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.projects.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends projectsDeleteManyArgs>(args?: SelectSubset<T, projectsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projectsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const projects = await prisma.projects.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends projectsUpdateManyArgs>(args: SelectSubset<T, projectsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects and returns the data updated in the database.
     * @param {projectsUpdateManyAndReturnArgs} args - Arguments to update many Projects.
     * @example
     * // Update many Projects
     * const projects = await prisma.projects.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Projects and only return the `id`
     * const projectsWithIdOnly = await prisma.projects.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends projectsUpdateManyAndReturnArgs>(args: SelectSubset<T, projectsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$projectsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Projects.
     * @param {projectsUpsertArgs} args - Arguments to update or create a Projects.
     * @example
     * // Update or create a Projects
     * const projects = await prisma.projects.upsert({
     *   create: {
     *     // ... data to create a Projects
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Projects we want to update
     *   }
     * })
     */
    upsert<T extends projectsUpsertArgs>(args: SelectSubset<T, projectsUpsertArgs<ExtArgs>>): Prisma__projectsClient<$Result.GetResult<Prisma.$projectsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projectsCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.projects.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends projectsCountArgs>(
      args?: Subset<T, projectsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectsAggregateArgs>(args: Subset<T, ProjectsAggregateArgs>): Prisma.PrismaPromise<GetProjectsAggregateType<T>>

    /**
     * Group by Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {projectsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends projectsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: projectsGroupByArgs['orderBy'] }
        : { orderBy?: projectsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, projectsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the projects model
   */
  readonly fields: projectsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for projects.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__projectsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cvs<T extends cvsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, cvsDefaultArgs<ExtArgs>>): Prisma__cvsClient<$Result.GetResult<Prisma.$cvsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the projects model
   */
  interface projectsFieldRefs {
    readonly id: FieldRef<"projects", 'Int'>
    readonly title: FieldRef<"projects", 'String'>
    readonly description: FieldRef<"projects", 'String'>
    readonly start_date: FieldRef<"projects", 'DateTime'>
    readonly end_date: FieldRef<"projects", 'DateTime'>
    readonly cv_id: FieldRef<"projects", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * projects findUnique
   */
  export type projectsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projects
     */
    select?: projectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projects
     */
    omit?: projectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectsInclude<ExtArgs> | null
    /**
     * Filter, which projects to fetch.
     */
    where: projectsWhereUniqueInput
  }

  /**
   * projects findUniqueOrThrow
   */
  export type projectsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projects
     */
    select?: projectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projects
     */
    omit?: projectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectsInclude<ExtArgs> | null
    /**
     * Filter, which projects to fetch.
     */
    where: projectsWhereUniqueInput
  }

  /**
   * projects findFirst
   */
  export type projectsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projects
     */
    select?: projectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projects
     */
    omit?: projectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectsInclude<ExtArgs> | null
    /**
     * Filter, which projects to fetch.
     */
    where?: projectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projects to fetch.
     */
    orderBy?: projectsOrderByWithRelationInput | projectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for projects.
     */
    cursor?: projectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of projects.
     */
    distinct?: ProjectsScalarFieldEnum | ProjectsScalarFieldEnum[]
  }

  /**
   * projects findFirstOrThrow
   */
  export type projectsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projects
     */
    select?: projectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projects
     */
    omit?: projectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectsInclude<ExtArgs> | null
    /**
     * Filter, which projects to fetch.
     */
    where?: projectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projects to fetch.
     */
    orderBy?: projectsOrderByWithRelationInput | projectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for projects.
     */
    cursor?: projectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of projects.
     */
    distinct?: ProjectsScalarFieldEnum | ProjectsScalarFieldEnum[]
  }

  /**
   * projects findMany
   */
  export type projectsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projects
     */
    select?: projectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projects
     */
    omit?: projectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectsInclude<ExtArgs> | null
    /**
     * Filter, which projects to fetch.
     */
    where?: projectsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of projects to fetch.
     */
    orderBy?: projectsOrderByWithRelationInput | projectsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing projects.
     */
    cursor?: projectsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` projects.
     */
    skip?: number
    distinct?: ProjectsScalarFieldEnum | ProjectsScalarFieldEnum[]
  }

  /**
   * projects create
   */
  export type projectsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projects
     */
    select?: projectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projects
     */
    omit?: projectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectsInclude<ExtArgs> | null
    /**
     * The data needed to create a projects.
     */
    data: XOR<projectsCreateInput, projectsUncheckedCreateInput>
  }

  /**
   * projects createMany
   */
  export type projectsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many projects.
     */
    data: projectsCreateManyInput | projectsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * projects createManyAndReturn
   */
  export type projectsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projects
     */
    select?: projectsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the projects
     */
    omit?: projectsOmit<ExtArgs> | null
    /**
     * The data used to create many projects.
     */
    data: projectsCreateManyInput | projectsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * projects update
   */
  export type projectsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projects
     */
    select?: projectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projects
     */
    omit?: projectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectsInclude<ExtArgs> | null
    /**
     * The data needed to update a projects.
     */
    data: XOR<projectsUpdateInput, projectsUncheckedUpdateInput>
    /**
     * Choose, which projects to update.
     */
    where: projectsWhereUniqueInput
  }

  /**
   * projects updateMany
   */
  export type projectsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update projects.
     */
    data: XOR<projectsUpdateManyMutationInput, projectsUncheckedUpdateManyInput>
    /**
     * Filter which projects to update
     */
    where?: projectsWhereInput
    /**
     * Limit how many projects to update.
     */
    limit?: number
  }

  /**
   * projects updateManyAndReturn
   */
  export type projectsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projects
     */
    select?: projectsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the projects
     */
    omit?: projectsOmit<ExtArgs> | null
    /**
     * The data used to update projects.
     */
    data: XOR<projectsUpdateManyMutationInput, projectsUncheckedUpdateManyInput>
    /**
     * Filter which projects to update
     */
    where?: projectsWhereInput
    /**
     * Limit how many projects to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * projects upsert
   */
  export type projectsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projects
     */
    select?: projectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projects
     */
    omit?: projectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectsInclude<ExtArgs> | null
    /**
     * The filter to search for the projects to update in case it exists.
     */
    where: projectsWhereUniqueInput
    /**
     * In case the projects found by the `where` argument doesn't exist, create a new projects with this data.
     */
    create: XOR<projectsCreateInput, projectsUncheckedCreateInput>
    /**
     * In case the projects was found with the provided `where` argument, update it with this data.
     */
    update: XOR<projectsUpdateInput, projectsUncheckedUpdateInput>
  }

  /**
   * projects delete
   */
  export type projectsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projects
     */
    select?: projectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projects
     */
    omit?: projectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectsInclude<ExtArgs> | null
    /**
     * Filter which projects to delete.
     */
    where: projectsWhereUniqueInput
  }

  /**
   * projects deleteMany
   */
  export type projectsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which projects to delete
     */
    where?: projectsWhereInput
    /**
     * Limit how many projects to delete.
     */
    limit?: number
  }

  /**
   * projects without action
   */
  export type projectsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the projects
     */
    select?: projectsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the projects
     */
    omit?: projectsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: projectsInclude<ExtArgs> | null
  }


  /**
   * Model questions
   */

  export type AggregateQuestions = {
    _count: QuestionsCountAggregateOutputType | null
    _avg: QuestionsAvgAggregateOutputType | null
    _sum: QuestionsSumAggregateOutputType | null
    _min: QuestionsMinAggregateOutputType | null
    _max: QuestionsMaxAggregateOutputType | null
  }

  export type QuestionsAvgAggregateOutputType = {
    id: number | null
  }

  export type QuestionsSumAggregateOutputType = {
    id: number | null
  }

  export type QuestionsMinAggregateOutputType = {
    id: number | null
    question: string | null
  }

  export type QuestionsMaxAggregateOutputType = {
    id: number | null
    question: string | null
  }

  export type QuestionsCountAggregateOutputType = {
    id: number
    question: number
    _all: number
  }


  export type QuestionsAvgAggregateInputType = {
    id?: true
  }

  export type QuestionsSumAggregateInputType = {
    id?: true
  }

  export type QuestionsMinAggregateInputType = {
    id?: true
    question?: true
  }

  export type QuestionsMaxAggregateInputType = {
    id?: true
    question?: true
  }

  export type QuestionsCountAggregateInputType = {
    id?: true
    question?: true
    _all?: true
  }

  export type QuestionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which questions to aggregate.
     */
    where?: questionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questions to fetch.
     */
    orderBy?: questionsOrderByWithRelationInput | questionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: questionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned questions
    **/
    _count?: true | QuestionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuestionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuestionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionsMaxAggregateInputType
  }

  export type GetQuestionsAggregateType<T extends QuestionsAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestions[P]>
      : GetScalarType<T[P], AggregateQuestions[P]>
  }




  export type questionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: questionsWhereInput
    orderBy?: questionsOrderByWithAggregationInput | questionsOrderByWithAggregationInput[]
    by: QuestionsScalarFieldEnum[] | QuestionsScalarFieldEnum
    having?: questionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionsCountAggregateInputType | true
    _avg?: QuestionsAvgAggregateInputType
    _sum?: QuestionsSumAggregateInputType
    _min?: QuestionsMinAggregateInputType
    _max?: QuestionsMaxAggregateInputType
  }

  export type QuestionsGroupByOutputType = {
    id: number
    question: string
    _count: QuestionsCountAggregateOutputType | null
    _avg: QuestionsAvgAggregateOutputType | null
    _sum: QuestionsSumAggregateOutputType | null
    _min: QuestionsMinAggregateOutputType | null
    _max: QuestionsMaxAggregateOutputType | null
  }

  type GetQuestionsGroupByPayload<T extends questionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionsGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionsGroupByOutputType[P]>
        }
      >
    >


  export type questionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    question?: boolean
    answers?: boolean | questions$answersArgs<ExtArgs>
    personalityTestResults?: boolean | questions$personalityTestResultsArgs<ExtArgs>
    _count?: boolean | QuestionsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questions"]>

  export type questionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    question?: boolean
  }, ExtArgs["result"]["questions"]>

  export type questionsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    question?: boolean
  }, ExtArgs["result"]["questions"]>

  export type questionsSelectScalar = {
    id?: boolean
    question?: boolean
  }

  export type questionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "question", ExtArgs["result"]["questions"]>
  export type questionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    answers?: boolean | questions$answersArgs<ExtArgs>
    personalityTestResults?: boolean | questions$personalityTestResultsArgs<ExtArgs>
    _count?: boolean | QuestionsCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type questionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type questionsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $questionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "questions"
    objects: {
      answers: Prisma.$answersPayload<ExtArgs>[]
      personalityTestResults: Prisma.$personalityTestResultsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      question: string
    }, ExtArgs["result"]["questions"]>
    composites: {}
  }

  type questionsGetPayload<S extends boolean | null | undefined | questionsDefaultArgs> = $Result.GetResult<Prisma.$questionsPayload, S>

  type questionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<questionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuestionsCountAggregateInputType | true
    }

  export interface questionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['questions'], meta: { name: 'questions' } }
    /**
     * Find zero or one Questions that matches the filter.
     * @param {questionsFindUniqueArgs} args - Arguments to find a Questions
     * @example
     * // Get one Questions
     * const questions = await prisma.questions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends questionsFindUniqueArgs>(args: SelectSubset<T, questionsFindUniqueArgs<ExtArgs>>): Prisma__questionsClient<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Questions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {questionsFindUniqueOrThrowArgs} args - Arguments to find a Questions
     * @example
     * // Get one Questions
     * const questions = await prisma.questions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends questionsFindUniqueOrThrowArgs>(args: SelectSubset<T, questionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__questionsClient<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Questions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionsFindFirstArgs} args - Arguments to find a Questions
     * @example
     * // Get one Questions
     * const questions = await prisma.questions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends questionsFindFirstArgs>(args?: SelectSubset<T, questionsFindFirstArgs<ExtArgs>>): Prisma__questionsClient<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Questions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionsFindFirstOrThrowArgs} args - Arguments to find a Questions
     * @example
     * // Get one Questions
     * const questions = await prisma.questions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends questionsFindFirstOrThrowArgs>(args?: SelectSubset<T, questionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__questionsClient<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Questions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Questions
     * const questions = await prisma.questions.findMany()
     * 
     * // Get first 10 Questions
     * const questions = await prisma.questions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionsWithIdOnly = await prisma.questions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends questionsFindManyArgs>(args?: SelectSubset<T, questionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Questions.
     * @param {questionsCreateArgs} args - Arguments to create a Questions.
     * @example
     * // Create one Questions
     * const Questions = await prisma.questions.create({
     *   data: {
     *     // ... data to create a Questions
     *   }
     * })
     * 
     */
    create<T extends questionsCreateArgs>(args: SelectSubset<T, questionsCreateArgs<ExtArgs>>): Prisma__questionsClient<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Questions.
     * @param {questionsCreateManyArgs} args - Arguments to create many Questions.
     * @example
     * // Create many Questions
     * const questions = await prisma.questions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends questionsCreateManyArgs>(args?: SelectSubset<T, questionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Questions and returns the data saved in the database.
     * @param {questionsCreateManyAndReturnArgs} args - Arguments to create many Questions.
     * @example
     * // Create many Questions
     * const questions = await prisma.questions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Questions and only return the `id`
     * const questionsWithIdOnly = await prisma.questions.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends questionsCreateManyAndReturnArgs>(args?: SelectSubset<T, questionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Questions.
     * @param {questionsDeleteArgs} args - Arguments to delete one Questions.
     * @example
     * // Delete one Questions
     * const Questions = await prisma.questions.delete({
     *   where: {
     *     // ... filter to delete one Questions
     *   }
     * })
     * 
     */
    delete<T extends questionsDeleteArgs>(args: SelectSubset<T, questionsDeleteArgs<ExtArgs>>): Prisma__questionsClient<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Questions.
     * @param {questionsUpdateArgs} args - Arguments to update one Questions.
     * @example
     * // Update one Questions
     * const questions = await prisma.questions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends questionsUpdateArgs>(args: SelectSubset<T, questionsUpdateArgs<ExtArgs>>): Prisma__questionsClient<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Questions.
     * @param {questionsDeleteManyArgs} args - Arguments to filter Questions to delete.
     * @example
     * // Delete a few Questions
     * const { count } = await prisma.questions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends questionsDeleteManyArgs>(args?: SelectSubset<T, questionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Questions
     * const questions = await prisma.questions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends questionsUpdateManyArgs>(args: SelectSubset<T, questionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Questions and returns the data updated in the database.
     * @param {questionsUpdateManyAndReturnArgs} args - Arguments to update many Questions.
     * @example
     * // Update many Questions
     * const questions = await prisma.questions.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Questions and only return the `id`
     * const questionsWithIdOnly = await prisma.questions.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends questionsUpdateManyAndReturnArgs>(args: SelectSubset<T, questionsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Questions.
     * @param {questionsUpsertArgs} args - Arguments to update or create a Questions.
     * @example
     * // Update or create a Questions
     * const questions = await prisma.questions.upsert({
     *   create: {
     *     // ... data to create a Questions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Questions we want to update
     *   }
     * })
     */
    upsert<T extends questionsUpsertArgs>(args: SelectSubset<T, questionsUpsertArgs<ExtArgs>>): Prisma__questionsClient<$Result.GetResult<Prisma.$questionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionsCountArgs} args - Arguments to filter Questions to count.
     * @example
     * // Count the number of Questions
     * const count = await prisma.questions.count({
     *   where: {
     *     // ... the filter for the Questions we want to count
     *   }
     * })
    **/
    count<T extends questionsCountArgs>(
      args?: Subset<T, questionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionsAggregateArgs>(args: Subset<T, QuestionsAggregateArgs>): Prisma.PrismaPromise<GetQuestionsAggregateType<T>>

    /**
     * Group by Questions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {questionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends questionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: questionsGroupByArgs['orderBy'] }
        : { orderBy?: questionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, questionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the questions model
   */
  readonly fields: questionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for questions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__questionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    answers<T extends questions$answersArgs<ExtArgs> = {}>(args?: Subset<T, questions$answersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$answersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    personalityTestResults<T extends questions$personalityTestResultsArgs<ExtArgs> = {}>(args?: Subset<T, questions$personalityTestResultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$personalityTestResultsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the questions model
   */
  interface questionsFieldRefs {
    readonly id: FieldRef<"questions", 'Int'>
    readonly question: FieldRef<"questions", 'String'>
  }
    

  // Custom InputTypes
  /**
   * questions findUnique
   */
  export type questionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the questions
     */
    omit?: questionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
    /**
     * Filter, which questions to fetch.
     */
    where: questionsWhereUniqueInput
  }

  /**
   * questions findUniqueOrThrow
   */
  export type questionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the questions
     */
    omit?: questionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
    /**
     * Filter, which questions to fetch.
     */
    where: questionsWhereUniqueInput
  }

  /**
   * questions findFirst
   */
  export type questionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the questions
     */
    omit?: questionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
    /**
     * Filter, which questions to fetch.
     */
    where?: questionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questions to fetch.
     */
    orderBy?: questionsOrderByWithRelationInput | questionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for questions.
     */
    cursor?: questionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of questions.
     */
    distinct?: QuestionsScalarFieldEnum | QuestionsScalarFieldEnum[]
  }

  /**
   * questions findFirstOrThrow
   */
  export type questionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the questions
     */
    omit?: questionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
    /**
     * Filter, which questions to fetch.
     */
    where?: questionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questions to fetch.
     */
    orderBy?: questionsOrderByWithRelationInput | questionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for questions.
     */
    cursor?: questionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of questions.
     */
    distinct?: QuestionsScalarFieldEnum | QuestionsScalarFieldEnum[]
  }

  /**
   * questions findMany
   */
  export type questionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the questions
     */
    omit?: questionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
    /**
     * Filter, which questions to fetch.
     */
    where?: questionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of questions to fetch.
     */
    orderBy?: questionsOrderByWithRelationInput | questionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing questions.
     */
    cursor?: questionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` questions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` questions.
     */
    skip?: number
    distinct?: QuestionsScalarFieldEnum | QuestionsScalarFieldEnum[]
  }

  /**
   * questions create
   */
  export type questionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the questions
     */
    omit?: questionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
    /**
     * The data needed to create a questions.
     */
    data: XOR<questionsCreateInput, questionsUncheckedCreateInput>
  }

  /**
   * questions createMany
   */
  export type questionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many questions.
     */
    data: questionsCreateManyInput | questionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * questions createManyAndReturn
   */
  export type questionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the questions
     */
    omit?: questionsOmit<ExtArgs> | null
    /**
     * The data used to create many questions.
     */
    data: questionsCreateManyInput | questionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * questions update
   */
  export type questionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the questions
     */
    omit?: questionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
    /**
     * The data needed to update a questions.
     */
    data: XOR<questionsUpdateInput, questionsUncheckedUpdateInput>
    /**
     * Choose, which questions to update.
     */
    where: questionsWhereUniqueInput
  }

  /**
   * questions updateMany
   */
  export type questionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update questions.
     */
    data: XOR<questionsUpdateManyMutationInput, questionsUncheckedUpdateManyInput>
    /**
     * Filter which questions to update
     */
    where?: questionsWhereInput
    /**
     * Limit how many questions to update.
     */
    limit?: number
  }

  /**
   * questions updateManyAndReturn
   */
  export type questionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the questions
     */
    omit?: questionsOmit<ExtArgs> | null
    /**
     * The data used to update questions.
     */
    data: XOR<questionsUpdateManyMutationInput, questionsUncheckedUpdateManyInput>
    /**
     * Filter which questions to update
     */
    where?: questionsWhereInput
    /**
     * Limit how many questions to update.
     */
    limit?: number
  }

  /**
   * questions upsert
   */
  export type questionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the questions
     */
    omit?: questionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
    /**
     * The filter to search for the questions to update in case it exists.
     */
    where: questionsWhereUniqueInput
    /**
     * In case the questions found by the `where` argument doesn't exist, create a new questions with this data.
     */
    create: XOR<questionsCreateInput, questionsUncheckedCreateInput>
    /**
     * In case the questions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<questionsUpdateInput, questionsUncheckedUpdateInput>
  }

  /**
   * questions delete
   */
  export type questionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the questions
     */
    omit?: questionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
    /**
     * Filter which questions to delete.
     */
    where: questionsWhereUniqueInput
  }

  /**
   * questions deleteMany
   */
  export type questionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which questions to delete
     */
    where?: questionsWhereInput
    /**
     * Limit how many questions to delete.
     */
    limit?: number
  }

  /**
   * questions.answers
   */
  export type questions$answersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the answers
     */
    select?: answersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the answers
     */
    omit?: answersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: answersInclude<ExtArgs> | null
    where?: answersWhereInput
    orderBy?: answersOrderByWithRelationInput | answersOrderByWithRelationInput[]
    cursor?: answersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AnswersScalarFieldEnum | AnswersScalarFieldEnum[]
  }

  /**
   * questions.personalityTestResults
   */
  export type questions$personalityTestResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the personalityTestResults
     */
    select?: personalityTestResultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the personalityTestResults
     */
    omit?: personalityTestResultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: personalityTestResultsInclude<ExtArgs> | null
    where?: personalityTestResultsWhereInput
    orderBy?: personalityTestResultsOrderByWithRelationInput | personalityTestResultsOrderByWithRelationInput[]
    cursor?: personalityTestResultsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersonalityTestResultsScalarFieldEnum | PersonalityTestResultsScalarFieldEnum[]
  }

  /**
   * questions without action
   */
  export type questionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the questions
     */
    select?: questionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the questions
     */
    omit?: questionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: questionsInclude<ExtArgs> | null
  }


  /**
   * Model references
   */

  export type AggregateReferences = {
    _count: ReferencesCountAggregateOutputType | null
    _avg: ReferencesAvgAggregateOutputType | null
    _sum: ReferencesSumAggregateOutputType | null
    _min: ReferencesMinAggregateOutputType | null
    _max: ReferencesMaxAggregateOutputType | null
  }

  export type ReferencesAvgAggregateOutputType = {
    id: number | null
    cv_id: number | null
  }

  export type ReferencesSumAggregateOutputType = {
    id: number | null
    cv_id: number | null
  }

  export type ReferencesMinAggregateOutputType = {
    id: number | null
    name: string | null
    phone: string | null
    email: string | null
    cv_id: number | null
  }

  export type ReferencesMaxAggregateOutputType = {
    id: number | null
    name: string | null
    phone: string | null
    email: string | null
    cv_id: number | null
  }

  export type ReferencesCountAggregateOutputType = {
    id: number
    name: number
    phone: number
    email: number
    cv_id: number
    _all: number
  }


  export type ReferencesAvgAggregateInputType = {
    id?: true
    cv_id?: true
  }

  export type ReferencesSumAggregateInputType = {
    id?: true
    cv_id?: true
  }

  export type ReferencesMinAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    email?: true
    cv_id?: true
  }

  export type ReferencesMaxAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    email?: true
    cv_id?: true
  }

  export type ReferencesCountAggregateInputType = {
    id?: true
    name?: true
    phone?: true
    email?: true
    cv_id?: true
    _all?: true
  }

  export type ReferencesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which references to aggregate.
     */
    where?: referencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of references to fetch.
     */
    orderBy?: referencesOrderByWithRelationInput | referencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: referencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` references from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` references.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned references
    **/
    _count?: true | ReferencesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReferencesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReferencesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReferencesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReferencesMaxAggregateInputType
  }

  export type GetReferencesAggregateType<T extends ReferencesAggregateArgs> = {
        [P in keyof T & keyof AggregateReferences]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReferences[P]>
      : GetScalarType<T[P], AggregateReferences[P]>
  }




  export type referencesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: referencesWhereInput
    orderBy?: referencesOrderByWithAggregationInput | referencesOrderByWithAggregationInput[]
    by: ReferencesScalarFieldEnum[] | ReferencesScalarFieldEnum
    having?: referencesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReferencesCountAggregateInputType | true
    _avg?: ReferencesAvgAggregateInputType
    _sum?: ReferencesSumAggregateInputType
    _min?: ReferencesMinAggregateInputType
    _max?: ReferencesMaxAggregateInputType
  }

  export type ReferencesGroupByOutputType = {
    id: number
    name: string
    phone: string | null
    email: string | null
    cv_id: number
    _count: ReferencesCountAggregateOutputType | null
    _avg: ReferencesAvgAggregateOutputType | null
    _sum: ReferencesSumAggregateOutputType | null
    _min: ReferencesMinAggregateOutputType | null
    _max: ReferencesMaxAggregateOutputType | null
  }

  type GetReferencesGroupByPayload<T extends referencesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReferencesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReferencesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReferencesGroupByOutputType[P]>
            : GetScalarType<T[P], ReferencesGroupByOutputType[P]>
        }
      >
    >


  export type referencesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    cv_id?: boolean
    cvs?: boolean | cvsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["references"]>

  export type referencesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    cv_id?: boolean
    cvs?: boolean | cvsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["references"]>

  export type referencesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    cv_id?: boolean
    cvs?: boolean | cvsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["references"]>

  export type referencesSelectScalar = {
    id?: boolean
    name?: boolean
    phone?: boolean
    email?: boolean
    cv_id?: boolean
  }

  export type referencesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "phone" | "email" | "cv_id", ExtArgs["result"]["references"]>
  export type referencesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cvs?: boolean | cvsDefaultArgs<ExtArgs>
  }
  export type referencesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cvs?: boolean | cvsDefaultArgs<ExtArgs>
  }
  export type referencesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cvs?: boolean | cvsDefaultArgs<ExtArgs>
  }

  export type $referencesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "references"
    objects: {
      cvs: Prisma.$cvsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      phone: string | null
      email: string | null
      cv_id: number
    }, ExtArgs["result"]["references"]>
    composites: {}
  }

  type referencesGetPayload<S extends boolean | null | undefined | referencesDefaultArgs> = $Result.GetResult<Prisma.$referencesPayload, S>

  type referencesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<referencesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReferencesCountAggregateInputType | true
    }

  export interface referencesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['references'], meta: { name: 'references' } }
    /**
     * Find zero or one References that matches the filter.
     * @param {referencesFindUniqueArgs} args - Arguments to find a References
     * @example
     * // Get one References
     * const references = await prisma.references.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends referencesFindUniqueArgs>(args: SelectSubset<T, referencesFindUniqueArgs<ExtArgs>>): Prisma__referencesClient<$Result.GetResult<Prisma.$referencesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one References that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {referencesFindUniqueOrThrowArgs} args - Arguments to find a References
     * @example
     * // Get one References
     * const references = await prisma.references.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends referencesFindUniqueOrThrowArgs>(args: SelectSubset<T, referencesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__referencesClient<$Result.GetResult<Prisma.$referencesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first References that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {referencesFindFirstArgs} args - Arguments to find a References
     * @example
     * // Get one References
     * const references = await prisma.references.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends referencesFindFirstArgs>(args?: SelectSubset<T, referencesFindFirstArgs<ExtArgs>>): Prisma__referencesClient<$Result.GetResult<Prisma.$referencesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first References that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {referencesFindFirstOrThrowArgs} args - Arguments to find a References
     * @example
     * // Get one References
     * const references = await prisma.references.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends referencesFindFirstOrThrowArgs>(args?: SelectSubset<T, referencesFindFirstOrThrowArgs<ExtArgs>>): Prisma__referencesClient<$Result.GetResult<Prisma.$referencesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more References that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {referencesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all References
     * const references = await prisma.references.findMany()
     * 
     * // Get first 10 References
     * const references = await prisma.references.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const referencesWithIdOnly = await prisma.references.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends referencesFindManyArgs>(args?: SelectSubset<T, referencesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$referencesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a References.
     * @param {referencesCreateArgs} args - Arguments to create a References.
     * @example
     * // Create one References
     * const References = await prisma.references.create({
     *   data: {
     *     // ... data to create a References
     *   }
     * })
     * 
     */
    create<T extends referencesCreateArgs>(args: SelectSubset<T, referencesCreateArgs<ExtArgs>>): Prisma__referencesClient<$Result.GetResult<Prisma.$referencesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many References.
     * @param {referencesCreateManyArgs} args - Arguments to create many References.
     * @example
     * // Create many References
     * const references = await prisma.references.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends referencesCreateManyArgs>(args?: SelectSubset<T, referencesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many References and returns the data saved in the database.
     * @param {referencesCreateManyAndReturnArgs} args - Arguments to create many References.
     * @example
     * // Create many References
     * const references = await prisma.references.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many References and only return the `id`
     * const referencesWithIdOnly = await prisma.references.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends referencesCreateManyAndReturnArgs>(args?: SelectSubset<T, referencesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$referencesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a References.
     * @param {referencesDeleteArgs} args - Arguments to delete one References.
     * @example
     * // Delete one References
     * const References = await prisma.references.delete({
     *   where: {
     *     // ... filter to delete one References
     *   }
     * })
     * 
     */
    delete<T extends referencesDeleteArgs>(args: SelectSubset<T, referencesDeleteArgs<ExtArgs>>): Prisma__referencesClient<$Result.GetResult<Prisma.$referencesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one References.
     * @param {referencesUpdateArgs} args - Arguments to update one References.
     * @example
     * // Update one References
     * const references = await prisma.references.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends referencesUpdateArgs>(args: SelectSubset<T, referencesUpdateArgs<ExtArgs>>): Prisma__referencesClient<$Result.GetResult<Prisma.$referencesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more References.
     * @param {referencesDeleteManyArgs} args - Arguments to filter References to delete.
     * @example
     * // Delete a few References
     * const { count } = await prisma.references.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends referencesDeleteManyArgs>(args?: SelectSubset<T, referencesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more References.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {referencesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many References
     * const references = await prisma.references.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends referencesUpdateManyArgs>(args: SelectSubset<T, referencesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more References and returns the data updated in the database.
     * @param {referencesUpdateManyAndReturnArgs} args - Arguments to update many References.
     * @example
     * // Update many References
     * const references = await prisma.references.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more References and only return the `id`
     * const referencesWithIdOnly = await prisma.references.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends referencesUpdateManyAndReturnArgs>(args: SelectSubset<T, referencesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$referencesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one References.
     * @param {referencesUpsertArgs} args - Arguments to update or create a References.
     * @example
     * // Update or create a References
     * const references = await prisma.references.upsert({
     *   create: {
     *     // ... data to create a References
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the References we want to update
     *   }
     * })
     */
    upsert<T extends referencesUpsertArgs>(args: SelectSubset<T, referencesUpsertArgs<ExtArgs>>): Prisma__referencesClient<$Result.GetResult<Prisma.$referencesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of References.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {referencesCountArgs} args - Arguments to filter References to count.
     * @example
     * // Count the number of References
     * const count = await prisma.references.count({
     *   where: {
     *     // ... the filter for the References we want to count
     *   }
     * })
    **/
    count<T extends referencesCountArgs>(
      args?: Subset<T, referencesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReferencesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a References.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReferencesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReferencesAggregateArgs>(args: Subset<T, ReferencesAggregateArgs>): Prisma.PrismaPromise<GetReferencesAggregateType<T>>

    /**
     * Group by References.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {referencesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends referencesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: referencesGroupByArgs['orderBy'] }
        : { orderBy?: referencesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, referencesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReferencesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the references model
   */
  readonly fields: referencesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for references.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__referencesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cvs<T extends cvsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, cvsDefaultArgs<ExtArgs>>): Prisma__cvsClient<$Result.GetResult<Prisma.$cvsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the references model
   */
  interface referencesFieldRefs {
    readonly id: FieldRef<"references", 'Int'>
    readonly name: FieldRef<"references", 'String'>
    readonly phone: FieldRef<"references", 'String'>
    readonly email: FieldRef<"references", 'String'>
    readonly cv_id: FieldRef<"references", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * references findUnique
   */
  export type referencesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the references
     */
    select?: referencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the references
     */
    omit?: referencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: referencesInclude<ExtArgs> | null
    /**
     * Filter, which references to fetch.
     */
    where: referencesWhereUniqueInput
  }

  /**
   * references findUniqueOrThrow
   */
  export type referencesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the references
     */
    select?: referencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the references
     */
    omit?: referencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: referencesInclude<ExtArgs> | null
    /**
     * Filter, which references to fetch.
     */
    where: referencesWhereUniqueInput
  }

  /**
   * references findFirst
   */
  export type referencesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the references
     */
    select?: referencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the references
     */
    omit?: referencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: referencesInclude<ExtArgs> | null
    /**
     * Filter, which references to fetch.
     */
    where?: referencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of references to fetch.
     */
    orderBy?: referencesOrderByWithRelationInput | referencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for references.
     */
    cursor?: referencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` references from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` references.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of references.
     */
    distinct?: ReferencesScalarFieldEnum | ReferencesScalarFieldEnum[]
  }

  /**
   * references findFirstOrThrow
   */
  export type referencesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the references
     */
    select?: referencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the references
     */
    omit?: referencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: referencesInclude<ExtArgs> | null
    /**
     * Filter, which references to fetch.
     */
    where?: referencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of references to fetch.
     */
    orderBy?: referencesOrderByWithRelationInput | referencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for references.
     */
    cursor?: referencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` references from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` references.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of references.
     */
    distinct?: ReferencesScalarFieldEnum | ReferencesScalarFieldEnum[]
  }

  /**
   * references findMany
   */
  export type referencesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the references
     */
    select?: referencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the references
     */
    omit?: referencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: referencesInclude<ExtArgs> | null
    /**
     * Filter, which references to fetch.
     */
    where?: referencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of references to fetch.
     */
    orderBy?: referencesOrderByWithRelationInput | referencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing references.
     */
    cursor?: referencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` references from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` references.
     */
    skip?: number
    distinct?: ReferencesScalarFieldEnum | ReferencesScalarFieldEnum[]
  }

  /**
   * references create
   */
  export type referencesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the references
     */
    select?: referencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the references
     */
    omit?: referencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: referencesInclude<ExtArgs> | null
    /**
     * The data needed to create a references.
     */
    data: XOR<referencesCreateInput, referencesUncheckedCreateInput>
  }

  /**
   * references createMany
   */
  export type referencesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many references.
     */
    data: referencesCreateManyInput | referencesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * references createManyAndReturn
   */
  export type referencesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the references
     */
    select?: referencesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the references
     */
    omit?: referencesOmit<ExtArgs> | null
    /**
     * The data used to create many references.
     */
    data: referencesCreateManyInput | referencesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: referencesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * references update
   */
  export type referencesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the references
     */
    select?: referencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the references
     */
    omit?: referencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: referencesInclude<ExtArgs> | null
    /**
     * The data needed to update a references.
     */
    data: XOR<referencesUpdateInput, referencesUncheckedUpdateInput>
    /**
     * Choose, which references to update.
     */
    where: referencesWhereUniqueInput
  }

  /**
   * references updateMany
   */
  export type referencesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update references.
     */
    data: XOR<referencesUpdateManyMutationInput, referencesUncheckedUpdateManyInput>
    /**
     * Filter which references to update
     */
    where?: referencesWhereInput
    /**
     * Limit how many references to update.
     */
    limit?: number
  }

  /**
   * references updateManyAndReturn
   */
  export type referencesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the references
     */
    select?: referencesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the references
     */
    omit?: referencesOmit<ExtArgs> | null
    /**
     * The data used to update references.
     */
    data: XOR<referencesUpdateManyMutationInput, referencesUncheckedUpdateManyInput>
    /**
     * Filter which references to update
     */
    where?: referencesWhereInput
    /**
     * Limit how many references to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: referencesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * references upsert
   */
  export type referencesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the references
     */
    select?: referencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the references
     */
    omit?: referencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: referencesInclude<ExtArgs> | null
    /**
     * The filter to search for the references to update in case it exists.
     */
    where: referencesWhereUniqueInput
    /**
     * In case the references found by the `where` argument doesn't exist, create a new references with this data.
     */
    create: XOR<referencesCreateInput, referencesUncheckedCreateInput>
    /**
     * In case the references was found with the provided `where` argument, update it with this data.
     */
    update: XOR<referencesUpdateInput, referencesUncheckedUpdateInput>
  }

  /**
   * references delete
   */
  export type referencesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the references
     */
    select?: referencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the references
     */
    omit?: referencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: referencesInclude<ExtArgs> | null
    /**
     * Filter which references to delete.
     */
    where: referencesWhereUniqueInput
  }

  /**
   * references deleteMany
   */
  export type referencesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which references to delete
     */
    where?: referencesWhereInput
    /**
     * Limit how many references to delete.
     */
    limit?: number
  }

  /**
   * references without action
   */
  export type referencesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the references
     */
    select?: referencesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the references
     */
    omit?: referencesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: referencesInclude<ExtArgs> | null
  }


  /**
   * Model roles
   */

  export type AggregateRoles = {
    _count: RolesCountAggregateOutputType | null
    _avg: RolesAvgAggregateOutputType | null
    _sum: RolesSumAggregateOutputType | null
    _min: RolesMinAggregateOutputType | null
    _max: RolesMaxAggregateOutputType | null
  }

  export type RolesAvgAggregateOutputType = {
    id: number | null
  }

  export type RolesSumAggregateOutputType = {
    id: number | null
  }

  export type RolesMinAggregateOutputType = {
    id: number | null
    role_name: string | null
  }

  export type RolesMaxAggregateOutputType = {
    id: number | null
    role_name: string | null
  }

  export type RolesCountAggregateOutputType = {
    id: number
    role_name: number
    _all: number
  }


  export type RolesAvgAggregateInputType = {
    id?: true
  }

  export type RolesSumAggregateInputType = {
    id?: true
  }

  export type RolesMinAggregateInputType = {
    id?: true
    role_name?: true
  }

  export type RolesMaxAggregateInputType = {
    id?: true
    role_name?: true
  }

  export type RolesCountAggregateInputType = {
    id?: true
    role_name?: true
    _all?: true
  }

  export type RolesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which roles to aggregate.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned roles
    **/
    _count?: true | RolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolesMaxAggregateInputType
  }

  export type GetRolesAggregateType<T extends RolesAggregateArgs> = {
        [P in keyof T & keyof AggregateRoles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoles[P]>
      : GetScalarType<T[P], AggregateRoles[P]>
  }




  export type rolesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rolesWhereInput
    orderBy?: rolesOrderByWithAggregationInput | rolesOrderByWithAggregationInput[]
    by: RolesScalarFieldEnum[] | RolesScalarFieldEnum
    having?: rolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolesCountAggregateInputType | true
    _avg?: RolesAvgAggregateInputType
    _sum?: RolesSumAggregateInputType
    _min?: RolesMinAggregateInputType
    _max?: RolesMaxAggregateInputType
  }

  export type RolesGroupByOutputType = {
    id: number
    role_name: string
    _count: RolesCountAggregateOutputType | null
    _avg: RolesAvgAggregateOutputType | null
    _sum: RolesSumAggregateOutputType | null
    _min: RolesMinAggregateOutputType | null
    _max: RolesMaxAggregateOutputType | null
  }

  type GetRolesGroupByPayload<T extends rolesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolesGroupByOutputType[P]>
            : GetScalarType<T[P], RolesGroupByOutputType[P]>
        }
      >
    >


  export type rolesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role_name?: boolean
    users?: boolean | roles$usersArgs<ExtArgs>
    _count?: boolean | RolesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roles"]>

  export type rolesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role_name?: boolean
  }, ExtArgs["result"]["roles"]>

  export type rolesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    role_name?: boolean
  }, ExtArgs["result"]["roles"]>

  export type rolesSelectScalar = {
    id?: boolean
    role_name?: boolean
  }

  export type rolesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "role_name", ExtArgs["result"]["roles"]>
  export type rolesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | roles$usersArgs<ExtArgs>
    _count?: boolean | RolesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type rolesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type rolesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $rolesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "roles"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      role_name: string
    }, ExtArgs["result"]["roles"]>
    composites: {}
  }

  type rolesGetPayload<S extends boolean | null | undefined | rolesDefaultArgs> = $Result.GetResult<Prisma.$rolesPayload, S>

  type rolesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<rolesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RolesCountAggregateInputType | true
    }

  export interface rolesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['roles'], meta: { name: 'roles' } }
    /**
     * Find zero or one Roles that matches the filter.
     * @param {rolesFindUniqueArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends rolesFindUniqueArgs>(args: SelectSubset<T, rolesFindUniqueArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Roles that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {rolesFindUniqueOrThrowArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends rolesFindUniqueOrThrowArgs>(args: SelectSubset<T, rolesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesFindFirstArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends rolesFindFirstArgs>(args?: SelectSubset<T, rolesFindFirstArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Roles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesFindFirstOrThrowArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends rolesFindFirstOrThrowArgs>(args?: SelectSubset<T, rolesFindFirstOrThrowArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.roles.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.roles.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rolesWithIdOnly = await prisma.roles.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends rolesFindManyArgs>(args?: SelectSubset<T, rolesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Roles.
     * @param {rolesCreateArgs} args - Arguments to create a Roles.
     * @example
     * // Create one Roles
     * const Roles = await prisma.roles.create({
     *   data: {
     *     // ... data to create a Roles
     *   }
     * })
     * 
     */
    create<T extends rolesCreateArgs>(args: SelectSubset<T, rolesCreateArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roles.
     * @param {rolesCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const roles = await prisma.roles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends rolesCreateManyArgs>(args?: SelectSubset<T, rolesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {rolesCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const roles = await prisma.roles.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const rolesWithIdOnly = await prisma.roles.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends rolesCreateManyAndReturnArgs>(args?: SelectSubset<T, rolesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Roles.
     * @param {rolesDeleteArgs} args - Arguments to delete one Roles.
     * @example
     * // Delete one Roles
     * const Roles = await prisma.roles.delete({
     *   where: {
     *     // ... filter to delete one Roles
     *   }
     * })
     * 
     */
    delete<T extends rolesDeleteArgs>(args: SelectSubset<T, rolesDeleteArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Roles.
     * @param {rolesUpdateArgs} args - Arguments to update one Roles.
     * @example
     * // Update one Roles
     * const roles = await prisma.roles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends rolesUpdateArgs>(args: SelectSubset<T, rolesUpdateArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roles.
     * @param {rolesDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.roles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends rolesDeleteManyArgs>(args?: SelectSubset<T, rolesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const roles = await prisma.roles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends rolesUpdateManyArgs>(args: SelectSubset<T, rolesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles and returns the data updated in the database.
     * @param {rolesUpdateManyAndReturnArgs} args - Arguments to update many Roles.
     * @example
     * // Update many Roles
     * const roles = await prisma.roles.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Roles and only return the `id`
     * const rolesWithIdOnly = await prisma.roles.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends rolesUpdateManyAndReturnArgs>(args: SelectSubset<T, rolesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Roles.
     * @param {rolesUpsertArgs} args - Arguments to update or create a Roles.
     * @example
     * // Update or create a Roles
     * const roles = await prisma.roles.upsert({
     *   create: {
     *     // ... data to create a Roles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Roles we want to update
     *   }
     * })
     */
    upsert<T extends rolesUpsertArgs>(args: SelectSubset<T, rolesUpsertArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.roles.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends rolesCountArgs>(
      args?: Subset<T, rolesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolesAggregateArgs>(args: Subset<T, RolesAggregateArgs>): Prisma.PrismaPromise<GetRolesAggregateType<T>>

    /**
     * Group by Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends rolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: rolesGroupByArgs['orderBy'] }
        : { orderBy?: rolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, rolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the roles model
   */
  readonly fields: rolesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for roles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__rolesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends roles$usersArgs<ExtArgs> = {}>(args?: Subset<T, roles$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the roles model
   */
  interface rolesFieldRefs {
    readonly id: FieldRef<"roles", 'Int'>
    readonly role_name: FieldRef<"roles", 'String'>
  }
    

  // Custom InputTypes
  /**
   * roles findUnique
   */
  export type rolesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where: rolesWhereUniqueInput
  }

  /**
   * roles findUniqueOrThrow
   */
  export type rolesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where: rolesWhereUniqueInput
  }

  /**
   * roles findFirst
   */
  export type rolesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roles.
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roles.
     */
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * roles findFirstOrThrow
   */
  export type rolesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roles.
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roles.
     */
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * roles findMany
   */
  export type rolesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing roles.
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * roles create
   */
  export type rolesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * The data needed to create a roles.
     */
    data: XOR<rolesCreateInput, rolesUncheckedCreateInput>
  }

  /**
   * roles createMany
   */
  export type rolesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many roles.
     */
    data: rolesCreateManyInput | rolesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * roles createManyAndReturn
   */
  export type rolesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * The data used to create many roles.
     */
    data: rolesCreateManyInput | rolesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * roles update
   */
  export type rolesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * The data needed to update a roles.
     */
    data: XOR<rolesUpdateInput, rolesUncheckedUpdateInput>
    /**
     * Choose, which roles to update.
     */
    where: rolesWhereUniqueInput
  }

  /**
   * roles updateMany
   */
  export type rolesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update roles.
     */
    data: XOR<rolesUpdateManyMutationInput, rolesUncheckedUpdateManyInput>
    /**
     * Filter which roles to update
     */
    where?: rolesWhereInput
    /**
     * Limit how many roles to update.
     */
    limit?: number
  }

  /**
   * roles updateManyAndReturn
   */
  export type rolesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * The data used to update roles.
     */
    data: XOR<rolesUpdateManyMutationInput, rolesUncheckedUpdateManyInput>
    /**
     * Filter which roles to update
     */
    where?: rolesWhereInput
    /**
     * Limit how many roles to update.
     */
    limit?: number
  }

  /**
   * roles upsert
   */
  export type rolesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * The filter to search for the roles to update in case it exists.
     */
    where: rolesWhereUniqueInput
    /**
     * In case the roles found by the `where` argument doesn't exist, create a new roles with this data.
     */
    create: XOR<rolesCreateInput, rolesUncheckedCreateInput>
    /**
     * In case the roles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<rolesUpdateInput, rolesUncheckedUpdateInput>
  }

  /**
   * roles delete
   */
  export type rolesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter which roles to delete.
     */
    where: rolesWhereUniqueInput
  }

  /**
   * roles deleteMany
   */
  export type rolesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which roles to delete
     */
    where?: rolesWhereInput
    /**
     * Limit how many roles to delete.
     */
    limit?: number
  }

  /**
   * roles.users
   */
  export type roles$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    cursor?: usersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * roles without action
   */
  export type rolesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
  }


  /**
   * Model savedJobs
   */

  export type AggregateSavedJobs = {
    _count: SavedJobsCountAggregateOutputType | null
    _min: SavedJobsMinAggregateOutputType | null
    _max: SavedJobsMaxAggregateOutputType | null
  }

  export type SavedJobsMinAggregateOutputType = {
    user_id: string | null
    job_id: string | null
    saved_at: Date | null
  }

  export type SavedJobsMaxAggregateOutputType = {
    user_id: string | null
    job_id: string | null
    saved_at: Date | null
  }

  export type SavedJobsCountAggregateOutputType = {
    user_id: number
    job_id: number
    saved_at: number
    _all: number
  }


  export type SavedJobsMinAggregateInputType = {
    user_id?: true
    job_id?: true
    saved_at?: true
  }

  export type SavedJobsMaxAggregateInputType = {
    user_id?: true
    job_id?: true
    saved_at?: true
  }

  export type SavedJobsCountAggregateInputType = {
    user_id?: true
    job_id?: true
    saved_at?: true
    _all?: true
  }

  export type SavedJobsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which savedJobs to aggregate.
     */
    where?: savedJobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of savedJobs to fetch.
     */
    orderBy?: savedJobsOrderByWithRelationInput | savedJobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: savedJobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` savedJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` savedJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned savedJobs
    **/
    _count?: true | SavedJobsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SavedJobsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SavedJobsMaxAggregateInputType
  }

  export type GetSavedJobsAggregateType<T extends SavedJobsAggregateArgs> = {
        [P in keyof T & keyof AggregateSavedJobs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSavedJobs[P]>
      : GetScalarType<T[P], AggregateSavedJobs[P]>
  }




  export type savedJobsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: savedJobsWhereInput
    orderBy?: savedJobsOrderByWithAggregationInput | savedJobsOrderByWithAggregationInput[]
    by: SavedJobsScalarFieldEnum[] | SavedJobsScalarFieldEnum
    having?: savedJobsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SavedJobsCountAggregateInputType | true
    _min?: SavedJobsMinAggregateInputType
    _max?: SavedJobsMaxAggregateInputType
  }

  export type SavedJobsGroupByOutputType = {
    user_id: string
    job_id: string
    saved_at: Date
    _count: SavedJobsCountAggregateOutputType | null
    _min: SavedJobsMinAggregateOutputType | null
    _max: SavedJobsMaxAggregateOutputType | null
  }

  type GetSavedJobsGroupByPayload<T extends savedJobsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SavedJobsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SavedJobsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SavedJobsGroupByOutputType[P]>
            : GetScalarType<T[P], SavedJobsGroupByOutputType[P]>
        }
      >
    >


  export type savedJobsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    job_id?: boolean
    saved_at?: boolean
    jobs?: boolean | jobsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["savedJobs"]>

  export type savedJobsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    job_id?: boolean
    saved_at?: boolean
    jobs?: boolean | jobsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["savedJobs"]>

  export type savedJobsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    user_id?: boolean
    job_id?: boolean
    saved_at?: boolean
    jobs?: boolean | jobsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["savedJobs"]>

  export type savedJobsSelectScalar = {
    user_id?: boolean
    job_id?: boolean
    saved_at?: boolean
  }

  export type savedJobsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"user_id" | "job_id" | "saved_at", ExtArgs["result"]["savedJobs"]>
  export type savedJobsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobs?: boolean | jobsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type savedJobsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobs?: boolean | jobsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type savedJobsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    jobs?: boolean | jobsDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $savedJobsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "savedJobs"
    objects: {
      jobs: Prisma.$jobsPayload<ExtArgs>
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      user_id: string
      job_id: string
      saved_at: Date
    }, ExtArgs["result"]["savedJobs"]>
    composites: {}
  }

  type savedJobsGetPayload<S extends boolean | null | undefined | savedJobsDefaultArgs> = $Result.GetResult<Prisma.$savedJobsPayload, S>

  type savedJobsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<savedJobsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SavedJobsCountAggregateInputType | true
    }

  export interface savedJobsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['savedJobs'], meta: { name: 'savedJobs' } }
    /**
     * Find zero or one SavedJobs that matches the filter.
     * @param {savedJobsFindUniqueArgs} args - Arguments to find a SavedJobs
     * @example
     * // Get one SavedJobs
     * const savedJobs = await prisma.savedJobs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends savedJobsFindUniqueArgs>(args: SelectSubset<T, savedJobsFindUniqueArgs<ExtArgs>>): Prisma__savedJobsClient<$Result.GetResult<Prisma.$savedJobsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SavedJobs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {savedJobsFindUniqueOrThrowArgs} args - Arguments to find a SavedJobs
     * @example
     * // Get one SavedJobs
     * const savedJobs = await prisma.savedJobs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends savedJobsFindUniqueOrThrowArgs>(args: SelectSubset<T, savedJobsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__savedJobsClient<$Result.GetResult<Prisma.$savedJobsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SavedJobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {savedJobsFindFirstArgs} args - Arguments to find a SavedJobs
     * @example
     * // Get one SavedJobs
     * const savedJobs = await prisma.savedJobs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends savedJobsFindFirstArgs>(args?: SelectSubset<T, savedJobsFindFirstArgs<ExtArgs>>): Prisma__savedJobsClient<$Result.GetResult<Prisma.$savedJobsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SavedJobs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {savedJobsFindFirstOrThrowArgs} args - Arguments to find a SavedJobs
     * @example
     * // Get one SavedJobs
     * const savedJobs = await prisma.savedJobs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends savedJobsFindFirstOrThrowArgs>(args?: SelectSubset<T, savedJobsFindFirstOrThrowArgs<ExtArgs>>): Prisma__savedJobsClient<$Result.GetResult<Prisma.$savedJobsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SavedJobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {savedJobsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SavedJobs
     * const savedJobs = await prisma.savedJobs.findMany()
     * 
     * // Get first 10 SavedJobs
     * const savedJobs = await prisma.savedJobs.findMany({ take: 10 })
     * 
     * // Only select the `user_id`
     * const savedJobsWithUser_idOnly = await prisma.savedJobs.findMany({ select: { user_id: true } })
     * 
     */
    findMany<T extends savedJobsFindManyArgs>(args?: SelectSubset<T, savedJobsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$savedJobsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SavedJobs.
     * @param {savedJobsCreateArgs} args - Arguments to create a SavedJobs.
     * @example
     * // Create one SavedJobs
     * const SavedJobs = await prisma.savedJobs.create({
     *   data: {
     *     // ... data to create a SavedJobs
     *   }
     * })
     * 
     */
    create<T extends savedJobsCreateArgs>(args: SelectSubset<T, savedJobsCreateArgs<ExtArgs>>): Prisma__savedJobsClient<$Result.GetResult<Prisma.$savedJobsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SavedJobs.
     * @param {savedJobsCreateManyArgs} args - Arguments to create many SavedJobs.
     * @example
     * // Create many SavedJobs
     * const savedJobs = await prisma.savedJobs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends savedJobsCreateManyArgs>(args?: SelectSubset<T, savedJobsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SavedJobs and returns the data saved in the database.
     * @param {savedJobsCreateManyAndReturnArgs} args - Arguments to create many SavedJobs.
     * @example
     * // Create many SavedJobs
     * const savedJobs = await prisma.savedJobs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SavedJobs and only return the `user_id`
     * const savedJobsWithUser_idOnly = await prisma.savedJobs.createManyAndReturn({
     *   select: { user_id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends savedJobsCreateManyAndReturnArgs>(args?: SelectSubset<T, savedJobsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$savedJobsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SavedJobs.
     * @param {savedJobsDeleteArgs} args - Arguments to delete one SavedJobs.
     * @example
     * // Delete one SavedJobs
     * const SavedJobs = await prisma.savedJobs.delete({
     *   where: {
     *     // ... filter to delete one SavedJobs
     *   }
     * })
     * 
     */
    delete<T extends savedJobsDeleteArgs>(args: SelectSubset<T, savedJobsDeleteArgs<ExtArgs>>): Prisma__savedJobsClient<$Result.GetResult<Prisma.$savedJobsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SavedJobs.
     * @param {savedJobsUpdateArgs} args - Arguments to update one SavedJobs.
     * @example
     * // Update one SavedJobs
     * const savedJobs = await prisma.savedJobs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends savedJobsUpdateArgs>(args: SelectSubset<T, savedJobsUpdateArgs<ExtArgs>>): Prisma__savedJobsClient<$Result.GetResult<Prisma.$savedJobsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SavedJobs.
     * @param {savedJobsDeleteManyArgs} args - Arguments to filter SavedJobs to delete.
     * @example
     * // Delete a few SavedJobs
     * const { count } = await prisma.savedJobs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends savedJobsDeleteManyArgs>(args?: SelectSubset<T, savedJobsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SavedJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {savedJobsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SavedJobs
     * const savedJobs = await prisma.savedJobs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends savedJobsUpdateManyArgs>(args: SelectSubset<T, savedJobsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SavedJobs and returns the data updated in the database.
     * @param {savedJobsUpdateManyAndReturnArgs} args - Arguments to update many SavedJobs.
     * @example
     * // Update many SavedJobs
     * const savedJobs = await prisma.savedJobs.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SavedJobs and only return the `user_id`
     * const savedJobsWithUser_idOnly = await prisma.savedJobs.updateManyAndReturn({
     *   select: { user_id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends savedJobsUpdateManyAndReturnArgs>(args: SelectSubset<T, savedJobsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$savedJobsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SavedJobs.
     * @param {savedJobsUpsertArgs} args - Arguments to update or create a SavedJobs.
     * @example
     * // Update or create a SavedJobs
     * const savedJobs = await prisma.savedJobs.upsert({
     *   create: {
     *     // ... data to create a SavedJobs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SavedJobs we want to update
     *   }
     * })
     */
    upsert<T extends savedJobsUpsertArgs>(args: SelectSubset<T, savedJobsUpsertArgs<ExtArgs>>): Prisma__savedJobsClient<$Result.GetResult<Prisma.$savedJobsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SavedJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {savedJobsCountArgs} args - Arguments to filter SavedJobs to count.
     * @example
     * // Count the number of SavedJobs
     * const count = await prisma.savedJobs.count({
     *   where: {
     *     // ... the filter for the SavedJobs we want to count
     *   }
     * })
    **/
    count<T extends savedJobsCountArgs>(
      args?: Subset<T, savedJobsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SavedJobsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SavedJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedJobsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SavedJobsAggregateArgs>(args: Subset<T, SavedJobsAggregateArgs>): Prisma.PrismaPromise<GetSavedJobsAggregateType<T>>

    /**
     * Group by SavedJobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {savedJobsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends savedJobsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: savedJobsGroupByArgs['orderBy'] }
        : { orderBy?: savedJobsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, savedJobsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSavedJobsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the savedJobs model
   */
  readonly fields: savedJobsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for savedJobs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__savedJobsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    jobs<T extends jobsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, jobsDefaultArgs<ExtArgs>>): Prisma__jobsClient<$Result.GetResult<Prisma.$jobsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the savedJobs model
   */
  interface savedJobsFieldRefs {
    readonly user_id: FieldRef<"savedJobs", 'String'>
    readonly job_id: FieldRef<"savedJobs", 'String'>
    readonly saved_at: FieldRef<"savedJobs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * savedJobs findUnique
   */
  export type savedJobsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the savedJobs
     */
    select?: savedJobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the savedJobs
     */
    omit?: savedJobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: savedJobsInclude<ExtArgs> | null
    /**
     * Filter, which savedJobs to fetch.
     */
    where: savedJobsWhereUniqueInput
  }

  /**
   * savedJobs findUniqueOrThrow
   */
  export type savedJobsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the savedJobs
     */
    select?: savedJobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the savedJobs
     */
    omit?: savedJobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: savedJobsInclude<ExtArgs> | null
    /**
     * Filter, which savedJobs to fetch.
     */
    where: savedJobsWhereUniqueInput
  }

  /**
   * savedJobs findFirst
   */
  export type savedJobsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the savedJobs
     */
    select?: savedJobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the savedJobs
     */
    omit?: savedJobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: savedJobsInclude<ExtArgs> | null
    /**
     * Filter, which savedJobs to fetch.
     */
    where?: savedJobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of savedJobs to fetch.
     */
    orderBy?: savedJobsOrderByWithRelationInput | savedJobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for savedJobs.
     */
    cursor?: savedJobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` savedJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` savedJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of savedJobs.
     */
    distinct?: SavedJobsScalarFieldEnum | SavedJobsScalarFieldEnum[]
  }

  /**
   * savedJobs findFirstOrThrow
   */
  export type savedJobsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the savedJobs
     */
    select?: savedJobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the savedJobs
     */
    omit?: savedJobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: savedJobsInclude<ExtArgs> | null
    /**
     * Filter, which savedJobs to fetch.
     */
    where?: savedJobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of savedJobs to fetch.
     */
    orderBy?: savedJobsOrderByWithRelationInput | savedJobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for savedJobs.
     */
    cursor?: savedJobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` savedJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` savedJobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of savedJobs.
     */
    distinct?: SavedJobsScalarFieldEnum | SavedJobsScalarFieldEnum[]
  }

  /**
   * savedJobs findMany
   */
  export type savedJobsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the savedJobs
     */
    select?: savedJobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the savedJobs
     */
    omit?: savedJobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: savedJobsInclude<ExtArgs> | null
    /**
     * Filter, which savedJobs to fetch.
     */
    where?: savedJobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of savedJobs to fetch.
     */
    orderBy?: savedJobsOrderByWithRelationInput | savedJobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing savedJobs.
     */
    cursor?: savedJobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` savedJobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` savedJobs.
     */
    skip?: number
    distinct?: SavedJobsScalarFieldEnum | SavedJobsScalarFieldEnum[]
  }

  /**
   * savedJobs create
   */
  export type savedJobsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the savedJobs
     */
    select?: savedJobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the savedJobs
     */
    omit?: savedJobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: savedJobsInclude<ExtArgs> | null
    /**
     * The data needed to create a savedJobs.
     */
    data: XOR<savedJobsCreateInput, savedJobsUncheckedCreateInput>
  }

  /**
   * savedJobs createMany
   */
  export type savedJobsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many savedJobs.
     */
    data: savedJobsCreateManyInput | savedJobsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * savedJobs createManyAndReturn
   */
  export type savedJobsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the savedJobs
     */
    select?: savedJobsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the savedJobs
     */
    omit?: savedJobsOmit<ExtArgs> | null
    /**
     * The data used to create many savedJobs.
     */
    data: savedJobsCreateManyInput | savedJobsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: savedJobsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * savedJobs update
   */
  export type savedJobsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the savedJobs
     */
    select?: savedJobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the savedJobs
     */
    omit?: savedJobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: savedJobsInclude<ExtArgs> | null
    /**
     * The data needed to update a savedJobs.
     */
    data: XOR<savedJobsUpdateInput, savedJobsUncheckedUpdateInput>
    /**
     * Choose, which savedJobs to update.
     */
    where: savedJobsWhereUniqueInput
  }

  /**
   * savedJobs updateMany
   */
  export type savedJobsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update savedJobs.
     */
    data: XOR<savedJobsUpdateManyMutationInput, savedJobsUncheckedUpdateManyInput>
    /**
     * Filter which savedJobs to update
     */
    where?: savedJobsWhereInput
    /**
     * Limit how many savedJobs to update.
     */
    limit?: number
  }

  /**
   * savedJobs updateManyAndReturn
   */
  export type savedJobsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the savedJobs
     */
    select?: savedJobsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the savedJobs
     */
    omit?: savedJobsOmit<ExtArgs> | null
    /**
     * The data used to update savedJobs.
     */
    data: XOR<savedJobsUpdateManyMutationInput, savedJobsUncheckedUpdateManyInput>
    /**
     * Filter which savedJobs to update
     */
    where?: savedJobsWhereInput
    /**
     * Limit how many savedJobs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: savedJobsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * savedJobs upsert
   */
  export type savedJobsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the savedJobs
     */
    select?: savedJobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the savedJobs
     */
    omit?: savedJobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: savedJobsInclude<ExtArgs> | null
    /**
     * The filter to search for the savedJobs to update in case it exists.
     */
    where: savedJobsWhereUniqueInput
    /**
     * In case the savedJobs found by the `where` argument doesn't exist, create a new savedJobs with this data.
     */
    create: XOR<savedJobsCreateInput, savedJobsUncheckedCreateInput>
    /**
     * In case the savedJobs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<savedJobsUpdateInput, savedJobsUncheckedUpdateInput>
  }

  /**
   * savedJobs delete
   */
  export type savedJobsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the savedJobs
     */
    select?: savedJobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the savedJobs
     */
    omit?: savedJobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: savedJobsInclude<ExtArgs> | null
    /**
     * Filter which savedJobs to delete.
     */
    where: savedJobsWhereUniqueInput
  }

  /**
   * savedJobs deleteMany
   */
  export type savedJobsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which savedJobs to delete
     */
    where?: savedJobsWhereInput
    /**
     * Limit how many savedJobs to delete.
     */
    limit?: number
  }

  /**
   * savedJobs without action
   */
  export type savedJobsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the savedJobs
     */
    select?: savedJobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the savedJobs
     */
    omit?: savedJobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: savedJobsInclude<ExtArgs> | null
  }


  /**
   * Model subscriptions
   */

  export type AggregateSubscriptions = {
    _count: SubscriptionsCountAggregateOutputType | null
    _avg: SubscriptionsAvgAggregateOutputType | null
    _sum: SubscriptionsSumAggregateOutputType | null
    _min: SubscriptionsMinAggregateOutputType | null
    _max: SubscriptionsMaxAggregateOutputType | null
  }

  export type SubscriptionsAvgAggregateOutputType = {
    amount_paid: number | null
    plan_id: number | null
  }

  export type SubscriptionsSumAggregateOutputType = {
    amount_paid: bigint | null
    plan_id: number | null
  }

  export type SubscriptionsMinAggregateOutputType = {
    id: string | null
    start_date: Date | null
    end_date: Date | null
    amount_paid: bigint | null
    is_extended: boolean | null
    status: $Enums.SubscriptionStatus | null
    user_id: string | null
    plan_id: number | null
    payment_id: string | null
  }

  export type SubscriptionsMaxAggregateOutputType = {
    id: string | null
    start_date: Date | null
    end_date: Date | null
    amount_paid: bigint | null
    is_extended: boolean | null
    status: $Enums.SubscriptionStatus | null
    user_id: string | null
    plan_id: number | null
    payment_id: string | null
  }

  export type SubscriptionsCountAggregateOutputType = {
    id: number
    start_date: number
    end_date: number
    amount_paid: number
    is_extended: number
    status: number
    user_id: number
    plan_id: number
    payment_id: number
    _all: number
  }


  export type SubscriptionsAvgAggregateInputType = {
    amount_paid?: true
    plan_id?: true
  }

  export type SubscriptionsSumAggregateInputType = {
    amount_paid?: true
    plan_id?: true
  }

  export type SubscriptionsMinAggregateInputType = {
    id?: true
    start_date?: true
    end_date?: true
    amount_paid?: true
    is_extended?: true
    status?: true
    user_id?: true
    plan_id?: true
    payment_id?: true
  }

  export type SubscriptionsMaxAggregateInputType = {
    id?: true
    start_date?: true
    end_date?: true
    amount_paid?: true
    is_extended?: true
    status?: true
    user_id?: true
    plan_id?: true
    payment_id?: true
  }

  export type SubscriptionsCountAggregateInputType = {
    id?: true
    start_date?: true
    end_date?: true
    amount_paid?: true
    is_extended?: true
    status?: true
    user_id?: true
    plan_id?: true
    payment_id?: true
    _all?: true
  }

  export type SubscriptionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which subscriptions to aggregate.
     */
    where?: subscriptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subscriptions to fetch.
     */
    orderBy?: subscriptionsOrderByWithRelationInput | subscriptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: subscriptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned subscriptions
    **/
    _count?: true | SubscriptionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscriptionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscriptionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionsMaxAggregateInputType
  }

  export type GetSubscriptionsAggregateType<T extends SubscriptionsAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscriptions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscriptions[P]>
      : GetScalarType<T[P], AggregateSubscriptions[P]>
  }




  export type subscriptionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: subscriptionsWhereInput
    orderBy?: subscriptionsOrderByWithAggregationInput | subscriptionsOrderByWithAggregationInput[]
    by: SubscriptionsScalarFieldEnum[] | SubscriptionsScalarFieldEnum
    having?: subscriptionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionsCountAggregateInputType | true
    _avg?: SubscriptionsAvgAggregateInputType
    _sum?: SubscriptionsSumAggregateInputType
    _min?: SubscriptionsMinAggregateInputType
    _max?: SubscriptionsMaxAggregateInputType
  }

  export type SubscriptionsGroupByOutputType = {
    id: string
    start_date: Date
    end_date: Date
    amount_paid: bigint
    is_extended: boolean
    status: $Enums.SubscriptionStatus
    user_id: string
    plan_id: number
    payment_id: string
    _count: SubscriptionsCountAggregateOutputType | null
    _avg: SubscriptionsAvgAggregateOutputType | null
    _sum: SubscriptionsSumAggregateOutputType | null
    _min: SubscriptionsMinAggregateOutputType | null
    _max: SubscriptionsMaxAggregateOutputType | null
  }

  type GetSubscriptionsGroupByPayload<T extends subscriptionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionsGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionsGroupByOutputType[P]>
        }
      >
    >


  export type subscriptionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    start_date?: boolean
    end_date?: boolean
    amount_paid?: boolean
    is_extended?: boolean
    status?: boolean
    user_id?: boolean
    plan_id?: boolean
    payment_id?: boolean
    payments?: boolean | paymentsDefaultArgs<ExtArgs>
    membershipPlans?: boolean | membershipPlansDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscriptions"]>

  export type subscriptionsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    start_date?: boolean
    end_date?: boolean
    amount_paid?: boolean
    is_extended?: boolean
    status?: boolean
    user_id?: boolean
    plan_id?: boolean
    payment_id?: boolean
    payments?: boolean | paymentsDefaultArgs<ExtArgs>
    membershipPlans?: boolean | membershipPlansDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscriptions"]>

  export type subscriptionsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    start_date?: boolean
    end_date?: boolean
    amount_paid?: boolean
    is_extended?: boolean
    status?: boolean
    user_id?: boolean
    plan_id?: boolean
    payment_id?: boolean
    payments?: boolean | paymentsDefaultArgs<ExtArgs>
    membershipPlans?: boolean | membershipPlansDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscriptions"]>

  export type subscriptionsSelectScalar = {
    id?: boolean
    start_date?: boolean
    end_date?: boolean
    amount_paid?: boolean
    is_extended?: boolean
    status?: boolean
    user_id?: boolean
    plan_id?: boolean
    payment_id?: boolean
  }

  export type subscriptionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "start_date" | "end_date" | "amount_paid" | "is_extended" | "status" | "user_id" | "plan_id" | "payment_id", ExtArgs["result"]["subscriptions"]>
  export type subscriptionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | paymentsDefaultArgs<ExtArgs>
    membershipPlans?: boolean | membershipPlansDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type subscriptionsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | paymentsDefaultArgs<ExtArgs>
    membershipPlans?: boolean | membershipPlansDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type subscriptionsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | paymentsDefaultArgs<ExtArgs>
    membershipPlans?: boolean | membershipPlansDefaultArgs<ExtArgs>
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $subscriptionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "subscriptions"
    objects: {
      payments: Prisma.$paymentsPayload<ExtArgs>
      membershipPlans: Prisma.$membershipPlansPayload<ExtArgs>
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      start_date: Date
      end_date: Date
      amount_paid: bigint
      is_extended: boolean
      status: $Enums.SubscriptionStatus
      user_id: string
      plan_id: number
      payment_id: string
    }, ExtArgs["result"]["subscriptions"]>
    composites: {}
  }

  type subscriptionsGetPayload<S extends boolean | null | undefined | subscriptionsDefaultArgs> = $Result.GetResult<Prisma.$subscriptionsPayload, S>

  type subscriptionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<subscriptionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubscriptionsCountAggregateInputType | true
    }

  export interface subscriptionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['subscriptions'], meta: { name: 'subscriptions' } }
    /**
     * Find zero or one Subscriptions that matches the filter.
     * @param {subscriptionsFindUniqueArgs} args - Arguments to find a Subscriptions
     * @example
     * // Get one Subscriptions
     * const subscriptions = await prisma.subscriptions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends subscriptionsFindUniqueArgs>(args: SelectSubset<T, subscriptionsFindUniqueArgs<ExtArgs>>): Prisma__subscriptionsClient<$Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subscriptions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {subscriptionsFindUniqueOrThrowArgs} args - Arguments to find a Subscriptions
     * @example
     * // Get one Subscriptions
     * const subscriptions = await prisma.subscriptions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends subscriptionsFindUniqueOrThrowArgs>(args: SelectSubset<T, subscriptionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__subscriptionsClient<$Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionsFindFirstArgs} args - Arguments to find a Subscriptions
     * @example
     * // Get one Subscriptions
     * const subscriptions = await prisma.subscriptions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends subscriptionsFindFirstArgs>(args?: SelectSubset<T, subscriptionsFindFirstArgs<ExtArgs>>): Prisma__subscriptionsClient<$Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscriptions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionsFindFirstOrThrowArgs} args - Arguments to find a Subscriptions
     * @example
     * // Get one Subscriptions
     * const subscriptions = await prisma.subscriptions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends subscriptionsFindFirstOrThrowArgs>(args?: SelectSubset<T, subscriptionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__subscriptionsClient<$Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscriptions.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscriptions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionsWithIdOnly = await prisma.subscriptions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends subscriptionsFindManyArgs>(args?: SelectSubset<T, subscriptionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subscriptions.
     * @param {subscriptionsCreateArgs} args - Arguments to create a Subscriptions.
     * @example
     * // Create one Subscriptions
     * const Subscriptions = await prisma.subscriptions.create({
     *   data: {
     *     // ... data to create a Subscriptions
     *   }
     * })
     * 
     */
    create<T extends subscriptionsCreateArgs>(args: SelectSubset<T, subscriptionsCreateArgs<ExtArgs>>): Prisma__subscriptionsClient<$Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subscriptions.
     * @param {subscriptionsCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscriptions = await prisma.subscriptions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends subscriptionsCreateManyArgs>(args?: SelectSubset<T, subscriptionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subscriptions and returns the data saved in the database.
     * @param {subscriptionsCreateManyAndReturnArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscriptions = await prisma.subscriptions.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subscriptions and only return the `id`
     * const subscriptionsWithIdOnly = await prisma.subscriptions.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends subscriptionsCreateManyAndReturnArgs>(args?: SelectSubset<T, subscriptionsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Subscriptions.
     * @param {subscriptionsDeleteArgs} args - Arguments to delete one Subscriptions.
     * @example
     * // Delete one Subscriptions
     * const Subscriptions = await prisma.subscriptions.delete({
     *   where: {
     *     // ... filter to delete one Subscriptions
     *   }
     * })
     * 
     */
    delete<T extends subscriptionsDeleteArgs>(args: SelectSubset<T, subscriptionsDeleteArgs<ExtArgs>>): Prisma__subscriptionsClient<$Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subscriptions.
     * @param {subscriptionsUpdateArgs} args - Arguments to update one Subscriptions.
     * @example
     * // Update one Subscriptions
     * const subscriptions = await prisma.subscriptions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends subscriptionsUpdateArgs>(args: SelectSubset<T, subscriptionsUpdateArgs<ExtArgs>>): Prisma__subscriptionsClient<$Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subscriptions.
     * @param {subscriptionsDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscriptions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends subscriptionsDeleteManyArgs>(args?: SelectSubset<T, subscriptionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscriptions = await prisma.subscriptions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends subscriptionsUpdateManyArgs>(args: SelectSubset<T, subscriptionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions and returns the data updated in the database.
     * @param {subscriptionsUpdateManyAndReturnArgs} args - Arguments to update many Subscriptions.
     * @example
     * // Update many Subscriptions
     * const subscriptions = await prisma.subscriptions.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Subscriptions and only return the `id`
     * const subscriptionsWithIdOnly = await prisma.subscriptions.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends subscriptionsUpdateManyAndReturnArgs>(args: SelectSubset<T, subscriptionsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Subscriptions.
     * @param {subscriptionsUpsertArgs} args - Arguments to update or create a Subscriptions.
     * @example
     * // Update or create a Subscriptions
     * const subscriptions = await prisma.subscriptions.upsert({
     *   create: {
     *     // ... data to create a Subscriptions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscriptions we want to update
     *   }
     * })
     */
    upsert<T extends subscriptionsUpsertArgs>(args: SelectSubset<T, subscriptionsUpsertArgs<ExtArgs>>): Prisma__subscriptionsClient<$Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionsCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscriptions.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends subscriptionsCountArgs>(
      args?: Subset<T, subscriptionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionsAggregateArgs>(args: Subset<T, SubscriptionsAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionsAggregateType<T>>

    /**
     * Group by Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends subscriptionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: subscriptionsGroupByArgs['orderBy'] }
        : { orderBy?: subscriptionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, subscriptionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the subscriptions model
   */
  readonly fields: subscriptionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for subscriptions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__subscriptionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    payments<T extends paymentsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, paymentsDefaultArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    membershipPlans<T extends membershipPlansDefaultArgs<ExtArgs> = {}>(args?: Subset<T, membershipPlansDefaultArgs<ExtArgs>>): Prisma__membershipPlansClient<$Result.GetResult<Prisma.$membershipPlansPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the subscriptions model
   */
  interface subscriptionsFieldRefs {
    readonly id: FieldRef<"subscriptions", 'String'>
    readonly start_date: FieldRef<"subscriptions", 'DateTime'>
    readonly end_date: FieldRef<"subscriptions", 'DateTime'>
    readonly amount_paid: FieldRef<"subscriptions", 'BigInt'>
    readonly is_extended: FieldRef<"subscriptions", 'Boolean'>
    readonly status: FieldRef<"subscriptions", 'SubscriptionStatus'>
    readonly user_id: FieldRef<"subscriptions", 'String'>
    readonly plan_id: FieldRef<"subscriptions", 'Int'>
    readonly payment_id: FieldRef<"subscriptions", 'String'>
  }
    

  // Custom InputTypes
  /**
   * subscriptions findUnique
   */
  export type subscriptionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscriptions
     */
    omit?: subscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsInclude<ExtArgs> | null
    /**
     * Filter, which subscriptions to fetch.
     */
    where: subscriptionsWhereUniqueInput
  }

  /**
   * subscriptions findUniqueOrThrow
   */
  export type subscriptionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscriptions
     */
    omit?: subscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsInclude<ExtArgs> | null
    /**
     * Filter, which subscriptions to fetch.
     */
    where: subscriptionsWhereUniqueInput
  }

  /**
   * subscriptions findFirst
   */
  export type subscriptionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscriptions
     */
    omit?: subscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsInclude<ExtArgs> | null
    /**
     * Filter, which subscriptions to fetch.
     */
    where?: subscriptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subscriptions to fetch.
     */
    orderBy?: subscriptionsOrderByWithRelationInput | subscriptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for subscriptions.
     */
    cursor?: subscriptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of subscriptions.
     */
    distinct?: SubscriptionsScalarFieldEnum | SubscriptionsScalarFieldEnum[]
  }

  /**
   * subscriptions findFirstOrThrow
   */
  export type subscriptionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscriptions
     */
    omit?: subscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsInclude<ExtArgs> | null
    /**
     * Filter, which subscriptions to fetch.
     */
    where?: subscriptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subscriptions to fetch.
     */
    orderBy?: subscriptionsOrderByWithRelationInput | subscriptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for subscriptions.
     */
    cursor?: subscriptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of subscriptions.
     */
    distinct?: SubscriptionsScalarFieldEnum | SubscriptionsScalarFieldEnum[]
  }

  /**
   * subscriptions findMany
   */
  export type subscriptionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscriptions
     */
    omit?: subscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsInclude<ExtArgs> | null
    /**
     * Filter, which subscriptions to fetch.
     */
    where?: subscriptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subscriptions to fetch.
     */
    orderBy?: subscriptionsOrderByWithRelationInput | subscriptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing subscriptions.
     */
    cursor?: subscriptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subscriptions.
     */
    skip?: number
    distinct?: SubscriptionsScalarFieldEnum | SubscriptionsScalarFieldEnum[]
  }

  /**
   * subscriptions create
   */
  export type subscriptionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscriptions
     */
    omit?: subscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsInclude<ExtArgs> | null
    /**
     * The data needed to create a subscriptions.
     */
    data: XOR<subscriptionsCreateInput, subscriptionsUncheckedCreateInput>
  }

  /**
   * subscriptions createMany
   */
  export type subscriptionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many subscriptions.
     */
    data: subscriptionsCreateManyInput | subscriptionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * subscriptions createManyAndReturn
   */
  export type subscriptionsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the subscriptions
     */
    omit?: subscriptionsOmit<ExtArgs> | null
    /**
     * The data used to create many subscriptions.
     */
    data: subscriptionsCreateManyInput | subscriptionsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * subscriptions update
   */
  export type subscriptionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscriptions
     */
    omit?: subscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsInclude<ExtArgs> | null
    /**
     * The data needed to update a subscriptions.
     */
    data: XOR<subscriptionsUpdateInput, subscriptionsUncheckedUpdateInput>
    /**
     * Choose, which subscriptions to update.
     */
    where: subscriptionsWhereUniqueInput
  }

  /**
   * subscriptions updateMany
   */
  export type subscriptionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update subscriptions.
     */
    data: XOR<subscriptionsUpdateManyMutationInput, subscriptionsUncheckedUpdateManyInput>
    /**
     * Filter which subscriptions to update
     */
    where?: subscriptionsWhereInput
    /**
     * Limit how many subscriptions to update.
     */
    limit?: number
  }

  /**
   * subscriptions updateManyAndReturn
   */
  export type subscriptionsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the subscriptions
     */
    omit?: subscriptionsOmit<ExtArgs> | null
    /**
     * The data used to update subscriptions.
     */
    data: XOR<subscriptionsUpdateManyMutationInput, subscriptionsUncheckedUpdateManyInput>
    /**
     * Filter which subscriptions to update
     */
    where?: subscriptionsWhereInput
    /**
     * Limit how many subscriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * subscriptions upsert
   */
  export type subscriptionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscriptions
     */
    omit?: subscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsInclude<ExtArgs> | null
    /**
     * The filter to search for the subscriptions to update in case it exists.
     */
    where: subscriptionsWhereUniqueInput
    /**
     * In case the subscriptions found by the `where` argument doesn't exist, create a new subscriptions with this data.
     */
    create: XOR<subscriptionsCreateInput, subscriptionsUncheckedCreateInput>
    /**
     * In case the subscriptions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<subscriptionsUpdateInput, subscriptionsUncheckedUpdateInput>
  }

  /**
   * subscriptions delete
   */
  export type subscriptionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscriptions
     */
    omit?: subscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsInclude<ExtArgs> | null
    /**
     * Filter which subscriptions to delete.
     */
    where: subscriptionsWhereUniqueInput
  }

  /**
   * subscriptions deleteMany
   */
  export type subscriptionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which subscriptions to delete
     */
    where?: subscriptionsWhereInput
    /**
     * Limit how many subscriptions to delete.
     */
    limit?: number
  }

  /**
   * subscriptions without action
   */
  export type subscriptionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscriptions
     */
    omit?: subscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsInclude<ExtArgs> | null
  }


  /**
   * Model userActivitiesHistory
   */

  export type AggregateUserActivitiesHistory = {
    _count: UserActivitiesHistoryCountAggregateOutputType | null
    _avg: UserActivitiesHistoryAvgAggregateOutputType | null
    _sum: UserActivitiesHistorySumAggregateOutputType | null
    _min: UserActivitiesHistoryMinAggregateOutputType | null
    _max: UserActivitiesHistoryMaxAggregateOutputType | null
  }

  export type UserActivitiesHistoryAvgAggregateOutputType = {
    id: number | null
  }

  export type UserActivitiesHistorySumAggregateOutputType = {
    id: number | null
  }

  export type UserActivitiesHistoryMinAggregateOutputType = {
    id: number | null
    activity_name: string | null
    time: Date | null
    user_id: string | null
  }

  export type UserActivitiesHistoryMaxAggregateOutputType = {
    id: number | null
    activity_name: string | null
    time: Date | null
    user_id: string | null
  }

  export type UserActivitiesHistoryCountAggregateOutputType = {
    id: number
    activity_name: number
    time: number
    user_id: number
    _all: number
  }


  export type UserActivitiesHistoryAvgAggregateInputType = {
    id?: true
  }

  export type UserActivitiesHistorySumAggregateInputType = {
    id?: true
  }

  export type UserActivitiesHistoryMinAggregateInputType = {
    id?: true
    activity_name?: true
    time?: true
    user_id?: true
  }

  export type UserActivitiesHistoryMaxAggregateInputType = {
    id?: true
    activity_name?: true
    time?: true
    user_id?: true
  }

  export type UserActivitiesHistoryCountAggregateInputType = {
    id?: true
    activity_name?: true
    time?: true
    user_id?: true
    _all?: true
  }

  export type UserActivitiesHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which userActivitiesHistory to aggregate.
     */
    where?: userActivitiesHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userActivitiesHistories to fetch.
     */
    orderBy?: userActivitiesHistoryOrderByWithRelationInput | userActivitiesHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userActivitiesHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userActivitiesHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userActivitiesHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned userActivitiesHistories
    **/
    _count?: true | UserActivitiesHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserActivitiesHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserActivitiesHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserActivitiesHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserActivitiesHistoryMaxAggregateInputType
  }

  export type GetUserActivitiesHistoryAggregateType<T extends UserActivitiesHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateUserActivitiesHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserActivitiesHistory[P]>
      : GetScalarType<T[P], AggregateUserActivitiesHistory[P]>
  }




  export type userActivitiesHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userActivitiesHistoryWhereInput
    orderBy?: userActivitiesHistoryOrderByWithAggregationInput | userActivitiesHistoryOrderByWithAggregationInput[]
    by: UserActivitiesHistoryScalarFieldEnum[] | UserActivitiesHistoryScalarFieldEnum
    having?: userActivitiesHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserActivitiesHistoryCountAggregateInputType | true
    _avg?: UserActivitiesHistoryAvgAggregateInputType
    _sum?: UserActivitiesHistorySumAggregateInputType
    _min?: UserActivitiesHistoryMinAggregateInputType
    _max?: UserActivitiesHistoryMaxAggregateInputType
  }

  export type UserActivitiesHistoryGroupByOutputType = {
    id: number
    activity_name: string
    time: Date
    user_id: string
    _count: UserActivitiesHistoryCountAggregateOutputType | null
    _avg: UserActivitiesHistoryAvgAggregateOutputType | null
    _sum: UserActivitiesHistorySumAggregateOutputType | null
    _min: UserActivitiesHistoryMinAggregateOutputType | null
    _max: UserActivitiesHistoryMaxAggregateOutputType | null
  }

  type GetUserActivitiesHistoryGroupByPayload<T extends userActivitiesHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserActivitiesHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserActivitiesHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserActivitiesHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], UserActivitiesHistoryGroupByOutputType[P]>
        }
      >
    >


  export type userActivitiesHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    activity_name?: boolean
    time?: boolean
    user_id?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userActivitiesHistory"]>

  export type userActivitiesHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    activity_name?: boolean
    time?: boolean
    user_id?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userActivitiesHistory"]>

  export type userActivitiesHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    activity_name?: boolean
    time?: boolean
    user_id?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userActivitiesHistory"]>

  export type userActivitiesHistorySelectScalar = {
    id?: boolean
    activity_name?: boolean
    time?: boolean
    user_id?: boolean
  }

  export type userActivitiesHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "activity_name" | "time" | "user_id", ExtArgs["result"]["userActivitiesHistory"]>
  export type userActivitiesHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type userActivitiesHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type userActivitiesHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $userActivitiesHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "userActivitiesHistory"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      activity_name: string
      time: Date
      user_id: string
    }, ExtArgs["result"]["userActivitiesHistory"]>
    composites: {}
  }

  type userActivitiesHistoryGetPayload<S extends boolean | null | undefined | userActivitiesHistoryDefaultArgs> = $Result.GetResult<Prisma.$userActivitiesHistoryPayload, S>

  type userActivitiesHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<userActivitiesHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserActivitiesHistoryCountAggregateInputType | true
    }

  export interface userActivitiesHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['userActivitiesHistory'], meta: { name: 'userActivitiesHistory' } }
    /**
     * Find zero or one UserActivitiesHistory that matches the filter.
     * @param {userActivitiesHistoryFindUniqueArgs} args - Arguments to find a UserActivitiesHistory
     * @example
     * // Get one UserActivitiesHistory
     * const userActivitiesHistory = await prisma.userActivitiesHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends userActivitiesHistoryFindUniqueArgs>(args: SelectSubset<T, userActivitiesHistoryFindUniqueArgs<ExtArgs>>): Prisma__userActivitiesHistoryClient<$Result.GetResult<Prisma.$userActivitiesHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserActivitiesHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {userActivitiesHistoryFindUniqueOrThrowArgs} args - Arguments to find a UserActivitiesHistory
     * @example
     * // Get one UserActivitiesHistory
     * const userActivitiesHistory = await prisma.userActivitiesHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends userActivitiesHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, userActivitiesHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__userActivitiesHistoryClient<$Result.GetResult<Prisma.$userActivitiesHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserActivitiesHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userActivitiesHistoryFindFirstArgs} args - Arguments to find a UserActivitiesHistory
     * @example
     * // Get one UserActivitiesHistory
     * const userActivitiesHistory = await prisma.userActivitiesHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends userActivitiesHistoryFindFirstArgs>(args?: SelectSubset<T, userActivitiesHistoryFindFirstArgs<ExtArgs>>): Prisma__userActivitiesHistoryClient<$Result.GetResult<Prisma.$userActivitiesHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserActivitiesHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userActivitiesHistoryFindFirstOrThrowArgs} args - Arguments to find a UserActivitiesHistory
     * @example
     * // Get one UserActivitiesHistory
     * const userActivitiesHistory = await prisma.userActivitiesHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends userActivitiesHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, userActivitiesHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__userActivitiesHistoryClient<$Result.GetResult<Prisma.$userActivitiesHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserActivitiesHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userActivitiesHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserActivitiesHistories
     * const userActivitiesHistories = await prisma.userActivitiesHistory.findMany()
     * 
     * // Get first 10 UserActivitiesHistories
     * const userActivitiesHistories = await prisma.userActivitiesHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userActivitiesHistoryWithIdOnly = await prisma.userActivitiesHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends userActivitiesHistoryFindManyArgs>(args?: SelectSubset<T, userActivitiesHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userActivitiesHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserActivitiesHistory.
     * @param {userActivitiesHistoryCreateArgs} args - Arguments to create a UserActivitiesHistory.
     * @example
     * // Create one UserActivitiesHistory
     * const UserActivitiesHistory = await prisma.userActivitiesHistory.create({
     *   data: {
     *     // ... data to create a UserActivitiesHistory
     *   }
     * })
     * 
     */
    create<T extends userActivitiesHistoryCreateArgs>(args: SelectSubset<T, userActivitiesHistoryCreateArgs<ExtArgs>>): Prisma__userActivitiesHistoryClient<$Result.GetResult<Prisma.$userActivitiesHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserActivitiesHistories.
     * @param {userActivitiesHistoryCreateManyArgs} args - Arguments to create many UserActivitiesHistories.
     * @example
     * // Create many UserActivitiesHistories
     * const userActivitiesHistory = await prisma.userActivitiesHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends userActivitiesHistoryCreateManyArgs>(args?: SelectSubset<T, userActivitiesHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserActivitiesHistories and returns the data saved in the database.
     * @param {userActivitiesHistoryCreateManyAndReturnArgs} args - Arguments to create many UserActivitiesHistories.
     * @example
     * // Create many UserActivitiesHistories
     * const userActivitiesHistory = await prisma.userActivitiesHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserActivitiesHistories and only return the `id`
     * const userActivitiesHistoryWithIdOnly = await prisma.userActivitiesHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends userActivitiesHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, userActivitiesHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userActivitiesHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserActivitiesHistory.
     * @param {userActivitiesHistoryDeleteArgs} args - Arguments to delete one UserActivitiesHistory.
     * @example
     * // Delete one UserActivitiesHistory
     * const UserActivitiesHistory = await prisma.userActivitiesHistory.delete({
     *   where: {
     *     // ... filter to delete one UserActivitiesHistory
     *   }
     * })
     * 
     */
    delete<T extends userActivitiesHistoryDeleteArgs>(args: SelectSubset<T, userActivitiesHistoryDeleteArgs<ExtArgs>>): Prisma__userActivitiesHistoryClient<$Result.GetResult<Prisma.$userActivitiesHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserActivitiesHistory.
     * @param {userActivitiesHistoryUpdateArgs} args - Arguments to update one UserActivitiesHistory.
     * @example
     * // Update one UserActivitiesHistory
     * const userActivitiesHistory = await prisma.userActivitiesHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends userActivitiesHistoryUpdateArgs>(args: SelectSubset<T, userActivitiesHistoryUpdateArgs<ExtArgs>>): Prisma__userActivitiesHistoryClient<$Result.GetResult<Prisma.$userActivitiesHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserActivitiesHistories.
     * @param {userActivitiesHistoryDeleteManyArgs} args - Arguments to filter UserActivitiesHistories to delete.
     * @example
     * // Delete a few UserActivitiesHistories
     * const { count } = await prisma.userActivitiesHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends userActivitiesHistoryDeleteManyArgs>(args?: SelectSubset<T, userActivitiesHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserActivitiesHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userActivitiesHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserActivitiesHistories
     * const userActivitiesHistory = await prisma.userActivitiesHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends userActivitiesHistoryUpdateManyArgs>(args: SelectSubset<T, userActivitiesHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserActivitiesHistories and returns the data updated in the database.
     * @param {userActivitiesHistoryUpdateManyAndReturnArgs} args - Arguments to update many UserActivitiesHistories.
     * @example
     * // Update many UserActivitiesHistories
     * const userActivitiesHistory = await prisma.userActivitiesHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserActivitiesHistories and only return the `id`
     * const userActivitiesHistoryWithIdOnly = await prisma.userActivitiesHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends userActivitiesHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, userActivitiesHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userActivitiesHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserActivitiesHistory.
     * @param {userActivitiesHistoryUpsertArgs} args - Arguments to update or create a UserActivitiesHistory.
     * @example
     * // Update or create a UserActivitiesHistory
     * const userActivitiesHistory = await prisma.userActivitiesHistory.upsert({
     *   create: {
     *     // ... data to create a UserActivitiesHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserActivitiesHistory we want to update
     *   }
     * })
     */
    upsert<T extends userActivitiesHistoryUpsertArgs>(args: SelectSubset<T, userActivitiesHistoryUpsertArgs<ExtArgs>>): Prisma__userActivitiesHistoryClient<$Result.GetResult<Prisma.$userActivitiesHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserActivitiesHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userActivitiesHistoryCountArgs} args - Arguments to filter UserActivitiesHistories to count.
     * @example
     * // Count the number of UserActivitiesHistories
     * const count = await prisma.userActivitiesHistory.count({
     *   where: {
     *     // ... the filter for the UserActivitiesHistories we want to count
     *   }
     * })
    **/
    count<T extends userActivitiesHistoryCountArgs>(
      args?: Subset<T, userActivitiesHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserActivitiesHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserActivitiesHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserActivitiesHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserActivitiesHistoryAggregateArgs>(args: Subset<T, UserActivitiesHistoryAggregateArgs>): Prisma.PrismaPromise<GetUserActivitiesHistoryAggregateType<T>>

    /**
     * Group by UserActivitiesHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userActivitiesHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userActivitiesHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userActivitiesHistoryGroupByArgs['orderBy'] }
        : { orderBy?: userActivitiesHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userActivitiesHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserActivitiesHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the userActivitiesHistory model
   */
  readonly fields: userActivitiesHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for userActivitiesHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userActivitiesHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the userActivitiesHistory model
   */
  interface userActivitiesHistoryFieldRefs {
    readonly id: FieldRef<"userActivitiesHistory", 'Int'>
    readonly activity_name: FieldRef<"userActivitiesHistory", 'String'>
    readonly time: FieldRef<"userActivitiesHistory", 'DateTime'>
    readonly user_id: FieldRef<"userActivitiesHistory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * userActivitiesHistory findUnique
   */
  export type userActivitiesHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userActivitiesHistory
     */
    select?: userActivitiesHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the userActivitiesHistory
     */
    omit?: userActivitiesHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userActivitiesHistoryInclude<ExtArgs> | null
    /**
     * Filter, which userActivitiesHistory to fetch.
     */
    where: userActivitiesHistoryWhereUniqueInput
  }

  /**
   * userActivitiesHistory findUniqueOrThrow
   */
  export type userActivitiesHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userActivitiesHistory
     */
    select?: userActivitiesHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the userActivitiesHistory
     */
    omit?: userActivitiesHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userActivitiesHistoryInclude<ExtArgs> | null
    /**
     * Filter, which userActivitiesHistory to fetch.
     */
    where: userActivitiesHistoryWhereUniqueInput
  }

  /**
   * userActivitiesHistory findFirst
   */
  export type userActivitiesHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userActivitiesHistory
     */
    select?: userActivitiesHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the userActivitiesHistory
     */
    omit?: userActivitiesHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userActivitiesHistoryInclude<ExtArgs> | null
    /**
     * Filter, which userActivitiesHistory to fetch.
     */
    where?: userActivitiesHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userActivitiesHistories to fetch.
     */
    orderBy?: userActivitiesHistoryOrderByWithRelationInput | userActivitiesHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userActivitiesHistories.
     */
    cursor?: userActivitiesHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userActivitiesHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userActivitiesHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userActivitiesHistories.
     */
    distinct?: UserActivitiesHistoryScalarFieldEnum | UserActivitiesHistoryScalarFieldEnum[]
  }

  /**
   * userActivitiesHistory findFirstOrThrow
   */
  export type userActivitiesHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userActivitiesHistory
     */
    select?: userActivitiesHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the userActivitiesHistory
     */
    omit?: userActivitiesHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userActivitiesHistoryInclude<ExtArgs> | null
    /**
     * Filter, which userActivitiesHistory to fetch.
     */
    where?: userActivitiesHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userActivitiesHistories to fetch.
     */
    orderBy?: userActivitiesHistoryOrderByWithRelationInput | userActivitiesHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userActivitiesHistories.
     */
    cursor?: userActivitiesHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userActivitiesHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userActivitiesHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userActivitiesHistories.
     */
    distinct?: UserActivitiesHistoryScalarFieldEnum | UserActivitiesHistoryScalarFieldEnum[]
  }

  /**
   * userActivitiesHistory findMany
   */
  export type userActivitiesHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userActivitiesHistory
     */
    select?: userActivitiesHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the userActivitiesHistory
     */
    omit?: userActivitiesHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userActivitiesHistoryInclude<ExtArgs> | null
    /**
     * Filter, which userActivitiesHistories to fetch.
     */
    where?: userActivitiesHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userActivitiesHistories to fetch.
     */
    orderBy?: userActivitiesHistoryOrderByWithRelationInput | userActivitiesHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing userActivitiesHistories.
     */
    cursor?: userActivitiesHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userActivitiesHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userActivitiesHistories.
     */
    skip?: number
    distinct?: UserActivitiesHistoryScalarFieldEnum | UserActivitiesHistoryScalarFieldEnum[]
  }

  /**
   * userActivitiesHistory create
   */
  export type userActivitiesHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userActivitiesHistory
     */
    select?: userActivitiesHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the userActivitiesHistory
     */
    omit?: userActivitiesHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userActivitiesHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a userActivitiesHistory.
     */
    data: XOR<userActivitiesHistoryCreateInput, userActivitiesHistoryUncheckedCreateInput>
  }

  /**
   * userActivitiesHistory createMany
   */
  export type userActivitiesHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many userActivitiesHistories.
     */
    data: userActivitiesHistoryCreateManyInput | userActivitiesHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * userActivitiesHistory createManyAndReturn
   */
  export type userActivitiesHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userActivitiesHistory
     */
    select?: userActivitiesHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the userActivitiesHistory
     */
    omit?: userActivitiesHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many userActivitiesHistories.
     */
    data: userActivitiesHistoryCreateManyInput | userActivitiesHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userActivitiesHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * userActivitiesHistory update
   */
  export type userActivitiesHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userActivitiesHistory
     */
    select?: userActivitiesHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the userActivitiesHistory
     */
    omit?: userActivitiesHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userActivitiesHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a userActivitiesHistory.
     */
    data: XOR<userActivitiesHistoryUpdateInput, userActivitiesHistoryUncheckedUpdateInput>
    /**
     * Choose, which userActivitiesHistory to update.
     */
    where: userActivitiesHistoryWhereUniqueInput
  }

  /**
   * userActivitiesHistory updateMany
   */
  export type userActivitiesHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update userActivitiesHistories.
     */
    data: XOR<userActivitiesHistoryUpdateManyMutationInput, userActivitiesHistoryUncheckedUpdateManyInput>
    /**
     * Filter which userActivitiesHistories to update
     */
    where?: userActivitiesHistoryWhereInput
    /**
     * Limit how many userActivitiesHistories to update.
     */
    limit?: number
  }

  /**
   * userActivitiesHistory updateManyAndReturn
   */
  export type userActivitiesHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userActivitiesHistory
     */
    select?: userActivitiesHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the userActivitiesHistory
     */
    omit?: userActivitiesHistoryOmit<ExtArgs> | null
    /**
     * The data used to update userActivitiesHistories.
     */
    data: XOR<userActivitiesHistoryUpdateManyMutationInput, userActivitiesHistoryUncheckedUpdateManyInput>
    /**
     * Filter which userActivitiesHistories to update
     */
    where?: userActivitiesHistoryWhereInput
    /**
     * Limit how many userActivitiesHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userActivitiesHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * userActivitiesHistory upsert
   */
  export type userActivitiesHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userActivitiesHistory
     */
    select?: userActivitiesHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the userActivitiesHistory
     */
    omit?: userActivitiesHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userActivitiesHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the userActivitiesHistory to update in case it exists.
     */
    where: userActivitiesHistoryWhereUniqueInput
    /**
     * In case the userActivitiesHistory found by the `where` argument doesn't exist, create a new userActivitiesHistory with this data.
     */
    create: XOR<userActivitiesHistoryCreateInput, userActivitiesHistoryUncheckedCreateInput>
    /**
     * In case the userActivitiesHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userActivitiesHistoryUpdateInput, userActivitiesHistoryUncheckedUpdateInput>
  }

  /**
   * userActivitiesHistory delete
   */
  export type userActivitiesHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userActivitiesHistory
     */
    select?: userActivitiesHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the userActivitiesHistory
     */
    omit?: userActivitiesHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userActivitiesHistoryInclude<ExtArgs> | null
    /**
     * Filter which userActivitiesHistory to delete.
     */
    where: userActivitiesHistoryWhereUniqueInput
  }

  /**
   * userActivitiesHistory deleteMany
   */
  export type userActivitiesHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which userActivitiesHistories to delete
     */
    where?: userActivitiesHistoryWhereInput
    /**
     * Limit how many userActivitiesHistories to delete.
     */
    limit?: number
  }

  /**
   * userActivitiesHistory without action
   */
  export type userActivitiesHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userActivitiesHistory
     */
    select?: userActivitiesHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the userActivitiesHistory
     */
    omit?: userActivitiesHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userActivitiesHistoryInclude<ExtArgs> | null
  }


  /**
   * Model userNotifications
   */

  export type AggregateUserNotifications = {
    _count: UserNotificationsCountAggregateOutputType | null
    _avg: UserNotificationsAvgAggregateOutputType | null
    _sum: UserNotificationsSumAggregateOutputType | null
    _min: UserNotificationsMinAggregateOutputType | null
    _max: UserNotificationsMaxAggregateOutputType | null
  }

  export type UserNotificationsAvgAggregateOutputType = {
    id: number | null
  }

  export type UserNotificationsSumAggregateOutputType = {
    id: number | null
  }

  export type UserNotificationsMinAggregateOutputType = {
    id: number | null
    user_id: string | null
    title: string | null
    content: string | null
    type: $Enums.NotificationsType | null
    is_read: boolean | null
    sent_at: Date | null
    read_at: Date | null
  }

  export type UserNotificationsMaxAggregateOutputType = {
    id: number | null
    user_id: string | null
    title: string | null
    content: string | null
    type: $Enums.NotificationsType | null
    is_read: boolean | null
    sent_at: Date | null
    read_at: Date | null
  }

  export type UserNotificationsCountAggregateOutputType = {
    id: number
    user_id: number
    title: number
    content: number
    type: number
    is_read: number
    sent_at: number
    read_at: number
    _all: number
  }


  export type UserNotificationsAvgAggregateInputType = {
    id?: true
  }

  export type UserNotificationsSumAggregateInputType = {
    id?: true
  }

  export type UserNotificationsMinAggregateInputType = {
    id?: true
    user_id?: true
    title?: true
    content?: true
    type?: true
    is_read?: true
    sent_at?: true
    read_at?: true
  }

  export type UserNotificationsMaxAggregateInputType = {
    id?: true
    user_id?: true
    title?: true
    content?: true
    type?: true
    is_read?: true
    sent_at?: true
    read_at?: true
  }

  export type UserNotificationsCountAggregateInputType = {
    id?: true
    user_id?: true
    title?: true
    content?: true
    type?: true
    is_read?: true
    sent_at?: true
    read_at?: true
    _all?: true
  }

  export type UserNotificationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which userNotifications to aggregate.
     */
    where?: userNotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userNotifications to fetch.
     */
    orderBy?: userNotificationsOrderByWithRelationInput | userNotificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userNotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned userNotifications
    **/
    _count?: true | UserNotificationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserNotificationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserNotificationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserNotificationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserNotificationsMaxAggregateInputType
  }

  export type GetUserNotificationsAggregateType<T extends UserNotificationsAggregateArgs> = {
        [P in keyof T & keyof AggregateUserNotifications]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserNotifications[P]>
      : GetScalarType<T[P], AggregateUserNotifications[P]>
  }




  export type userNotificationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userNotificationsWhereInput
    orderBy?: userNotificationsOrderByWithAggregationInput | userNotificationsOrderByWithAggregationInput[]
    by: UserNotificationsScalarFieldEnum[] | UserNotificationsScalarFieldEnum
    having?: userNotificationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserNotificationsCountAggregateInputType | true
    _avg?: UserNotificationsAvgAggregateInputType
    _sum?: UserNotificationsSumAggregateInputType
    _min?: UserNotificationsMinAggregateInputType
    _max?: UserNotificationsMaxAggregateInputType
  }

  export type UserNotificationsGroupByOutputType = {
    id: number
    user_id: string
    title: string
    content: string | null
    type: $Enums.NotificationsType
    is_read: boolean
    sent_at: Date
    read_at: Date | null
    _count: UserNotificationsCountAggregateOutputType | null
    _avg: UserNotificationsAvgAggregateOutputType | null
    _sum: UserNotificationsSumAggregateOutputType | null
    _min: UserNotificationsMinAggregateOutputType | null
    _max: UserNotificationsMaxAggregateOutputType | null
  }

  type GetUserNotificationsGroupByPayload<T extends userNotificationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserNotificationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserNotificationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserNotificationsGroupByOutputType[P]>
            : GetScalarType<T[P], UserNotificationsGroupByOutputType[P]>
        }
      >
    >


  export type userNotificationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    title?: boolean
    content?: boolean
    type?: boolean
    is_read?: boolean
    sent_at?: boolean
    read_at?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userNotifications"]>

  export type userNotificationsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    title?: boolean
    content?: boolean
    type?: boolean
    is_read?: boolean
    sent_at?: boolean
    read_at?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userNotifications"]>

  export type userNotificationsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    title?: boolean
    content?: boolean
    type?: boolean
    is_read?: boolean
    sent_at?: boolean
    read_at?: boolean
    users?: boolean | usersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userNotifications"]>

  export type userNotificationsSelectScalar = {
    id?: boolean
    user_id?: boolean
    title?: boolean
    content?: boolean
    type?: boolean
    is_read?: boolean
    sent_at?: boolean
    read_at?: boolean
  }

  export type userNotificationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "title" | "content" | "type" | "is_read" | "sent_at" | "read_at", ExtArgs["result"]["userNotifications"]>
  export type userNotificationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type userNotificationsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }
  export type userNotificationsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | usersDefaultArgs<ExtArgs>
  }

  export type $userNotificationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "userNotifications"
    objects: {
      users: Prisma.$usersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_id: string
      title: string
      content: string | null
      type: $Enums.NotificationsType
      is_read: boolean
      sent_at: Date
      read_at: Date | null
    }, ExtArgs["result"]["userNotifications"]>
    composites: {}
  }

  type userNotificationsGetPayload<S extends boolean | null | undefined | userNotificationsDefaultArgs> = $Result.GetResult<Prisma.$userNotificationsPayload, S>

  type userNotificationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<userNotificationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserNotificationsCountAggregateInputType | true
    }

  export interface userNotificationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['userNotifications'], meta: { name: 'userNotifications' } }
    /**
     * Find zero or one UserNotifications that matches the filter.
     * @param {userNotificationsFindUniqueArgs} args - Arguments to find a UserNotifications
     * @example
     * // Get one UserNotifications
     * const userNotifications = await prisma.userNotifications.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends userNotificationsFindUniqueArgs>(args: SelectSubset<T, userNotificationsFindUniqueArgs<ExtArgs>>): Prisma__userNotificationsClient<$Result.GetResult<Prisma.$userNotificationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserNotifications that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {userNotificationsFindUniqueOrThrowArgs} args - Arguments to find a UserNotifications
     * @example
     * // Get one UserNotifications
     * const userNotifications = await prisma.userNotifications.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends userNotificationsFindUniqueOrThrowArgs>(args: SelectSubset<T, userNotificationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__userNotificationsClient<$Result.GetResult<Prisma.$userNotificationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserNotifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userNotificationsFindFirstArgs} args - Arguments to find a UserNotifications
     * @example
     * // Get one UserNotifications
     * const userNotifications = await prisma.userNotifications.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends userNotificationsFindFirstArgs>(args?: SelectSubset<T, userNotificationsFindFirstArgs<ExtArgs>>): Prisma__userNotificationsClient<$Result.GetResult<Prisma.$userNotificationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserNotifications that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userNotificationsFindFirstOrThrowArgs} args - Arguments to find a UserNotifications
     * @example
     * // Get one UserNotifications
     * const userNotifications = await prisma.userNotifications.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends userNotificationsFindFirstOrThrowArgs>(args?: SelectSubset<T, userNotificationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__userNotificationsClient<$Result.GetResult<Prisma.$userNotificationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserNotifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userNotificationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserNotifications
     * const userNotifications = await prisma.userNotifications.findMany()
     * 
     * // Get first 10 UserNotifications
     * const userNotifications = await prisma.userNotifications.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userNotificationsWithIdOnly = await prisma.userNotifications.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends userNotificationsFindManyArgs>(args?: SelectSubset<T, userNotificationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userNotificationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserNotifications.
     * @param {userNotificationsCreateArgs} args - Arguments to create a UserNotifications.
     * @example
     * // Create one UserNotifications
     * const UserNotifications = await prisma.userNotifications.create({
     *   data: {
     *     // ... data to create a UserNotifications
     *   }
     * })
     * 
     */
    create<T extends userNotificationsCreateArgs>(args: SelectSubset<T, userNotificationsCreateArgs<ExtArgs>>): Prisma__userNotificationsClient<$Result.GetResult<Prisma.$userNotificationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserNotifications.
     * @param {userNotificationsCreateManyArgs} args - Arguments to create many UserNotifications.
     * @example
     * // Create many UserNotifications
     * const userNotifications = await prisma.userNotifications.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends userNotificationsCreateManyArgs>(args?: SelectSubset<T, userNotificationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserNotifications and returns the data saved in the database.
     * @param {userNotificationsCreateManyAndReturnArgs} args - Arguments to create many UserNotifications.
     * @example
     * // Create many UserNotifications
     * const userNotifications = await prisma.userNotifications.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserNotifications and only return the `id`
     * const userNotificationsWithIdOnly = await prisma.userNotifications.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends userNotificationsCreateManyAndReturnArgs>(args?: SelectSubset<T, userNotificationsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userNotificationsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserNotifications.
     * @param {userNotificationsDeleteArgs} args - Arguments to delete one UserNotifications.
     * @example
     * // Delete one UserNotifications
     * const UserNotifications = await prisma.userNotifications.delete({
     *   where: {
     *     // ... filter to delete one UserNotifications
     *   }
     * })
     * 
     */
    delete<T extends userNotificationsDeleteArgs>(args: SelectSubset<T, userNotificationsDeleteArgs<ExtArgs>>): Prisma__userNotificationsClient<$Result.GetResult<Prisma.$userNotificationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserNotifications.
     * @param {userNotificationsUpdateArgs} args - Arguments to update one UserNotifications.
     * @example
     * // Update one UserNotifications
     * const userNotifications = await prisma.userNotifications.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends userNotificationsUpdateArgs>(args: SelectSubset<T, userNotificationsUpdateArgs<ExtArgs>>): Prisma__userNotificationsClient<$Result.GetResult<Prisma.$userNotificationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserNotifications.
     * @param {userNotificationsDeleteManyArgs} args - Arguments to filter UserNotifications to delete.
     * @example
     * // Delete a few UserNotifications
     * const { count } = await prisma.userNotifications.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends userNotificationsDeleteManyArgs>(args?: SelectSubset<T, userNotificationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userNotificationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserNotifications
     * const userNotifications = await prisma.userNotifications.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends userNotificationsUpdateManyArgs>(args: SelectSubset<T, userNotificationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserNotifications and returns the data updated in the database.
     * @param {userNotificationsUpdateManyAndReturnArgs} args - Arguments to update many UserNotifications.
     * @example
     * // Update many UserNotifications
     * const userNotifications = await prisma.userNotifications.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserNotifications and only return the `id`
     * const userNotificationsWithIdOnly = await prisma.userNotifications.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends userNotificationsUpdateManyAndReturnArgs>(args: SelectSubset<T, userNotificationsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userNotificationsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserNotifications.
     * @param {userNotificationsUpsertArgs} args - Arguments to update or create a UserNotifications.
     * @example
     * // Update or create a UserNotifications
     * const userNotifications = await prisma.userNotifications.upsert({
     *   create: {
     *     // ... data to create a UserNotifications
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserNotifications we want to update
     *   }
     * })
     */
    upsert<T extends userNotificationsUpsertArgs>(args: SelectSubset<T, userNotificationsUpsertArgs<ExtArgs>>): Prisma__userNotificationsClient<$Result.GetResult<Prisma.$userNotificationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userNotificationsCountArgs} args - Arguments to filter UserNotifications to count.
     * @example
     * // Count the number of UserNotifications
     * const count = await prisma.userNotifications.count({
     *   where: {
     *     // ... the filter for the UserNotifications we want to count
     *   }
     * })
    **/
    count<T extends userNotificationsCountArgs>(
      args?: Subset<T, userNotificationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserNotificationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserNotificationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserNotificationsAggregateArgs>(args: Subset<T, UserNotificationsAggregateArgs>): Prisma.PrismaPromise<GetUserNotificationsAggregateType<T>>

    /**
     * Group by UserNotifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userNotificationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userNotificationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userNotificationsGroupByArgs['orderBy'] }
        : { orderBy?: userNotificationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userNotificationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserNotificationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the userNotifications model
   */
  readonly fields: userNotificationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for userNotifications.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userNotificationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, usersDefaultArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the userNotifications model
   */
  interface userNotificationsFieldRefs {
    readonly id: FieldRef<"userNotifications", 'Int'>
    readonly user_id: FieldRef<"userNotifications", 'String'>
    readonly title: FieldRef<"userNotifications", 'String'>
    readonly content: FieldRef<"userNotifications", 'String'>
    readonly type: FieldRef<"userNotifications", 'NotificationsType'>
    readonly is_read: FieldRef<"userNotifications", 'Boolean'>
    readonly sent_at: FieldRef<"userNotifications", 'DateTime'>
    readonly read_at: FieldRef<"userNotifications", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * userNotifications findUnique
   */
  export type userNotificationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userNotifications
     */
    select?: userNotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userNotifications
     */
    omit?: userNotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userNotificationsInclude<ExtArgs> | null
    /**
     * Filter, which userNotifications to fetch.
     */
    where: userNotificationsWhereUniqueInput
  }

  /**
   * userNotifications findUniqueOrThrow
   */
  export type userNotificationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userNotifications
     */
    select?: userNotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userNotifications
     */
    omit?: userNotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userNotificationsInclude<ExtArgs> | null
    /**
     * Filter, which userNotifications to fetch.
     */
    where: userNotificationsWhereUniqueInput
  }

  /**
   * userNotifications findFirst
   */
  export type userNotificationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userNotifications
     */
    select?: userNotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userNotifications
     */
    omit?: userNotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userNotificationsInclude<ExtArgs> | null
    /**
     * Filter, which userNotifications to fetch.
     */
    where?: userNotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userNotifications to fetch.
     */
    orderBy?: userNotificationsOrderByWithRelationInput | userNotificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userNotifications.
     */
    cursor?: userNotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userNotifications.
     */
    distinct?: UserNotificationsScalarFieldEnum | UserNotificationsScalarFieldEnum[]
  }

  /**
   * userNotifications findFirstOrThrow
   */
  export type userNotificationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userNotifications
     */
    select?: userNotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userNotifications
     */
    omit?: userNotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userNotificationsInclude<ExtArgs> | null
    /**
     * Filter, which userNotifications to fetch.
     */
    where?: userNotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userNotifications to fetch.
     */
    orderBy?: userNotificationsOrderByWithRelationInput | userNotificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userNotifications.
     */
    cursor?: userNotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userNotifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userNotifications.
     */
    distinct?: UserNotificationsScalarFieldEnum | UserNotificationsScalarFieldEnum[]
  }

  /**
   * userNotifications findMany
   */
  export type userNotificationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userNotifications
     */
    select?: userNotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userNotifications
     */
    omit?: userNotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userNotificationsInclude<ExtArgs> | null
    /**
     * Filter, which userNotifications to fetch.
     */
    where?: userNotificationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userNotifications to fetch.
     */
    orderBy?: userNotificationsOrderByWithRelationInput | userNotificationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing userNotifications.
     */
    cursor?: userNotificationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userNotifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userNotifications.
     */
    skip?: number
    distinct?: UserNotificationsScalarFieldEnum | UserNotificationsScalarFieldEnum[]
  }

  /**
   * userNotifications create
   */
  export type userNotificationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userNotifications
     */
    select?: userNotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userNotifications
     */
    omit?: userNotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userNotificationsInclude<ExtArgs> | null
    /**
     * The data needed to create a userNotifications.
     */
    data: XOR<userNotificationsCreateInput, userNotificationsUncheckedCreateInput>
  }

  /**
   * userNotifications createMany
   */
  export type userNotificationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many userNotifications.
     */
    data: userNotificationsCreateManyInput | userNotificationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * userNotifications createManyAndReturn
   */
  export type userNotificationsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userNotifications
     */
    select?: userNotificationsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the userNotifications
     */
    omit?: userNotificationsOmit<ExtArgs> | null
    /**
     * The data used to create many userNotifications.
     */
    data: userNotificationsCreateManyInput | userNotificationsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userNotificationsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * userNotifications update
   */
  export type userNotificationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userNotifications
     */
    select?: userNotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userNotifications
     */
    omit?: userNotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userNotificationsInclude<ExtArgs> | null
    /**
     * The data needed to update a userNotifications.
     */
    data: XOR<userNotificationsUpdateInput, userNotificationsUncheckedUpdateInput>
    /**
     * Choose, which userNotifications to update.
     */
    where: userNotificationsWhereUniqueInput
  }

  /**
   * userNotifications updateMany
   */
  export type userNotificationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update userNotifications.
     */
    data: XOR<userNotificationsUpdateManyMutationInput, userNotificationsUncheckedUpdateManyInput>
    /**
     * Filter which userNotifications to update
     */
    where?: userNotificationsWhereInput
    /**
     * Limit how many userNotifications to update.
     */
    limit?: number
  }

  /**
   * userNotifications updateManyAndReturn
   */
  export type userNotificationsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userNotifications
     */
    select?: userNotificationsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the userNotifications
     */
    omit?: userNotificationsOmit<ExtArgs> | null
    /**
     * The data used to update userNotifications.
     */
    data: XOR<userNotificationsUpdateManyMutationInput, userNotificationsUncheckedUpdateManyInput>
    /**
     * Filter which userNotifications to update
     */
    where?: userNotificationsWhereInput
    /**
     * Limit how many userNotifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userNotificationsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * userNotifications upsert
   */
  export type userNotificationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userNotifications
     */
    select?: userNotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userNotifications
     */
    omit?: userNotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userNotificationsInclude<ExtArgs> | null
    /**
     * The filter to search for the userNotifications to update in case it exists.
     */
    where: userNotificationsWhereUniqueInput
    /**
     * In case the userNotifications found by the `where` argument doesn't exist, create a new userNotifications with this data.
     */
    create: XOR<userNotificationsCreateInput, userNotificationsUncheckedCreateInput>
    /**
     * In case the userNotifications was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userNotificationsUpdateInput, userNotificationsUncheckedUpdateInput>
  }

  /**
   * userNotifications delete
   */
  export type userNotificationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userNotifications
     */
    select?: userNotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userNotifications
     */
    omit?: userNotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userNotificationsInclude<ExtArgs> | null
    /**
     * Filter which userNotifications to delete.
     */
    where: userNotificationsWhereUniqueInput
  }

  /**
   * userNotifications deleteMany
   */
  export type userNotificationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which userNotifications to delete
     */
    where?: userNotificationsWhereInput
    /**
     * Limit how many userNotifications to delete.
     */
    limit?: number
  }

  /**
   * userNotifications without action
   */
  export type userNotificationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userNotifications
     */
    select?: userNotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userNotifications
     */
    omit?: userNotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userNotificationsInclude<ExtArgs> | null
  }


  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    role_id: number | null
  }

  export type UsersSumAggregateOutputType = {
    role_id: number | null
  }

  export type UsersMinAggregateOutputType = {
    id: string | null
    username: string | null
    password: string | null
    avatar_url: string | null
    email: string | null
    phone: string | null
    address_street: string | null
    address_ward: string | null
    address_city: string | null
    address_country: string | null
    gender: $Enums.Gender | null
    is_deleted: boolean | null
    created_at: Date | null
    updated_at: Date | null
    role_id: number | null
  }

  export type UsersMaxAggregateOutputType = {
    id: string | null
    username: string | null
    password: string | null
    avatar_url: string | null
    email: string | null
    phone: string | null
    address_street: string | null
    address_ward: string | null
    address_city: string | null
    address_country: string | null
    gender: $Enums.Gender | null
    is_deleted: boolean | null
    created_at: Date | null
    updated_at: Date | null
    role_id: number | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    username: number
    password: number
    avatar_url: number
    email: number
    phone: number
    address_street: number
    address_ward: number
    address_city: number
    address_country: number
    gender: number
    is_deleted: number
    created_at: number
    updated_at: number
    role_id: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    role_id?: true
  }

  export type UsersSumAggregateInputType = {
    role_id?: true
  }

  export type UsersMinAggregateInputType = {
    id?: true
    username?: true
    password?: true
    avatar_url?: true
    email?: true
    phone?: true
    address_street?: true
    address_ward?: true
    address_city?: true
    address_country?: true
    gender?: true
    is_deleted?: true
    created_at?: true
    updated_at?: true
    role_id?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    username?: true
    password?: true
    avatar_url?: true
    email?: true
    phone?: true
    address_street?: true
    address_ward?: true
    address_city?: true
    address_country?: true
    gender?: true
    is_deleted?: true
    created_at?: true
    updated_at?: true
    role_id?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    username?: true
    password?: true
    avatar_url?: true
    email?: true
    phone?: true
    address_street?: true
    address_ward?: true
    address_city?: true
    address_country?: true
    gender?: true
    is_deleted?: true
    created_at?: true
    updated_at?: true
    role_id?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: string
    username: string
    password: string
    avatar_url: string | null
    email: string
    phone: string | null
    address_street: string | null
    address_ward: string | null
    address_city: string | null
    address_country: string | null
    gender: $Enums.Gender | null
    is_deleted: boolean
    created_at: Date
    updated_at: Date
    role_id: number
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    avatar_url?: boolean
    email?: boolean
    phone?: boolean
    address_street?: boolean
    address_ward?: boolean
    address_city?: boolean
    address_country?: boolean
    gender?: boolean
    is_deleted?: boolean
    created_at?: boolean
    updated_at?: boolean
    role_id?: boolean
    blogs?: boolean | users$blogsArgs<ExtArgs>
    careerPaths?: boolean | users$careerPathsArgs<ExtArgs>
    companies?: boolean | users$companiesArgs<ExtArgs>
    feedbacks?: boolean | users$feedbacksArgs<ExtArgs>
    followedCompanies?: boolean | users$followedCompaniesArgs<ExtArgs>
    messages?: boolean | users$messagesArgs<ExtArgs>
    payments?: boolean | users$paymentsArgs<ExtArgs>
    personalityTestResults?: boolean | users$personalityTestResultsArgs<ExtArgs>
    savedJobs?: boolean | users$savedJobsArgs<ExtArgs>
    subscriptions?: boolean | users$subscriptionsArgs<ExtArgs>
    userActivitiesHistory?: boolean | users$userActivitiesHistoryArgs<ExtArgs>
    userNotifications?: boolean | users$userNotificationsArgs<ExtArgs>
    roles?: boolean | rolesDefaultArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type usersSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    avatar_url?: boolean
    email?: boolean
    phone?: boolean
    address_street?: boolean
    address_ward?: boolean
    address_city?: boolean
    address_country?: boolean
    gender?: boolean
    is_deleted?: boolean
    created_at?: boolean
    updated_at?: boolean
    role_id?: boolean
    roles?: boolean | rolesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type usersSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    username?: boolean
    password?: boolean
    avatar_url?: boolean
    email?: boolean
    phone?: boolean
    address_street?: boolean
    address_ward?: boolean
    address_city?: boolean
    address_country?: boolean
    gender?: boolean
    is_deleted?: boolean
    created_at?: boolean
    updated_at?: boolean
    role_id?: boolean
    roles?: boolean | rolesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>

  export type usersSelectScalar = {
    id?: boolean
    username?: boolean
    password?: boolean
    avatar_url?: boolean
    email?: boolean
    phone?: boolean
    address_street?: boolean
    address_ward?: boolean
    address_city?: boolean
    address_country?: boolean
    gender?: boolean
    is_deleted?: boolean
    created_at?: boolean
    updated_at?: boolean
    role_id?: boolean
  }

  export type usersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "username" | "password" | "avatar_url" | "email" | "phone" | "address_street" | "address_ward" | "address_city" | "address_country" | "gender" | "is_deleted" | "created_at" | "updated_at" | "role_id", ExtArgs["result"]["users"]>
  export type usersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    blogs?: boolean | users$blogsArgs<ExtArgs>
    careerPaths?: boolean | users$careerPathsArgs<ExtArgs>
    companies?: boolean | users$companiesArgs<ExtArgs>
    feedbacks?: boolean | users$feedbacksArgs<ExtArgs>
    followedCompanies?: boolean | users$followedCompaniesArgs<ExtArgs>
    messages?: boolean | users$messagesArgs<ExtArgs>
    payments?: boolean | users$paymentsArgs<ExtArgs>
    personalityTestResults?: boolean | users$personalityTestResultsArgs<ExtArgs>
    savedJobs?: boolean | users$savedJobsArgs<ExtArgs>
    subscriptions?: boolean | users$subscriptionsArgs<ExtArgs>
    userActivitiesHistory?: boolean | users$userActivitiesHistoryArgs<ExtArgs>
    userNotifications?: boolean | users$userNotificationsArgs<ExtArgs>
    roles?: boolean | rolesDefaultArgs<ExtArgs>
    _count?: boolean | UsersCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type usersIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | rolesDefaultArgs<ExtArgs>
  }
  export type usersIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | rolesDefaultArgs<ExtArgs>
  }

  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users"
    objects: {
      blogs: Prisma.$blogsPayload<ExtArgs>[]
      careerPaths: Prisma.$careerPathsPayload<ExtArgs>[]
      companies: Prisma.$companiesPayload<ExtArgs> | null
      feedbacks: Prisma.$feedbacksPayload<ExtArgs>[]
      followedCompanies: Prisma.$followedCompaniesPayload<ExtArgs>[]
      messages: Prisma.$messagesPayload<ExtArgs>[]
      payments: Prisma.$paymentsPayload<ExtArgs>[]
      personalityTestResults: Prisma.$personalityTestResultsPayload<ExtArgs>[]
      savedJobs: Prisma.$savedJobsPayload<ExtArgs>[]
      subscriptions: Prisma.$subscriptionsPayload<ExtArgs>[]
      userActivitiesHistory: Prisma.$userActivitiesHistoryPayload<ExtArgs>[]
      userNotifications: Prisma.$userNotificationsPayload<ExtArgs>[]
      roles: Prisma.$rolesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      username: string
      password: string
      avatar_url: string | null
      email: string
      phone: string | null
      address_street: string | null
      address_ward: string | null
      address_city: string | null
      address_country: string | null
      gender: $Enums.Gender | null
      is_deleted: boolean
      created_at: Date
      updated_at: Date
      role_id: number
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usersFindUniqueArgs>(args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(args: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usersFindFirstArgs>(args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends usersFindManyArgs>(args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends usersCreateArgs>(args: SelectSubset<T, usersCreateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {usersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usersCreateManyArgs>(args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {usersCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends usersCreateManyAndReturnArgs>(args?: SelectSubset<T, usersCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends usersDeleteArgs>(args: SelectSubset<T, usersDeleteArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usersUpdateArgs>(args: SelectSubset<T, usersUpdateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usersDeleteManyArgs>(args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usersUpdateManyArgs>(args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {usersUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const usersWithIdOnly = await prisma.users.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends usersUpdateManyAndReturnArgs>(args: SelectSubset<T, usersUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends usersUpsertArgs>(args: SelectSubset<T, usersUpsertArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users model
   */
  readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    blogs<T extends users$blogsArgs<ExtArgs> = {}>(args?: Subset<T, users$blogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$blogsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    careerPaths<T extends users$careerPathsArgs<ExtArgs> = {}>(args?: Subset<T, users$careerPathsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$careerPathsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    companies<T extends users$companiesArgs<ExtArgs> = {}>(args?: Subset<T, users$companiesArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    feedbacks<T extends users$feedbacksArgs<ExtArgs> = {}>(args?: Subset<T, users$feedbacksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$feedbacksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    followedCompanies<T extends users$followedCompaniesArgs<ExtArgs> = {}>(args?: Subset<T, users$followedCompaniesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$followedCompaniesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    messages<T extends users$messagesArgs<ExtArgs> = {}>(args?: Subset<T, users$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$messagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends users$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, users$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    personalityTestResults<T extends users$personalityTestResultsArgs<ExtArgs> = {}>(args?: Subset<T, users$personalityTestResultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$personalityTestResultsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    savedJobs<T extends users$savedJobsArgs<ExtArgs> = {}>(args?: Subset<T, users$savedJobsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$savedJobsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subscriptions<T extends users$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, users$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userActivitiesHistory<T extends users$userActivitiesHistoryArgs<ExtArgs> = {}>(args?: Subset<T, users$userActivitiesHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userActivitiesHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userNotifications<T extends users$userNotificationsArgs<ExtArgs> = {}>(args?: Subset<T, users$userNotificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userNotificationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    roles<T extends rolesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, rolesDefaultArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the users model
   */
  interface usersFieldRefs {
    readonly id: FieldRef<"users", 'String'>
    readonly username: FieldRef<"users", 'String'>
    readonly password: FieldRef<"users", 'String'>
    readonly avatar_url: FieldRef<"users", 'String'>
    readonly email: FieldRef<"users", 'String'>
    readonly phone: FieldRef<"users", 'String'>
    readonly address_street: FieldRef<"users", 'String'>
    readonly address_ward: FieldRef<"users", 'String'>
    readonly address_city: FieldRef<"users", 'String'>
    readonly address_country: FieldRef<"users", 'String'>
    readonly gender: FieldRef<"users", 'Gender'>
    readonly is_deleted: FieldRef<"users", 'Boolean'>
    readonly created_at: FieldRef<"users", 'DateTime'>
    readonly updated_at: FieldRef<"users", 'DateTime'>
    readonly role_id: FieldRef<"users", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findFirst
   */
  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }

  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users createManyAndReturn
   */
  export type usersCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * users updateManyAndReturn
   */
  export type usersUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }

  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * users.blogs
   */
  export type users$blogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the blogs
     */
    select?: blogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the blogs
     */
    omit?: blogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: blogsInclude<ExtArgs> | null
    where?: blogsWhereInput
    orderBy?: blogsOrderByWithRelationInput | blogsOrderByWithRelationInput[]
    cursor?: blogsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BlogsScalarFieldEnum | BlogsScalarFieldEnum[]
  }

  /**
   * users.careerPaths
   */
  export type users$careerPathsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the careerPaths
     */
    select?: careerPathsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the careerPaths
     */
    omit?: careerPathsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: careerPathsInclude<ExtArgs> | null
    where?: careerPathsWhereInput
    orderBy?: careerPathsOrderByWithRelationInput | careerPathsOrderByWithRelationInput[]
    cursor?: careerPathsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CareerPathsScalarFieldEnum | CareerPathsScalarFieldEnum[]
  }

  /**
   * users.companies
   */
  export type users$companiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    where?: companiesWhereInput
  }

  /**
   * users.feedbacks
   */
  export type users$feedbacksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the feedbacks
     */
    select?: feedbacksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the feedbacks
     */
    omit?: feedbacksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: feedbacksInclude<ExtArgs> | null
    where?: feedbacksWhereInput
    orderBy?: feedbacksOrderByWithRelationInput | feedbacksOrderByWithRelationInput[]
    cursor?: feedbacksWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FeedbacksScalarFieldEnum | FeedbacksScalarFieldEnum[]
  }

  /**
   * users.followedCompanies
   */
  export type users$followedCompaniesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the followedCompanies
     */
    select?: followedCompaniesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the followedCompanies
     */
    omit?: followedCompaniesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: followedCompaniesInclude<ExtArgs> | null
    where?: followedCompaniesWhereInput
    orderBy?: followedCompaniesOrderByWithRelationInput | followedCompaniesOrderByWithRelationInput[]
    cursor?: followedCompaniesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FollowedCompaniesScalarFieldEnum | FollowedCompaniesScalarFieldEnum[]
  }

  /**
   * users.messages
   */
  export type users$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the messages
     */
    select?: messagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the messages
     */
    omit?: messagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: messagesInclude<ExtArgs> | null
    where?: messagesWhereInput
    orderBy?: messagesOrderByWithRelationInput | messagesOrderByWithRelationInput[]
    cursor?: messagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessagesScalarFieldEnum | MessagesScalarFieldEnum[]
  }

  /**
   * users.payments
   */
  export type users$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    where?: paymentsWhereInput
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    cursor?: paymentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * users.personalityTestResults
   */
  export type users$personalityTestResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the personalityTestResults
     */
    select?: personalityTestResultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the personalityTestResults
     */
    omit?: personalityTestResultsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: personalityTestResultsInclude<ExtArgs> | null
    where?: personalityTestResultsWhereInput
    orderBy?: personalityTestResultsOrderByWithRelationInput | personalityTestResultsOrderByWithRelationInput[]
    cursor?: personalityTestResultsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersonalityTestResultsScalarFieldEnum | PersonalityTestResultsScalarFieldEnum[]
  }

  /**
   * users.savedJobs
   */
  export type users$savedJobsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the savedJobs
     */
    select?: savedJobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the savedJobs
     */
    omit?: savedJobsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: savedJobsInclude<ExtArgs> | null
    where?: savedJobsWhereInput
    orderBy?: savedJobsOrderByWithRelationInput | savedJobsOrderByWithRelationInput[]
    cursor?: savedJobsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SavedJobsScalarFieldEnum | SavedJobsScalarFieldEnum[]
  }

  /**
   * users.subscriptions
   */
  export type users$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscriptions
     */
    omit?: subscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsInclude<ExtArgs> | null
    where?: subscriptionsWhereInput
    orderBy?: subscriptionsOrderByWithRelationInput | subscriptionsOrderByWithRelationInput[]
    cursor?: subscriptionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionsScalarFieldEnum | SubscriptionsScalarFieldEnum[]
  }

  /**
   * users.userActivitiesHistory
   */
  export type users$userActivitiesHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userActivitiesHistory
     */
    select?: userActivitiesHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the userActivitiesHistory
     */
    omit?: userActivitiesHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userActivitiesHistoryInclude<ExtArgs> | null
    where?: userActivitiesHistoryWhereInput
    orderBy?: userActivitiesHistoryOrderByWithRelationInput | userActivitiesHistoryOrderByWithRelationInput[]
    cursor?: userActivitiesHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserActivitiesHistoryScalarFieldEnum | UserActivitiesHistoryScalarFieldEnum[]
  }

  /**
   * users.userNotifications
   */
  export type users$userNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userNotifications
     */
    select?: userNotificationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userNotifications
     */
    omit?: userNotificationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userNotificationsInclude<ExtArgs> | null
    where?: userNotificationsWhereInput
    orderBy?: userNotificationsOrderByWithRelationInput | userNotificationsOrderByWithRelationInput[]
    cursor?: userNotificationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserNotificationsScalarFieldEnum | UserNotificationsScalarFieldEnum[]
  }

  /**
   * users without action
   */
  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AnswersScalarFieldEnum: {
    id: 'id',
    answer: 'answer',
    question_id: 'question_id'
  };

  export type AnswersScalarFieldEnum = (typeof AnswersScalarFieldEnum)[keyof typeof AnswersScalarFieldEnum]


  export const ApplicantsScalarFieldEnum: {
    cv_id: 'cv_id',
    job_id: 'job_id',
    description: 'description',
    apply_date: 'apply_date',
    verified_date: 'verified_date',
    status: 'status',
    feedback: 'feedback'
  };

  export type ApplicantsScalarFieldEnum = (typeof ApplicantsScalarFieldEnum)[keyof typeof ApplicantsScalarFieldEnum]


  export const AwardsScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    start_date: 'start_date',
    end_date: 'end_date',
    cv_id: 'cv_id'
  };

  export type AwardsScalarFieldEnum = (typeof AwardsScalarFieldEnum)[keyof typeof AwardsScalarFieldEnum]


  export const BlogsScalarFieldEnum: {
    id: 'id',
    title: 'title',
    cover_image_url: 'cover_image_url',
    description_url: 'description_url',
    created_at: 'created_at',
    updated_at: 'updated_at',
    user_id: 'user_id'
  };

  export type BlogsScalarFieldEnum = (typeof BlogsScalarFieldEnum)[keyof typeof BlogsScalarFieldEnum]


  export const CareerPathStepsScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    resources: 'resources',
    career_id: 'career_id'
  };

  export type CareerPathStepsScalarFieldEnum = (typeof CareerPathStepsScalarFieldEnum)[keyof typeof CareerPathStepsScalarFieldEnum]


  export const CareerPathsScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    resources: 'resources',
    level: 'level',
    estimate_duration: 'estimate_duration',
    user_id: 'user_id',
    jobspecialized_id: 'jobspecialized_id'
  };

  export type CareerPathsScalarFieldEnum = (typeof CareerPathsScalarFieldEnum)[keyof typeof CareerPathsScalarFieldEnum]


  export const CategoriesScalarFieldEnum: {
    id: 'id',
    category_name: 'category_name'
  };

  export type CategoriesScalarFieldEnum = (typeof CategoriesScalarFieldEnum)[keyof typeof CategoriesScalarFieldEnum]


  export const CertificatesScalarFieldEnum: {
    id: 'id',
    title: 'title',
    link: 'link',
    description: 'description',
    start_date: 'start_date',
    end_date: 'end_date',
    cv_id: 'cv_id'
  };

  export type CertificatesScalarFieldEnum = (typeof CertificatesScalarFieldEnum)[keyof typeof CertificatesScalarFieldEnum]


  export const CompaniesScalarFieldEnum: {
    id: 'id',
    company_name: 'company_name',
    company_website: 'company_website',
    address_street: 'address_street',
    address_ward: 'address_ward',
    address_city: 'address_city',
    address_country: 'address_country',
    email: 'email',
    phone: 'phone',
    business_certificate: 'business_certificate',
    company_type: 'company_type',
    description: 'description',
    logo_url: 'logo_url',
    background_url: 'background_url',
    employees: 'employees',
    is_verified: 'is_verified',
    fax_code: 'fax_code',
    is_deleted: 'is_deleted',
    created_at: 'created_at',
    updated_at: 'updated_at',
    field_id: 'field_id',
    label_id: 'label_id'
  };

  export type CompaniesScalarFieldEnum = (typeof CompaniesScalarFieldEnum)[keyof typeof CompaniesScalarFieldEnum]


  export const CompanyActivitiesHistoryScalarFieldEnum: {
    id: 'id',
    activity_name: 'activity_name',
    time: 'time',
    company_id: 'company_id'
  };

  export type CompanyActivitiesHistoryScalarFieldEnum = (typeof CompanyActivitiesHistoryScalarFieldEnum)[keyof typeof CompanyActivitiesHistoryScalarFieldEnum]


  export const CompanyLabelsScalarFieldEnum: {
    id: 'id',
    label_name: 'label_name'
  };

  export type CompanyLabelsScalarFieldEnum = (typeof CompanyLabelsScalarFieldEnum)[keyof typeof CompanyLabelsScalarFieldEnum]


  export const CompanyNotificationsScalarFieldEnum: {
    id: 'id',
    company_id: 'company_id',
    title: 'title',
    content: 'content',
    type: 'type',
    is_read: 'is_read',
    sent_at: 'sent_at',
    read_at: 'read_at'
  };

  export type CompanyNotificationsScalarFieldEnum = (typeof CompanyNotificationsScalarFieldEnum)[keyof typeof CompanyNotificationsScalarFieldEnum]


  export const CvsScalarFieldEnum: {
    id: 'id',
    fullname: 'fullname',
    age: 'age',
    gender: 'gender',
    address: 'address',
    email: 'email',
    introduction: 'introduction',
    soft_skills: 'soft_skills',
    primary_skills: 'primary_skills',
    phone: 'phone',
    hobbies: 'hobbies',
    others: 'others'
  };

  export type CvsScalarFieldEnum = (typeof CvsScalarFieldEnum)[keyof typeof CvsScalarFieldEnum]


  export const EducationsScalarFieldEnum: {
    id: 'id',
    school: 'school',
    graduated_type: 'graduated_type',
    gpa: 'gpa',
    start_date: 'start_date',
    end_date: 'end_date',
    cv_id: 'cv_id'
  };

  export type EducationsScalarFieldEnum = (typeof EducationsScalarFieldEnum)[keyof typeof EducationsScalarFieldEnum]


  export const ExperiencesScalarFieldEnum: {
    id: 'id',
    company_name: 'company_name',
    title: 'title',
    description: 'description',
    start_date: 'start_date',
    end_date: 'end_date',
    cv_id: 'cv_id'
  };

  export type ExperiencesScalarFieldEnum = (typeof ExperiencesScalarFieldEnum)[keyof typeof ExperiencesScalarFieldEnum]


  export const FeaturesScalarFieldEnum: {
    id: 'id',
    feature_name: 'feature_name',
    description: 'description',
    plan_id: 'plan_id'
  };

  export type FeaturesScalarFieldEnum = (typeof FeaturesScalarFieldEnum)[keyof typeof FeaturesScalarFieldEnum]


  export const FeedbacksScalarFieldEnum: {
    user_id: 'user_id',
    company_id: 'company_id',
    description: 'description',
    stars: 'stars',
    work_environment: 'work_environment',
    benefit: 'benefit',
    created_at: 'created_at'
  };

  export type FeedbacksScalarFieldEnum = (typeof FeedbacksScalarFieldEnum)[keyof typeof FeedbacksScalarFieldEnum]


  export const FieldsScalarFieldEnum: {
    id: 'id',
    field_name: 'field_name'
  };

  export type FieldsScalarFieldEnum = (typeof FieldsScalarFieldEnum)[keyof typeof FieldsScalarFieldEnum]


  export const FollowedCompaniesScalarFieldEnum: {
    user_id: 'user_id',
    company_id: 'company_id',
    followed_at: 'followed_at',
    is_notified: 'is_notified'
  };

  export type FollowedCompaniesScalarFieldEnum = (typeof FollowedCompaniesScalarFieldEnum)[keyof typeof FollowedCompaniesScalarFieldEnum]


  export const JobCategoriesScalarFieldEnum: {
    id: 'id',
    job_category: 'job_category',
    description: 'description'
  };

  export type JobCategoriesScalarFieldEnum = (typeof JobCategoriesScalarFieldEnum)[keyof typeof JobCategoriesScalarFieldEnum]


  export const JobLabelsScalarFieldEnum: {
    id: 'id',
    label_name: 'label_name'
  };

  export type JobLabelsScalarFieldEnum = (typeof JobLabelsScalarFieldEnum)[keyof typeof JobLabelsScalarFieldEnum]


  export const JobSpecializedScalarFieldEnum: {
    id: 'id',
    job_type: 'job_type',
    description: 'description',
    jobcategory_id: 'jobcategory_id'
  };

  export type JobSpecializedScalarFieldEnum = (typeof JobSpecializedScalarFieldEnum)[keyof typeof JobSpecializedScalarFieldEnum]


  export const JobsScalarFieldEnum: {
    id: 'id',
    job_title: 'job_title',
    description: 'description',
    location: 'location',
    benefit: 'benefit',
    working_time: 'working_time',
    salary: 'salary',
    currency: 'currency',
    job_type: 'job_type',
    status: 'status',
    job_level: 'job_level',
    quantity: 'quantity',
    skill_tags: 'skill_tags',
    education: 'education',
    experience: 'experience',
    start_date: 'start_date',
    end_date: 'end_date',
    created_at: 'created_at',
    updated_at: 'updated_at',
    category_id: 'category_id',
    label_id: 'label_id'
  };

  export type JobsScalarFieldEnum = (typeof JobsScalarFieldEnum)[keyof typeof JobsScalarFieldEnum]


  export const MembershipPlansScalarFieldEnum: {
    id: 'id',
    plan_name: 'plan_name',
    description: 'description',
    price: 'price',
    duration_days: 'duration_days',
    is_active: 'is_active',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type MembershipPlansScalarFieldEnum = (typeof MembershipPlansScalarFieldEnum)[keyof typeof MembershipPlansScalarFieldEnum]


  export const MessagesScalarFieldEnum: {
    id: 'id',
    message_content: 'message_content',
    response_content: 'response_content',
    created_at: 'created_at',
    user_id: 'user_id'
  };

  export type MessagesScalarFieldEnum = (typeof MessagesScalarFieldEnum)[keyof typeof MessagesScalarFieldEnum]


  export const PaymentsScalarFieldEnum: {
    id: 'id',
    amount: 'amount',
    currency: 'currency',
    payment_gateway: 'payment_gateway',
    payment_method: 'payment_method',
    transaction_id: 'transaction_id',
    status: 'status',
    created_at: 'created_at',
    user_id: 'user_id'
  };

  export type PaymentsScalarFieldEnum = (typeof PaymentsScalarFieldEnum)[keyof typeof PaymentsScalarFieldEnum]


  export const PersonalityTestResultsScalarFieldEnum: {
    user_id: 'user_id',
    question_id: 'question_id',
    answer_id: 'answer_id'
  };

  export type PersonalityTestResultsScalarFieldEnum = (typeof PersonalityTestResultsScalarFieldEnum)[keyof typeof PersonalityTestResultsScalarFieldEnum]


  export const ProjectsScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    start_date: 'start_date',
    end_date: 'end_date',
    cv_id: 'cv_id'
  };

  export type ProjectsScalarFieldEnum = (typeof ProjectsScalarFieldEnum)[keyof typeof ProjectsScalarFieldEnum]


  export const QuestionsScalarFieldEnum: {
    id: 'id',
    question: 'question'
  };

  export type QuestionsScalarFieldEnum = (typeof QuestionsScalarFieldEnum)[keyof typeof QuestionsScalarFieldEnum]


  export const ReferencesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    phone: 'phone',
    email: 'email',
    cv_id: 'cv_id'
  };

  export type ReferencesScalarFieldEnum = (typeof ReferencesScalarFieldEnum)[keyof typeof ReferencesScalarFieldEnum]


  export const RolesScalarFieldEnum: {
    id: 'id',
    role_name: 'role_name'
  };

  export type RolesScalarFieldEnum = (typeof RolesScalarFieldEnum)[keyof typeof RolesScalarFieldEnum]


  export const SavedJobsScalarFieldEnum: {
    user_id: 'user_id',
    job_id: 'job_id',
    saved_at: 'saved_at'
  };

  export type SavedJobsScalarFieldEnum = (typeof SavedJobsScalarFieldEnum)[keyof typeof SavedJobsScalarFieldEnum]


  export const SubscriptionsScalarFieldEnum: {
    id: 'id',
    start_date: 'start_date',
    end_date: 'end_date',
    amount_paid: 'amount_paid',
    is_extended: 'is_extended',
    status: 'status',
    user_id: 'user_id',
    plan_id: 'plan_id',
    payment_id: 'payment_id'
  };

  export type SubscriptionsScalarFieldEnum = (typeof SubscriptionsScalarFieldEnum)[keyof typeof SubscriptionsScalarFieldEnum]


  export const UserActivitiesHistoryScalarFieldEnum: {
    id: 'id',
    activity_name: 'activity_name',
    time: 'time',
    user_id: 'user_id'
  };

  export type UserActivitiesHistoryScalarFieldEnum = (typeof UserActivitiesHistoryScalarFieldEnum)[keyof typeof UserActivitiesHistoryScalarFieldEnum]


  export const UserNotificationsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    title: 'title',
    content: 'content',
    type: 'type',
    is_read: 'is_read',
    sent_at: 'sent_at',
    read_at: 'read_at'
  };

  export type UserNotificationsScalarFieldEnum = (typeof UserNotificationsScalarFieldEnum)[keyof typeof UserNotificationsScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    id: 'id',
    username: 'username',
    password: 'password',
    avatar_url: 'avatar_url',
    email: 'email',
    phone: 'phone',
    address_street: 'address_street',
    address_ward: 'address_ward',
    address_city: 'address_city',
    address_country: 'address_country',
    gender: 'gender',
    is_deleted: 'is_deleted',
    created_at: 'created_at',
    updated_at: 'updated_at',
    role_id: 'role_id'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'ApplicantsStatus'
   */
  export type EnumApplicantsStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApplicantsStatus'>
    


  /**
   * Reference to a field of type 'ApplicantsStatus[]'
   */
  export type ListEnumApplicantsStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApplicantsStatus[]'>
    


  /**
   * Reference to a field of type 'Company_Type'
   */
  export type EnumCompany_TypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Company_Type'>
    


  /**
   * Reference to a field of type 'Company_Type[]'
   */
  export type ListEnumCompany_TypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Company_Type[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'NotificationsType'
   */
  export type EnumNotificationsTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationsType'>
    


  /**
   * Reference to a field of type 'NotificationsType[]'
   */
  export type ListEnumNotificationsTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationsType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Job_Type'
   */
  export type EnumJob_TypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Job_Type'>
    


  /**
   * Reference to a field of type 'Job_Type[]'
   */
  export type ListEnumJob_TypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Job_Type[]'>
    


  /**
   * Reference to a field of type 'Job_Status'
   */
  export type EnumJob_StatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Job_Status'>
    


  /**
   * Reference to a field of type 'Job_Status[]'
   */
  export type ListEnumJob_StatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Job_Status[]'>
    


  /**
   * Reference to a field of type 'Education'
   */
  export type EnumEducationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Education'>
    


  /**
   * Reference to a field of type 'Education[]'
   */
  export type ListEnumEducationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Education[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'PaymentGateway'
   */
  export type EnumPaymentGatewayFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentGateway'>
    


  /**
   * Reference to a field of type 'PaymentGateway[]'
   */
  export type ListEnumPaymentGatewayFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentGateway[]'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'PaymentMethod[]'
   */
  export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod[]'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus'
   */
  export type EnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus[]'
   */
  export type ListEnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus[]'>
    


  /**
   * Reference to a field of type 'Gender'
   */
  export type EnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender'>
    


  /**
   * Reference to a field of type 'Gender[]'
   */
  export type ListEnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender[]'>
    
  /**
   * Deep Input Types
   */


  export type answersWhereInput = {
    AND?: answersWhereInput | answersWhereInput[]
    OR?: answersWhereInput[]
    NOT?: answersWhereInput | answersWhereInput[]
    id?: IntFilter<"answers"> | number
    answer?: StringFilter<"answers"> | string
    question_id?: IntFilter<"answers"> | number
    questions?: XOR<QuestionsScalarRelationFilter, questionsWhereInput>
    personalityTestResults?: PersonalityTestResultsListRelationFilter
  }

  export type answersOrderByWithRelationInput = {
    id?: SortOrder
    answer?: SortOrder
    question_id?: SortOrder
    questions?: questionsOrderByWithRelationInput
    personalityTestResults?: personalityTestResultsOrderByRelationAggregateInput
  }

  export type answersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: answersWhereInput | answersWhereInput[]
    OR?: answersWhereInput[]
    NOT?: answersWhereInput | answersWhereInput[]
    answer?: StringFilter<"answers"> | string
    question_id?: IntFilter<"answers"> | number
    questions?: XOR<QuestionsScalarRelationFilter, questionsWhereInput>
    personalityTestResults?: PersonalityTestResultsListRelationFilter
  }, "id">

  export type answersOrderByWithAggregationInput = {
    id?: SortOrder
    answer?: SortOrder
    question_id?: SortOrder
    _count?: answersCountOrderByAggregateInput
    _avg?: answersAvgOrderByAggregateInput
    _max?: answersMaxOrderByAggregateInput
    _min?: answersMinOrderByAggregateInput
    _sum?: answersSumOrderByAggregateInput
  }

  export type answersScalarWhereWithAggregatesInput = {
    AND?: answersScalarWhereWithAggregatesInput | answersScalarWhereWithAggregatesInput[]
    OR?: answersScalarWhereWithAggregatesInput[]
    NOT?: answersScalarWhereWithAggregatesInput | answersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"answers"> | number
    answer?: StringWithAggregatesFilter<"answers"> | string
    question_id?: IntWithAggregatesFilter<"answers"> | number
  }

  export type applicantsWhereInput = {
    AND?: applicantsWhereInput | applicantsWhereInput[]
    OR?: applicantsWhereInput[]
    NOT?: applicantsWhereInput | applicantsWhereInput[]
    cv_id?: IntFilter<"applicants"> | number
    job_id?: StringFilter<"applicants"> | string
    description?: StringNullableFilter<"applicants"> | string | null
    apply_date?: DateTimeFilter<"applicants"> | Date | string
    verified_date?: DateTimeFilter<"applicants"> | Date | string
    status?: EnumApplicantsStatusFilter<"applicants"> | $Enums.ApplicantsStatus
    feedback?: StringNullableFilter<"applicants"> | string | null
    cvs?: XOR<CvsScalarRelationFilter, cvsWhereInput>
    jobs?: XOR<JobsScalarRelationFilter, jobsWhereInput>
  }

  export type applicantsOrderByWithRelationInput = {
    cv_id?: SortOrder
    job_id?: SortOrder
    description?: SortOrderInput | SortOrder
    apply_date?: SortOrder
    verified_date?: SortOrder
    status?: SortOrder
    feedback?: SortOrderInput | SortOrder
    cvs?: cvsOrderByWithRelationInput
    jobs?: jobsOrderByWithRelationInput
  }

  export type applicantsWhereUniqueInput = Prisma.AtLeast<{
    cv_id_job_id?: applicantsCv_idJob_idCompoundUniqueInput
    AND?: applicantsWhereInput | applicantsWhereInput[]
    OR?: applicantsWhereInput[]
    NOT?: applicantsWhereInput | applicantsWhereInput[]
    cv_id?: IntFilter<"applicants"> | number
    job_id?: StringFilter<"applicants"> | string
    description?: StringNullableFilter<"applicants"> | string | null
    apply_date?: DateTimeFilter<"applicants"> | Date | string
    verified_date?: DateTimeFilter<"applicants"> | Date | string
    status?: EnumApplicantsStatusFilter<"applicants"> | $Enums.ApplicantsStatus
    feedback?: StringNullableFilter<"applicants"> | string | null
    cvs?: XOR<CvsScalarRelationFilter, cvsWhereInput>
    jobs?: XOR<JobsScalarRelationFilter, jobsWhereInput>
  }, "cv_id_job_id">

  export type applicantsOrderByWithAggregationInput = {
    cv_id?: SortOrder
    job_id?: SortOrder
    description?: SortOrderInput | SortOrder
    apply_date?: SortOrder
    verified_date?: SortOrder
    status?: SortOrder
    feedback?: SortOrderInput | SortOrder
    _count?: applicantsCountOrderByAggregateInput
    _avg?: applicantsAvgOrderByAggregateInput
    _max?: applicantsMaxOrderByAggregateInput
    _min?: applicantsMinOrderByAggregateInput
    _sum?: applicantsSumOrderByAggregateInput
  }

  export type applicantsScalarWhereWithAggregatesInput = {
    AND?: applicantsScalarWhereWithAggregatesInput | applicantsScalarWhereWithAggregatesInput[]
    OR?: applicantsScalarWhereWithAggregatesInput[]
    NOT?: applicantsScalarWhereWithAggregatesInput | applicantsScalarWhereWithAggregatesInput[]
    cv_id?: IntWithAggregatesFilter<"applicants"> | number
    job_id?: StringWithAggregatesFilter<"applicants"> | string
    description?: StringNullableWithAggregatesFilter<"applicants"> | string | null
    apply_date?: DateTimeWithAggregatesFilter<"applicants"> | Date | string
    verified_date?: DateTimeWithAggregatesFilter<"applicants"> | Date | string
    status?: EnumApplicantsStatusWithAggregatesFilter<"applicants"> | $Enums.ApplicantsStatus
    feedback?: StringNullableWithAggregatesFilter<"applicants"> | string | null
  }

  export type awardsWhereInput = {
    AND?: awardsWhereInput | awardsWhereInput[]
    OR?: awardsWhereInput[]
    NOT?: awardsWhereInput | awardsWhereInput[]
    id?: IntFilter<"awards"> | number
    title?: StringFilter<"awards"> | string
    description?: StringNullableFilter<"awards"> | string | null
    start_date?: DateTimeNullableFilter<"awards"> | Date | string | null
    end_date?: DateTimeNullableFilter<"awards"> | Date | string | null
    cv_id?: IntFilter<"awards"> | number
    cvs?: XOR<CvsScalarRelationFilter, cvsWhereInput>
  }

  export type awardsOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    start_date?: SortOrderInput | SortOrder
    end_date?: SortOrderInput | SortOrder
    cv_id?: SortOrder
    cvs?: cvsOrderByWithRelationInput
  }

  export type awardsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: awardsWhereInput | awardsWhereInput[]
    OR?: awardsWhereInput[]
    NOT?: awardsWhereInput | awardsWhereInput[]
    title?: StringFilter<"awards"> | string
    description?: StringNullableFilter<"awards"> | string | null
    start_date?: DateTimeNullableFilter<"awards"> | Date | string | null
    end_date?: DateTimeNullableFilter<"awards"> | Date | string | null
    cv_id?: IntFilter<"awards"> | number
    cvs?: XOR<CvsScalarRelationFilter, cvsWhereInput>
  }, "id">

  export type awardsOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    start_date?: SortOrderInput | SortOrder
    end_date?: SortOrderInput | SortOrder
    cv_id?: SortOrder
    _count?: awardsCountOrderByAggregateInput
    _avg?: awardsAvgOrderByAggregateInput
    _max?: awardsMaxOrderByAggregateInput
    _min?: awardsMinOrderByAggregateInput
    _sum?: awardsSumOrderByAggregateInput
  }

  export type awardsScalarWhereWithAggregatesInput = {
    AND?: awardsScalarWhereWithAggregatesInput | awardsScalarWhereWithAggregatesInput[]
    OR?: awardsScalarWhereWithAggregatesInput[]
    NOT?: awardsScalarWhereWithAggregatesInput | awardsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"awards"> | number
    title?: StringWithAggregatesFilter<"awards"> | string
    description?: StringNullableWithAggregatesFilter<"awards"> | string | null
    start_date?: DateTimeNullableWithAggregatesFilter<"awards"> | Date | string | null
    end_date?: DateTimeNullableWithAggregatesFilter<"awards"> | Date | string | null
    cv_id?: IntWithAggregatesFilter<"awards"> | number
  }

  export type blogsWhereInput = {
    AND?: blogsWhereInput | blogsWhereInput[]
    OR?: blogsWhereInput[]
    NOT?: blogsWhereInput | blogsWhereInput[]
    id?: IntFilter<"blogs"> | number
    title?: StringFilter<"blogs"> | string
    cover_image_url?: StringFilter<"blogs"> | string
    description_url?: StringFilter<"blogs"> | string
    created_at?: DateTimeFilter<"blogs"> | Date | string
    updated_at?: DateTimeFilter<"blogs"> | Date | string
    user_id?: StringFilter<"blogs"> | string
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type blogsOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    cover_image_url?: SortOrder
    description_url?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user_id?: SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type blogsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: blogsWhereInput | blogsWhereInput[]
    OR?: blogsWhereInput[]
    NOT?: blogsWhereInput | blogsWhereInput[]
    title?: StringFilter<"blogs"> | string
    cover_image_url?: StringFilter<"blogs"> | string
    description_url?: StringFilter<"blogs"> | string
    created_at?: DateTimeFilter<"blogs"> | Date | string
    updated_at?: DateTimeFilter<"blogs"> | Date | string
    user_id?: StringFilter<"blogs"> | string
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id">

  export type blogsOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    cover_image_url?: SortOrder
    description_url?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user_id?: SortOrder
    _count?: blogsCountOrderByAggregateInput
    _avg?: blogsAvgOrderByAggregateInput
    _max?: blogsMaxOrderByAggregateInput
    _min?: blogsMinOrderByAggregateInput
    _sum?: blogsSumOrderByAggregateInput
  }

  export type blogsScalarWhereWithAggregatesInput = {
    AND?: blogsScalarWhereWithAggregatesInput | blogsScalarWhereWithAggregatesInput[]
    OR?: blogsScalarWhereWithAggregatesInput[]
    NOT?: blogsScalarWhereWithAggregatesInput | blogsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"blogs"> | number
    title?: StringWithAggregatesFilter<"blogs"> | string
    cover_image_url?: StringWithAggregatesFilter<"blogs"> | string
    description_url?: StringWithAggregatesFilter<"blogs"> | string
    created_at?: DateTimeWithAggregatesFilter<"blogs"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"blogs"> | Date | string
    user_id?: StringWithAggregatesFilter<"blogs"> | string
  }

  export type careerPathStepsWhereInput = {
    AND?: careerPathStepsWhereInput | careerPathStepsWhereInput[]
    OR?: careerPathStepsWhereInput[]
    NOT?: careerPathStepsWhereInput | careerPathStepsWhereInput[]
    id?: IntFilter<"careerPathSteps"> | number
    title?: StringFilter<"careerPathSteps"> | string
    description?: StringNullableFilter<"careerPathSteps"> | string | null
    resources?: StringNullableFilter<"careerPathSteps"> | string | null
    career_id?: IntFilter<"careerPathSteps"> | number
    careerPaths?: XOR<CareerPathsScalarRelationFilter, careerPathsWhereInput>
  }

  export type careerPathStepsOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    resources?: SortOrderInput | SortOrder
    career_id?: SortOrder
    careerPaths?: careerPathsOrderByWithRelationInput
  }

  export type careerPathStepsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: careerPathStepsWhereInput | careerPathStepsWhereInput[]
    OR?: careerPathStepsWhereInput[]
    NOT?: careerPathStepsWhereInput | careerPathStepsWhereInput[]
    title?: StringFilter<"careerPathSteps"> | string
    description?: StringNullableFilter<"careerPathSteps"> | string | null
    resources?: StringNullableFilter<"careerPathSteps"> | string | null
    career_id?: IntFilter<"careerPathSteps"> | number
    careerPaths?: XOR<CareerPathsScalarRelationFilter, careerPathsWhereInput>
  }, "id">

  export type careerPathStepsOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    resources?: SortOrderInput | SortOrder
    career_id?: SortOrder
    _count?: careerPathStepsCountOrderByAggregateInput
    _avg?: careerPathStepsAvgOrderByAggregateInput
    _max?: careerPathStepsMaxOrderByAggregateInput
    _min?: careerPathStepsMinOrderByAggregateInput
    _sum?: careerPathStepsSumOrderByAggregateInput
  }

  export type careerPathStepsScalarWhereWithAggregatesInput = {
    AND?: careerPathStepsScalarWhereWithAggregatesInput | careerPathStepsScalarWhereWithAggregatesInput[]
    OR?: careerPathStepsScalarWhereWithAggregatesInput[]
    NOT?: careerPathStepsScalarWhereWithAggregatesInput | careerPathStepsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"careerPathSteps"> | number
    title?: StringWithAggregatesFilter<"careerPathSteps"> | string
    description?: StringNullableWithAggregatesFilter<"careerPathSteps"> | string | null
    resources?: StringNullableWithAggregatesFilter<"careerPathSteps"> | string | null
    career_id?: IntWithAggregatesFilter<"careerPathSteps"> | number
  }

  export type careerPathsWhereInput = {
    AND?: careerPathsWhereInput | careerPathsWhereInput[]
    OR?: careerPathsWhereInput[]
    NOT?: careerPathsWhereInput | careerPathsWhereInput[]
    id?: IntFilter<"careerPaths"> | number
    title?: StringFilter<"careerPaths"> | string
    description?: StringNullableFilter<"careerPaths"> | string | null
    resources?: StringNullableFilter<"careerPaths"> | string | null
    level?: StringNullableFilter<"careerPaths"> | string | null
    estimate_duration?: StringNullableFilter<"careerPaths"> | string | null
    user_id?: StringFilter<"careerPaths"> | string
    jobspecialized_id?: IntFilter<"careerPaths"> | number
    careerPathSteps?: CareerPathStepsListRelationFilter
    jobSpecialized?: XOR<JobSpecializedScalarRelationFilter, jobSpecializedWhereInput>
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type careerPathsOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    resources?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    estimate_duration?: SortOrderInput | SortOrder
    user_id?: SortOrder
    jobspecialized_id?: SortOrder
    careerPathSteps?: careerPathStepsOrderByRelationAggregateInput
    jobSpecialized?: jobSpecializedOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
  }

  export type careerPathsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    jobspecialized_id?: number
    AND?: careerPathsWhereInput | careerPathsWhereInput[]
    OR?: careerPathsWhereInput[]
    NOT?: careerPathsWhereInput | careerPathsWhereInput[]
    title?: StringFilter<"careerPaths"> | string
    description?: StringNullableFilter<"careerPaths"> | string | null
    resources?: StringNullableFilter<"careerPaths"> | string | null
    level?: StringNullableFilter<"careerPaths"> | string | null
    estimate_duration?: StringNullableFilter<"careerPaths"> | string | null
    user_id?: StringFilter<"careerPaths"> | string
    careerPathSteps?: CareerPathStepsListRelationFilter
    jobSpecialized?: XOR<JobSpecializedScalarRelationFilter, jobSpecializedWhereInput>
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id" | "jobspecialized_id">

  export type careerPathsOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    resources?: SortOrderInput | SortOrder
    level?: SortOrderInput | SortOrder
    estimate_duration?: SortOrderInput | SortOrder
    user_id?: SortOrder
    jobspecialized_id?: SortOrder
    _count?: careerPathsCountOrderByAggregateInput
    _avg?: careerPathsAvgOrderByAggregateInput
    _max?: careerPathsMaxOrderByAggregateInput
    _min?: careerPathsMinOrderByAggregateInput
    _sum?: careerPathsSumOrderByAggregateInput
  }

  export type careerPathsScalarWhereWithAggregatesInput = {
    AND?: careerPathsScalarWhereWithAggregatesInput | careerPathsScalarWhereWithAggregatesInput[]
    OR?: careerPathsScalarWhereWithAggregatesInput[]
    NOT?: careerPathsScalarWhereWithAggregatesInput | careerPathsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"careerPaths"> | number
    title?: StringWithAggregatesFilter<"careerPaths"> | string
    description?: StringNullableWithAggregatesFilter<"careerPaths"> | string | null
    resources?: StringNullableWithAggregatesFilter<"careerPaths"> | string | null
    level?: StringNullableWithAggregatesFilter<"careerPaths"> | string | null
    estimate_duration?: StringNullableWithAggregatesFilter<"careerPaths"> | string | null
    user_id?: StringWithAggregatesFilter<"careerPaths"> | string
    jobspecialized_id?: IntWithAggregatesFilter<"careerPaths"> | number
  }

  export type categoriesWhereInput = {
    AND?: categoriesWhereInput | categoriesWhereInput[]
    OR?: categoriesWhereInput[]
    NOT?: categoriesWhereInput | categoriesWhereInput[]
    id?: IntFilter<"categories"> | number
    category_name?: StringFilter<"categories"> | string
    jobs?: JobsListRelationFilter
  }

  export type categoriesOrderByWithRelationInput = {
    id?: SortOrder
    category_name?: SortOrder
    jobs?: jobsOrderByRelationAggregateInput
  }

  export type categoriesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    category_name?: string
    AND?: categoriesWhereInput | categoriesWhereInput[]
    OR?: categoriesWhereInput[]
    NOT?: categoriesWhereInput | categoriesWhereInput[]
    jobs?: JobsListRelationFilter
  }, "id" | "category_name">

  export type categoriesOrderByWithAggregationInput = {
    id?: SortOrder
    category_name?: SortOrder
    _count?: categoriesCountOrderByAggregateInput
    _avg?: categoriesAvgOrderByAggregateInput
    _max?: categoriesMaxOrderByAggregateInput
    _min?: categoriesMinOrderByAggregateInput
    _sum?: categoriesSumOrderByAggregateInput
  }

  export type categoriesScalarWhereWithAggregatesInput = {
    AND?: categoriesScalarWhereWithAggregatesInput | categoriesScalarWhereWithAggregatesInput[]
    OR?: categoriesScalarWhereWithAggregatesInput[]
    NOT?: categoriesScalarWhereWithAggregatesInput | categoriesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"categories"> | number
    category_name?: StringWithAggregatesFilter<"categories"> | string
  }

  export type certificatesWhereInput = {
    AND?: certificatesWhereInput | certificatesWhereInput[]
    OR?: certificatesWhereInput[]
    NOT?: certificatesWhereInput | certificatesWhereInput[]
    id?: IntFilter<"certificates"> | number
    title?: StringFilter<"certificates"> | string
    link?: StringNullableFilter<"certificates"> | string | null
    description?: StringNullableFilter<"certificates"> | string | null
    start_date?: DateTimeNullableFilter<"certificates"> | Date | string | null
    end_date?: DateTimeNullableFilter<"certificates"> | Date | string | null
    cv_id?: IntFilter<"certificates"> | number
    cvs?: XOR<CvsScalarRelationFilter, cvsWhereInput>
  }

  export type certificatesOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    link?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    start_date?: SortOrderInput | SortOrder
    end_date?: SortOrderInput | SortOrder
    cv_id?: SortOrder
    cvs?: cvsOrderByWithRelationInput
  }

  export type certificatesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: certificatesWhereInput | certificatesWhereInput[]
    OR?: certificatesWhereInput[]
    NOT?: certificatesWhereInput | certificatesWhereInput[]
    title?: StringFilter<"certificates"> | string
    link?: StringNullableFilter<"certificates"> | string | null
    description?: StringNullableFilter<"certificates"> | string | null
    start_date?: DateTimeNullableFilter<"certificates"> | Date | string | null
    end_date?: DateTimeNullableFilter<"certificates"> | Date | string | null
    cv_id?: IntFilter<"certificates"> | number
    cvs?: XOR<CvsScalarRelationFilter, cvsWhereInput>
  }, "id">

  export type certificatesOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    link?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    start_date?: SortOrderInput | SortOrder
    end_date?: SortOrderInput | SortOrder
    cv_id?: SortOrder
    _count?: certificatesCountOrderByAggregateInput
    _avg?: certificatesAvgOrderByAggregateInput
    _max?: certificatesMaxOrderByAggregateInput
    _min?: certificatesMinOrderByAggregateInput
    _sum?: certificatesSumOrderByAggregateInput
  }

  export type certificatesScalarWhereWithAggregatesInput = {
    AND?: certificatesScalarWhereWithAggregatesInput | certificatesScalarWhereWithAggregatesInput[]
    OR?: certificatesScalarWhereWithAggregatesInput[]
    NOT?: certificatesScalarWhereWithAggregatesInput | certificatesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"certificates"> | number
    title?: StringWithAggregatesFilter<"certificates"> | string
    link?: StringNullableWithAggregatesFilter<"certificates"> | string | null
    description?: StringNullableWithAggregatesFilter<"certificates"> | string | null
    start_date?: DateTimeNullableWithAggregatesFilter<"certificates"> | Date | string | null
    end_date?: DateTimeNullableWithAggregatesFilter<"certificates"> | Date | string | null
    cv_id?: IntWithAggregatesFilter<"certificates"> | number
  }

  export type companiesWhereInput = {
    AND?: companiesWhereInput | companiesWhereInput[]
    OR?: companiesWhereInput[]
    NOT?: companiesWhereInput | companiesWhereInput[]
    id?: StringFilter<"companies"> | string
    company_name?: StringFilter<"companies"> | string
    company_website?: StringNullableFilter<"companies"> | string | null
    address_street?: StringFilter<"companies"> | string
    address_ward?: StringFilter<"companies"> | string
    address_city?: StringFilter<"companies"> | string
    address_country?: StringFilter<"companies"> | string
    email?: StringFilter<"companies"> | string
    phone?: StringFilter<"companies"> | string
    business_certificate?: StringNullableFilter<"companies"> | string | null
    company_type?: EnumCompany_TypeFilter<"companies"> | $Enums.Company_Type
    description?: StringNullableFilter<"companies"> | string | null
    logo_url?: StringNullableFilter<"companies"> | string | null
    background_url?: StringNullableFilter<"companies"> | string | null
    employees?: IntNullableFilter<"companies"> | number | null
    is_verified?: BoolFilter<"companies"> | boolean
    fax_code?: StringNullableFilter<"companies"> | string | null
    is_deleted?: BoolFilter<"companies"> | boolean
    created_at?: DateTimeFilter<"companies"> | Date | string
    updated_at?: DateTimeFilter<"companies"> | Date | string
    field_id?: IntNullableFilter<"companies"> | number | null
    label_id?: IntNullableFilter<"companies"> | number | null
    fields?: XOR<FieldsNullableScalarRelationFilter, fieldsWhereInput> | null
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    companyLabels?: XOR<CompanyLabelsNullableScalarRelationFilter, companyLabelsWhereInput> | null
    companyActivitiesHistory?: CompanyActivitiesHistoryListRelationFilter
    companyNotifications?: CompanyNotificationsListRelationFilter
    feedbacks?: FeedbacksListRelationFilter
    followedCompanies?: FollowedCompaniesListRelationFilter
  }

  export type companiesOrderByWithRelationInput = {
    id?: SortOrder
    company_name?: SortOrder
    company_website?: SortOrderInput | SortOrder
    address_street?: SortOrder
    address_ward?: SortOrder
    address_city?: SortOrder
    address_country?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    business_certificate?: SortOrderInput | SortOrder
    company_type?: SortOrder
    description?: SortOrderInput | SortOrder
    logo_url?: SortOrderInput | SortOrder
    background_url?: SortOrderInput | SortOrder
    employees?: SortOrderInput | SortOrder
    is_verified?: SortOrder
    fax_code?: SortOrderInput | SortOrder
    is_deleted?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    field_id?: SortOrderInput | SortOrder
    label_id?: SortOrderInput | SortOrder
    fields?: fieldsOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
    companyLabels?: companyLabelsOrderByWithRelationInput
    companyActivitiesHistory?: companyActivitiesHistoryOrderByRelationAggregateInput
    companyNotifications?: companyNotificationsOrderByRelationAggregateInput
    feedbacks?: feedbacksOrderByRelationAggregateInput
    followedCompanies?: followedCompaniesOrderByRelationAggregateInput
  }

  export type companiesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    company_name?: string
    email?: string
    phone?: string
    AND?: companiesWhereInput | companiesWhereInput[]
    OR?: companiesWhereInput[]
    NOT?: companiesWhereInput | companiesWhereInput[]
    company_website?: StringNullableFilter<"companies"> | string | null
    address_street?: StringFilter<"companies"> | string
    address_ward?: StringFilter<"companies"> | string
    address_city?: StringFilter<"companies"> | string
    address_country?: StringFilter<"companies"> | string
    business_certificate?: StringNullableFilter<"companies"> | string | null
    company_type?: EnumCompany_TypeFilter<"companies"> | $Enums.Company_Type
    description?: StringNullableFilter<"companies"> | string | null
    logo_url?: StringNullableFilter<"companies"> | string | null
    background_url?: StringNullableFilter<"companies"> | string | null
    employees?: IntNullableFilter<"companies"> | number | null
    is_verified?: BoolFilter<"companies"> | boolean
    fax_code?: StringNullableFilter<"companies"> | string | null
    is_deleted?: BoolFilter<"companies"> | boolean
    created_at?: DateTimeFilter<"companies"> | Date | string
    updated_at?: DateTimeFilter<"companies"> | Date | string
    field_id?: IntNullableFilter<"companies"> | number | null
    label_id?: IntNullableFilter<"companies"> | number | null
    fields?: XOR<FieldsNullableScalarRelationFilter, fieldsWhereInput> | null
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    companyLabels?: XOR<CompanyLabelsNullableScalarRelationFilter, companyLabelsWhereInput> | null
    companyActivitiesHistory?: CompanyActivitiesHistoryListRelationFilter
    companyNotifications?: CompanyNotificationsListRelationFilter
    feedbacks?: FeedbacksListRelationFilter
    followedCompanies?: FollowedCompaniesListRelationFilter
  }, "id" | "company_name" | "email" | "phone">

  export type companiesOrderByWithAggregationInput = {
    id?: SortOrder
    company_name?: SortOrder
    company_website?: SortOrderInput | SortOrder
    address_street?: SortOrder
    address_ward?: SortOrder
    address_city?: SortOrder
    address_country?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    business_certificate?: SortOrderInput | SortOrder
    company_type?: SortOrder
    description?: SortOrderInput | SortOrder
    logo_url?: SortOrderInput | SortOrder
    background_url?: SortOrderInput | SortOrder
    employees?: SortOrderInput | SortOrder
    is_verified?: SortOrder
    fax_code?: SortOrderInput | SortOrder
    is_deleted?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    field_id?: SortOrderInput | SortOrder
    label_id?: SortOrderInput | SortOrder
    _count?: companiesCountOrderByAggregateInput
    _avg?: companiesAvgOrderByAggregateInput
    _max?: companiesMaxOrderByAggregateInput
    _min?: companiesMinOrderByAggregateInput
    _sum?: companiesSumOrderByAggregateInput
  }

  export type companiesScalarWhereWithAggregatesInput = {
    AND?: companiesScalarWhereWithAggregatesInput | companiesScalarWhereWithAggregatesInput[]
    OR?: companiesScalarWhereWithAggregatesInput[]
    NOT?: companiesScalarWhereWithAggregatesInput | companiesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"companies"> | string
    company_name?: StringWithAggregatesFilter<"companies"> | string
    company_website?: StringNullableWithAggregatesFilter<"companies"> | string | null
    address_street?: StringWithAggregatesFilter<"companies"> | string
    address_ward?: StringWithAggregatesFilter<"companies"> | string
    address_city?: StringWithAggregatesFilter<"companies"> | string
    address_country?: StringWithAggregatesFilter<"companies"> | string
    email?: StringWithAggregatesFilter<"companies"> | string
    phone?: StringWithAggregatesFilter<"companies"> | string
    business_certificate?: StringNullableWithAggregatesFilter<"companies"> | string | null
    company_type?: EnumCompany_TypeWithAggregatesFilter<"companies"> | $Enums.Company_Type
    description?: StringNullableWithAggregatesFilter<"companies"> | string | null
    logo_url?: StringNullableWithAggregatesFilter<"companies"> | string | null
    background_url?: StringNullableWithAggregatesFilter<"companies"> | string | null
    employees?: IntNullableWithAggregatesFilter<"companies"> | number | null
    is_verified?: BoolWithAggregatesFilter<"companies"> | boolean
    fax_code?: StringNullableWithAggregatesFilter<"companies"> | string | null
    is_deleted?: BoolWithAggregatesFilter<"companies"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"companies"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"companies"> | Date | string
    field_id?: IntNullableWithAggregatesFilter<"companies"> | number | null
    label_id?: IntNullableWithAggregatesFilter<"companies"> | number | null
  }

  export type companyActivitiesHistoryWhereInput = {
    AND?: companyActivitiesHistoryWhereInput | companyActivitiesHistoryWhereInput[]
    OR?: companyActivitiesHistoryWhereInput[]
    NOT?: companyActivitiesHistoryWhereInput | companyActivitiesHistoryWhereInput[]
    id?: IntFilter<"companyActivitiesHistory"> | number
    activity_name?: StringFilter<"companyActivitiesHistory"> | string
    time?: DateTimeFilter<"companyActivitiesHistory"> | Date | string
    company_id?: StringFilter<"companyActivitiesHistory"> | string
    companies?: XOR<CompaniesScalarRelationFilter, companiesWhereInput>
  }

  export type companyActivitiesHistoryOrderByWithRelationInput = {
    id?: SortOrder
    activity_name?: SortOrder
    time?: SortOrder
    company_id?: SortOrder
    companies?: companiesOrderByWithRelationInput
  }

  export type companyActivitiesHistoryWhereUniqueInput = Prisma.AtLeast<{
    id_company_id?: companyActivitiesHistoryIdCompany_idCompoundUniqueInput
    AND?: companyActivitiesHistoryWhereInput | companyActivitiesHistoryWhereInput[]
    OR?: companyActivitiesHistoryWhereInput[]
    NOT?: companyActivitiesHistoryWhereInput | companyActivitiesHistoryWhereInput[]
    id?: IntFilter<"companyActivitiesHistory"> | number
    activity_name?: StringFilter<"companyActivitiesHistory"> | string
    time?: DateTimeFilter<"companyActivitiesHistory"> | Date | string
    company_id?: StringFilter<"companyActivitiesHistory"> | string
    companies?: XOR<CompaniesScalarRelationFilter, companiesWhereInput>
  }, "id_company_id">

  export type companyActivitiesHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    activity_name?: SortOrder
    time?: SortOrder
    company_id?: SortOrder
    _count?: companyActivitiesHistoryCountOrderByAggregateInput
    _avg?: companyActivitiesHistoryAvgOrderByAggregateInput
    _max?: companyActivitiesHistoryMaxOrderByAggregateInput
    _min?: companyActivitiesHistoryMinOrderByAggregateInput
    _sum?: companyActivitiesHistorySumOrderByAggregateInput
  }

  export type companyActivitiesHistoryScalarWhereWithAggregatesInput = {
    AND?: companyActivitiesHistoryScalarWhereWithAggregatesInput | companyActivitiesHistoryScalarWhereWithAggregatesInput[]
    OR?: companyActivitiesHistoryScalarWhereWithAggregatesInput[]
    NOT?: companyActivitiesHistoryScalarWhereWithAggregatesInput | companyActivitiesHistoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"companyActivitiesHistory"> | number
    activity_name?: StringWithAggregatesFilter<"companyActivitiesHistory"> | string
    time?: DateTimeWithAggregatesFilter<"companyActivitiesHistory"> | Date | string
    company_id?: StringWithAggregatesFilter<"companyActivitiesHistory"> | string
  }

  export type companyLabelsWhereInput = {
    AND?: companyLabelsWhereInput | companyLabelsWhereInput[]
    OR?: companyLabelsWhereInput[]
    NOT?: companyLabelsWhereInput | companyLabelsWhereInput[]
    id?: IntFilter<"companyLabels"> | number
    label_name?: StringFilter<"companyLabels"> | string
    companies?: CompaniesListRelationFilter
  }

  export type companyLabelsOrderByWithRelationInput = {
    id?: SortOrder
    label_name?: SortOrder
    companies?: companiesOrderByRelationAggregateInput
  }

  export type companyLabelsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    label_name?: string
    AND?: companyLabelsWhereInput | companyLabelsWhereInput[]
    OR?: companyLabelsWhereInput[]
    NOT?: companyLabelsWhereInput | companyLabelsWhereInput[]
    companies?: CompaniesListRelationFilter
  }, "id" | "label_name">

  export type companyLabelsOrderByWithAggregationInput = {
    id?: SortOrder
    label_name?: SortOrder
    _count?: companyLabelsCountOrderByAggregateInput
    _avg?: companyLabelsAvgOrderByAggregateInput
    _max?: companyLabelsMaxOrderByAggregateInput
    _min?: companyLabelsMinOrderByAggregateInput
    _sum?: companyLabelsSumOrderByAggregateInput
  }

  export type companyLabelsScalarWhereWithAggregatesInput = {
    AND?: companyLabelsScalarWhereWithAggregatesInput | companyLabelsScalarWhereWithAggregatesInput[]
    OR?: companyLabelsScalarWhereWithAggregatesInput[]
    NOT?: companyLabelsScalarWhereWithAggregatesInput | companyLabelsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"companyLabels"> | number
    label_name?: StringWithAggregatesFilter<"companyLabels"> | string
  }

  export type companyNotificationsWhereInput = {
    AND?: companyNotificationsWhereInput | companyNotificationsWhereInput[]
    OR?: companyNotificationsWhereInput[]
    NOT?: companyNotificationsWhereInput | companyNotificationsWhereInput[]
    id?: IntFilter<"companyNotifications"> | number
    company_id?: StringFilter<"companyNotifications"> | string
    title?: StringFilter<"companyNotifications"> | string
    content?: StringNullableFilter<"companyNotifications"> | string | null
    type?: EnumNotificationsTypeFilter<"companyNotifications"> | $Enums.NotificationsType
    is_read?: BoolFilter<"companyNotifications"> | boolean
    sent_at?: DateTimeFilter<"companyNotifications"> | Date | string
    read_at?: DateTimeNullableFilter<"companyNotifications"> | Date | string | null
    companies?: XOR<CompaniesScalarRelationFilter, companiesWhereInput>
  }

  export type companyNotificationsOrderByWithRelationInput = {
    id?: SortOrder
    company_id?: SortOrder
    title?: SortOrder
    content?: SortOrderInput | SortOrder
    type?: SortOrder
    is_read?: SortOrder
    sent_at?: SortOrder
    read_at?: SortOrderInput | SortOrder
    companies?: companiesOrderByWithRelationInput
  }

  export type companyNotificationsWhereUniqueInput = Prisma.AtLeast<{
    id_company_id?: companyNotificationsIdCompany_idCompoundUniqueInput
    AND?: companyNotificationsWhereInput | companyNotificationsWhereInput[]
    OR?: companyNotificationsWhereInput[]
    NOT?: companyNotificationsWhereInput | companyNotificationsWhereInput[]
    id?: IntFilter<"companyNotifications"> | number
    company_id?: StringFilter<"companyNotifications"> | string
    title?: StringFilter<"companyNotifications"> | string
    content?: StringNullableFilter<"companyNotifications"> | string | null
    type?: EnumNotificationsTypeFilter<"companyNotifications"> | $Enums.NotificationsType
    is_read?: BoolFilter<"companyNotifications"> | boolean
    sent_at?: DateTimeFilter<"companyNotifications"> | Date | string
    read_at?: DateTimeNullableFilter<"companyNotifications"> | Date | string | null
    companies?: XOR<CompaniesScalarRelationFilter, companiesWhereInput>
  }, "id_company_id">

  export type companyNotificationsOrderByWithAggregationInput = {
    id?: SortOrder
    company_id?: SortOrder
    title?: SortOrder
    content?: SortOrderInput | SortOrder
    type?: SortOrder
    is_read?: SortOrder
    sent_at?: SortOrder
    read_at?: SortOrderInput | SortOrder
    _count?: companyNotificationsCountOrderByAggregateInput
    _avg?: companyNotificationsAvgOrderByAggregateInput
    _max?: companyNotificationsMaxOrderByAggregateInput
    _min?: companyNotificationsMinOrderByAggregateInput
    _sum?: companyNotificationsSumOrderByAggregateInput
  }

  export type companyNotificationsScalarWhereWithAggregatesInput = {
    AND?: companyNotificationsScalarWhereWithAggregatesInput | companyNotificationsScalarWhereWithAggregatesInput[]
    OR?: companyNotificationsScalarWhereWithAggregatesInput[]
    NOT?: companyNotificationsScalarWhereWithAggregatesInput | companyNotificationsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"companyNotifications"> | number
    company_id?: StringWithAggregatesFilter<"companyNotifications"> | string
    title?: StringWithAggregatesFilter<"companyNotifications"> | string
    content?: StringNullableWithAggregatesFilter<"companyNotifications"> | string | null
    type?: EnumNotificationsTypeWithAggregatesFilter<"companyNotifications"> | $Enums.NotificationsType
    is_read?: BoolWithAggregatesFilter<"companyNotifications"> | boolean
    sent_at?: DateTimeWithAggregatesFilter<"companyNotifications"> | Date | string
    read_at?: DateTimeNullableWithAggregatesFilter<"companyNotifications"> | Date | string | null
  }

  export type cvsWhereInput = {
    AND?: cvsWhereInput | cvsWhereInput[]
    OR?: cvsWhereInput[]
    NOT?: cvsWhereInput | cvsWhereInput[]
    id?: IntFilter<"cvs"> | number
    fullname?: StringFilter<"cvs"> | string
    age?: IntNullableFilter<"cvs"> | number | null
    gender?: StringNullableFilter<"cvs"> | string | null
    address?: StringNullableFilter<"cvs"> | string | null
    email?: StringNullableFilter<"cvs"> | string | null
    introduction?: StringNullableFilter<"cvs"> | string | null
    soft_skills?: StringNullableListFilter<"cvs">
    primary_skills?: StringNullableListFilter<"cvs">
    phone?: StringNullableFilter<"cvs"> | string | null
    hobbies?: StringNullableFilter<"cvs"> | string | null
    others?: StringNullableFilter<"cvs"> | string | null
    applicants?: ApplicantsListRelationFilter
    awards?: AwardsListRelationFilter
    certificates?: CertificatesListRelationFilter
    educations?: EducationsListRelationFilter
    experiences?: ExperiencesListRelationFilter
    projects?: ProjectsListRelationFilter
    references?: ReferencesListRelationFilter
  }

  export type cvsOrderByWithRelationInput = {
    id?: SortOrder
    fullname?: SortOrder
    age?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    introduction?: SortOrderInput | SortOrder
    soft_skills?: SortOrder
    primary_skills?: SortOrder
    phone?: SortOrderInput | SortOrder
    hobbies?: SortOrderInput | SortOrder
    others?: SortOrderInput | SortOrder
    applicants?: applicantsOrderByRelationAggregateInput
    awards?: awardsOrderByRelationAggregateInput
    certificates?: certificatesOrderByRelationAggregateInput
    educations?: educationsOrderByRelationAggregateInput
    experiences?: experiencesOrderByRelationAggregateInput
    projects?: projectsOrderByRelationAggregateInput
    references?: referencesOrderByRelationAggregateInput
  }

  export type cvsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: cvsWhereInput | cvsWhereInput[]
    OR?: cvsWhereInput[]
    NOT?: cvsWhereInput | cvsWhereInput[]
    fullname?: StringFilter<"cvs"> | string
    age?: IntNullableFilter<"cvs"> | number | null
    gender?: StringNullableFilter<"cvs"> | string | null
    address?: StringNullableFilter<"cvs"> | string | null
    email?: StringNullableFilter<"cvs"> | string | null
    introduction?: StringNullableFilter<"cvs"> | string | null
    soft_skills?: StringNullableListFilter<"cvs">
    primary_skills?: StringNullableListFilter<"cvs">
    phone?: StringNullableFilter<"cvs"> | string | null
    hobbies?: StringNullableFilter<"cvs"> | string | null
    others?: StringNullableFilter<"cvs"> | string | null
    applicants?: ApplicantsListRelationFilter
    awards?: AwardsListRelationFilter
    certificates?: CertificatesListRelationFilter
    educations?: EducationsListRelationFilter
    experiences?: ExperiencesListRelationFilter
    projects?: ProjectsListRelationFilter
    references?: ReferencesListRelationFilter
  }, "id">

  export type cvsOrderByWithAggregationInput = {
    id?: SortOrder
    fullname?: SortOrder
    age?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    introduction?: SortOrderInput | SortOrder
    soft_skills?: SortOrder
    primary_skills?: SortOrder
    phone?: SortOrderInput | SortOrder
    hobbies?: SortOrderInput | SortOrder
    others?: SortOrderInput | SortOrder
    _count?: cvsCountOrderByAggregateInput
    _avg?: cvsAvgOrderByAggregateInput
    _max?: cvsMaxOrderByAggregateInput
    _min?: cvsMinOrderByAggregateInput
    _sum?: cvsSumOrderByAggregateInput
  }

  export type cvsScalarWhereWithAggregatesInput = {
    AND?: cvsScalarWhereWithAggregatesInput | cvsScalarWhereWithAggregatesInput[]
    OR?: cvsScalarWhereWithAggregatesInput[]
    NOT?: cvsScalarWhereWithAggregatesInput | cvsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"cvs"> | number
    fullname?: StringWithAggregatesFilter<"cvs"> | string
    age?: IntNullableWithAggregatesFilter<"cvs"> | number | null
    gender?: StringNullableWithAggregatesFilter<"cvs"> | string | null
    address?: StringNullableWithAggregatesFilter<"cvs"> | string | null
    email?: StringNullableWithAggregatesFilter<"cvs"> | string | null
    introduction?: StringNullableWithAggregatesFilter<"cvs"> | string | null
    soft_skills?: StringNullableListFilter<"cvs">
    primary_skills?: StringNullableListFilter<"cvs">
    phone?: StringNullableWithAggregatesFilter<"cvs"> | string | null
    hobbies?: StringNullableWithAggregatesFilter<"cvs"> | string | null
    others?: StringNullableWithAggregatesFilter<"cvs"> | string | null
  }

  export type educationsWhereInput = {
    AND?: educationsWhereInput | educationsWhereInput[]
    OR?: educationsWhereInput[]
    NOT?: educationsWhereInput | educationsWhereInput[]
    id?: IntFilter<"educations"> | number
    school?: StringFilter<"educations"> | string
    graduated_type?: StringNullableFilter<"educations"> | string | null
    gpa?: FloatNullableFilter<"educations"> | number | null
    start_date?: DateTimeNullableFilter<"educations"> | Date | string | null
    end_date?: DateTimeNullableFilter<"educations"> | Date | string | null
    cv_id?: IntFilter<"educations"> | number
    cvs?: XOR<CvsScalarRelationFilter, cvsWhereInput>
  }

  export type educationsOrderByWithRelationInput = {
    id?: SortOrder
    school?: SortOrder
    graduated_type?: SortOrderInput | SortOrder
    gpa?: SortOrderInput | SortOrder
    start_date?: SortOrderInput | SortOrder
    end_date?: SortOrderInput | SortOrder
    cv_id?: SortOrder
    cvs?: cvsOrderByWithRelationInput
  }

  export type educationsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: educationsWhereInput | educationsWhereInput[]
    OR?: educationsWhereInput[]
    NOT?: educationsWhereInput | educationsWhereInput[]
    school?: StringFilter<"educations"> | string
    graduated_type?: StringNullableFilter<"educations"> | string | null
    gpa?: FloatNullableFilter<"educations"> | number | null
    start_date?: DateTimeNullableFilter<"educations"> | Date | string | null
    end_date?: DateTimeNullableFilter<"educations"> | Date | string | null
    cv_id?: IntFilter<"educations"> | number
    cvs?: XOR<CvsScalarRelationFilter, cvsWhereInput>
  }, "id">

  export type educationsOrderByWithAggregationInput = {
    id?: SortOrder
    school?: SortOrder
    graduated_type?: SortOrderInput | SortOrder
    gpa?: SortOrderInput | SortOrder
    start_date?: SortOrderInput | SortOrder
    end_date?: SortOrderInput | SortOrder
    cv_id?: SortOrder
    _count?: educationsCountOrderByAggregateInput
    _avg?: educationsAvgOrderByAggregateInput
    _max?: educationsMaxOrderByAggregateInput
    _min?: educationsMinOrderByAggregateInput
    _sum?: educationsSumOrderByAggregateInput
  }

  export type educationsScalarWhereWithAggregatesInput = {
    AND?: educationsScalarWhereWithAggregatesInput | educationsScalarWhereWithAggregatesInput[]
    OR?: educationsScalarWhereWithAggregatesInput[]
    NOT?: educationsScalarWhereWithAggregatesInput | educationsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"educations"> | number
    school?: StringWithAggregatesFilter<"educations"> | string
    graduated_type?: StringNullableWithAggregatesFilter<"educations"> | string | null
    gpa?: FloatNullableWithAggregatesFilter<"educations"> | number | null
    start_date?: DateTimeNullableWithAggregatesFilter<"educations"> | Date | string | null
    end_date?: DateTimeNullableWithAggregatesFilter<"educations"> | Date | string | null
    cv_id?: IntWithAggregatesFilter<"educations"> | number
  }

  export type experiencesWhereInput = {
    AND?: experiencesWhereInput | experiencesWhereInput[]
    OR?: experiencesWhereInput[]
    NOT?: experiencesWhereInput | experiencesWhereInput[]
    id?: IntFilter<"experiences"> | number
    company_name?: StringNullableFilter<"experiences"> | string | null
    title?: StringNullableFilter<"experiences"> | string | null
    description?: StringNullableFilter<"experiences"> | string | null
    start_date?: DateTimeNullableFilter<"experiences"> | Date | string | null
    end_date?: DateTimeNullableFilter<"experiences"> | Date | string | null
    cv_id?: IntFilter<"experiences"> | number
    cvs?: XOR<CvsScalarRelationFilter, cvsWhereInput>
  }

  export type experiencesOrderByWithRelationInput = {
    id?: SortOrder
    company_name?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    start_date?: SortOrderInput | SortOrder
    end_date?: SortOrderInput | SortOrder
    cv_id?: SortOrder
    cvs?: cvsOrderByWithRelationInput
  }

  export type experiencesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: experiencesWhereInput | experiencesWhereInput[]
    OR?: experiencesWhereInput[]
    NOT?: experiencesWhereInput | experiencesWhereInput[]
    company_name?: StringNullableFilter<"experiences"> | string | null
    title?: StringNullableFilter<"experiences"> | string | null
    description?: StringNullableFilter<"experiences"> | string | null
    start_date?: DateTimeNullableFilter<"experiences"> | Date | string | null
    end_date?: DateTimeNullableFilter<"experiences"> | Date | string | null
    cv_id?: IntFilter<"experiences"> | number
    cvs?: XOR<CvsScalarRelationFilter, cvsWhereInput>
  }, "id">

  export type experiencesOrderByWithAggregationInput = {
    id?: SortOrder
    company_name?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    start_date?: SortOrderInput | SortOrder
    end_date?: SortOrderInput | SortOrder
    cv_id?: SortOrder
    _count?: experiencesCountOrderByAggregateInput
    _avg?: experiencesAvgOrderByAggregateInput
    _max?: experiencesMaxOrderByAggregateInput
    _min?: experiencesMinOrderByAggregateInput
    _sum?: experiencesSumOrderByAggregateInput
  }

  export type experiencesScalarWhereWithAggregatesInput = {
    AND?: experiencesScalarWhereWithAggregatesInput | experiencesScalarWhereWithAggregatesInput[]
    OR?: experiencesScalarWhereWithAggregatesInput[]
    NOT?: experiencesScalarWhereWithAggregatesInput | experiencesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"experiences"> | number
    company_name?: StringNullableWithAggregatesFilter<"experiences"> | string | null
    title?: StringNullableWithAggregatesFilter<"experiences"> | string | null
    description?: StringNullableWithAggregatesFilter<"experiences"> | string | null
    start_date?: DateTimeNullableWithAggregatesFilter<"experiences"> | Date | string | null
    end_date?: DateTimeNullableWithAggregatesFilter<"experiences"> | Date | string | null
    cv_id?: IntWithAggregatesFilter<"experiences"> | number
  }

  export type featuresWhereInput = {
    AND?: featuresWhereInput | featuresWhereInput[]
    OR?: featuresWhereInput[]
    NOT?: featuresWhereInput | featuresWhereInput[]
    id?: IntFilter<"features"> | number
    feature_name?: StringFilter<"features"> | string
    description?: StringNullableFilter<"features"> | string | null
    plan_id?: IntNullableFilter<"features"> | number | null
    membershipPlans?: XOR<MembershipPlansNullableScalarRelationFilter, membershipPlansWhereInput> | null
  }

  export type featuresOrderByWithRelationInput = {
    id?: SortOrder
    feature_name?: SortOrder
    description?: SortOrderInput | SortOrder
    plan_id?: SortOrderInput | SortOrder
    membershipPlans?: membershipPlansOrderByWithRelationInput
  }

  export type featuresWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: featuresWhereInput | featuresWhereInput[]
    OR?: featuresWhereInput[]
    NOT?: featuresWhereInput | featuresWhereInput[]
    feature_name?: StringFilter<"features"> | string
    description?: StringNullableFilter<"features"> | string | null
    plan_id?: IntNullableFilter<"features"> | number | null
    membershipPlans?: XOR<MembershipPlansNullableScalarRelationFilter, membershipPlansWhereInput> | null
  }, "id">

  export type featuresOrderByWithAggregationInput = {
    id?: SortOrder
    feature_name?: SortOrder
    description?: SortOrderInput | SortOrder
    plan_id?: SortOrderInput | SortOrder
    _count?: featuresCountOrderByAggregateInput
    _avg?: featuresAvgOrderByAggregateInput
    _max?: featuresMaxOrderByAggregateInput
    _min?: featuresMinOrderByAggregateInput
    _sum?: featuresSumOrderByAggregateInput
  }

  export type featuresScalarWhereWithAggregatesInput = {
    AND?: featuresScalarWhereWithAggregatesInput | featuresScalarWhereWithAggregatesInput[]
    OR?: featuresScalarWhereWithAggregatesInput[]
    NOT?: featuresScalarWhereWithAggregatesInput | featuresScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"features"> | number
    feature_name?: StringWithAggregatesFilter<"features"> | string
    description?: StringNullableWithAggregatesFilter<"features"> | string | null
    plan_id?: IntNullableWithAggregatesFilter<"features"> | number | null
  }

  export type feedbacksWhereInput = {
    AND?: feedbacksWhereInput | feedbacksWhereInput[]
    OR?: feedbacksWhereInput[]
    NOT?: feedbacksWhereInput | feedbacksWhereInput[]
    user_id?: StringFilter<"feedbacks"> | string
    company_id?: StringFilter<"feedbacks"> | string
    description?: StringFilter<"feedbacks"> | string
    stars?: FloatFilter<"feedbacks"> | number
    work_environment?: StringNullableFilter<"feedbacks"> | string | null
    benefit?: StringNullableFilter<"feedbacks"> | string | null
    created_at?: DateTimeFilter<"feedbacks"> | Date | string
    companies?: XOR<CompaniesScalarRelationFilter, companiesWhereInput>
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type feedbacksOrderByWithRelationInput = {
    user_id?: SortOrder
    company_id?: SortOrder
    description?: SortOrder
    stars?: SortOrder
    work_environment?: SortOrderInput | SortOrder
    benefit?: SortOrderInput | SortOrder
    created_at?: SortOrder
    companies?: companiesOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
  }

  export type feedbacksWhereUniqueInput = Prisma.AtLeast<{
    user_id_company_id?: feedbacksUser_idCompany_idCompoundUniqueInput
    AND?: feedbacksWhereInput | feedbacksWhereInput[]
    OR?: feedbacksWhereInput[]
    NOT?: feedbacksWhereInput | feedbacksWhereInput[]
    user_id?: StringFilter<"feedbacks"> | string
    company_id?: StringFilter<"feedbacks"> | string
    description?: StringFilter<"feedbacks"> | string
    stars?: FloatFilter<"feedbacks"> | number
    work_environment?: StringNullableFilter<"feedbacks"> | string | null
    benefit?: StringNullableFilter<"feedbacks"> | string | null
    created_at?: DateTimeFilter<"feedbacks"> | Date | string
    companies?: XOR<CompaniesScalarRelationFilter, companiesWhereInput>
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "user_id_company_id">

  export type feedbacksOrderByWithAggregationInput = {
    user_id?: SortOrder
    company_id?: SortOrder
    description?: SortOrder
    stars?: SortOrder
    work_environment?: SortOrderInput | SortOrder
    benefit?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: feedbacksCountOrderByAggregateInput
    _avg?: feedbacksAvgOrderByAggregateInput
    _max?: feedbacksMaxOrderByAggregateInput
    _min?: feedbacksMinOrderByAggregateInput
    _sum?: feedbacksSumOrderByAggregateInput
  }

  export type feedbacksScalarWhereWithAggregatesInput = {
    AND?: feedbacksScalarWhereWithAggregatesInput | feedbacksScalarWhereWithAggregatesInput[]
    OR?: feedbacksScalarWhereWithAggregatesInput[]
    NOT?: feedbacksScalarWhereWithAggregatesInput | feedbacksScalarWhereWithAggregatesInput[]
    user_id?: StringWithAggregatesFilter<"feedbacks"> | string
    company_id?: StringWithAggregatesFilter<"feedbacks"> | string
    description?: StringWithAggregatesFilter<"feedbacks"> | string
    stars?: FloatWithAggregatesFilter<"feedbacks"> | number
    work_environment?: StringNullableWithAggregatesFilter<"feedbacks"> | string | null
    benefit?: StringNullableWithAggregatesFilter<"feedbacks"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"feedbacks"> | Date | string
  }

  export type fieldsWhereInput = {
    AND?: fieldsWhereInput | fieldsWhereInput[]
    OR?: fieldsWhereInput[]
    NOT?: fieldsWhereInput | fieldsWhereInput[]
    id?: IntFilter<"fields"> | number
    field_name?: StringFilter<"fields"> | string
    companies?: CompaniesListRelationFilter
  }

  export type fieldsOrderByWithRelationInput = {
    id?: SortOrder
    field_name?: SortOrder
    companies?: companiesOrderByRelationAggregateInput
  }

  export type fieldsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    field_name?: string
    AND?: fieldsWhereInput | fieldsWhereInput[]
    OR?: fieldsWhereInput[]
    NOT?: fieldsWhereInput | fieldsWhereInput[]
    companies?: CompaniesListRelationFilter
  }, "id" | "field_name">

  export type fieldsOrderByWithAggregationInput = {
    id?: SortOrder
    field_name?: SortOrder
    _count?: fieldsCountOrderByAggregateInput
    _avg?: fieldsAvgOrderByAggregateInput
    _max?: fieldsMaxOrderByAggregateInput
    _min?: fieldsMinOrderByAggregateInput
    _sum?: fieldsSumOrderByAggregateInput
  }

  export type fieldsScalarWhereWithAggregatesInput = {
    AND?: fieldsScalarWhereWithAggregatesInput | fieldsScalarWhereWithAggregatesInput[]
    OR?: fieldsScalarWhereWithAggregatesInput[]
    NOT?: fieldsScalarWhereWithAggregatesInput | fieldsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"fields"> | number
    field_name?: StringWithAggregatesFilter<"fields"> | string
  }

  export type followedCompaniesWhereInput = {
    AND?: followedCompaniesWhereInput | followedCompaniesWhereInput[]
    OR?: followedCompaniesWhereInput[]
    NOT?: followedCompaniesWhereInput | followedCompaniesWhereInput[]
    user_id?: StringFilter<"followedCompanies"> | string
    company_id?: StringFilter<"followedCompanies"> | string
    followed_at?: DateTimeFilter<"followedCompanies"> | Date | string
    is_notified?: BoolFilter<"followedCompanies"> | boolean
    companies?: XOR<CompaniesScalarRelationFilter, companiesWhereInput>
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type followedCompaniesOrderByWithRelationInput = {
    user_id?: SortOrder
    company_id?: SortOrder
    followed_at?: SortOrder
    is_notified?: SortOrder
    companies?: companiesOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
  }

  export type followedCompaniesWhereUniqueInput = Prisma.AtLeast<{
    user_id_company_id?: followedCompaniesUser_idCompany_idCompoundUniqueInput
    AND?: followedCompaniesWhereInput | followedCompaniesWhereInput[]
    OR?: followedCompaniesWhereInput[]
    NOT?: followedCompaniesWhereInput | followedCompaniesWhereInput[]
    user_id?: StringFilter<"followedCompanies"> | string
    company_id?: StringFilter<"followedCompanies"> | string
    followed_at?: DateTimeFilter<"followedCompanies"> | Date | string
    is_notified?: BoolFilter<"followedCompanies"> | boolean
    companies?: XOR<CompaniesScalarRelationFilter, companiesWhereInput>
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "user_id_company_id">

  export type followedCompaniesOrderByWithAggregationInput = {
    user_id?: SortOrder
    company_id?: SortOrder
    followed_at?: SortOrder
    is_notified?: SortOrder
    _count?: followedCompaniesCountOrderByAggregateInput
    _max?: followedCompaniesMaxOrderByAggregateInput
    _min?: followedCompaniesMinOrderByAggregateInput
  }

  export type followedCompaniesScalarWhereWithAggregatesInput = {
    AND?: followedCompaniesScalarWhereWithAggregatesInput | followedCompaniesScalarWhereWithAggregatesInput[]
    OR?: followedCompaniesScalarWhereWithAggregatesInput[]
    NOT?: followedCompaniesScalarWhereWithAggregatesInput | followedCompaniesScalarWhereWithAggregatesInput[]
    user_id?: StringWithAggregatesFilter<"followedCompanies"> | string
    company_id?: StringWithAggregatesFilter<"followedCompanies"> | string
    followed_at?: DateTimeWithAggregatesFilter<"followedCompanies"> | Date | string
    is_notified?: BoolWithAggregatesFilter<"followedCompanies"> | boolean
  }

  export type jobCategoriesWhereInput = {
    AND?: jobCategoriesWhereInput | jobCategoriesWhereInput[]
    OR?: jobCategoriesWhereInput[]
    NOT?: jobCategoriesWhereInput | jobCategoriesWhereInput[]
    id?: IntFilter<"jobCategories"> | number
    job_category?: StringFilter<"jobCategories"> | string
    description?: StringNullableFilter<"jobCategories"> | string | null
    jobSpecialized?: JobSpecializedListRelationFilter
  }

  export type jobCategoriesOrderByWithRelationInput = {
    id?: SortOrder
    job_category?: SortOrder
    description?: SortOrderInput | SortOrder
    jobSpecialized?: jobSpecializedOrderByRelationAggregateInput
  }

  export type jobCategoriesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    job_category?: string
    AND?: jobCategoriesWhereInput | jobCategoriesWhereInput[]
    OR?: jobCategoriesWhereInput[]
    NOT?: jobCategoriesWhereInput | jobCategoriesWhereInput[]
    description?: StringNullableFilter<"jobCategories"> | string | null
    jobSpecialized?: JobSpecializedListRelationFilter
  }, "id" | "job_category">

  export type jobCategoriesOrderByWithAggregationInput = {
    id?: SortOrder
    job_category?: SortOrder
    description?: SortOrderInput | SortOrder
    _count?: jobCategoriesCountOrderByAggregateInput
    _avg?: jobCategoriesAvgOrderByAggregateInput
    _max?: jobCategoriesMaxOrderByAggregateInput
    _min?: jobCategoriesMinOrderByAggregateInput
    _sum?: jobCategoriesSumOrderByAggregateInput
  }

  export type jobCategoriesScalarWhereWithAggregatesInput = {
    AND?: jobCategoriesScalarWhereWithAggregatesInput | jobCategoriesScalarWhereWithAggregatesInput[]
    OR?: jobCategoriesScalarWhereWithAggregatesInput[]
    NOT?: jobCategoriesScalarWhereWithAggregatesInput | jobCategoriesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"jobCategories"> | number
    job_category?: StringWithAggregatesFilter<"jobCategories"> | string
    description?: StringNullableWithAggregatesFilter<"jobCategories"> | string | null
  }

  export type jobLabelsWhereInput = {
    AND?: jobLabelsWhereInput | jobLabelsWhereInput[]
    OR?: jobLabelsWhereInput[]
    NOT?: jobLabelsWhereInput | jobLabelsWhereInput[]
    id?: IntFilter<"jobLabels"> | number
    label_name?: StringFilter<"jobLabels"> | string
    jobs?: JobsListRelationFilter
  }

  export type jobLabelsOrderByWithRelationInput = {
    id?: SortOrder
    label_name?: SortOrder
    jobs?: jobsOrderByRelationAggregateInput
  }

  export type jobLabelsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    label_name?: string
    AND?: jobLabelsWhereInput | jobLabelsWhereInput[]
    OR?: jobLabelsWhereInput[]
    NOT?: jobLabelsWhereInput | jobLabelsWhereInput[]
    jobs?: JobsListRelationFilter
  }, "id" | "label_name">

  export type jobLabelsOrderByWithAggregationInput = {
    id?: SortOrder
    label_name?: SortOrder
    _count?: jobLabelsCountOrderByAggregateInput
    _avg?: jobLabelsAvgOrderByAggregateInput
    _max?: jobLabelsMaxOrderByAggregateInput
    _min?: jobLabelsMinOrderByAggregateInput
    _sum?: jobLabelsSumOrderByAggregateInput
  }

  export type jobLabelsScalarWhereWithAggregatesInput = {
    AND?: jobLabelsScalarWhereWithAggregatesInput | jobLabelsScalarWhereWithAggregatesInput[]
    OR?: jobLabelsScalarWhereWithAggregatesInput[]
    NOT?: jobLabelsScalarWhereWithAggregatesInput | jobLabelsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"jobLabels"> | number
    label_name?: StringWithAggregatesFilter<"jobLabels"> | string
  }

  export type jobSpecializedWhereInput = {
    AND?: jobSpecializedWhereInput | jobSpecializedWhereInput[]
    OR?: jobSpecializedWhereInput[]
    NOT?: jobSpecializedWhereInput | jobSpecializedWhereInput[]
    id?: IntFilter<"jobSpecialized"> | number
    job_type?: StringFilter<"jobSpecialized"> | string
    description?: StringNullableFilter<"jobSpecialized"> | string | null
    jobcategory_id?: IntFilter<"jobSpecialized"> | number
    careerPaths?: XOR<CareerPathsNullableScalarRelationFilter, careerPathsWhereInput> | null
    jobCategories?: XOR<JobCategoriesScalarRelationFilter, jobCategoriesWhereInput>
  }

  export type jobSpecializedOrderByWithRelationInput = {
    id?: SortOrder
    job_type?: SortOrder
    description?: SortOrderInput | SortOrder
    jobcategory_id?: SortOrder
    careerPaths?: careerPathsOrderByWithRelationInput
    jobCategories?: jobCategoriesOrderByWithRelationInput
  }

  export type jobSpecializedWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: jobSpecializedWhereInput | jobSpecializedWhereInput[]
    OR?: jobSpecializedWhereInput[]
    NOT?: jobSpecializedWhereInput | jobSpecializedWhereInput[]
    job_type?: StringFilter<"jobSpecialized"> | string
    description?: StringNullableFilter<"jobSpecialized"> | string | null
    jobcategory_id?: IntFilter<"jobSpecialized"> | number
    careerPaths?: XOR<CareerPathsNullableScalarRelationFilter, careerPathsWhereInput> | null
    jobCategories?: XOR<JobCategoriesScalarRelationFilter, jobCategoriesWhereInput>
  }, "id">

  export type jobSpecializedOrderByWithAggregationInput = {
    id?: SortOrder
    job_type?: SortOrder
    description?: SortOrderInput | SortOrder
    jobcategory_id?: SortOrder
    _count?: jobSpecializedCountOrderByAggregateInput
    _avg?: jobSpecializedAvgOrderByAggregateInput
    _max?: jobSpecializedMaxOrderByAggregateInput
    _min?: jobSpecializedMinOrderByAggregateInput
    _sum?: jobSpecializedSumOrderByAggregateInput
  }

  export type jobSpecializedScalarWhereWithAggregatesInput = {
    AND?: jobSpecializedScalarWhereWithAggregatesInput | jobSpecializedScalarWhereWithAggregatesInput[]
    OR?: jobSpecializedScalarWhereWithAggregatesInput[]
    NOT?: jobSpecializedScalarWhereWithAggregatesInput | jobSpecializedScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"jobSpecialized"> | number
    job_type?: StringWithAggregatesFilter<"jobSpecialized"> | string
    description?: StringNullableWithAggregatesFilter<"jobSpecialized"> | string | null
    jobcategory_id?: IntWithAggregatesFilter<"jobSpecialized"> | number
  }

  export type jobsWhereInput = {
    AND?: jobsWhereInput | jobsWhereInput[]
    OR?: jobsWhereInput[]
    NOT?: jobsWhereInput | jobsWhereInput[]
    id?: StringFilter<"jobs"> | string
    job_title?: StringFilter<"jobs"> | string
    description?: StringFilter<"jobs"> | string
    location?: StringNullableFilter<"jobs"> | string | null
    benefit?: StringNullableFilter<"jobs"> | string | null
    working_time?: StringNullableFilter<"jobs"> | string | null
    salary?: StringNullableListFilter<"jobs">
    currency?: StringNullableFilter<"jobs"> | string | null
    job_type?: EnumJob_TypeNullableFilter<"jobs"> | $Enums.Job_Type | null
    status?: EnumJob_StatusNullableFilter<"jobs"> | $Enums.Job_Status | null
    job_level?: StringFilter<"jobs"> | string
    quantity?: IntNullableFilter<"jobs"> | number | null
    skill_tags?: StringNullableListFilter<"jobs">
    education?: EnumEducationNullableFilter<"jobs"> | $Enums.Education | null
    experience?: StringNullableFilter<"jobs"> | string | null
    start_date?: DateTimeFilter<"jobs"> | Date | string
    end_date?: DateTimeNullableFilter<"jobs"> | Date | string | null
    created_at?: DateTimeFilter<"jobs"> | Date | string
    updated_at?: DateTimeFilter<"jobs"> | Date | string
    category_id?: IntNullableFilter<"jobs"> | number | null
    label_id?: IntNullableFilter<"jobs"> | number | null
    applicants?: ApplicantsListRelationFilter
    categories?: XOR<CategoriesNullableScalarRelationFilter, categoriesWhereInput> | null
    jobLabels?: XOR<JobLabelsNullableScalarRelationFilter, jobLabelsWhereInput> | null
    savedJobs?: SavedJobsListRelationFilter
  }

  export type jobsOrderByWithRelationInput = {
    id?: SortOrder
    job_title?: SortOrder
    description?: SortOrder
    location?: SortOrderInput | SortOrder
    benefit?: SortOrderInput | SortOrder
    working_time?: SortOrderInput | SortOrder
    salary?: SortOrder
    currency?: SortOrderInput | SortOrder
    job_type?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    job_level?: SortOrder
    quantity?: SortOrderInput | SortOrder
    skill_tags?: SortOrder
    education?: SortOrderInput | SortOrder
    experience?: SortOrderInput | SortOrder
    start_date?: SortOrder
    end_date?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    category_id?: SortOrderInput | SortOrder
    label_id?: SortOrderInput | SortOrder
    applicants?: applicantsOrderByRelationAggregateInput
    categories?: categoriesOrderByWithRelationInput
    jobLabels?: jobLabelsOrderByWithRelationInput
    savedJobs?: savedJobsOrderByRelationAggregateInput
  }

  export type jobsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: jobsWhereInput | jobsWhereInput[]
    OR?: jobsWhereInput[]
    NOT?: jobsWhereInput | jobsWhereInput[]
    job_title?: StringFilter<"jobs"> | string
    description?: StringFilter<"jobs"> | string
    location?: StringNullableFilter<"jobs"> | string | null
    benefit?: StringNullableFilter<"jobs"> | string | null
    working_time?: StringNullableFilter<"jobs"> | string | null
    salary?: StringNullableListFilter<"jobs">
    currency?: StringNullableFilter<"jobs"> | string | null
    job_type?: EnumJob_TypeNullableFilter<"jobs"> | $Enums.Job_Type | null
    status?: EnumJob_StatusNullableFilter<"jobs"> | $Enums.Job_Status | null
    job_level?: StringFilter<"jobs"> | string
    quantity?: IntNullableFilter<"jobs"> | number | null
    skill_tags?: StringNullableListFilter<"jobs">
    education?: EnumEducationNullableFilter<"jobs"> | $Enums.Education | null
    experience?: StringNullableFilter<"jobs"> | string | null
    start_date?: DateTimeFilter<"jobs"> | Date | string
    end_date?: DateTimeNullableFilter<"jobs"> | Date | string | null
    created_at?: DateTimeFilter<"jobs"> | Date | string
    updated_at?: DateTimeFilter<"jobs"> | Date | string
    category_id?: IntNullableFilter<"jobs"> | number | null
    label_id?: IntNullableFilter<"jobs"> | number | null
    applicants?: ApplicantsListRelationFilter
    categories?: XOR<CategoriesNullableScalarRelationFilter, categoriesWhereInput> | null
    jobLabels?: XOR<JobLabelsNullableScalarRelationFilter, jobLabelsWhereInput> | null
    savedJobs?: SavedJobsListRelationFilter
  }, "id">

  export type jobsOrderByWithAggregationInput = {
    id?: SortOrder
    job_title?: SortOrder
    description?: SortOrder
    location?: SortOrderInput | SortOrder
    benefit?: SortOrderInput | SortOrder
    working_time?: SortOrderInput | SortOrder
    salary?: SortOrder
    currency?: SortOrderInput | SortOrder
    job_type?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    job_level?: SortOrder
    quantity?: SortOrderInput | SortOrder
    skill_tags?: SortOrder
    education?: SortOrderInput | SortOrder
    experience?: SortOrderInput | SortOrder
    start_date?: SortOrder
    end_date?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    category_id?: SortOrderInput | SortOrder
    label_id?: SortOrderInput | SortOrder
    _count?: jobsCountOrderByAggregateInput
    _avg?: jobsAvgOrderByAggregateInput
    _max?: jobsMaxOrderByAggregateInput
    _min?: jobsMinOrderByAggregateInput
    _sum?: jobsSumOrderByAggregateInput
  }

  export type jobsScalarWhereWithAggregatesInput = {
    AND?: jobsScalarWhereWithAggregatesInput | jobsScalarWhereWithAggregatesInput[]
    OR?: jobsScalarWhereWithAggregatesInput[]
    NOT?: jobsScalarWhereWithAggregatesInput | jobsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"jobs"> | string
    job_title?: StringWithAggregatesFilter<"jobs"> | string
    description?: StringWithAggregatesFilter<"jobs"> | string
    location?: StringNullableWithAggregatesFilter<"jobs"> | string | null
    benefit?: StringNullableWithAggregatesFilter<"jobs"> | string | null
    working_time?: StringNullableWithAggregatesFilter<"jobs"> | string | null
    salary?: StringNullableListFilter<"jobs">
    currency?: StringNullableWithAggregatesFilter<"jobs"> | string | null
    job_type?: EnumJob_TypeNullableWithAggregatesFilter<"jobs"> | $Enums.Job_Type | null
    status?: EnumJob_StatusNullableWithAggregatesFilter<"jobs"> | $Enums.Job_Status | null
    job_level?: StringWithAggregatesFilter<"jobs"> | string
    quantity?: IntNullableWithAggregatesFilter<"jobs"> | number | null
    skill_tags?: StringNullableListFilter<"jobs">
    education?: EnumEducationNullableWithAggregatesFilter<"jobs"> | $Enums.Education | null
    experience?: StringNullableWithAggregatesFilter<"jobs"> | string | null
    start_date?: DateTimeWithAggregatesFilter<"jobs"> | Date | string
    end_date?: DateTimeNullableWithAggregatesFilter<"jobs"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"jobs"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"jobs"> | Date | string
    category_id?: IntNullableWithAggregatesFilter<"jobs"> | number | null
    label_id?: IntNullableWithAggregatesFilter<"jobs"> | number | null
  }

  export type membershipPlansWhereInput = {
    AND?: membershipPlansWhereInput | membershipPlansWhereInput[]
    OR?: membershipPlansWhereInput[]
    NOT?: membershipPlansWhereInput | membershipPlansWhereInput[]
    id?: IntFilter<"membershipPlans"> | number
    plan_name?: StringFilter<"membershipPlans"> | string
    description?: StringNullableFilter<"membershipPlans"> | string | null
    price?: BigIntFilter<"membershipPlans"> | bigint | number
    duration_days?: IntFilter<"membershipPlans"> | number
    is_active?: BoolFilter<"membershipPlans"> | boolean
    created_at?: DateTimeFilter<"membershipPlans"> | Date | string
    updated_at?: DateTimeFilter<"membershipPlans"> | Date | string
    features?: FeaturesListRelationFilter
    subscriptions?: SubscriptionsListRelationFilter
  }

  export type membershipPlansOrderByWithRelationInput = {
    id?: SortOrder
    plan_name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    duration_days?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    features?: featuresOrderByRelationAggregateInput
    subscriptions?: subscriptionsOrderByRelationAggregateInput
  }

  export type membershipPlansWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: membershipPlansWhereInput | membershipPlansWhereInput[]
    OR?: membershipPlansWhereInput[]
    NOT?: membershipPlansWhereInput | membershipPlansWhereInput[]
    plan_name?: StringFilter<"membershipPlans"> | string
    description?: StringNullableFilter<"membershipPlans"> | string | null
    price?: BigIntFilter<"membershipPlans"> | bigint | number
    duration_days?: IntFilter<"membershipPlans"> | number
    is_active?: BoolFilter<"membershipPlans"> | boolean
    created_at?: DateTimeFilter<"membershipPlans"> | Date | string
    updated_at?: DateTimeFilter<"membershipPlans"> | Date | string
    features?: FeaturesListRelationFilter
    subscriptions?: SubscriptionsListRelationFilter
  }, "id">

  export type membershipPlansOrderByWithAggregationInput = {
    id?: SortOrder
    plan_name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    duration_days?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: membershipPlansCountOrderByAggregateInput
    _avg?: membershipPlansAvgOrderByAggregateInput
    _max?: membershipPlansMaxOrderByAggregateInput
    _min?: membershipPlansMinOrderByAggregateInput
    _sum?: membershipPlansSumOrderByAggregateInput
  }

  export type membershipPlansScalarWhereWithAggregatesInput = {
    AND?: membershipPlansScalarWhereWithAggregatesInput | membershipPlansScalarWhereWithAggregatesInput[]
    OR?: membershipPlansScalarWhereWithAggregatesInput[]
    NOT?: membershipPlansScalarWhereWithAggregatesInput | membershipPlansScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"membershipPlans"> | number
    plan_name?: StringWithAggregatesFilter<"membershipPlans"> | string
    description?: StringNullableWithAggregatesFilter<"membershipPlans"> | string | null
    price?: BigIntWithAggregatesFilter<"membershipPlans"> | bigint | number
    duration_days?: IntWithAggregatesFilter<"membershipPlans"> | number
    is_active?: BoolWithAggregatesFilter<"membershipPlans"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"membershipPlans"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"membershipPlans"> | Date | string
  }

  export type messagesWhereInput = {
    AND?: messagesWhereInput | messagesWhereInput[]
    OR?: messagesWhereInput[]
    NOT?: messagesWhereInput | messagesWhereInput[]
    id?: IntFilter<"messages"> | number
    message_content?: StringNullableFilter<"messages"> | string | null
    response_content?: StringNullableFilter<"messages"> | string | null
    created_at?: DateTimeFilter<"messages"> | Date | string
    user_id?: StringFilter<"messages"> | string
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type messagesOrderByWithRelationInput = {
    id?: SortOrder
    message_content?: SortOrderInput | SortOrder
    response_content?: SortOrderInput | SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type messagesWhereUniqueInput = Prisma.AtLeast<{
    id_user_id?: messagesIdUser_idCompoundUniqueInput
    AND?: messagesWhereInput | messagesWhereInput[]
    OR?: messagesWhereInput[]
    NOT?: messagesWhereInput | messagesWhereInput[]
    id?: IntFilter<"messages"> | number
    message_content?: StringNullableFilter<"messages"> | string | null
    response_content?: StringNullableFilter<"messages"> | string | null
    created_at?: DateTimeFilter<"messages"> | Date | string
    user_id?: StringFilter<"messages"> | string
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id_user_id">

  export type messagesOrderByWithAggregationInput = {
    id?: SortOrder
    message_content?: SortOrderInput | SortOrder
    response_content?: SortOrderInput | SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
    _count?: messagesCountOrderByAggregateInput
    _avg?: messagesAvgOrderByAggregateInput
    _max?: messagesMaxOrderByAggregateInput
    _min?: messagesMinOrderByAggregateInput
    _sum?: messagesSumOrderByAggregateInput
  }

  export type messagesScalarWhereWithAggregatesInput = {
    AND?: messagesScalarWhereWithAggregatesInput | messagesScalarWhereWithAggregatesInput[]
    OR?: messagesScalarWhereWithAggregatesInput[]
    NOT?: messagesScalarWhereWithAggregatesInput | messagesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"messages"> | number
    message_content?: StringNullableWithAggregatesFilter<"messages"> | string | null
    response_content?: StringNullableWithAggregatesFilter<"messages"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"messages"> | Date | string
    user_id?: StringWithAggregatesFilter<"messages"> | string
  }

  export type paymentsWhereInput = {
    AND?: paymentsWhereInput | paymentsWhereInput[]
    OR?: paymentsWhereInput[]
    NOT?: paymentsWhereInput | paymentsWhereInput[]
    id?: StringFilter<"payments"> | string
    amount?: BigIntFilter<"payments"> | bigint | number
    currency?: StringNullableFilter<"payments"> | string | null
    payment_gateway?: EnumPaymentGatewayFilter<"payments"> | $Enums.PaymentGateway
    payment_method?: EnumPaymentMethodFilter<"payments"> | $Enums.PaymentMethod
    transaction_id?: StringNullableFilter<"payments"> | string | null
    status?: EnumPaymentStatusFilter<"payments"> | $Enums.PaymentStatus
    created_at?: DateTimeFilter<"payments"> | Date | string
    user_id?: StringFilter<"payments"> | string
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    subscriptions?: XOR<SubscriptionsNullableScalarRelationFilter, subscriptionsWhereInput> | null
  }

  export type paymentsOrderByWithRelationInput = {
    id?: SortOrder
    amount?: SortOrder
    currency?: SortOrderInput | SortOrder
    payment_gateway?: SortOrder
    payment_method?: SortOrder
    transaction_id?: SortOrderInput | SortOrder
    status?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
    users?: usersOrderByWithRelationInput
    subscriptions?: subscriptionsOrderByWithRelationInput
  }

  export type paymentsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: paymentsWhereInput | paymentsWhereInput[]
    OR?: paymentsWhereInput[]
    NOT?: paymentsWhereInput | paymentsWhereInput[]
    amount?: BigIntFilter<"payments"> | bigint | number
    currency?: StringNullableFilter<"payments"> | string | null
    payment_gateway?: EnumPaymentGatewayFilter<"payments"> | $Enums.PaymentGateway
    payment_method?: EnumPaymentMethodFilter<"payments"> | $Enums.PaymentMethod
    transaction_id?: StringNullableFilter<"payments"> | string | null
    status?: EnumPaymentStatusFilter<"payments"> | $Enums.PaymentStatus
    created_at?: DateTimeFilter<"payments"> | Date | string
    user_id?: StringFilter<"payments"> | string
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
    subscriptions?: XOR<SubscriptionsNullableScalarRelationFilter, subscriptionsWhereInput> | null
  }, "id">

  export type paymentsOrderByWithAggregationInput = {
    id?: SortOrder
    amount?: SortOrder
    currency?: SortOrderInput | SortOrder
    payment_gateway?: SortOrder
    payment_method?: SortOrder
    transaction_id?: SortOrderInput | SortOrder
    status?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
    _count?: paymentsCountOrderByAggregateInput
    _avg?: paymentsAvgOrderByAggregateInput
    _max?: paymentsMaxOrderByAggregateInput
    _min?: paymentsMinOrderByAggregateInput
    _sum?: paymentsSumOrderByAggregateInput
  }

  export type paymentsScalarWhereWithAggregatesInput = {
    AND?: paymentsScalarWhereWithAggregatesInput | paymentsScalarWhereWithAggregatesInput[]
    OR?: paymentsScalarWhereWithAggregatesInput[]
    NOT?: paymentsScalarWhereWithAggregatesInput | paymentsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"payments"> | string
    amount?: BigIntWithAggregatesFilter<"payments"> | bigint | number
    currency?: StringNullableWithAggregatesFilter<"payments"> | string | null
    payment_gateway?: EnumPaymentGatewayWithAggregatesFilter<"payments"> | $Enums.PaymentGateway
    payment_method?: EnumPaymentMethodWithAggregatesFilter<"payments"> | $Enums.PaymentMethod
    transaction_id?: StringNullableWithAggregatesFilter<"payments"> | string | null
    status?: EnumPaymentStatusWithAggregatesFilter<"payments"> | $Enums.PaymentStatus
    created_at?: DateTimeWithAggregatesFilter<"payments"> | Date | string
    user_id?: StringWithAggregatesFilter<"payments"> | string
  }

  export type personalityTestResultsWhereInput = {
    AND?: personalityTestResultsWhereInput | personalityTestResultsWhereInput[]
    OR?: personalityTestResultsWhereInput[]
    NOT?: personalityTestResultsWhereInput | personalityTestResultsWhereInput[]
    user_id?: StringFilter<"personalityTestResults"> | string
    question_id?: IntFilter<"personalityTestResults"> | number
    answer_id?: IntFilter<"personalityTestResults"> | number
    answers?: XOR<AnswersScalarRelationFilter, answersWhereInput>
    questions?: XOR<QuestionsScalarRelationFilter, questionsWhereInput>
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type personalityTestResultsOrderByWithRelationInput = {
    user_id?: SortOrder
    question_id?: SortOrder
    answer_id?: SortOrder
    answers?: answersOrderByWithRelationInput
    questions?: questionsOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
  }

  export type personalityTestResultsWhereUniqueInput = Prisma.AtLeast<{
    user_id_question_id_answer_id?: personalityTestResultsUser_idQuestion_idAnswer_idCompoundUniqueInput
    AND?: personalityTestResultsWhereInput | personalityTestResultsWhereInput[]
    OR?: personalityTestResultsWhereInput[]
    NOT?: personalityTestResultsWhereInput | personalityTestResultsWhereInput[]
    user_id?: StringFilter<"personalityTestResults"> | string
    question_id?: IntFilter<"personalityTestResults"> | number
    answer_id?: IntFilter<"personalityTestResults"> | number
    answers?: XOR<AnswersScalarRelationFilter, answersWhereInput>
    questions?: XOR<QuestionsScalarRelationFilter, questionsWhereInput>
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "user_id_question_id_answer_id">

  export type personalityTestResultsOrderByWithAggregationInput = {
    user_id?: SortOrder
    question_id?: SortOrder
    answer_id?: SortOrder
    _count?: personalityTestResultsCountOrderByAggregateInput
    _avg?: personalityTestResultsAvgOrderByAggregateInput
    _max?: personalityTestResultsMaxOrderByAggregateInput
    _min?: personalityTestResultsMinOrderByAggregateInput
    _sum?: personalityTestResultsSumOrderByAggregateInput
  }

  export type personalityTestResultsScalarWhereWithAggregatesInput = {
    AND?: personalityTestResultsScalarWhereWithAggregatesInput | personalityTestResultsScalarWhereWithAggregatesInput[]
    OR?: personalityTestResultsScalarWhereWithAggregatesInput[]
    NOT?: personalityTestResultsScalarWhereWithAggregatesInput | personalityTestResultsScalarWhereWithAggregatesInput[]
    user_id?: StringWithAggregatesFilter<"personalityTestResults"> | string
    question_id?: IntWithAggregatesFilter<"personalityTestResults"> | number
    answer_id?: IntWithAggregatesFilter<"personalityTestResults"> | number
  }

  export type projectsWhereInput = {
    AND?: projectsWhereInput | projectsWhereInput[]
    OR?: projectsWhereInput[]
    NOT?: projectsWhereInput | projectsWhereInput[]
    id?: IntFilter<"projects"> | number
    title?: StringFilter<"projects"> | string
    description?: StringNullableFilter<"projects"> | string | null
    start_date?: DateTimeNullableFilter<"projects"> | Date | string | null
    end_date?: DateTimeNullableFilter<"projects"> | Date | string | null
    cv_id?: IntFilter<"projects"> | number
    cvs?: XOR<CvsScalarRelationFilter, cvsWhereInput>
  }

  export type projectsOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    start_date?: SortOrderInput | SortOrder
    end_date?: SortOrderInput | SortOrder
    cv_id?: SortOrder
    cvs?: cvsOrderByWithRelationInput
  }

  export type projectsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: projectsWhereInput | projectsWhereInput[]
    OR?: projectsWhereInput[]
    NOT?: projectsWhereInput | projectsWhereInput[]
    title?: StringFilter<"projects"> | string
    description?: StringNullableFilter<"projects"> | string | null
    start_date?: DateTimeNullableFilter<"projects"> | Date | string | null
    end_date?: DateTimeNullableFilter<"projects"> | Date | string | null
    cv_id?: IntFilter<"projects"> | number
    cvs?: XOR<CvsScalarRelationFilter, cvsWhereInput>
  }, "id">

  export type projectsOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    start_date?: SortOrderInput | SortOrder
    end_date?: SortOrderInput | SortOrder
    cv_id?: SortOrder
    _count?: projectsCountOrderByAggregateInput
    _avg?: projectsAvgOrderByAggregateInput
    _max?: projectsMaxOrderByAggregateInput
    _min?: projectsMinOrderByAggregateInput
    _sum?: projectsSumOrderByAggregateInput
  }

  export type projectsScalarWhereWithAggregatesInput = {
    AND?: projectsScalarWhereWithAggregatesInput | projectsScalarWhereWithAggregatesInput[]
    OR?: projectsScalarWhereWithAggregatesInput[]
    NOT?: projectsScalarWhereWithAggregatesInput | projectsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"projects"> | number
    title?: StringWithAggregatesFilter<"projects"> | string
    description?: StringNullableWithAggregatesFilter<"projects"> | string | null
    start_date?: DateTimeNullableWithAggregatesFilter<"projects"> | Date | string | null
    end_date?: DateTimeNullableWithAggregatesFilter<"projects"> | Date | string | null
    cv_id?: IntWithAggregatesFilter<"projects"> | number
  }

  export type questionsWhereInput = {
    AND?: questionsWhereInput | questionsWhereInput[]
    OR?: questionsWhereInput[]
    NOT?: questionsWhereInput | questionsWhereInput[]
    id?: IntFilter<"questions"> | number
    question?: StringFilter<"questions"> | string
    answers?: AnswersListRelationFilter
    personalityTestResults?: PersonalityTestResultsListRelationFilter
  }

  export type questionsOrderByWithRelationInput = {
    id?: SortOrder
    question?: SortOrder
    answers?: answersOrderByRelationAggregateInput
    personalityTestResults?: personalityTestResultsOrderByRelationAggregateInput
  }

  export type questionsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    question?: string
    AND?: questionsWhereInput | questionsWhereInput[]
    OR?: questionsWhereInput[]
    NOT?: questionsWhereInput | questionsWhereInput[]
    answers?: AnswersListRelationFilter
    personalityTestResults?: PersonalityTestResultsListRelationFilter
  }, "id" | "question">

  export type questionsOrderByWithAggregationInput = {
    id?: SortOrder
    question?: SortOrder
    _count?: questionsCountOrderByAggregateInput
    _avg?: questionsAvgOrderByAggregateInput
    _max?: questionsMaxOrderByAggregateInput
    _min?: questionsMinOrderByAggregateInput
    _sum?: questionsSumOrderByAggregateInput
  }

  export type questionsScalarWhereWithAggregatesInput = {
    AND?: questionsScalarWhereWithAggregatesInput | questionsScalarWhereWithAggregatesInput[]
    OR?: questionsScalarWhereWithAggregatesInput[]
    NOT?: questionsScalarWhereWithAggregatesInput | questionsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"questions"> | number
    question?: StringWithAggregatesFilter<"questions"> | string
  }

  export type referencesWhereInput = {
    AND?: referencesWhereInput | referencesWhereInput[]
    OR?: referencesWhereInput[]
    NOT?: referencesWhereInput | referencesWhereInput[]
    id?: IntFilter<"references"> | number
    name?: StringFilter<"references"> | string
    phone?: StringNullableFilter<"references"> | string | null
    email?: StringNullableFilter<"references"> | string | null
    cv_id?: IntFilter<"references"> | number
    cvs?: XOR<CvsScalarRelationFilter, cvsWhereInput>
  }

  export type referencesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    cv_id?: SortOrder
    cvs?: cvsOrderByWithRelationInput
  }

  export type referencesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: referencesWhereInput | referencesWhereInput[]
    OR?: referencesWhereInput[]
    NOT?: referencesWhereInput | referencesWhereInput[]
    name?: StringFilter<"references"> | string
    phone?: StringNullableFilter<"references"> | string | null
    email?: StringNullableFilter<"references"> | string | null
    cv_id?: IntFilter<"references"> | number
    cvs?: XOR<CvsScalarRelationFilter, cvsWhereInput>
  }, "id">

  export type referencesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    cv_id?: SortOrder
    _count?: referencesCountOrderByAggregateInput
    _avg?: referencesAvgOrderByAggregateInput
    _max?: referencesMaxOrderByAggregateInput
    _min?: referencesMinOrderByAggregateInput
    _sum?: referencesSumOrderByAggregateInput
  }

  export type referencesScalarWhereWithAggregatesInput = {
    AND?: referencesScalarWhereWithAggregatesInput | referencesScalarWhereWithAggregatesInput[]
    OR?: referencesScalarWhereWithAggregatesInput[]
    NOT?: referencesScalarWhereWithAggregatesInput | referencesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"references"> | number
    name?: StringWithAggregatesFilter<"references"> | string
    phone?: StringNullableWithAggregatesFilter<"references"> | string | null
    email?: StringNullableWithAggregatesFilter<"references"> | string | null
    cv_id?: IntWithAggregatesFilter<"references"> | number
  }

  export type rolesWhereInput = {
    AND?: rolesWhereInput | rolesWhereInput[]
    OR?: rolesWhereInput[]
    NOT?: rolesWhereInput | rolesWhereInput[]
    id?: IntFilter<"roles"> | number
    role_name?: StringFilter<"roles"> | string
    users?: UsersListRelationFilter
  }

  export type rolesOrderByWithRelationInput = {
    id?: SortOrder
    role_name?: SortOrder
    users?: usersOrderByRelationAggregateInput
  }

  export type rolesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    role_name?: string
    AND?: rolesWhereInput | rolesWhereInput[]
    OR?: rolesWhereInput[]
    NOT?: rolesWhereInput | rolesWhereInput[]
    users?: UsersListRelationFilter
  }, "id" | "role_name">

  export type rolesOrderByWithAggregationInput = {
    id?: SortOrder
    role_name?: SortOrder
    _count?: rolesCountOrderByAggregateInput
    _avg?: rolesAvgOrderByAggregateInput
    _max?: rolesMaxOrderByAggregateInput
    _min?: rolesMinOrderByAggregateInput
    _sum?: rolesSumOrderByAggregateInput
  }

  export type rolesScalarWhereWithAggregatesInput = {
    AND?: rolesScalarWhereWithAggregatesInput | rolesScalarWhereWithAggregatesInput[]
    OR?: rolesScalarWhereWithAggregatesInput[]
    NOT?: rolesScalarWhereWithAggregatesInput | rolesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"roles"> | number
    role_name?: StringWithAggregatesFilter<"roles"> | string
  }

  export type savedJobsWhereInput = {
    AND?: savedJobsWhereInput | savedJobsWhereInput[]
    OR?: savedJobsWhereInput[]
    NOT?: savedJobsWhereInput | savedJobsWhereInput[]
    user_id?: StringFilter<"savedJobs"> | string
    job_id?: StringFilter<"savedJobs"> | string
    saved_at?: DateTimeFilter<"savedJobs"> | Date | string
    jobs?: XOR<JobsScalarRelationFilter, jobsWhereInput>
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type savedJobsOrderByWithRelationInput = {
    user_id?: SortOrder
    job_id?: SortOrder
    saved_at?: SortOrder
    jobs?: jobsOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
  }

  export type savedJobsWhereUniqueInput = Prisma.AtLeast<{
    user_id_job_id?: savedJobsUser_idJob_idCompoundUniqueInput
    AND?: savedJobsWhereInput | savedJobsWhereInput[]
    OR?: savedJobsWhereInput[]
    NOT?: savedJobsWhereInput | savedJobsWhereInput[]
    user_id?: StringFilter<"savedJobs"> | string
    job_id?: StringFilter<"savedJobs"> | string
    saved_at?: DateTimeFilter<"savedJobs"> | Date | string
    jobs?: XOR<JobsScalarRelationFilter, jobsWhereInput>
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "user_id_job_id">

  export type savedJobsOrderByWithAggregationInput = {
    user_id?: SortOrder
    job_id?: SortOrder
    saved_at?: SortOrder
    _count?: savedJobsCountOrderByAggregateInput
    _max?: savedJobsMaxOrderByAggregateInput
    _min?: savedJobsMinOrderByAggregateInput
  }

  export type savedJobsScalarWhereWithAggregatesInput = {
    AND?: savedJobsScalarWhereWithAggregatesInput | savedJobsScalarWhereWithAggregatesInput[]
    OR?: savedJobsScalarWhereWithAggregatesInput[]
    NOT?: savedJobsScalarWhereWithAggregatesInput | savedJobsScalarWhereWithAggregatesInput[]
    user_id?: StringWithAggregatesFilter<"savedJobs"> | string
    job_id?: StringWithAggregatesFilter<"savedJobs"> | string
    saved_at?: DateTimeWithAggregatesFilter<"savedJobs"> | Date | string
  }

  export type subscriptionsWhereInput = {
    AND?: subscriptionsWhereInput | subscriptionsWhereInput[]
    OR?: subscriptionsWhereInput[]
    NOT?: subscriptionsWhereInput | subscriptionsWhereInput[]
    id?: StringFilter<"subscriptions"> | string
    start_date?: DateTimeFilter<"subscriptions"> | Date | string
    end_date?: DateTimeFilter<"subscriptions"> | Date | string
    amount_paid?: BigIntFilter<"subscriptions"> | bigint | number
    is_extended?: BoolFilter<"subscriptions"> | boolean
    status?: EnumSubscriptionStatusFilter<"subscriptions"> | $Enums.SubscriptionStatus
    user_id?: StringFilter<"subscriptions"> | string
    plan_id?: IntFilter<"subscriptions"> | number
    payment_id?: StringFilter<"subscriptions"> | string
    payments?: XOR<PaymentsScalarRelationFilter, paymentsWhereInput>
    membershipPlans?: XOR<MembershipPlansScalarRelationFilter, membershipPlansWhereInput>
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type subscriptionsOrderByWithRelationInput = {
    id?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    amount_paid?: SortOrder
    is_extended?: SortOrder
    status?: SortOrder
    user_id?: SortOrder
    plan_id?: SortOrder
    payment_id?: SortOrder
    payments?: paymentsOrderByWithRelationInput
    membershipPlans?: membershipPlansOrderByWithRelationInput
    users?: usersOrderByWithRelationInput
  }

  export type subscriptionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    payment_id?: string
    AND?: subscriptionsWhereInput | subscriptionsWhereInput[]
    OR?: subscriptionsWhereInput[]
    NOT?: subscriptionsWhereInput | subscriptionsWhereInput[]
    start_date?: DateTimeFilter<"subscriptions"> | Date | string
    end_date?: DateTimeFilter<"subscriptions"> | Date | string
    amount_paid?: BigIntFilter<"subscriptions"> | bigint | number
    is_extended?: BoolFilter<"subscriptions"> | boolean
    status?: EnumSubscriptionStatusFilter<"subscriptions"> | $Enums.SubscriptionStatus
    user_id?: StringFilter<"subscriptions"> | string
    plan_id?: IntFilter<"subscriptions"> | number
    payments?: XOR<PaymentsScalarRelationFilter, paymentsWhereInput>
    membershipPlans?: XOR<MembershipPlansScalarRelationFilter, membershipPlansWhereInput>
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id" | "payment_id">

  export type subscriptionsOrderByWithAggregationInput = {
    id?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    amount_paid?: SortOrder
    is_extended?: SortOrder
    status?: SortOrder
    user_id?: SortOrder
    plan_id?: SortOrder
    payment_id?: SortOrder
    _count?: subscriptionsCountOrderByAggregateInput
    _avg?: subscriptionsAvgOrderByAggregateInput
    _max?: subscriptionsMaxOrderByAggregateInput
    _min?: subscriptionsMinOrderByAggregateInput
    _sum?: subscriptionsSumOrderByAggregateInput
  }

  export type subscriptionsScalarWhereWithAggregatesInput = {
    AND?: subscriptionsScalarWhereWithAggregatesInput | subscriptionsScalarWhereWithAggregatesInput[]
    OR?: subscriptionsScalarWhereWithAggregatesInput[]
    NOT?: subscriptionsScalarWhereWithAggregatesInput | subscriptionsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"subscriptions"> | string
    start_date?: DateTimeWithAggregatesFilter<"subscriptions"> | Date | string
    end_date?: DateTimeWithAggregatesFilter<"subscriptions"> | Date | string
    amount_paid?: BigIntWithAggregatesFilter<"subscriptions"> | bigint | number
    is_extended?: BoolWithAggregatesFilter<"subscriptions"> | boolean
    status?: EnumSubscriptionStatusWithAggregatesFilter<"subscriptions"> | $Enums.SubscriptionStatus
    user_id?: StringWithAggregatesFilter<"subscriptions"> | string
    plan_id?: IntWithAggregatesFilter<"subscriptions"> | number
    payment_id?: StringWithAggregatesFilter<"subscriptions"> | string
  }

  export type userActivitiesHistoryWhereInput = {
    AND?: userActivitiesHistoryWhereInput | userActivitiesHistoryWhereInput[]
    OR?: userActivitiesHistoryWhereInput[]
    NOT?: userActivitiesHistoryWhereInput | userActivitiesHistoryWhereInput[]
    id?: IntFilter<"userActivitiesHistory"> | number
    activity_name?: StringFilter<"userActivitiesHistory"> | string
    time?: DateTimeFilter<"userActivitiesHistory"> | Date | string
    user_id?: StringFilter<"userActivitiesHistory"> | string
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type userActivitiesHistoryOrderByWithRelationInput = {
    id?: SortOrder
    activity_name?: SortOrder
    time?: SortOrder
    user_id?: SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type userActivitiesHistoryWhereUniqueInput = Prisma.AtLeast<{
    id_user_id?: userActivitiesHistoryIdUser_idCompoundUniqueInput
    AND?: userActivitiesHistoryWhereInput | userActivitiesHistoryWhereInput[]
    OR?: userActivitiesHistoryWhereInput[]
    NOT?: userActivitiesHistoryWhereInput | userActivitiesHistoryWhereInput[]
    id?: IntFilter<"userActivitiesHistory"> | number
    activity_name?: StringFilter<"userActivitiesHistory"> | string
    time?: DateTimeFilter<"userActivitiesHistory"> | Date | string
    user_id?: StringFilter<"userActivitiesHistory"> | string
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id_user_id">

  export type userActivitiesHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    activity_name?: SortOrder
    time?: SortOrder
    user_id?: SortOrder
    _count?: userActivitiesHistoryCountOrderByAggregateInput
    _avg?: userActivitiesHistoryAvgOrderByAggregateInput
    _max?: userActivitiesHistoryMaxOrderByAggregateInput
    _min?: userActivitiesHistoryMinOrderByAggregateInput
    _sum?: userActivitiesHistorySumOrderByAggregateInput
  }

  export type userActivitiesHistoryScalarWhereWithAggregatesInput = {
    AND?: userActivitiesHistoryScalarWhereWithAggregatesInput | userActivitiesHistoryScalarWhereWithAggregatesInput[]
    OR?: userActivitiesHistoryScalarWhereWithAggregatesInput[]
    NOT?: userActivitiesHistoryScalarWhereWithAggregatesInput | userActivitiesHistoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"userActivitiesHistory"> | number
    activity_name?: StringWithAggregatesFilter<"userActivitiesHistory"> | string
    time?: DateTimeWithAggregatesFilter<"userActivitiesHistory"> | Date | string
    user_id?: StringWithAggregatesFilter<"userActivitiesHistory"> | string
  }

  export type userNotificationsWhereInput = {
    AND?: userNotificationsWhereInput | userNotificationsWhereInput[]
    OR?: userNotificationsWhereInput[]
    NOT?: userNotificationsWhereInput | userNotificationsWhereInput[]
    id?: IntFilter<"userNotifications"> | number
    user_id?: StringFilter<"userNotifications"> | string
    title?: StringFilter<"userNotifications"> | string
    content?: StringNullableFilter<"userNotifications"> | string | null
    type?: EnumNotificationsTypeFilter<"userNotifications"> | $Enums.NotificationsType
    is_read?: BoolFilter<"userNotifications"> | boolean
    sent_at?: DateTimeFilter<"userNotifications"> | Date | string
    read_at?: DateTimeNullableFilter<"userNotifications"> | Date | string | null
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }

  export type userNotificationsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    content?: SortOrderInput | SortOrder
    type?: SortOrder
    is_read?: SortOrder
    sent_at?: SortOrder
    read_at?: SortOrderInput | SortOrder
    users?: usersOrderByWithRelationInput
  }

  export type userNotificationsWhereUniqueInput = Prisma.AtLeast<{
    id_user_id?: userNotificationsIdUser_idCompoundUniqueInput
    AND?: userNotificationsWhereInput | userNotificationsWhereInput[]
    OR?: userNotificationsWhereInput[]
    NOT?: userNotificationsWhereInput | userNotificationsWhereInput[]
    id?: IntFilter<"userNotifications"> | number
    user_id?: StringFilter<"userNotifications"> | string
    title?: StringFilter<"userNotifications"> | string
    content?: StringNullableFilter<"userNotifications"> | string | null
    type?: EnumNotificationsTypeFilter<"userNotifications"> | $Enums.NotificationsType
    is_read?: BoolFilter<"userNotifications"> | boolean
    sent_at?: DateTimeFilter<"userNotifications"> | Date | string
    read_at?: DateTimeNullableFilter<"userNotifications"> | Date | string | null
    users?: XOR<UsersScalarRelationFilter, usersWhereInput>
  }, "id_user_id">

  export type userNotificationsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    content?: SortOrderInput | SortOrder
    type?: SortOrder
    is_read?: SortOrder
    sent_at?: SortOrder
    read_at?: SortOrderInput | SortOrder
    _count?: userNotificationsCountOrderByAggregateInput
    _avg?: userNotificationsAvgOrderByAggregateInput
    _max?: userNotificationsMaxOrderByAggregateInput
    _min?: userNotificationsMinOrderByAggregateInput
    _sum?: userNotificationsSumOrderByAggregateInput
  }

  export type userNotificationsScalarWhereWithAggregatesInput = {
    AND?: userNotificationsScalarWhereWithAggregatesInput | userNotificationsScalarWhereWithAggregatesInput[]
    OR?: userNotificationsScalarWhereWithAggregatesInput[]
    NOT?: userNotificationsScalarWhereWithAggregatesInput | userNotificationsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"userNotifications"> | number
    user_id?: StringWithAggregatesFilter<"userNotifications"> | string
    title?: StringWithAggregatesFilter<"userNotifications"> | string
    content?: StringNullableWithAggregatesFilter<"userNotifications"> | string | null
    type?: EnumNotificationsTypeWithAggregatesFilter<"userNotifications"> | $Enums.NotificationsType
    is_read?: BoolWithAggregatesFilter<"userNotifications"> | boolean
    sent_at?: DateTimeWithAggregatesFilter<"userNotifications"> | Date | string
    read_at?: DateTimeNullableWithAggregatesFilter<"userNotifications"> | Date | string | null
  }

  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    id?: StringFilter<"users"> | string
    username?: StringFilter<"users"> | string
    password?: StringFilter<"users"> | string
    avatar_url?: StringNullableFilter<"users"> | string | null
    email?: StringFilter<"users"> | string
    phone?: StringNullableFilter<"users"> | string | null
    address_street?: StringNullableFilter<"users"> | string | null
    address_ward?: StringNullableFilter<"users"> | string | null
    address_city?: StringNullableFilter<"users"> | string | null
    address_country?: StringNullableFilter<"users"> | string | null
    gender?: EnumGenderNullableFilter<"users"> | $Enums.Gender | null
    is_deleted?: BoolFilter<"users"> | boolean
    created_at?: DateTimeFilter<"users"> | Date | string
    updated_at?: DateTimeFilter<"users"> | Date | string
    role_id?: IntFilter<"users"> | number
    blogs?: BlogsListRelationFilter
    careerPaths?: CareerPathsListRelationFilter
    companies?: XOR<CompaniesNullableScalarRelationFilter, companiesWhereInput> | null
    feedbacks?: FeedbacksListRelationFilter
    followedCompanies?: FollowedCompaniesListRelationFilter
    messages?: MessagesListRelationFilter
    payments?: PaymentsListRelationFilter
    personalityTestResults?: PersonalityTestResultsListRelationFilter
    savedJobs?: SavedJobsListRelationFilter
    subscriptions?: SubscriptionsListRelationFilter
    userActivitiesHistory?: UserActivitiesHistoryListRelationFilter
    userNotifications?: UserNotificationsListRelationFilter
    roles?: XOR<RolesScalarRelationFilter, rolesWhereInput>
  }

  export type usersOrderByWithRelationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    avatar_url?: SortOrderInput | SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    address_street?: SortOrderInput | SortOrder
    address_ward?: SortOrderInput | SortOrder
    address_city?: SortOrderInput | SortOrder
    address_country?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    is_deleted?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    role_id?: SortOrder
    blogs?: blogsOrderByRelationAggregateInput
    careerPaths?: careerPathsOrderByRelationAggregateInput
    companies?: companiesOrderByWithRelationInput
    feedbacks?: feedbacksOrderByRelationAggregateInput
    followedCompanies?: followedCompaniesOrderByRelationAggregateInput
    messages?: messagesOrderByRelationAggregateInput
    payments?: paymentsOrderByRelationAggregateInput
    personalityTestResults?: personalityTestResultsOrderByRelationAggregateInput
    savedJobs?: savedJobsOrderByRelationAggregateInput
    subscriptions?: subscriptionsOrderByRelationAggregateInput
    userActivitiesHistory?: userActivitiesHistoryOrderByRelationAggregateInput
    userNotifications?: userNotificationsOrderByRelationAggregateInput
    roles?: rolesOrderByWithRelationInput
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    phone?: string
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    username?: StringFilter<"users"> | string
    password?: StringFilter<"users"> | string
    avatar_url?: StringNullableFilter<"users"> | string | null
    address_street?: StringNullableFilter<"users"> | string | null
    address_ward?: StringNullableFilter<"users"> | string | null
    address_city?: StringNullableFilter<"users"> | string | null
    address_country?: StringNullableFilter<"users"> | string | null
    gender?: EnumGenderNullableFilter<"users"> | $Enums.Gender | null
    is_deleted?: BoolFilter<"users"> | boolean
    created_at?: DateTimeFilter<"users"> | Date | string
    updated_at?: DateTimeFilter<"users"> | Date | string
    role_id?: IntFilter<"users"> | number
    blogs?: BlogsListRelationFilter
    careerPaths?: CareerPathsListRelationFilter
    companies?: XOR<CompaniesNullableScalarRelationFilter, companiesWhereInput> | null
    feedbacks?: FeedbacksListRelationFilter
    followedCompanies?: FollowedCompaniesListRelationFilter
    messages?: MessagesListRelationFilter
    payments?: PaymentsListRelationFilter
    personalityTestResults?: PersonalityTestResultsListRelationFilter
    savedJobs?: SavedJobsListRelationFilter
    subscriptions?: SubscriptionsListRelationFilter
    userActivitiesHistory?: UserActivitiesHistoryListRelationFilter
    userNotifications?: UserNotificationsListRelationFilter
    roles?: XOR<RolesScalarRelationFilter, rolesWhereInput>
  }, "id" | "email" | "phone">

  export type usersOrderByWithAggregationInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    avatar_url?: SortOrderInput | SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    address_street?: SortOrderInput | SortOrder
    address_ward?: SortOrderInput | SortOrder
    address_city?: SortOrderInput | SortOrder
    address_country?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    is_deleted?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    role_id?: SortOrder
    _count?: usersCountOrderByAggregateInput
    _avg?: usersAvgOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
    _sum?: usersSumOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    OR?: usersScalarWhereWithAggregatesInput[]
    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"users"> | string
    username?: StringWithAggregatesFilter<"users"> | string
    password?: StringWithAggregatesFilter<"users"> | string
    avatar_url?: StringNullableWithAggregatesFilter<"users"> | string | null
    email?: StringWithAggregatesFilter<"users"> | string
    phone?: StringNullableWithAggregatesFilter<"users"> | string | null
    address_street?: StringNullableWithAggregatesFilter<"users"> | string | null
    address_ward?: StringNullableWithAggregatesFilter<"users"> | string | null
    address_city?: StringNullableWithAggregatesFilter<"users"> | string | null
    address_country?: StringNullableWithAggregatesFilter<"users"> | string | null
    gender?: EnumGenderNullableWithAggregatesFilter<"users"> | $Enums.Gender | null
    is_deleted?: BoolWithAggregatesFilter<"users"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"users"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"users"> | Date | string
    role_id?: IntWithAggregatesFilter<"users"> | number
  }

  export type answersCreateInput = {
    answer: string
    questions: questionsCreateNestedOneWithoutAnswersInput
    personalityTestResults?: personalityTestResultsCreateNestedManyWithoutAnswersInput
  }

  export type answersUncheckedCreateInput = {
    id?: number
    answer: string
    question_id: number
    personalityTestResults?: personalityTestResultsUncheckedCreateNestedManyWithoutAnswersInput
  }

  export type answersUpdateInput = {
    answer?: StringFieldUpdateOperationsInput | string
    questions?: questionsUpdateOneRequiredWithoutAnswersNestedInput
    personalityTestResults?: personalityTestResultsUpdateManyWithoutAnswersNestedInput
  }

  export type answersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    answer?: StringFieldUpdateOperationsInput | string
    question_id?: IntFieldUpdateOperationsInput | number
    personalityTestResults?: personalityTestResultsUncheckedUpdateManyWithoutAnswersNestedInput
  }

  export type answersCreateManyInput = {
    id?: number
    answer: string
    question_id: number
  }

  export type answersUpdateManyMutationInput = {
    answer?: StringFieldUpdateOperationsInput | string
  }

  export type answersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    answer?: StringFieldUpdateOperationsInput | string
    question_id?: IntFieldUpdateOperationsInput | number
  }

  export type applicantsCreateInput = {
    description?: string | null
    apply_date?: Date | string
    verified_date: Date | string
    status?: $Enums.ApplicantsStatus
    feedback?: string | null
    cvs: cvsCreateNestedOneWithoutApplicantsInput
    jobs: jobsCreateNestedOneWithoutApplicantsInput
  }

  export type applicantsUncheckedCreateInput = {
    cv_id: number
    job_id: string
    description?: string | null
    apply_date?: Date | string
    verified_date: Date | string
    status?: $Enums.ApplicantsStatus
    feedback?: string | null
  }

  export type applicantsUpdateInput = {
    description?: NullableStringFieldUpdateOperationsInput | string | null
    apply_date?: DateTimeFieldUpdateOperationsInput | Date | string
    verified_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumApplicantsStatusFieldUpdateOperationsInput | $Enums.ApplicantsStatus
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    cvs?: cvsUpdateOneRequiredWithoutApplicantsNestedInput
    jobs?: jobsUpdateOneRequiredWithoutApplicantsNestedInput
  }

  export type applicantsUncheckedUpdateInput = {
    cv_id?: IntFieldUpdateOperationsInput | number
    job_id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    apply_date?: DateTimeFieldUpdateOperationsInput | Date | string
    verified_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumApplicantsStatusFieldUpdateOperationsInput | $Enums.ApplicantsStatus
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type applicantsCreateManyInput = {
    cv_id: number
    job_id: string
    description?: string | null
    apply_date?: Date | string
    verified_date: Date | string
    status?: $Enums.ApplicantsStatus
    feedback?: string | null
  }

  export type applicantsUpdateManyMutationInput = {
    description?: NullableStringFieldUpdateOperationsInput | string | null
    apply_date?: DateTimeFieldUpdateOperationsInput | Date | string
    verified_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumApplicantsStatusFieldUpdateOperationsInput | $Enums.ApplicantsStatus
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type applicantsUncheckedUpdateManyInput = {
    cv_id?: IntFieldUpdateOperationsInput | number
    job_id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    apply_date?: DateTimeFieldUpdateOperationsInput | Date | string
    verified_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumApplicantsStatusFieldUpdateOperationsInput | $Enums.ApplicantsStatus
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type awardsCreateInput = {
    title: string
    description?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    cvs: cvsCreateNestedOneWithoutAwardsInput
  }

  export type awardsUncheckedCreateInput = {
    id?: number
    title: string
    description?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    cv_id: number
  }

  export type awardsUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cvs?: cvsUpdateOneRequiredWithoutAwardsNestedInput
  }

  export type awardsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cv_id?: IntFieldUpdateOperationsInput | number
  }

  export type awardsCreateManyInput = {
    id?: number
    title: string
    description?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    cv_id: number
  }

  export type awardsUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type awardsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cv_id?: IntFieldUpdateOperationsInput | number
  }

  export type blogsCreateInput = {
    title: string
    cover_image_url: string
    description_url: string
    created_at?: Date | string
    updated_at: Date | string
    users: usersCreateNestedOneWithoutBlogsInput
  }

  export type blogsUncheckedCreateInput = {
    id?: number
    title: string
    cover_image_url: string
    description_url: string
    created_at?: Date | string
    updated_at: Date | string
    user_id: string
  }

  export type blogsUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    cover_image_url?: StringFieldUpdateOperationsInput | string
    description_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutBlogsNestedInput
  }

  export type blogsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    cover_image_url?: StringFieldUpdateOperationsInput | string
    description_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type blogsCreateManyInput = {
    id?: number
    title: string
    cover_image_url: string
    description_url: string
    created_at?: Date | string
    updated_at: Date | string
    user_id: string
  }

  export type blogsUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    cover_image_url?: StringFieldUpdateOperationsInput | string
    description_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type blogsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    cover_image_url?: StringFieldUpdateOperationsInput | string
    description_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type careerPathStepsCreateInput = {
    title: string
    description?: string | null
    resources?: string | null
    careerPaths: careerPathsCreateNestedOneWithoutCareerPathStepsInput
  }

  export type careerPathStepsUncheckedCreateInput = {
    id?: number
    title: string
    description?: string | null
    resources?: string | null
    career_id: number
  }

  export type careerPathStepsUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resources?: NullableStringFieldUpdateOperationsInput | string | null
    careerPaths?: careerPathsUpdateOneRequiredWithoutCareerPathStepsNestedInput
  }

  export type careerPathStepsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resources?: NullableStringFieldUpdateOperationsInput | string | null
    career_id?: IntFieldUpdateOperationsInput | number
  }

  export type careerPathStepsCreateManyInput = {
    id?: number
    title: string
    description?: string | null
    resources?: string | null
    career_id: number
  }

  export type careerPathStepsUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resources?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type careerPathStepsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resources?: NullableStringFieldUpdateOperationsInput | string | null
    career_id?: IntFieldUpdateOperationsInput | number
  }

  export type careerPathsCreateInput = {
    title: string
    description?: string | null
    resources?: string | null
    level?: string | null
    estimate_duration?: string | null
    careerPathSteps?: careerPathStepsCreateNestedManyWithoutCareerPathsInput
    jobSpecialized: jobSpecializedCreateNestedOneWithoutCareerPathsInput
    users: usersCreateNestedOneWithoutCareerPathsInput
  }

  export type careerPathsUncheckedCreateInput = {
    id?: number
    title: string
    description?: string | null
    resources?: string | null
    level?: string | null
    estimate_duration?: string | null
    user_id: string
    jobspecialized_id: number
    careerPathSteps?: careerPathStepsUncheckedCreateNestedManyWithoutCareerPathsInput
  }

  export type careerPathsUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resources?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    estimate_duration?: NullableStringFieldUpdateOperationsInput | string | null
    careerPathSteps?: careerPathStepsUpdateManyWithoutCareerPathsNestedInput
    jobSpecialized?: jobSpecializedUpdateOneRequiredWithoutCareerPathsNestedInput
    users?: usersUpdateOneRequiredWithoutCareerPathsNestedInput
  }

  export type careerPathsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resources?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    estimate_duration?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    jobspecialized_id?: IntFieldUpdateOperationsInput | number
    careerPathSteps?: careerPathStepsUncheckedUpdateManyWithoutCareerPathsNestedInput
  }

  export type careerPathsCreateManyInput = {
    id?: number
    title: string
    description?: string | null
    resources?: string | null
    level?: string | null
    estimate_duration?: string | null
    user_id: string
    jobspecialized_id: number
  }

  export type careerPathsUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resources?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    estimate_duration?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type careerPathsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resources?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    estimate_duration?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    jobspecialized_id?: IntFieldUpdateOperationsInput | number
  }

  export type categoriesCreateInput = {
    category_name: string
    jobs?: jobsCreateNestedManyWithoutCategoriesInput
  }

  export type categoriesUncheckedCreateInput = {
    id?: number
    category_name: string
    jobs?: jobsUncheckedCreateNestedManyWithoutCategoriesInput
  }

  export type categoriesUpdateInput = {
    category_name?: StringFieldUpdateOperationsInput | string
    jobs?: jobsUpdateManyWithoutCategoriesNestedInput
  }

  export type categoriesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    category_name?: StringFieldUpdateOperationsInput | string
    jobs?: jobsUncheckedUpdateManyWithoutCategoriesNestedInput
  }

  export type categoriesCreateManyInput = {
    id?: number
    category_name: string
  }

  export type categoriesUpdateManyMutationInput = {
    category_name?: StringFieldUpdateOperationsInput | string
  }

  export type categoriesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    category_name?: StringFieldUpdateOperationsInput | string
  }

  export type certificatesCreateInput = {
    title: string
    link?: string | null
    description?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    cvs: cvsCreateNestedOneWithoutCertificatesInput
  }

  export type certificatesUncheckedCreateInput = {
    id?: number
    title: string
    link?: string | null
    description?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    cv_id: number
  }

  export type certificatesUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cvs?: cvsUpdateOneRequiredWithoutCertificatesNestedInput
  }

  export type certificatesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cv_id?: IntFieldUpdateOperationsInput | number
  }

  export type certificatesCreateManyInput = {
    id?: number
    title: string
    link?: string | null
    description?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    cv_id: number
  }

  export type certificatesUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type certificatesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cv_id?: IntFieldUpdateOperationsInput | number
  }

  export type companiesCreateInput = {
    company_name: string
    company_website?: string | null
    address_street: string
    address_ward: string
    address_city: string
    address_country: string
    email: string
    phone: string
    business_certificate?: string | null
    company_type?: $Enums.Company_Type
    description?: string | null
    logo_url?: string | null
    background_url?: string | null
    employees?: number | null
    is_verified?: boolean
    fax_code?: string | null
    is_deleted?: boolean
    created_at?: Date | string
    updated_at: Date | string
    fields?: fieldsCreateNestedOneWithoutCompaniesInput
    users: usersCreateNestedOneWithoutCompaniesInput
    companyLabels?: companyLabelsCreateNestedOneWithoutCompaniesInput
    companyActivitiesHistory?: companyActivitiesHistoryCreateNestedManyWithoutCompaniesInput
    companyNotifications?: companyNotificationsCreateNestedManyWithoutCompaniesInput
    feedbacks?: feedbacksCreateNestedManyWithoutCompaniesInput
    followedCompanies?: followedCompaniesCreateNestedManyWithoutCompaniesInput
  }

  export type companiesUncheckedCreateInput = {
    id: string
    company_name: string
    company_website?: string | null
    address_street: string
    address_ward: string
    address_city: string
    address_country: string
    email: string
    phone: string
    business_certificate?: string | null
    company_type?: $Enums.Company_Type
    description?: string | null
    logo_url?: string | null
    background_url?: string | null
    employees?: number | null
    is_verified?: boolean
    fax_code?: string | null
    is_deleted?: boolean
    created_at?: Date | string
    updated_at: Date | string
    field_id?: number | null
    label_id?: number | null
    companyActivitiesHistory?: companyActivitiesHistoryUncheckedCreateNestedManyWithoutCompaniesInput
    companyNotifications?: companyNotificationsUncheckedCreateNestedManyWithoutCompaniesInput
    feedbacks?: feedbacksUncheckedCreateNestedManyWithoutCompaniesInput
    followedCompanies?: followedCompaniesUncheckedCreateNestedManyWithoutCompaniesInput
  }

  export type companiesUpdateInput = {
    company_name?: StringFieldUpdateOperationsInput | string
    company_website?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: StringFieldUpdateOperationsInput | string
    address_ward?: StringFieldUpdateOperationsInput | string
    address_city?: StringFieldUpdateOperationsInput | string
    address_country?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    business_certificate?: NullableStringFieldUpdateOperationsInput | string | null
    company_type?: EnumCompany_TypeFieldUpdateOperationsInput | $Enums.Company_Type
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    background_url?: NullableStringFieldUpdateOperationsInput | string | null
    employees?: NullableIntFieldUpdateOperationsInput | number | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    fax_code?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    fields?: fieldsUpdateOneWithoutCompaniesNestedInput
    users?: usersUpdateOneRequiredWithoutCompaniesNestedInput
    companyLabels?: companyLabelsUpdateOneWithoutCompaniesNestedInput
    companyActivitiesHistory?: companyActivitiesHistoryUpdateManyWithoutCompaniesNestedInput
    companyNotifications?: companyNotificationsUpdateManyWithoutCompaniesNestedInput
    feedbacks?: feedbacksUpdateManyWithoutCompaniesNestedInput
    followedCompanies?: followedCompaniesUpdateManyWithoutCompaniesNestedInput
  }

  export type companiesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    company_name?: StringFieldUpdateOperationsInput | string
    company_website?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: StringFieldUpdateOperationsInput | string
    address_ward?: StringFieldUpdateOperationsInput | string
    address_city?: StringFieldUpdateOperationsInput | string
    address_country?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    business_certificate?: NullableStringFieldUpdateOperationsInput | string | null
    company_type?: EnumCompany_TypeFieldUpdateOperationsInput | $Enums.Company_Type
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    background_url?: NullableStringFieldUpdateOperationsInput | string | null
    employees?: NullableIntFieldUpdateOperationsInput | number | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    fax_code?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    field_id?: NullableIntFieldUpdateOperationsInput | number | null
    label_id?: NullableIntFieldUpdateOperationsInput | number | null
    companyActivitiesHistory?: companyActivitiesHistoryUncheckedUpdateManyWithoutCompaniesNestedInput
    companyNotifications?: companyNotificationsUncheckedUpdateManyWithoutCompaniesNestedInput
    feedbacks?: feedbacksUncheckedUpdateManyWithoutCompaniesNestedInput
    followedCompanies?: followedCompaniesUncheckedUpdateManyWithoutCompaniesNestedInput
  }

  export type companiesCreateManyInput = {
    id: string
    company_name: string
    company_website?: string | null
    address_street: string
    address_ward: string
    address_city: string
    address_country: string
    email: string
    phone: string
    business_certificate?: string | null
    company_type?: $Enums.Company_Type
    description?: string | null
    logo_url?: string | null
    background_url?: string | null
    employees?: number | null
    is_verified?: boolean
    fax_code?: string | null
    is_deleted?: boolean
    created_at?: Date | string
    updated_at: Date | string
    field_id?: number | null
    label_id?: number | null
  }

  export type companiesUpdateManyMutationInput = {
    company_name?: StringFieldUpdateOperationsInput | string
    company_website?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: StringFieldUpdateOperationsInput | string
    address_ward?: StringFieldUpdateOperationsInput | string
    address_city?: StringFieldUpdateOperationsInput | string
    address_country?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    business_certificate?: NullableStringFieldUpdateOperationsInput | string | null
    company_type?: EnumCompany_TypeFieldUpdateOperationsInput | $Enums.Company_Type
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    background_url?: NullableStringFieldUpdateOperationsInput | string | null
    employees?: NullableIntFieldUpdateOperationsInput | number | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    fax_code?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type companiesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    company_name?: StringFieldUpdateOperationsInput | string
    company_website?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: StringFieldUpdateOperationsInput | string
    address_ward?: StringFieldUpdateOperationsInput | string
    address_city?: StringFieldUpdateOperationsInput | string
    address_country?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    business_certificate?: NullableStringFieldUpdateOperationsInput | string | null
    company_type?: EnumCompany_TypeFieldUpdateOperationsInput | $Enums.Company_Type
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    background_url?: NullableStringFieldUpdateOperationsInput | string | null
    employees?: NullableIntFieldUpdateOperationsInput | number | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    fax_code?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    field_id?: NullableIntFieldUpdateOperationsInput | number | null
    label_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type companyActivitiesHistoryCreateInput = {
    id?: number
    activity_name: string
    time?: Date | string
    companies: companiesCreateNestedOneWithoutCompanyActivitiesHistoryInput
  }

  export type companyActivitiesHistoryUncheckedCreateInput = {
    id?: number
    activity_name: string
    time?: Date | string
    company_id: string
  }

  export type companyActivitiesHistoryUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    activity_name?: StringFieldUpdateOperationsInput | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    companies?: companiesUpdateOneRequiredWithoutCompanyActivitiesHistoryNestedInput
  }

  export type companyActivitiesHistoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    activity_name?: StringFieldUpdateOperationsInput | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    company_id?: StringFieldUpdateOperationsInput | string
  }

  export type companyActivitiesHistoryCreateManyInput = {
    id?: number
    activity_name: string
    time?: Date | string
    company_id: string
  }

  export type companyActivitiesHistoryUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    activity_name?: StringFieldUpdateOperationsInput | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type companyActivitiesHistoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    activity_name?: StringFieldUpdateOperationsInput | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    company_id?: StringFieldUpdateOperationsInput | string
  }

  export type companyLabelsCreateInput = {
    label_name: string
    companies?: companiesCreateNestedManyWithoutCompanyLabelsInput
  }

  export type companyLabelsUncheckedCreateInput = {
    id?: number
    label_name: string
    companies?: companiesUncheckedCreateNestedManyWithoutCompanyLabelsInput
  }

  export type companyLabelsUpdateInput = {
    label_name?: StringFieldUpdateOperationsInput | string
    companies?: companiesUpdateManyWithoutCompanyLabelsNestedInput
  }

  export type companyLabelsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    label_name?: StringFieldUpdateOperationsInput | string
    companies?: companiesUncheckedUpdateManyWithoutCompanyLabelsNestedInput
  }

  export type companyLabelsCreateManyInput = {
    id?: number
    label_name: string
  }

  export type companyLabelsUpdateManyMutationInput = {
    label_name?: StringFieldUpdateOperationsInput | string
  }

  export type companyLabelsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    label_name?: StringFieldUpdateOperationsInput | string
  }

  export type companyNotificationsCreateInput = {
    id?: number
    title: string
    content?: string | null
    type?: $Enums.NotificationsType
    is_read?: boolean
    sent_at?: Date | string
    read_at?: Date | string | null
    companies: companiesCreateNestedOneWithoutCompanyNotificationsInput
  }

  export type companyNotificationsUncheckedCreateInput = {
    id?: number
    company_id: string
    title: string
    content?: string | null
    type?: $Enums.NotificationsType
    is_read?: boolean
    sent_at?: Date | string
    read_at?: Date | string | null
  }

  export type companyNotificationsUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationsTypeFieldUpdateOperationsInput | $Enums.NotificationsType
    is_read?: BoolFieldUpdateOperationsInput | boolean
    sent_at?: DateTimeFieldUpdateOperationsInput | Date | string
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companies?: companiesUpdateOneRequiredWithoutCompanyNotificationsNestedInput
  }

  export type companyNotificationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationsTypeFieldUpdateOperationsInput | $Enums.NotificationsType
    is_read?: BoolFieldUpdateOperationsInput | boolean
    sent_at?: DateTimeFieldUpdateOperationsInput | Date | string
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type companyNotificationsCreateManyInput = {
    id?: number
    company_id: string
    title: string
    content?: string | null
    type?: $Enums.NotificationsType
    is_read?: boolean
    sent_at?: Date | string
    read_at?: Date | string | null
  }

  export type companyNotificationsUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationsTypeFieldUpdateOperationsInput | $Enums.NotificationsType
    is_read?: BoolFieldUpdateOperationsInput | boolean
    sent_at?: DateTimeFieldUpdateOperationsInput | Date | string
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type companyNotificationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationsTypeFieldUpdateOperationsInput | $Enums.NotificationsType
    is_read?: BoolFieldUpdateOperationsInput | boolean
    sent_at?: DateTimeFieldUpdateOperationsInput | Date | string
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type cvsCreateInput = {
    fullname: string
    age?: number | null
    gender?: string | null
    address?: string | null
    email?: string | null
    introduction?: string | null
    soft_skills?: cvsCreatesoft_skillsInput | string[]
    primary_skills?: cvsCreateprimary_skillsInput | string[]
    phone?: string | null
    hobbies?: string | null
    others?: string | null
    applicants?: applicantsCreateNestedManyWithoutCvsInput
    awards?: awardsCreateNestedManyWithoutCvsInput
    certificates?: certificatesCreateNestedManyWithoutCvsInput
    educations?: educationsCreateNestedManyWithoutCvsInput
    experiences?: experiencesCreateNestedManyWithoutCvsInput
    projects?: projectsCreateNestedManyWithoutCvsInput
    references?: referencesCreateNestedManyWithoutCvsInput
  }

  export type cvsUncheckedCreateInput = {
    id?: number
    fullname: string
    age?: number | null
    gender?: string | null
    address?: string | null
    email?: string | null
    introduction?: string | null
    soft_skills?: cvsCreatesoft_skillsInput | string[]
    primary_skills?: cvsCreateprimary_skillsInput | string[]
    phone?: string | null
    hobbies?: string | null
    others?: string | null
    applicants?: applicantsUncheckedCreateNestedManyWithoutCvsInput
    awards?: awardsUncheckedCreateNestedManyWithoutCvsInput
    certificates?: certificatesUncheckedCreateNestedManyWithoutCvsInput
    educations?: educationsUncheckedCreateNestedManyWithoutCvsInput
    experiences?: experiencesUncheckedCreateNestedManyWithoutCvsInput
    projects?: projectsUncheckedCreateNestedManyWithoutCvsInput
    references?: referencesUncheckedCreateNestedManyWithoutCvsInput
  }

  export type cvsUpdateInput = {
    fullname?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    soft_skills?: cvsUpdatesoft_skillsInput | string[]
    primary_skills?: cvsUpdateprimary_skillsInput | string[]
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    hobbies?: NullableStringFieldUpdateOperationsInput | string | null
    others?: NullableStringFieldUpdateOperationsInput | string | null
    applicants?: applicantsUpdateManyWithoutCvsNestedInput
    awards?: awardsUpdateManyWithoutCvsNestedInput
    certificates?: certificatesUpdateManyWithoutCvsNestedInput
    educations?: educationsUpdateManyWithoutCvsNestedInput
    experiences?: experiencesUpdateManyWithoutCvsNestedInput
    projects?: projectsUpdateManyWithoutCvsNestedInput
    references?: referencesUpdateManyWithoutCvsNestedInput
  }

  export type cvsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullname?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    soft_skills?: cvsUpdatesoft_skillsInput | string[]
    primary_skills?: cvsUpdateprimary_skillsInput | string[]
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    hobbies?: NullableStringFieldUpdateOperationsInput | string | null
    others?: NullableStringFieldUpdateOperationsInput | string | null
    applicants?: applicantsUncheckedUpdateManyWithoutCvsNestedInput
    awards?: awardsUncheckedUpdateManyWithoutCvsNestedInput
    certificates?: certificatesUncheckedUpdateManyWithoutCvsNestedInput
    educations?: educationsUncheckedUpdateManyWithoutCvsNestedInput
    experiences?: experiencesUncheckedUpdateManyWithoutCvsNestedInput
    projects?: projectsUncheckedUpdateManyWithoutCvsNestedInput
    references?: referencesUncheckedUpdateManyWithoutCvsNestedInput
  }

  export type cvsCreateManyInput = {
    id?: number
    fullname: string
    age?: number | null
    gender?: string | null
    address?: string | null
    email?: string | null
    introduction?: string | null
    soft_skills?: cvsCreatesoft_skillsInput | string[]
    primary_skills?: cvsCreateprimary_skillsInput | string[]
    phone?: string | null
    hobbies?: string | null
    others?: string | null
  }

  export type cvsUpdateManyMutationInput = {
    fullname?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    soft_skills?: cvsUpdatesoft_skillsInput | string[]
    primary_skills?: cvsUpdateprimary_skillsInput | string[]
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    hobbies?: NullableStringFieldUpdateOperationsInput | string | null
    others?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type cvsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullname?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    soft_skills?: cvsUpdatesoft_skillsInput | string[]
    primary_skills?: cvsUpdateprimary_skillsInput | string[]
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    hobbies?: NullableStringFieldUpdateOperationsInput | string | null
    others?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type educationsCreateInput = {
    school: string
    graduated_type?: string | null
    gpa?: number | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    cvs: cvsCreateNestedOneWithoutEducationsInput
  }

  export type educationsUncheckedCreateInput = {
    id?: number
    school: string
    graduated_type?: string | null
    gpa?: number | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    cv_id: number
  }

  export type educationsUpdateInput = {
    school?: StringFieldUpdateOperationsInput | string
    graduated_type?: NullableStringFieldUpdateOperationsInput | string | null
    gpa?: NullableFloatFieldUpdateOperationsInput | number | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cvs?: cvsUpdateOneRequiredWithoutEducationsNestedInput
  }

  export type educationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    school?: StringFieldUpdateOperationsInput | string
    graduated_type?: NullableStringFieldUpdateOperationsInput | string | null
    gpa?: NullableFloatFieldUpdateOperationsInput | number | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cv_id?: IntFieldUpdateOperationsInput | number
  }

  export type educationsCreateManyInput = {
    id?: number
    school: string
    graduated_type?: string | null
    gpa?: number | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    cv_id: number
  }

  export type educationsUpdateManyMutationInput = {
    school?: StringFieldUpdateOperationsInput | string
    graduated_type?: NullableStringFieldUpdateOperationsInput | string | null
    gpa?: NullableFloatFieldUpdateOperationsInput | number | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type educationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    school?: StringFieldUpdateOperationsInput | string
    graduated_type?: NullableStringFieldUpdateOperationsInput | string | null
    gpa?: NullableFloatFieldUpdateOperationsInput | number | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cv_id?: IntFieldUpdateOperationsInput | number
  }

  export type experiencesCreateInput = {
    company_name?: string | null
    title?: string | null
    description?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    cvs: cvsCreateNestedOneWithoutExperiencesInput
  }

  export type experiencesUncheckedCreateInput = {
    id?: number
    company_name?: string | null
    title?: string | null
    description?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    cv_id: number
  }

  export type experiencesUpdateInput = {
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cvs?: cvsUpdateOneRequiredWithoutExperiencesNestedInput
  }

  export type experiencesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cv_id?: IntFieldUpdateOperationsInput | number
  }

  export type experiencesCreateManyInput = {
    id?: number
    company_name?: string | null
    title?: string | null
    description?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    cv_id: number
  }

  export type experiencesUpdateManyMutationInput = {
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type experiencesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cv_id?: IntFieldUpdateOperationsInput | number
  }

  export type featuresCreateInput = {
    feature_name: string
    description?: string | null
    membershipPlans?: membershipPlansCreateNestedOneWithoutFeaturesInput
  }

  export type featuresUncheckedCreateInput = {
    id?: number
    feature_name: string
    description?: string | null
    plan_id?: number | null
  }

  export type featuresUpdateInput = {
    feature_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    membershipPlans?: membershipPlansUpdateOneWithoutFeaturesNestedInput
  }

  export type featuresUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    feature_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    plan_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type featuresCreateManyInput = {
    id?: number
    feature_name: string
    description?: string | null
    plan_id?: number | null
  }

  export type featuresUpdateManyMutationInput = {
    feature_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type featuresUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    feature_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    plan_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type feedbacksCreateInput = {
    description: string
    stars: number
    work_environment?: string | null
    benefit?: string | null
    created_at?: Date | string
    companies: companiesCreateNestedOneWithoutFeedbacksInput
    users: usersCreateNestedOneWithoutFeedbacksInput
  }

  export type feedbacksUncheckedCreateInput = {
    user_id: string
    company_id: string
    description: string
    stars: number
    work_environment?: string | null
    benefit?: string | null
    created_at?: Date | string
  }

  export type feedbacksUpdateInput = {
    description?: StringFieldUpdateOperationsInput | string
    stars?: FloatFieldUpdateOperationsInput | number
    work_environment?: NullableStringFieldUpdateOperationsInput | string | null
    benefit?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    companies?: companiesUpdateOneRequiredWithoutFeedbacksNestedInput
    users?: usersUpdateOneRequiredWithoutFeedbacksNestedInput
  }

  export type feedbacksUncheckedUpdateInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    company_id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    stars?: FloatFieldUpdateOperationsInput | number
    work_environment?: NullableStringFieldUpdateOperationsInput | string | null
    benefit?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type feedbacksCreateManyInput = {
    user_id: string
    company_id: string
    description: string
    stars: number
    work_environment?: string | null
    benefit?: string | null
    created_at?: Date | string
  }

  export type feedbacksUpdateManyMutationInput = {
    description?: StringFieldUpdateOperationsInput | string
    stars?: FloatFieldUpdateOperationsInput | number
    work_environment?: NullableStringFieldUpdateOperationsInput | string | null
    benefit?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type feedbacksUncheckedUpdateManyInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    company_id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    stars?: FloatFieldUpdateOperationsInput | number
    work_environment?: NullableStringFieldUpdateOperationsInput | string | null
    benefit?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type fieldsCreateInput = {
    field_name: string
    companies?: companiesCreateNestedManyWithoutFieldsInput
  }

  export type fieldsUncheckedCreateInput = {
    id?: number
    field_name: string
    companies?: companiesUncheckedCreateNestedManyWithoutFieldsInput
  }

  export type fieldsUpdateInput = {
    field_name?: StringFieldUpdateOperationsInput | string
    companies?: companiesUpdateManyWithoutFieldsNestedInput
  }

  export type fieldsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    field_name?: StringFieldUpdateOperationsInput | string
    companies?: companiesUncheckedUpdateManyWithoutFieldsNestedInput
  }

  export type fieldsCreateManyInput = {
    id?: number
    field_name: string
  }

  export type fieldsUpdateManyMutationInput = {
    field_name?: StringFieldUpdateOperationsInput | string
  }

  export type fieldsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    field_name?: StringFieldUpdateOperationsInput | string
  }

  export type followedCompaniesCreateInput = {
    followed_at?: Date | string
    is_notified?: boolean
    companies: companiesCreateNestedOneWithoutFollowedCompaniesInput
    users: usersCreateNestedOneWithoutFollowedCompaniesInput
  }

  export type followedCompaniesUncheckedCreateInput = {
    user_id: string
    company_id: string
    followed_at?: Date | string
    is_notified?: boolean
  }

  export type followedCompaniesUpdateInput = {
    followed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_notified?: BoolFieldUpdateOperationsInput | boolean
    companies?: companiesUpdateOneRequiredWithoutFollowedCompaniesNestedInput
    users?: usersUpdateOneRequiredWithoutFollowedCompaniesNestedInput
  }

  export type followedCompaniesUncheckedUpdateInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    company_id?: StringFieldUpdateOperationsInput | string
    followed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_notified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type followedCompaniesCreateManyInput = {
    user_id: string
    company_id: string
    followed_at?: Date | string
    is_notified?: boolean
  }

  export type followedCompaniesUpdateManyMutationInput = {
    followed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_notified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type followedCompaniesUncheckedUpdateManyInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    company_id?: StringFieldUpdateOperationsInput | string
    followed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_notified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type jobCategoriesCreateInput = {
    job_category: string
    description?: string | null
    jobSpecialized?: jobSpecializedCreateNestedManyWithoutJobCategoriesInput
  }

  export type jobCategoriesUncheckedCreateInput = {
    id?: number
    job_category: string
    description?: string | null
    jobSpecialized?: jobSpecializedUncheckedCreateNestedManyWithoutJobCategoriesInput
  }

  export type jobCategoriesUpdateInput = {
    job_category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    jobSpecialized?: jobSpecializedUpdateManyWithoutJobCategoriesNestedInput
  }

  export type jobCategoriesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    job_category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    jobSpecialized?: jobSpecializedUncheckedUpdateManyWithoutJobCategoriesNestedInput
  }

  export type jobCategoriesCreateManyInput = {
    id?: number
    job_category: string
    description?: string | null
  }

  export type jobCategoriesUpdateManyMutationInput = {
    job_category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type jobCategoriesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    job_category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type jobLabelsCreateInput = {
    label_name: string
    jobs?: jobsCreateNestedManyWithoutJobLabelsInput
  }

  export type jobLabelsUncheckedCreateInput = {
    id?: number
    label_name: string
    jobs?: jobsUncheckedCreateNestedManyWithoutJobLabelsInput
  }

  export type jobLabelsUpdateInput = {
    label_name?: StringFieldUpdateOperationsInput | string
    jobs?: jobsUpdateManyWithoutJobLabelsNestedInput
  }

  export type jobLabelsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    label_name?: StringFieldUpdateOperationsInput | string
    jobs?: jobsUncheckedUpdateManyWithoutJobLabelsNestedInput
  }

  export type jobLabelsCreateManyInput = {
    id?: number
    label_name: string
  }

  export type jobLabelsUpdateManyMutationInput = {
    label_name?: StringFieldUpdateOperationsInput | string
  }

  export type jobLabelsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    label_name?: StringFieldUpdateOperationsInput | string
  }

  export type jobSpecializedCreateInput = {
    job_type: string
    description?: string | null
    careerPaths?: careerPathsCreateNestedOneWithoutJobSpecializedInput
    jobCategories: jobCategoriesCreateNestedOneWithoutJobSpecializedInput
  }

  export type jobSpecializedUncheckedCreateInput = {
    id?: number
    job_type: string
    description?: string | null
    jobcategory_id: number
    careerPaths?: careerPathsUncheckedCreateNestedOneWithoutJobSpecializedInput
  }

  export type jobSpecializedUpdateInput = {
    job_type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    careerPaths?: careerPathsUpdateOneWithoutJobSpecializedNestedInput
    jobCategories?: jobCategoriesUpdateOneRequiredWithoutJobSpecializedNestedInput
  }

  export type jobSpecializedUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    job_type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    jobcategory_id?: IntFieldUpdateOperationsInput | number
    careerPaths?: careerPathsUncheckedUpdateOneWithoutJobSpecializedNestedInput
  }

  export type jobSpecializedCreateManyInput = {
    id?: number
    job_type: string
    description?: string | null
    jobcategory_id: number
  }

  export type jobSpecializedUpdateManyMutationInput = {
    job_type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type jobSpecializedUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    job_type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    jobcategory_id?: IntFieldUpdateOperationsInput | number
  }

  export type jobsCreateInput = {
    id: string
    job_title: string
    description: string
    location?: string | null
    benefit?: string | null
    working_time?: string | null
    salary?: jobsCreatesalaryInput | string[]
    currency?: string | null
    job_type?: $Enums.Job_Type | null
    status?: $Enums.Job_Status | null
    job_level: string
    quantity?: number | null
    skill_tags?: jobsCreateskill_tagsInput | string[]
    education?: $Enums.Education | null
    experience?: string | null
    start_date?: Date | string
    end_date?: Date | string | null
    created_at?: Date | string
    updated_at: Date | string
    applicants?: applicantsCreateNestedManyWithoutJobsInput
    categories?: categoriesCreateNestedOneWithoutJobsInput
    jobLabels?: jobLabelsCreateNestedOneWithoutJobsInput
    savedJobs?: savedJobsCreateNestedManyWithoutJobsInput
  }

  export type jobsUncheckedCreateInput = {
    id: string
    job_title: string
    description: string
    location?: string | null
    benefit?: string | null
    working_time?: string | null
    salary?: jobsCreatesalaryInput | string[]
    currency?: string | null
    job_type?: $Enums.Job_Type | null
    status?: $Enums.Job_Status | null
    job_level: string
    quantity?: number | null
    skill_tags?: jobsCreateskill_tagsInput | string[]
    education?: $Enums.Education | null
    experience?: string | null
    start_date?: Date | string
    end_date?: Date | string | null
    created_at?: Date | string
    updated_at: Date | string
    category_id?: number | null
    label_id?: number | null
    applicants?: applicantsUncheckedCreateNestedManyWithoutJobsInput
    savedJobs?: savedJobsUncheckedCreateNestedManyWithoutJobsInput
  }

  export type jobsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    job_title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    benefit?: NullableStringFieldUpdateOperationsInput | string | null
    working_time?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: jobsUpdatesalaryInput | string[]
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    job_type?: NullableEnumJob_TypeFieldUpdateOperationsInput | $Enums.Job_Type | null
    status?: NullableEnumJob_StatusFieldUpdateOperationsInput | $Enums.Job_Status | null
    job_level?: StringFieldUpdateOperationsInput | string
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    skill_tags?: jobsUpdateskill_tagsInput | string[]
    education?: NullableEnumEducationFieldUpdateOperationsInput | $Enums.Education | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    applicants?: applicantsUpdateManyWithoutJobsNestedInput
    categories?: categoriesUpdateOneWithoutJobsNestedInput
    jobLabels?: jobLabelsUpdateOneWithoutJobsNestedInput
    savedJobs?: savedJobsUpdateManyWithoutJobsNestedInput
  }

  export type jobsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    job_title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    benefit?: NullableStringFieldUpdateOperationsInput | string | null
    working_time?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: jobsUpdatesalaryInput | string[]
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    job_type?: NullableEnumJob_TypeFieldUpdateOperationsInput | $Enums.Job_Type | null
    status?: NullableEnumJob_StatusFieldUpdateOperationsInput | $Enums.Job_Status | null
    job_level?: StringFieldUpdateOperationsInput | string
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    skill_tags?: jobsUpdateskill_tagsInput | string[]
    education?: NullableEnumEducationFieldUpdateOperationsInput | $Enums.Education | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    label_id?: NullableIntFieldUpdateOperationsInput | number | null
    applicants?: applicantsUncheckedUpdateManyWithoutJobsNestedInput
    savedJobs?: savedJobsUncheckedUpdateManyWithoutJobsNestedInput
  }

  export type jobsCreateManyInput = {
    id: string
    job_title: string
    description: string
    location?: string | null
    benefit?: string | null
    working_time?: string | null
    salary?: jobsCreatesalaryInput | string[]
    currency?: string | null
    job_type?: $Enums.Job_Type | null
    status?: $Enums.Job_Status | null
    job_level: string
    quantity?: number | null
    skill_tags?: jobsCreateskill_tagsInput | string[]
    education?: $Enums.Education | null
    experience?: string | null
    start_date?: Date | string
    end_date?: Date | string | null
    created_at?: Date | string
    updated_at: Date | string
    category_id?: number | null
    label_id?: number | null
  }

  export type jobsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    job_title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    benefit?: NullableStringFieldUpdateOperationsInput | string | null
    working_time?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: jobsUpdatesalaryInput | string[]
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    job_type?: NullableEnumJob_TypeFieldUpdateOperationsInput | $Enums.Job_Type | null
    status?: NullableEnumJob_StatusFieldUpdateOperationsInput | $Enums.Job_Status | null
    job_level?: StringFieldUpdateOperationsInput | string
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    skill_tags?: jobsUpdateskill_tagsInput | string[]
    education?: NullableEnumEducationFieldUpdateOperationsInput | $Enums.Education | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type jobsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    job_title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    benefit?: NullableStringFieldUpdateOperationsInput | string | null
    working_time?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: jobsUpdatesalaryInput | string[]
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    job_type?: NullableEnumJob_TypeFieldUpdateOperationsInput | $Enums.Job_Type | null
    status?: NullableEnumJob_StatusFieldUpdateOperationsInput | $Enums.Job_Status | null
    job_level?: StringFieldUpdateOperationsInput | string
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    skill_tags?: jobsUpdateskill_tagsInput | string[]
    education?: NullableEnumEducationFieldUpdateOperationsInput | $Enums.Education | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    label_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type membershipPlansCreateInput = {
    plan_name: string
    description?: string | null
    price: bigint | number
    duration_days: number
    is_active?: boolean
    created_at?: Date | string
    updated_at: Date | string
    features?: featuresCreateNestedManyWithoutMembershipPlansInput
    subscriptions?: subscriptionsCreateNestedManyWithoutMembershipPlansInput
  }

  export type membershipPlansUncheckedCreateInput = {
    id?: number
    plan_name: string
    description?: string | null
    price: bigint | number
    duration_days: number
    is_active?: boolean
    created_at?: Date | string
    updated_at: Date | string
    features?: featuresUncheckedCreateNestedManyWithoutMembershipPlansInput
    subscriptions?: subscriptionsUncheckedCreateNestedManyWithoutMembershipPlansInput
  }

  export type membershipPlansUpdateInput = {
    plan_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: BigIntFieldUpdateOperationsInput | bigint | number
    duration_days?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: featuresUpdateManyWithoutMembershipPlansNestedInput
    subscriptions?: subscriptionsUpdateManyWithoutMembershipPlansNestedInput
  }

  export type membershipPlansUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    plan_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: BigIntFieldUpdateOperationsInput | bigint | number
    duration_days?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: featuresUncheckedUpdateManyWithoutMembershipPlansNestedInput
    subscriptions?: subscriptionsUncheckedUpdateManyWithoutMembershipPlansNestedInput
  }

  export type membershipPlansCreateManyInput = {
    id?: number
    plan_name: string
    description?: string | null
    price: bigint | number
    duration_days: number
    is_active?: boolean
    created_at?: Date | string
    updated_at: Date | string
  }

  export type membershipPlansUpdateManyMutationInput = {
    plan_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: BigIntFieldUpdateOperationsInput | bigint | number
    duration_days?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type membershipPlansUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    plan_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: BigIntFieldUpdateOperationsInput | bigint | number
    duration_days?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type messagesCreateInput = {
    id?: number
    message_content?: string | null
    response_content?: string | null
    created_at?: Date | string
    users: usersCreateNestedOneWithoutMessagesInput
  }

  export type messagesUncheckedCreateInput = {
    id?: number
    message_content?: string | null
    response_content?: string | null
    created_at?: Date | string
    user_id: string
  }

  export type messagesUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    message_content?: NullableStringFieldUpdateOperationsInput | string | null
    response_content?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type messagesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    message_content?: NullableStringFieldUpdateOperationsInput | string | null
    response_content?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type messagesCreateManyInput = {
    id?: number
    message_content?: string | null
    response_content?: string | null
    created_at?: Date | string
    user_id: string
  }

  export type messagesUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    message_content?: NullableStringFieldUpdateOperationsInput | string | null
    response_content?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type messagesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    message_content?: NullableStringFieldUpdateOperationsInput | string | null
    response_content?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type paymentsCreateInput = {
    id: string
    amount: bigint | number
    currency?: string | null
    payment_gateway: $Enums.PaymentGateway
    payment_method: $Enums.PaymentMethod
    transaction_id?: string | null
    status: $Enums.PaymentStatus
    created_at?: Date | string
    users: usersCreateNestedOneWithoutPaymentsInput
    subscriptions?: subscriptionsCreateNestedOneWithoutPaymentsInput
  }

  export type paymentsUncheckedCreateInput = {
    id: string
    amount: bigint | number
    currency?: string | null
    payment_gateway: $Enums.PaymentGateway
    payment_method: $Enums.PaymentMethod
    transaction_id?: string | null
    status: $Enums.PaymentStatus
    created_at?: Date | string
    user_id: string
    subscriptions?: subscriptionsUncheckedCreateNestedOneWithoutPaymentsInput
  }

  export type paymentsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    payment_gateway?: EnumPaymentGatewayFieldUpdateOperationsInput | $Enums.PaymentGateway
    payment_method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutPaymentsNestedInput
    subscriptions?: subscriptionsUpdateOneWithoutPaymentsNestedInput
  }

  export type paymentsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    payment_gateway?: EnumPaymentGatewayFieldUpdateOperationsInput | $Enums.PaymentGateway
    payment_method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
    subscriptions?: subscriptionsUncheckedUpdateOneWithoutPaymentsNestedInput
  }

  export type paymentsCreateManyInput = {
    id: string
    amount: bigint | number
    currency?: string | null
    payment_gateway: $Enums.PaymentGateway
    payment_method: $Enums.PaymentMethod
    transaction_id?: string | null
    status: $Enums.PaymentStatus
    created_at?: Date | string
    user_id: string
  }

  export type paymentsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    payment_gateway?: EnumPaymentGatewayFieldUpdateOperationsInput | $Enums.PaymentGateway
    payment_method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type paymentsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    payment_gateway?: EnumPaymentGatewayFieldUpdateOperationsInput | $Enums.PaymentGateway
    payment_method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type personalityTestResultsCreateInput = {
    answers: answersCreateNestedOneWithoutPersonalityTestResultsInput
    questions: questionsCreateNestedOneWithoutPersonalityTestResultsInput
    users: usersCreateNestedOneWithoutPersonalityTestResultsInput
  }

  export type personalityTestResultsUncheckedCreateInput = {
    user_id: string
    question_id: number
    answer_id: number
  }

  export type personalityTestResultsUpdateInput = {
    answers?: answersUpdateOneRequiredWithoutPersonalityTestResultsNestedInput
    questions?: questionsUpdateOneRequiredWithoutPersonalityTestResultsNestedInput
    users?: usersUpdateOneRequiredWithoutPersonalityTestResultsNestedInput
  }

  export type personalityTestResultsUncheckedUpdateInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    question_id?: IntFieldUpdateOperationsInput | number
    answer_id?: IntFieldUpdateOperationsInput | number
  }

  export type personalityTestResultsCreateManyInput = {
    user_id: string
    question_id: number
    answer_id: number
  }

  export type personalityTestResultsUpdateManyMutationInput = {

  }

  export type personalityTestResultsUncheckedUpdateManyInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    question_id?: IntFieldUpdateOperationsInput | number
    answer_id?: IntFieldUpdateOperationsInput | number
  }

  export type projectsCreateInput = {
    title: string
    description?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    cvs: cvsCreateNestedOneWithoutProjectsInput
  }

  export type projectsUncheckedCreateInput = {
    id?: number
    title: string
    description?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    cv_id: number
  }

  export type projectsUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cvs?: cvsUpdateOneRequiredWithoutProjectsNestedInput
  }

  export type projectsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cv_id?: IntFieldUpdateOperationsInput | number
  }

  export type projectsCreateManyInput = {
    id?: number
    title: string
    description?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    cv_id: number
  }

  export type projectsUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type projectsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cv_id?: IntFieldUpdateOperationsInput | number
  }

  export type questionsCreateInput = {
    question: string
    answers?: answersCreateNestedManyWithoutQuestionsInput
    personalityTestResults?: personalityTestResultsCreateNestedManyWithoutQuestionsInput
  }

  export type questionsUncheckedCreateInput = {
    id?: number
    question: string
    answers?: answersUncheckedCreateNestedManyWithoutQuestionsInput
    personalityTestResults?: personalityTestResultsUncheckedCreateNestedManyWithoutQuestionsInput
  }

  export type questionsUpdateInput = {
    question?: StringFieldUpdateOperationsInput | string
    answers?: answersUpdateManyWithoutQuestionsNestedInput
    personalityTestResults?: personalityTestResultsUpdateManyWithoutQuestionsNestedInput
  }

  export type questionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    answers?: answersUncheckedUpdateManyWithoutQuestionsNestedInput
    personalityTestResults?: personalityTestResultsUncheckedUpdateManyWithoutQuestionsNestedInput
  }

  export type questionsCreateManyInput = {
    id?: number
    question: string
  }

  export type questionsUpdateManyMutationInput = {
    question?: StringFieldUpdateOperationsInput | string
  }

  export type questionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
  }

  export type referencesCreateInput = {
    name: string
    phone?: string | null
    email?: string | null
    cvs: cvsCreateNestedOneWithoutReferencesInput
  }

  export type referencesUncheckedCreateInput = {
    id?: number
    name: string
    phone?: string | null
    email?: string | null
    cv_id: number
  }

  export type referencesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    cvs?: cvsUpdateOneRequiredWithoutReferencesNestedInput
  }

  export type referencesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    cv_id?: IntFieldUpdateOperationsInput | number
  }

  export type referencesCreateManyInput = {
    id?: number
    name: string
    phone?: string | null
    email?: string | null
    cv_id: number
  }

  export type referencesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type referencesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    cv_id?: IntFieldUpdateOperationsInput | number
  }

  export type rolesCreateInput = {
    role_name: string
    users?: usersCreateNestedManyWithoutRolesInput
  }

  export type rolesUncheckedCreateInput = {
    id?: number
    role_name: string
    users?: usersUncheckedCreateNestedManyWithoutRolesInput
  }

  export type rolesUpdateInput = {
    role_name?: StringFieldUpdateOperationsInput | string
    users?: usersUpdateManyWithoutRolesNestedInput
  }

  export type rolesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    role_name?: StringFieldUpdateOperationsInput | string
    users?: usersUncheckedUpdateManyWithoutRolesNestedInput
  }

  export type rolesCreateManyInput = {
    id?: number
    role_name: string
  }

  export type rolesUpdateManyMutationInput = {
    role_name?: StringFieldUpdateOperationsInput | string
  }

  export type rolesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    role_name?: StringFieldUpdateOperationsInput | string
  }

  export type savedJobsCreateInput = {
    saved_at?: Date | string
    jobs: jobsCreateNestedOneWithoutSavedJobsInput
    users: usersCreateNestedOneWithoutSavedJobsInput
  }

  export type savedJobsUncheckedCreateInput = {
    user_id: string
    job_id: string
    saved_at?: Date | string
  }

  export type savedJobsUpdateInput = {
    saved_at?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: jobsUpdateOneRequiredWithoutSavedJobsNestedInput
    users?: usersUpdateOneRequiredWithoutSavedJobsNestedInput
  }

  export type savedJobsUncheckedUpdateInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    job_id?: StringFieldUpdateOperationsInput | string
    saved_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type savedJobsCreateManyInput = {
    user_id: string
    job_id: string
    saved_at?: Date | string
  }

  export type savedJobsUpdateManyMutationInput = {
    saved_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type savedJobsUncheckedUpdateManyInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    job_id?: StringFieldUpdateOperationsInput | string
    saved_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type subscriptionsCreateInput = {
    id: string
    start_date?: Date | string
    end_date: Date | string
    amount_paid: bigint | number
    is_extended?: boolean
    status?: $Enums.SubscriptionStatus
    payments: paymentsCreateNestedOneWithoutSubscriptionsInput
    membershipPlans: membershipPlansCreateNestedOneWithoutSubscriptionsInput
    users: usersCreateNestedOneWithoutSubscriptionsInput
  }

  export type subscriptionsUncheckedCreateInput = {
    id: string
    start_date?: Date | string
    end_date: Date | string
    amount_paid: bigint | number
    is_extended?: boolean
    status?: $Enums.SubscriptionStatus
    user_id: string
    plan_id: number
    payment_id: string
  }

  export type subscriptionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount_paid?: BigIntFieldUpdateOperationsInput | bigint | number
    is_extended?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    payments?: paymentsUpdateOneRequiredWithoutSubscriptionsNestedInput
    membershipPlans?: membershipPlansUpdateOneRequiredWithoutSubscriptionsNestedInput
    users?: usersUpdateOneRequiredWithoutSubscriptionsNestedInput
  }

  export type subscriptionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount_paid?: BigIntFieldUpdateOperationsInput | bigint | number
    is_extended?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    user_id?: StringFieldUpdateOperationsInput | string
    plan_id?: IntFieldUpdateOperationsInput | number
    payment_id?: StringFieldUpdateOperationsInput | string
  }

  export type subscriptionsCreateManyInput = {
    id: string
    start_date?: Date | string
    end_date: Date | string
    amount_paid: bigint | number
    is_extended?: boolean
    status?: $Enums.SubscriptionStatus
    user_id: string
    plan_id: number
    payment_id: string
  }

  export type subscriptionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount_paid?: BigIntFieldUpdateOperationsInput | bigint | number
    is_extended?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
  }

  export type subscriptionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount_paid?: BigIntFieldUpdateOperationsInput | bigint | number
    is_extended?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    user_id?: StringFieldUpdateOperationsInput | string
    plan_id?: IntFieldUpdateOperationsInput | number
    payment_id?: StringFieldUpdateOperationsInput | string
  }

  export type userActivitiesHistoryCreateInput = {
    id?: number
    activity_name: string
    time?: Date | string
    users: usersCreateNestedOneWithoutUserActivitiesHistoryInput
  }

  export type userActivitiesHistoryUncheckedCreateInput = {
    id?: number
    activity_name: string
    time?: Date | string
    user_id: string
  }

  export type userActivitiesHistoryUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    activity_name?: StringFieldUpdateOperationsInput | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutUserActivitiesHistoryNestedInput
  }

  export type userActivitiesHistoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    activity_name?: StringFieldUpdateOperationsInput | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type userActivitiesHistoryCreateManyInput = {
    id?: number
    activity_name: string
    time?: Date | string
    user_id: string
  }

  export type userActivitiesHistoryUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    activity_name?: StringFieldUpdateOperationsInput | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userActivitiesHistoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    activity_name?: StringFieldUpdateOperationsInput | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type userNotificationsCreateInput = {
    id?: number
    title: string
    content?: string | null
    type?: $Enums.NotificationsType
    is_read?: boolean
    sent_at?: Date | string
    read_at?: Date | string | null
    users: usersCreateNestedOneWithoutUserNotificationsInput
  }

  export type userNotificationsUncheckedCreateInput = {
    id?: number
    user_id: string
    title: string
    content?: string | null
    type?: $Enums.NotificationsType
    is_read?: boolean
    sent_at?: Date | string
    read_at?: Date | string | null
  }

  export type userNotificationsUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationsTypeFieldUpdateOperationsInput | $Enums.NotificationsType
    is_read?: BoolFieldUpdateOperationsInput | boolean
    sent_at?: DateTimeFieldUpdateOperationsInput | Date | string
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    users?: usersUpdateOneRequiredWithoutUserNotificationsNestedInput
  }

  export type userNotificationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationsTypeFieldUpdateOperationsInput | $Enums.NotificationsType
    is_read?: BoolFieldUpdateOperationsInput | boolean
    sent_at?: DateTimeFieldUpdateOperationsInput | Date | string
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userNotificationsCreateManyInput = {
    id?: number
    user_id: string
    title: string
    content?: string | null
    type?: $Enums.NotificationsType
    is_read?: boolean
    sent_at?: Date | string
    read_at?: Date | string | null
  }

  export type userNotificationsUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationsTypeFieldUpdateOperationsInput | $Enums.NotificationsType
    is_read?: BoolFieldUpdateOperationsInput | boolean
    sent_at?: DateTimeFieldUpdateOperationsInput | Date | string
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userNotificationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationsTypeFieldUpdateOperationsInput | $Enums.NotificationsType
    is_read?: BoolFieldUpdateOperationsInput | boolean
    sent_at?: DateTimeFieldUpdateOperationsInput | Date | string
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersCreateInput = {
    id: string
    username: string
    password: string
    avatar_url?: string | null
    email: string
    phone?: string | null
    address_street?: string | null
    address_ward?: string | null
    address_city?: string | null
    address_country?: string | null
    gender?: $Enums.Gender | null
    is_deleted?: boolean
    created_at?: Date | string
    updated_at: Date | string
    blogs?: blogsCreateNestedManyWithoutUsersInput
    careerPaths?: careerPathsCreateNestedManyWithoutUsersInput
    companies?: companiesCreateNestedOneWithoutUsersInput
    feedbacks?: feedbacksCreateNestedManyWithoutUsersInput
    followedCompanies?: followedCompaniesCreateNestedManyWithoutUsersInput
    messages?: messagesCreateNestedManyWithoutUsersInput
    payments?: paymentsCreateNestedManyWithoutUsersInput
    personalityTestResults?: personalityTestResultsCreateNestedManyWithoutUsersInput
    savedJobs?: savedJobsCreateNestedManyWithoutUsersInput
    subscriptions?: subscriptionsCreateNestedManyWithoutUsersInput
    userActivitiesHistory?: userActivitiesHistoryCreateNestedManyWithoutUsersInput
    userNotifications?: userNotificationsCreateNestedManyWithoutUsersInput
    roles: rolesCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateInput = {
    id: string
    username: string
    password: string
    avatar_url?: string | null
    email: string
    phone?: string | null
    address_street?: string | null
    address_ward?: string | null
    address_city?: string | null
    address_country?: string | null
    gender?: $Enums.Gender | null
    is_deleted?: boolean
    created_at?: Date | string
    updated_at: Date | string
    role_id: number
    blogs?: blogsUncheckedCreateNestedManyWithoutUsersInput
    careerPaths?: careerPathsUncheckedCreateNestedManyWithoutUsersInput
    companies?: companiesUncheckedCreateNestedOneWithoutUsersInput
    feedbacks?: feedbacksUncheckedCreateNestedManyWithoutUsersInput
    followedCompanies?: followedCompaniesUncheckedCreateNestedManyWithoutUsersInput
    messages?: messagesUncheckedCreateNestedManyWithoutUsersInput
    payments?: paymentsUncheckedCreateNestedManyWithoutUsersInput
    personalityTestResults?: personalityTestResultsUncheckedCreateNestedManyWithoutUsersInput
    savedJobs?: savedJobsUncheckedCreateNestedManyWithoutUsersInput
    subscriptions?: subscriptionsUncheckedCreateNestedManyWithoutUsersInput
    userActivitiesHistory?: userActivitiesHistoryUncheckedCreateNestedManyWithoutUsersInput
    userNotifications?: userNotificationsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: NullableStringFieldUpdateOperationsInput | string | null
    address_ward?: NullableStringFieldUpdateOperationsInput | string | null
    address_city?: NullableStringFieldUpdateOperationsInput | string | null
    address_country?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    blogs?: blogsUpdateManyWithoutUsersNestedInput
    careerPaths?: careerPathsUpdateManyWithoutUsersNestedInput
    companies?: companiesUpdateOneWithoutUsersNestedInput
    feedbacks?: feedbacksUpdateManyWithoutUsersNestedInput
    followedCompanies?: followedCompaniesUpdateManyWithoutUsersNestedInput
    messages?: messagesUpdateManyWithoutUsersNestedInput
    payments?: paymentsUpdateManyWithoutUsersNestedInput
    personalityTestResults?: personalityTestResultsUpdateManyWithoutUsersNestedInput
    savedJobs?: savedJobsUpdateManyWithoutUsersNestedInput
    subscriptions?: subscriptionsUpdateManyWithoutUsersNestedInput
    userActivitiesHistory?: userActivitiesHistoryUpdateManyWithoutUsersNestedInput
    userNotifications?: userNotificationsUpdateManyWithoutUsersNestedInput
    roles?: rolesUpdateOneRequiredWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: NullableStringFieldUpdateOperationsInput | string | null
    address_ward?: NullableStringFieldUpdateOperationsInput | string | null
    address_city?: NullableStringFieldUpdateOperationsInput | string | null
    address_country?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role_id?: IntFieldUpdateOperationsInput | number
    blogs?: blogsUncheckedUpdateManyWithoutUsersNestedInput
    careerPaths?: careerPathsUncheckedUpdateManyWithoutUsersNestedInput
    companies?: companiesUncheckedUpdateOneWithoutUsersNestedInput
    feedbacks?: feedbacksUncheckedUpdateManyWithoutUsersNestedInput
    followedCompanies?: followedCompaniesUncheckedUpdateManyWithoutUsersNestedInput
    messages?: messagesUncheckedUpdateManyWithoutUsersNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutUsersNestedInput
    personalityTestResults?: personalityTestResultsUncheckedUpdateManyWithoutUsersNestedInput
    savedJobs?: savedJobsUncheckedUpdateManyWithoutUsersNestedInput
    subscriptions?: subscriptionsUncheckedUpdateManyWithoutUsersNestedInput
    userActivitiesHistory?: userActivitiesHistoryUncheckedUpdateManyWithoutUsersNestedInput
    userNotifications?: userNotificationsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersCreateManyInput = {
    id: string
    username: string
    password: string
    avatar_url?: string | null
    email: string
    phone?: string | null
    address_street?: string | null
    address_ward?: string | null
    address_city?: string | null
    address_country?: string | null
    gender?: $Enums.Gender | null
    is_deleted?: boolean
    created_at?: Date | string
    updated_at: Date | string
    role_id: number
  }

  export type usersUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: NullableStringFieldUpdateOperationsInput | string | null
    address_ward?: NullableStringFieldUpdateOperationsInput | string | null
    address_city?: NullableStringFieldUpdateOperationsInput | string | null
    address_country?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: NullableStringFieldUpdateOperationsInput | string | null
    address_ward?: NullableStringFieldUpdateOperationsInput | string | null
    address_city?: NullableStringFieldUpdateOperationsInput | string | null
    address_country?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role_id?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type QuestionsScalarRelationFilter = {
    is?: questionsWhereInput
    isNot?: questionsWhereInput
  }

  export type PersonalityTestResultsListRelationFilter = {
    every?: personalityTestResultsWhereInput
    some?: personalityTestResultsWhereInput
    none?: personalityTestResultsWhereInput
  }

  export type personalityTestResultsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type answersCountOrderByAggregateInput = {
    id?: SortOrder
    answer?: SortOrder
    question_id?: SortOrder
  }

  export type answersAvgOrderByAggregateInput = {
    id?: SortOrder
    question_id?: SortOrder
  }

  export type answersMaxOrderByAggregateInput = {
    id?: SortOrder
    answer?: SortOrder
    question_id?: SortOrder
  }

  export type answersMinOrderByAggregateInput = {
    id?: SortOrder
    answer?: SortOrder
    question_id?: SortOrder
  }

  export type answersSumOrderByAggregateInput = {
    id?: SortOrder
    question_id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type EnumApplicantsStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicantsStatus | EnumApplicantsStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicantsStatus[] | ListEnumApplicantsStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicantsStatus[] | ListEnumApplicantsStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicantsStatusFilter<$PrismaModel> | $Enums.ApplicantsStatus
  }

  export type CvsScalarRelationFilter = {
    is?: cvsWhereInput
    isNot?: cvsWhereInput
  }

  export type JobsScalarRelationFilter = {
    is?: jobsWhereInput
    isNot?: jobsWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type applicantsCv_idJob_idCompoundUniqueInput = {
    cv_id: number
    job_id: string
  }

  export type applicantsCountOrderByAggregateInput = {
    cv_id?: SortOrder
    job_id?: SortOrder
    description?: SortOrder
    apply_date?: SortOrder
    verified_date?: SortOrder
    status?: SortOrder
    feedback?: SortOrder
  }

  export type applicantsAvgOrderByAggregateInput = {
    cv_id?: SortOrder
  }

  export type applicantsMaxOrderByAggregateInput = {
    cv_id?: SortOrder
    job_id?: SortOrder
    description?: SortOrder
    apply_date?: SortOrder
    verified_date?: SortOrder
    status?: SortOrder
    feedback?: SortOrder
  }

  export type applicantsMinOrderByAggregateInput = {
    cv_id?: SortOrder
    job_id?: SortOrder
    description?: SortOrder
    apply_date?: SortOrder
    verified_date?: SortOrder
    status?: SortOrder
    feedback?: SortOrder
  }

  export type applicantsSumOrderByAggregateInput = {
    cv_id?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumApplicantsStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicantsStatus | EnumApplicantsStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicantsStatus[] | ListEnumApplicantsStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicantsStatus[] | ListEnumApplicantsStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicantsStatusWithAggregatesFilter<$PrismaModel> | $Enums.ApplicantsStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApplicantsStatusFilter<$PrismaModel>
    _max?: NestedEnumApplicantsStatusFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type awardsCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    cv_id?: SortOrder
  }

  export type awardsAvgOrderByAggregateInput = {
    id?: SortOrder
    cv_id?: SortOrder
  }

  export type awardsMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    cv_id?: SortOrder
  }

  export type awardsMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    cv_id?: SortOrder
  }

  export type awardsSumOrderByAggregateInput = {
    id?: SortOrder
    cv_id?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type UsersScalarRelationFilter = {
    is?: usersWhereInput
    isNot?: usersWhereInput
  }

  export type blogsCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    cover_image_url?: SortOrder
    description_url?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user_id?: SortOrder
  }

  export type blogsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type blogsMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    cover_image_url?: SortOrder
    description_url?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user_id?: SortOrder
  }

  export type blogsMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    cover_image_url?: SortOrder
    description_url?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    user_id?: SortOrder
  }

  export type blogsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CareerPathsScalarRelationFilter = {
    is?: careerPathsWhereInput
    isNot?: careerPathsWhereInput
  }

  export type careerPathStepsCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    resources?: SortOrder
    career_id?: SortOrder
  }

  export type careerPathStepsAvgOrderByAggregateInput = {
    id?: SortOrder
    career_id?: SortOrder
  }

  export type careerPathStepsMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    resources?: SortOrder
    career_id?: SortOrder
  }

  export type careerPathStepsMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    resources?: SortOrder
    career_id?: SortOrder
  }

  export type careerPathStepsSumOrderByAggregateInput = {
    id?: SortOrder
    career_id?: SortOrder
  }

  export type CareerPathStepsListRelationFilter = {
    every?: careerPathStepsWhereInput
    some?: careerPathStepsWhereInput
    none?: careerPathStepsWhereInput
  }

  export type JobSpecializedScalarRelationFilter = {
    is?: jobSpecializedWhereInput
    isNot?: jobSpecializedWhereInput
  }

  export type careerPathStepsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type careerPathsCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    resources?: SortOrder
    level?: SortOrder
    estimate_duration?: SortOrder
    user_id?: SortOrder
    jobspecialized_id?: SortOrder
  }

  export type careerPathsAvgOrderByAggregateInput = {
    id?: SortOrder
    jobspecialized_id?: SortOrder
  }

  export type careerPathsMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    resources?: SortOrder
    level?: SortOrder
    estimate_duration?: SortOrder
    user_id?: SortOrder
    jobspecialized_id?: SortOrder
  }

  export type careerPathsMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    resources?: SortOrder
    level?: SortOrder
    estimate_duration?: SortOrder
    user_id?: SortOrder
    jobspecialized_id?: SortOrder
  }

  export type careerPathsSumOrderByAggregateInput = {
    id?: SortOrder
    jobspecialized_id?: SortOrder
  }

  export type JobsListRelationFilter = {
    every?: jobsWhereInput
    some?: jobsWhereInput
    none?: jobsWhereInput
  }

  export type jobsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type categoriesCountOrderByAggregateInput = {
    id?: SortOrder
    category_name?: SortOrder
  }

  export type categoriesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type categoriesMaxOrderByAggregateInput = {
    id?: SortOrder
    category_name?: SortOrder
  }

  export type categoriesMinOrderByAggregateInput = {
    id?: SortOrder
    category_name?: SortOrder
  }

  export type categoriesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type certificatesCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    link?: SortOrder
    description?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    cv_id?: SortOrder
  }

  export type certificatesAvgOrderByAggregateInput = {
    id?: SortOrder
    cv_id?: SortOrder
  }

  export type certificatesMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    link?: SortOrder
    description?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    cv_id?: SortOrder
  }

  export type certificatesMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    link?: SortOrder
    description?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    cv_id?: SortOrder
  }

  export type certificatesSumOrderByAggregateInput = {
    id?: SortOrder
    cv_id?: SortOrder
  }

  export type EnumCompany_TypeFilter<$PrismaModel = never> = {
    equals?: $Enums.Company_Type | EnumCompany_TypeFieldRefInput<$PrismaModel>
    in?: $Enums.Company_Type[] | ListEnumCompany_TypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.Company_Type[] | ListEnumCompany_TypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCompany_TypeFilter<$PrismaModel> | $Enums.Company_Type
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type FieldsNullableScalarRelationFilter = {
    is?: fieldsWhereInput | null
    isNot?: fieldsWhereInput | null
  }

  export type CompanyLabelsNullableScalarRelationFilter = {
    is?: companyLabelsWhereInput | null
    isNot?: companyLabelsWhereInput | null
  }

  export type CompanyActivitiesHistoryListRelationFilter = {
    every?: companyActivitiesHistoryWhereInput
    some?: companyActivitiesHistoryWhereInput
    none?: companyActivitiesHistoryWhereInput
  }

  export type CompanyNotificationsListRelationFilter = {
    every?: companyNotificationsWhereInput
    some?: companyNotificationsWhereInput
    none?: companyNotificationsWhereInput
  }

  export type FeedbacksListRelationFilter = {
    every?: feedbacksWhereInput
    some?: feedbacksWhereInput
    none?: feedbacksWhereInput
  }

  export type FollowedCompaniesListRelationFilter = {
    every?: followedCompaniesWhereInput
    some?: followedCompaniesWhereInput
    none?: followedCompaniesWhereInput
  }

  export type companyActivitiesHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type companyNotificationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type feedbacksOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type followedCompaniesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type companiesCountOrderByAggregateInput = {
    id?: SortOrder
    company_name?: SortOrder
    company_website?: SortOrder
    address_street?: SortOrder
    address_ward?: SortOrder
    address_city?: SortOrder
    address_country?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    business_certificate?: SortOrder
    company_type?: SortOrder
    description?: SortOrder
    logo_url?: SortOrder
    background_url?: SortOrder
    employees?: SortOrder
    is_verified?: SortOrder
    fax_code?: SortOrder
    is_deleted?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    field_id?: SortOrder
    label_id?: SortOrder
  }

  export type companiesAvgOrderByAggregateInput = {
    employees?: SortOrder
    field_id?: SortOrder
    label_id?: SortOrder
  }

  export type companiesMaxOrderByAggregateInput = {
    id?: SortOrder
    company_name?: SortOrder
    company_website?: SortOrder
    address_street?: SortOrder
    address_ward?: SortOrder
    address_city?: SortOrder
    address_country?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    business_certificate?: SortOrder
    company_type?: SortOrder
    description?: SortOrder
    logo_url?: SortOrder
    background_url?: SortOrder
    employees?: SortOrder
    is_verified?: SortOrder
    fax_code?: SortOrder
    is_deleted?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    field_id?: SortOrder
    label_id?: SortOrder
  }

  export type companiesMinOrderByAggregateInput = {
    id?: SortOrder
    company_name?: SortOrder
    company_website?: SortOrder
    address_street?: SortOrder
    address_ward?: SortOrder
    address_city?: SortOrder
    address_country?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    business_certificate?: SortOrder
    company_type?: SortOrder
    description?: SortOrder
    logo_url?: SortOrder
    background_url?: SortOrder
    employees?: SortOrder
    is_verified?: SortOrder
    fax_code?: SortOrder
    is_deleted?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    field_id?: SortOrder
    label_id?: SortOrder
  }

  export type companiesSumOrderByAggregateInput = {
    employees?: SortOrder
    field_id?: SortOrder
    label_id?: SortOrder
  }

  export type EnumCompany_TypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Company_Type | EnumCompany_TypeFieldRefInput<$PrismaModel>
    in?: $Enums.Company_Type[] | ListEnumCompany_TypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.Company_Type[] | ListEnumCompany_TypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCompany_TypeWithAggregatesFilter<$PrismaModel> | $Enums.Company_Type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCompany_TypeFilter<$PrismaModel>
    _max?: NestedEnumCompany_TypeFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type CompaniesScalarRelationFilter = {
    is?: companiesWhereInput
    isNot?: companiesWhereInput
  }

  export type companyActivitiesHistoryIdCompany_idCompoundUniqueInput = {
    id: number
    company_id: string
  }

  export type companyActivitiesHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    activity_name?: SortOrder
    time?: SortOrder
    company_id?: SortOrder
  }

  export type companyActivitiesHistoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type companyActivitiesHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    activity_name?: SortOrder
    time?: SortOrder
    company_id?: SortOrder
  }

  export type companyActivitiesHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    activity_name?: SortOrder
    time?: SortOrder
    company_id?: SortOrder
  }

  export type companyActivitiesHistorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CompaniesListRelationFilter = {
    every?: companiesWhereInput
    some?: companiesWhereInput
    none?: companiesWhereInput
  }

  export type companiesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type companyLabelsCountOrderByAggregateInput = {
    id?: SortOrder
    label_name?: SortOrder
  }

  export type companyLabelsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type companyLabelsMaxOrderByAggregateInput = {
    id?: SortOrder
    label_name?: SortOrder
  }

  export type companyLabelsMinOrderByAggregateInput = {
    id?: SortOrder
    label_name?: SortOrder
  }

  export type companyLabelsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumNotificationsTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationsType | EnumNotificationsTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationsType[] | ListEnumNotificationsTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationsType[] | ListEnumNotificationsTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationsTypeFilter<$PrismaModel> | $Enums.NotificationsType
  }

  export type companyNotificationsIdCompany_idCompoundUniqueInput = {
    id: number
    company_id: string
  }

  export type companyNotificationsCountOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    is_read?: SortOrder
    sent_at?: SortOrder
    read_at?: SortOrder
  }

  export type companyNotificationsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type companyNotificationsMaxOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    is_read?: SortOrder
    sent_at?: SortOrder
    read_at?: SortOrder
  }

  export type companyNotificationsMinOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    is_read?: SortOrder
    sent_at?: SortOrder
    read_at?: SortOrder
  }

  export type companyNotificationsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumNotificationsTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationsType | EnumNotificationsTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationsType[] | ListEnumNotificationsTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationsType[] | ListEnumNotificationsTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationsTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationsType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationsTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationsTypeFilter<$PrismaModel>
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type ApplicantsListRelationFilter = {
    every?: applicantsWhereInput
    some?: applicantsWhereInput
    none?: applicantsWhereInput
  }

  export type AwardsListRelationFilter = {
    every?: awardsWhereInput
    some?: awardsWhereInput
    none?: awardsWhereInput
  }

  export type CertificatesListRelationFilter = {
    every?: certificatesWhereInput
    some?: certificatesWhereInput
    none?: certificatesWhereInput
  }

  export type EducationsListRelationFilter = {
    every?: educationsWhereInput
    some?: educationsWhereInput
    none?: educationsWhereInput
  }

  export type ExperiencesListRelationFilter = {
    every?: experiencesWhereInput
    some?: experiencesWhereInput
    none?: experiencesWhereInput
  }

  export type ProjectsListRelationFilter = {
    every?: projectsWhereInput
    some?: projectsWhereInput
    none?: projectsWhereInput
  }

  export type ReferencesListRelationFilter = {
    every?: referencesWhereInput
    some?: referencesWhereInput
    none?: referencesWhereInput
  }

  export type applicantsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type awardsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type certificatesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type educationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type experiencesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type projectsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type referencesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type cvsCountOrderByAggregateInput = {
    id?: SortOrder
    fullname?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    address?: SortOrder
    email?: SortOrder
    introduction?: SortOrder
    soft_skills?: SortOrder
    primary_skills?: SortOrder
    phone?: SortOrder
    hobbies?: SortOrder
    others?: SortOrder
  }

  export type cvsAvgOrderByAggregateInput = {
    id?: SortOrder
    age?: SortOrder
  }

  export type cvsMaxOrderByAggregateInput = {
    id?: SortOrder
    fullname?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    address?: SortOrder
    email?: SortOrder
    introduction?: SortOrder
    phone?: SortOrder
    hobbies?: SortOrder
    others?: SortOrder
  }

  export type cvsMinOrderByAggregateInput = {
    id?: SortOrder
    fullname?: SortOrder
    age?: SortOrder
    gender?: SortOrder
    address?: SortOrder
    email?: SortOrder
    introduction?: SortOrder
    phone?: SortOrder
    hobbies?: SortOrder
    others?: SortOrder
  }

  export type cvsSumOrderByAggregateInput = {
    id?: SortOrder
    age?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type educationsCountOrderByAggregateInput = {
    id?: SortOrder
    school?: SortOrder
    graduated_type?: SortOrder
    gpa?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    cv_id?: SortOrder
  }

  export type educationsAvgOrderByAggregateInput = {
    id?: SortOrder
    gpa?: SortOrder
    cv_id?: SortOrder
  }

  export type educationsMaxOrderByAggregateInput = {
    id?: SortOrder
    school?: SortOrder
    graduated_type?: SortOrder
    gpa?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    cv_id?: SortOrder
  }

  export type educationsMinOrderByAggregateInput = {
    id?: SortOrder
    school?: SortOrder
    graduated_type?: SortOrder
    gpa?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    cv_id?: SortOrder
  }

  export type educationsSumOrderByAggregateInput = {
    id?: SortOrder
    gpa?: SortOrder
    cv_id?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type experiencesCountOrderByAggregateInput = {
    id?: SortOrder
    company_name?: SortOrder
    title?: SortOrder
    description?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    cv_id?: SortOrder
  }

  export type experiencesAvgOrderByAggregateInput = {
    id?: SortOrder
    cv_id?: SortOrder
  }

  export type experiencesMaxOrderByAggregateInput = {
    id?: SortOrder
    company_name?: SortOrder
    title?: SortOrder
    description?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    cv_id?: SortOrder
  }

  export type experiencesMinOrderByAggregateInput = {
    id?: SortOrder
    company_name?: SortOrder
    title?: SortOrder
    description?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    cv_id?: SortOrder
  }

  export type experiencesSumOrderByAggregateInput = {
    id?: SortOrder
    cv_id?: SortOrder
  }

  export type MembershipPlansNullableScalarRelationFilter = {
    is?: membershipPlansWhereInput | null
    isNot?: membershipPlansWhereInput | null
  }

  export type featuresCountOrderByAggregateInput = {
    id?: SortOrder
    feature_name?: SortOrder
    description?: SortOrder
    plan_id?: SortOrder
  }

  export type featuresAvgOrderByAggregateInput = {
    id?: SortOrder
    plan_id?: SortOrder
  }

  export type featuresMaxOrderByAggregateInput = {
    id?: SortOrder
    feature_name?: SortOrder
    description?: SortOrder
    plan_id?: SortOrder
  }

  export type featuresMinOrderByAggregateInput = {
    id?: SortOrder
    feature_name?: SortOrder
    description?: SortOrder
    plan_id?: SortOrder
  }

  export type featuresSumOrderByAggregateInput = {
    id?: SortOrder
    plan_id?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type feedbacksUser_idCompany_idCompoundUniqueInput = {
    user_id: string
    company_id: string
  }

  export type feedbacksCountOrderByAggregateInput = {
    user_id?: SortOrder
    company_id?: SortOrder
    description?: SortOrder
    stars?: SortOrder
    work_environment?: SortOrder
    benefit?: SortOrder
    created_at?: SortOrder
  }

  export type feedbacksAvgOrderByAggregateInput = {
    stars?: SortOrder
  }

  export type feedbacksMaxOrderByAggregateInput = {
    user_id?: SortOrder
    company_id?: SortOrder
    description?: SortOrder
    stars?: SortOrder
    work_environment?: SortOrder
    benefit?: SortOrder
    created_at?: SortOrder
  }

  export type feedbacksMinOrderByAggregateInput = {
    user_id?: SortOrder
    company_id?: SortOrder
    description?: SortOrder
    stars?: SortOrder
    work_environment?: SortOrder
    benefit?: SortOrder
    created_at?: SortOrder
  }

  export type feedbacksSumOrderByAggregateInput = {
    stars?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type fieldsCountOrderByAggregateInput = {
    id?: SortOrder
    field_name?: SortOrder
  }

  export type fieldsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type fieldsMaxOrderByAggregateInput = {
    id?: SortOrder
    field_name?: SortOrder
  }

  export type fieldsMinOrderByAggregateInput = {
    id?: SortOrder
    field_name?: SortOrder
  }

  export type fieldsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type followedCompaniesUser_idCompany_idCompoundUniqueInput = {
    user_id: string
    company_id: string
  }

  export type followedCompaniesCountOrderByAggregateInput = {
    user_id?: SortOrder
    company_id?: SortOrder
    followed_at?: SortOrder
    is_notified?: SortOrder
  }

  export type followedCompaniesMaxOrderByAggregateInput = {
    user_id?: SortOrder
    company_id?: SortOrder
    followed_at?: SortOrder
    is_notified?: SortOrder
  }

  export type followedCompaniesMinOrderByAggregateInput = {
    user_id?: SortOrder
    company_id?: SortOrder
    followed_at?: SortOrder
    is_notified?: SortOrder
  }

  export type JobSpecializedListRelationFilter = {
    every?: jobSpecializedWhereInput
    some?: jobSpecializedWhereInput
    none?: jobSpecializedWhereInput
  }

  export type jobSpecializedOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type jobCategoriesCountOrderByAggregateInput = {
    id?: SortOrder
    job_category?: SortOrder
    description?: SortOrder
  }

  export type jobCategoriesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type jobCategoriesMaxOrderByAggregateInput = {
    id?: SortOrder
    job_category?: SortOrder
    description?: SortOrder
  }

  export type jobCategoriesMinOrderByAggregateInput = {
    id?: SortOrder
    job_category?: SortOrder
    description?: SortOrder
  }

  export type jobCategoriesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type jobLabelsCountOrderByAggregateInput = {
    id?: SortOrder
    label_name?: SortOrder
  }

  export type jobLabelsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type jobLabelsMaxOrderByAggregateInput = {
    id?: SortOrder
    label_name?: SortOrder
  }

  export type jobLabelsMinOrderByAggregateInput = {
    id?: SortOrder
    label_name?: SortOrder
  }

  export type jobLabelsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CareerPathsNullableScalarRelationFilter = {
    is?: careerPathsWhereInput | null
    isNot?: careerPathsWhereInput | null
  }

  export type JobCategoriesScalarRelationFilter = {
    is?: jobCategoriesWhereInput
    isNot?: jobCategoriesWhereInput
  }

  export type jobSpecializedCountOrderByAggregateInput = {
    id?: SortOrder
    job_type?: SortOrder
    description?: SortOrder
    jobcategory_id?: SortOrder
  }

  export type jobSpecializedAvgOrderByAggregateInput = {
    id?: SortOrder
    jobcategory_id?: SortOrder
  }

  export type jobSpecializedMaxOrderByAggregateInput = {
    id?: SortOrder
    job_type?: SortOrder
    description?: SortOrder
    jobcategory_id?: SortOrder
  }

  export type jobSpecializedMinOrderByAggregateInput = {
    id?: SortOrder
    job_type?: SortOrder
    description?: SortOrder
    jobcategory_id?: SortOrder
  }

  export type jobSpecializedSumOrderByAggregateInput = {
    id?: SortOrder
    jobcategory_id?: SortOrder
  }

  export type EnumJob_TypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Job_Type | EnumJob_TypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.Job_Type[] | ListEnumJob_TypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Job_Type[] | ListEnumJob_TypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumJob_TypeNullableFilter<$PrismaModel> | $Enums.Job_Type | null
  }

  export type EnumJob_StatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Job_Status | EnumJob_StatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.Job_Status[] | ListEnumJob_StatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Job_Status[] | ListEnumJob_StatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumJob_StatusNullableFilter<$PrismaModel> | $Enums.Job_Status | null
  }

  export type EnumEducationNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Education | EnumEducationFieldRefInput<$PrismaModel> | null
    in?: $Enums.Education[] | ListEnumEducationFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Education[] | ListEnumEducationFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEducationNullableFilter<$PrismaModel> | $Enums.Education | null
  }

  export type CategoriesNullableScalarRelationFilter = {
    is?: categoriesWhereInput | null
    isNot?: categoriesWhereInput | null
  }

  export type JobLabelsNullableScalarRelationFilter = {
    is?: jobLabelsWhereInput | null
    isNot?: jobLabelsWhereInput | null
  }

  export type SavedJobsListRelationFilter = {
    every?: savedJobsWhereInput
    some?: savedJobsWhereInput
    none?: savedJobsWhereInput
  }

  export type savedJobsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type jobsCountOrderByAggregateInput = {
    id?: SortOrder
    job_title?: SortOrder
    description?: SortOrder
    location?: SortOrder
    benefit?: SortOrder
    working_time?: SortOrder
    salary?: SortOrder
    currency?: SortOrder
    job_type?: SortOrder
    status?: SortOrder
    job_level?: SortOrder
    quantity?: SortOrder
    skill_tags?: SortOrder
    education?: SortOrder
    experience?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    category_id?: SortOrder
    label_id?: SortOrder
  }

  export type jobsAvgOrderByAggregateInput = {
    quantity?: SortOrder
    category_id?: SortOrder
    label_id?: SortOrder
  }

  export type jobsMaxOrderByAggregateInput = {
    id?: SortOrder
    job_title?: SortOrder
    description?: SortOrder
    location?: SortOrder
    benefit?: SortOrder
    working_time?: SortOrder
    currency?: SortOrder
    job_type?: SortOrder
    status?: SortOrder
    job_level?: SortOrder
    quantity?: SortOrder
    education?: SortOrder
    experience?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    category_id?: SortOrder
    label_id?: SortOrder
  }

  export type jobsMinOrderByAggregateInput = {
    id?: SortOrder
    job_title?: SortOrder
    description?: SortOrder
    location?: SortOrder
    benefit?: SortOrder
    working_time?: SortOrder
    currency?: SortOrder
    job_type?: SortOrder
    status?: SortOrder
    job_level?: SortOrder
    quantity?: SortOrder
    education?: SortOrder
    experience?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    category_id?: SortOrder
    label_id?: SortOrder
  }

  export type jobsSumOrderByAggregateInput = {
    quantity?: SortOrder
    category_id?: SortOrder
    label_id?: SortOrder
  }

  export type EnumJob_TypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Job_Type | EnumJob_TypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.Job_Type[] | ListEnumJob_TypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Job_Type[] | ListEnumJob_TypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumJob_TypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.Job_Type | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumJob_TypeNullableFilter<$PrismaModel>
    _max?: NestedEnumJob_TypeNullableFilter<$PrismaModel>
  }

  export type EnumJob_StatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Job_Status | EnumJob_StatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.Job_Status[] | ListEnumJob_StatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Job_Status[] | ListEnumJob_StatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumJob_StatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.Job_Status | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumJob_StatusNullableFilter<$PrismaModel>
    _max?: NestedEnumJob_StatusNullableFilter<$PrismaModel>
  }

  export type EnumEducationNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Education | EnumEducationFieldRefInput<$PrismaModel> | null
    in?: $Enums.Education[] | ListEnumEducationFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Education[] | ListEnumEducationFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEducationNullableWithAggregatesFilter<$PrismaModel> | $Enums.Education | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumEducationNullableFilter<$PrismaModel>
    _max?: NestedEnumEducationNullableFilter<$PrismaModel>
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type FeaturesListRelationFilter = {
    every?: featuresWhereInput
    some?: featuresWhereInput
    none?: featuresWhereInput
  }

  export type SubscriptionsListRelationFilter = {
    every?: subscriptionsWhereInput
    some?: subscriptionsWhereInput
    none?: subscriptionsWhereInput
  }

  export type featuresOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type subscriptionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type membershipPlansCountOrderByAggregateInput = {
    id?: SortOrder
    plan_name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    duration_days?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type membershipPlansAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    duration_days?: SortOrder
  }

  export type membershipPlansMaxOrderByAggregateInput = {
    id?: SortOrder
    plan_name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    duration_days?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type membershipPlansMinOrderByAggregateInput = {
    id?: SortOrder
    plan_name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    duration_days?: SortOrder
    is_active?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type membershipPlansSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    duration_days?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type messagesIdUser_idCompoundUniqueInput = {
    id: number
    user_id: string
  }

  export type messagesCountOrderByAggregateInput = {
    id?: SortOrder
    message_content?: SortOrder
    response_content?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
  }

  export type messagesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type messagesMaxOrderByAggregateInput = {
    id?: SortOrder
    message_content?: SortOrder
    response_content?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
  }

  export type messagesMinOrderByAggregateInput = {
    id?: SortOrder
    message_content?: SortOrder
    response_content?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
  }

  export type messagesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumPaymentGatewayFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentGateway | EnumPaymentGatewayFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentGateway[] | ListEnumPaymentGatewayFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentGateway[] | ListEnumPaymentGatewayFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentGatewayFilter<$PrismaModel> | $Enums.PaymentGateway
  }

  export type EnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type SubscriptionsNullableScalarRelationFilter = {
    is?: subscriptionsWhereInput | null
    isNot?: subscriptionsWhereInput | null
  }

  export type paymentsCountOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    payment_gateway?: SortOrder
    payment_method?: SortOrder
    transaction_id?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
  }

  export type paymentsAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type paymentsMaxOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    payment_gateway?: SortOrder
    payment_method?: SortOrder
    transaction_id?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
  }

  export type paymentsMinOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    payment_gateway?: SortOrder
    payment_method?: SortOrder
    transaction_id?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    user_id?: SortOrder
  }

  export type paymentsSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumPaymentGatewayWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentGateway | EnumPaymentGatewayFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentGateway[] | ListEnumPaymentGatewayFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentGateway[] | ListEnumPaymentGatewayFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentGatewayWithAggregatesFilter<$PrismaModel> | $Enums.PaymentGateway
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentGatewayFilter<$PrismaModel>
    _max?: NestedEnumPaymentGatewayFilter<$PrismaModel>
  }

  export type EnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type AnswersScalarRelationFilter = {
    is?: answersWhereInput
    isNot?: answersWhereInput
  }

  export type personalityTestResultsUser_idQuestion_idAnswer_idCompoundUniqueInput = {
    user_id: string
    question_id: number
    answer_id: number
  }

  export type personalityTestResultsCountOrderByAggregateInput = {
    user_id?: SortOrder
    question_id?: SortOrder
    answer_id?: SortOrder
  }

  export type personalityTestResultsAvgOrderByAggregateInput = {
    question_id?: SortOrder
    answer_id?: SortOrder
  }

  export type personalityTestResultsMaxOrderByAggregateInput = {
    user_id?: SortOrder
    question_id?: SortOrder
    answer_id?: SortOrder
  }

  export type personalityTestResultsMinOrderByAggregateInput = {
    user_id?: SortOrder
    question_id?: SortOrder
    answer_id?: SortOrder
  }

  export type personalityTestResultsSumOrderByAggregateInput = {
    question_id?: SortOrder
    answer_id?: SortOrder
  }

  export type projectsCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    cv_id?: SortOrder
  }

  export type projectsAvgOrderByAggregateInput = {
    id?: SortOrder
    cv_id?: SortOrder
  }

  export type projectsMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    cv_id?: SortOrder
  }

  export type projectsMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    cv_id?: SortOrder
  }

  export type projectsSumOrderByAggregateInput = {
    id?: SortOrder
    cv_id?: SortOrder
  }

  export type AnswersListRelationFilter = {
    every?: answersWhereInput
    some?: answersWhereInput
    none?: answersWhereInput
  }

  export type answersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type questionsCountOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
  }

  export type questionsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type questionsMaxOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
  }

  export type questionsMinOrderByAggregateInput = {
    id?: SortOrder
    question?: SortOrder
  }

  export type questionsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type referencesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    cv_id?: SortOrder
  }

  export type referencesAvgOrderByAggregateInput = {
    id?: SortOrder
    cv_id?: SortOrder
  }

  export type referencesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    cv_id?: SortOrder
  }

  export type referencesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    cv_id?: SortOrder
  }

  export type referencesSumOrderByAggregateInput = {
    id?: SortOrder
    cv_id?: SortOrder
  }

  export type UsersListRelationFilter = {
    every?: usersWhereInput
    some?: usersWhereInput
    none?: usersWhereInput
  }

  export type usersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type rolesCountOrderByAggregateInput = {
    id?: SortOrder
    role_name?: SortOrder
  }

  export type rolesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type rolesMaxOrderByAggregateInput = {
    id?: SortOrder
    role_name?: SortOrder
  }

  export type rolesMinOrderByAggregateInput = {
    id?: SortOrder
    role_name?: SortOrder
  }

  export type rolesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type savedJobsUser_idJob_idCompoundUniqueInput = {
    user_id: string
    job_id: string
  }

  export type savedJobsCountOrderByAggregateInput = {
    user_id?: SortOrder
    job_id?: SortOrder
    saved_at?: SortOrder
  }

  export type savedJobsMaxOrderByAggregateInput = {
    user_id?: SortOrder
    job_id?: SortOrder
    saved_at?: SortOrder
  }

  export type savedJobsMinOrderByAggregateInput = {
    user_id?: SortOrder
    job_id?: SortOrder
    saved_at?: SortOrder
  }

  export type EnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type PaymentsScalarRelationFilter = {
    is?: paymentsWhereInput
    isNot?: paymentsWhereInput
  }

  export type MembershipPlansScalarRelationFilter = {
    is?: membershipPlansWhereInput
    isNot?: membershipPlansWhereInput
  }

  export type subscriptionsCountOrderByAggregateInput = {
    id?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    amount_paid?: SortOrder
    is_extended?: SortOrder
    status?: SortOrder
    user_id?: SortOrder
    plan_id?: SortOrder
    payment_id?: SortOrder
  }

  export type subscriptionsAvgOrderByAggregateInput = {
    amount_paid?: SortOrder
    plan_id?: SortOrder
  }

  export type subscriptionsMaxOrderByAggregateInput = {
    id?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    amount_paid?: SortOrder
    is_extended?: SortOrder
    status?: SortOrder
    user_id?: SortOrder
    plan_id?: SortOrder
    payment_id?: SortOrder
  }

  export type subscriptionsMinOrderByAggregateInput = {
    id?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    amount_paid?: SortOrder
    is_extended?: SortOrder
    status?: SortOrder
    user_id?: SortOrder
    plan_id?: SortOrder
    payment_id?: SortOrder
  }

  export type subscriptionsSumOrderByAggregateInput = {
    amount_paid?: SortOrder
    plan_id?: SortOrder
  }

  export type EnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type userActivitiesHistoryIdUser_idCompoundUniqueInput = {
    id: number
    user_id: string
  }

  export type userActivitiesHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    activity_name?: SortOrder
    time?: SortOrder
    user_id?: SortOrder
  }

  export type userActivitiesHistoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type userActivitiesHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    activity_name?: SortOrder
    time?: SortOrder
    user_id?: SortOrder
  }

  export type userActivitiesHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    activity_name?: SortOrder
    time?: SortOrder
    user_id?: SortOrder
  }

  export type userActivitiesHistorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type userNotificationsIdUser_idCompoundUniqueInput = {
    id: number
    user_id: string
  }

  export type userNotificationsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    is_read?: SortOrder
    sent_at?: SortOrder
    read_at?: SortOrder
  }

  export type userNotificationsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type userNotificationsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    is_read?: SortOrder
    sent_at?: SortOrder
    read_at?: SortOrder
  }

  export type userNotificationsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    type?: SortOrder
    is_read?: SortOrder
    sent_at?: SortOrder
    read_at?: SortOrder
  }

  export type userNotificationsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumGenderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableFilter<$PrismaModel> | $Enums.Gender | null
  }

  export type BlogsListRelationFilter = {
    every?: blogsWhereInput
    some?: blogsWhereInput
    none?: blogsWhereInput
  }

  export type CareerPathsListRelationFilter = {
    every?: careerPathsWhereInput
    some?: careerPathsWhereInput
    none?: careerPathsWhereInput
  }

  export type CompaniesNullableScalarRelationFilter = {
    is?: companiesWhereInput | null
    isNot?: companiesWhereInput | null
  }

  export type MessagesListRelationFilter = {
    every?: messagesWhereInput
    some?: messagesWhereInput
    none?: messagesWhereInput
  }

  export type PaymentsListRelationFilter = {
    every?: paymentsWhereInput
    some?: paymentsWhereInput
    none?: paymentsWhereInput
  }

  export type UserActivitiesHistoryListRelationFilter = {
    every?: userActivitiesHistoryWhereInput
    some?: userActivitiesHistoryWhereInput
    none?: userActivitiesHistoryWhereInput
  }

  export type UserNotificationsListRelationFilter = {
    every?: userNotificationsWhereInput
    some?: userNotificationsWhereInput
    none?: userNotificationsWhereInput
  }

  export type RolesScalarRelationFilter = {
    is?: rolesWhereInput
    isNot?: rolesWhereInput
  }

  export type blogsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type careerPathsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type messagesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type paymentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type userActivitiesHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type userNotificationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usersCountOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    avatar_url?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address_street?: SortOrder
    address_ward?: SortOrder
    address_city?: SortOrder
    address_country?: SortOrder
    gender?: SortOrder
    is_deleted?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    role_id?: SortOrder
  }

  export type usersAvgOrderByAggregateInput = {
    role_id?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    avatar_url?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address_street?: SortOrder
    address_ward?: SortOrder
    address_city?: SortOrder
    address_country?: SortOrder
    gender?: SortOrder
    is_deleted?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    role_id?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    id?: SortOrder
    username?: SortOrder
    password?: SortOrder
    avatar_url?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address_street?: SortOrder
    address_ward?: SortOrder
    address_city?: SortOrder
    address_country?: SortOrder
    gender?: SortOrder
    is_deleted?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    role_id?: SortOrder
  }

  export type usersSumOrderByAggregateInput = {
    role_id?: SortOrder
  }

  export type EnumGenderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel> | $Enums.Gender | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGenderNullableFilter<$PrismaModel>
    _max?: NestedEnumGenderNullableFilter<$PrismaModel>
  }

  export type questionsCreateNestedOneWithoutAnswersInput = {
    create?: XOR<questionsCreateWithoutAnswersInput, questionsUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: questionsCreateOrConnectWithoutAnswersInput
    connect?: questionsWhereUniqueInput
  }

  export type personalityTestResultsCreateNestedManyWithoutAnswersInput = {
    create?: XOR<personalityTestResultsCreateWithoutAnswersInput, personalityTestResultsUncheckedCreateWithoutAnswersInput> | personalityTestResultsCreateWithoutAnswersInput[] | personalityTestResultsUncheckedCreateWithoutAnswersInput[]
    connectOrCreate?: personalityTestResultsCreateOrConnectWithoutAnswersInput | personalityTestResultsCreateOrConnectWithoutAnswersInput[]
    createMany?: personalityTestResultsCreateManyAnswersInputEnvelope
    connect?: personalityTestResultsWhereUniqueInput | personalityTestResultsWhereUniqueInput[]
  }

  export type personalityTestResultsUncheckedCreateNestedManyWithoutAnswersInput = {
    create?: XOR<personalityTestResultsCreateWithoutAnswersInput, personalityTestResultsUncheckedCreateWithoutAnswersInput> | personalityTestResultsCreateWithoutAnswersInput[] | personalityTestResultsUncheckedCreateWithoutAnswersInput[]
    connectOrCreate?: personalityTestResultsCreateOrConnectWithoutAnswersInput | personalityTestResultsCreateOrConnectWithoutAnswersInput[]
    createMany?: personalityTestResultsCreateManyAnswersInputEnvelope
    connect?: personalityTestResultsWhereUniqueInput | personalityTestResultsWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type questionsUpdateOneRequiredWithoutAnswersNestedInput = {
    create?: XOR<questionsCreateWithoutAnswersInput, questionsUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: questionsCreateOrConnectWithoutAnswersInput
    upsert?: questionsUpsertWithoutAnswersInput
    connect?: questionsWhereUniqueInput
    update?: XOR<XOR<questionsUpdateToOneWithWhereWithoutAnswersInput, questionsUpdateWithoutAnswersInput>, questionsUncheckedUpdateWithoutAnswersInput>
  }

  export type personalityTestResultsUpdateManyWithoutAnswersNestedInput = {
    create?: XOR<personalityTestResultsCreateWithoutAnswersInput, personalityTestResultsUncheckedCreateWithoutAnswersInput> | personalityTestResultsCreateWithoutAnswersInput[] | personalityTestResultsUncheckedCreateWithoutAnswersInput[]
    connectOrCreate?: personalityTestResultsCreateOrConnectWithoutAnswersInput | personalityTestResultsCreateOrConnectWithoutAnswersInput[]
    upsert?: personalityTestResultsUpsertWithWhereUniqueWithoutAnswersInput | personalityTestResultsUpsertWithWhereUniqueWithoutAnswersInput[]
    createMany?: personalityTestResultsCreateManyAnswersInputEnvelope
    set?: personalityTestResultsWhereUniqueInput | personalityTestResultsWhereUniqueInput[]
    disconnect?: personalityTestResultsWhereUniqueInput | personalityTestResultsWhereUniqueInput[]
    delete?: personalityTestResultsWhereUniqueInput | personalityTestResultsWhereUniqueInput[]
    connect?: personalityTestResultsWhereUniqueInput | personalityTestResultsWhereUniqueInput[]
    update?: personalityTestResultsUpdateWithWhereUniqueWithoutAnswersInput | personalityTestResultsUpdateWithWhereUniqueWithoutAnswersInput[]
    updateMany?: personalityTestResultsUpdateManyWithWhereWithoutAnswersInput | personalityTestResultsUpdateManyWithWhereWithoutAnswersInput[]
    deleteMany?: personalityTestResultsScalarWhereInput | personalityTestResultsScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type personalityTestResultsUncheckedUpdateManyWithoutAnswersNestedInput = {
    create?: XOR<personalityTestResultsCreateWithoutAnswersInput, personalityTestResultsUncheckedCreateWithoutAnswersInput> | personalityTestResultsCreateWithoutAnswersInput[] | personalityTestResultsUncheckedCreateWithoutAnswersInput[]
    connectOrCreate?: personalityTestResultsCreateOrConnectWithoutAnswersInput | personalityTestResultsCreateOrConnectWithoutAnswersInput[]
    upsert?: personalityTestResultsUpsertWithWhereUniqueWithoutAnswersInput | personalityTestResultsUpsertWithWhereUniqueWithoutAnswersInput[]
    createMany?: personalityTestResultsCreateManyAnswersInputEnvelope
    set?: personalityTestResultsWhereUniqueInput | personalityTestResultsWhereUniqueInput[]
    disconnect?: personalityTestResultsWhereUniqueInput | personalityTestResultsWhereUniqueInput[]
    delete?: personalityTestResultsWhereUniqueInput | personalityTestResultsWhereUniqueInput[]
    connect?: personalityTestResultsWhereUniqueInput | personalityTestResultsWhereUniqueInput[]
    update?: personalityTestResultsUpdateWithWhereUniqueWithoutAnswersInput | personalityTestResultsUpdateWithWhereUniqueWithoutAnswersInput[]
    updateMany?: personalityTestResultsUpdateManyWithWhereWithoutAnswersInput | personalityTestResultsUpdateManyWithWhereWithoutAnswersInput[]
    deleteMany?: personalityTestResultsScalarWhereInput | personalityTestResultsScalarWhereInput[]
  }

  export type cvsCreateNestedOneWithoutApplicantsInput = {
    create?: XOR<cvsCreateWithoutApplicantsInput, cvsUncheckedCreateWithoutApplicantsInput>
    connectOrCreate?: cvsCreateOrConnectWithoutApplicantsInput
    connect?: cvsWhereUniqueInput
  }

  export type jobsCreateNestedOneWithoutApplicantsInput = {
    create?: XOR<jobsCreateWithoutApplicantsInput, jobsUncheckedCreateWithoutApplicantsInput>
    connectOrCreate?: jobsCreateOrConnectWithoutApplicantsInput
    connect?: jobsWhereUniqueInput
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type EnumApplicantsStatusFieldUpdateOperationsInput = {
    set?: $Enums.ApplicantsStatus
  }

  export type cvsUpdateOneRequiredWithoutApplicantsNestedInput = {
    create?: XOR<cvsCreateWithoutApplicantsInput, cvsUncheckedCreateWithoutApplicantsInput>
    connectOrCreate?: cvsCreateOrConnectWithoutApplicantsInput
    upsert?: cvsUpsertWithoutApplicantsInput
    connect?: cvsWhereUniqueInput
    update?: XOR<XOR<cvsUpdateToOneWithWhereWithoutApplicantsInput, cvsUpdateWithoutApplicantsInput>, cvsUncheckedUpdateWithoutApplicantsInput>
  }

  export type jobsUpdateOneRequiredWithoutApplicantsNestedInput = {
    create?: XOR<jobsCreateWithoutApplicantsInput, jobsUncheckedCreateWithoutApplicantsInput>
    connectOrCreate?: jobsCreateOrConnectWithoutApplicantsInput
    upsert?: jobsUpsertWithoutApplicantsInput
    connect?: jobsWhereUniqueInput
    update?: XOR<XOR<jobsUpdateToOneWithWhereWithoutApplicantsInput, jobsUpdateWithoutApplicantsInput>, jobsUncheckedUpdateWithoutApplicantsInput>
  }

  export type cvsCreateNestedOneWithoutAwardsInput = {
    create?: XOR<cvsCreateWithoutAwardsInput, cvsUncheckedCreateWithoutAwardsInput>
    connectOrCreate?: cvsCreateOrConnectWithoutAwardsInput
    connect?: cvsWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type cvsUpdateOneRequiredWithoutAwardsNestedInput = {
    create?: XOR<cvsCreateWithoutAwardsInput, cvsUncheckedCreateWithoutAwardsInput>
    connectOrCreate?: cvsCreateOrConnectWithoutAwardsInput
    upsert?: cvsUpsertWithoutAwardsInput
    connect?: cvsWhereUniqueInput
    update?: XOR<XOR<cvsUpdateToOneWithWhereWithoutAwardsInput, cvsUpdateWithoutAwardsInput>, cvsUncheckedUpdateWithoutAwardsInput>
  }

  export type usersCreateNestedOneWithoutBlogsInput = {
    create?: XOR<usersCreateWithoutBlogsInput, usersUncheckedCreateWithoutBlogsInput>
    connectOrCreate?: usersCreateOrConnectWithoutBlogsInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutBlogsNestedInput = {
    create?: XOR<usersCreateWithoutBlogsInput, usersUncheckedCreateWithoutBlogsInput>
    connectOrCreate?: usersCreateOrConnectWithoutBlogsInput
    upsert?: usersUpsertWithoutBlogsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutBlogsInput, usersUpdateWithoutBlogsInput>, usersUncheckedUpdateWithoutBlogsInput>
  }

  export type careerPathsCreateNestedOneWithoutCareerPathStepsInput = {
    create?: XOR<careerPathsCreateWithoutCareerPathStepsInput, careerPathsUncheckedCreateWithoutCareerPathStepsInput>
    connectOrCreate?: careerPathsCreateOrConnectWithoutCareerPathStepsInput
    connect?: careerPathsWhereUniqueInput
  }

  export type careerPathsUpdateOneRequiredWithoutCareerPathStepsNestedInput = {
    create?: XOR<careerPathsCreateWithoutCareerPathStepsInput, careerPathsUncheckedCreateWithoutCareerPathStepsInput>
    connectOrCreate?: careerPathsCreateOrConnectWithoutCareerPathStepsInput
    upsert?: careerPathsUpsertWithoutCareerPathStepsInput
    connect?: careerPathsWhereUniqueInput
    update?: XOR<XOR<careerPathsUpdateToOneWithWhereWithoutCareerPathStepsInput, careerPathsUpdateWithoutCareerPathStepsInput>, careerPathsUncheckedUpdateWithoutCareerPathStepsInput>
  }

  export type careerPathStepsCreateNestedManyWithoutCareerPathsInput = {
    create?: XOR<careerPathStepsCreateWithoutCareerPathsInput, careerPathStepsUncheckedCreateWithoutCareerPathsInput> | careerPathStepsCreateWithoutCareerPathsInput[] | careerPathStepsUncheckedCreateWithoutCareerPathsInput[]
    connectOrCreate?: careerPathStepsCreateOrConnectWithoutCareerPathsInput | careerPathStepsCreateOrConnectWithoutCareerPathsInput[]
    createMany?: careerPathStepsCreateManyCareerPathsInputEnvelope
    connect?: careerPathStepsWhereUniqueInput | careerPathStepsWhereUniqueInput[]
  }

  export type jobSpecializedCreateNestedOneWithoutCareerPathsInput = {
    create?: XOR<jobSpecializedCreateWithoutCareerPathsInput, jobSpecializedUncheckedCreateWithoutCareerPathsInput>
    connectOrCreate?: jobSpecializedCreateOrConnectWithoutCareerPathsInput
    connect?: jobSpecializedWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutCareerPathsInput = {
    create?: XOR<usersCreateWithoutCareerPathsInput, usersUncheckedCreateWithoutCareerPathsInput>
    connectOrCreate?: usersCreateOrConnectWithoutCareerPathsInput
    connect?: usersWhereUniqueInput
  }

  export type careerPathStepsUncheckedCreateNestedManyWithoutCareerPathsInput = {
    create?: XOR<careerPathStepsCreateWithoutCareerPathsInput, careerPathStepsUncheckedCreateWithoutCareerPathsInput> | careerPathStepsCreateWithoutCareerPathsInput[] | careerPathStepsUncheckedCreateWithoutCareerPathsInput[]
    connectOrCreate?: careerPathStepsCreateOrConnectWithoutCareerPathsInput | careerPathStepsCreateOrConnectWithoutCareerPathsInput[]
    createMany?: careerPathStepsCreateManyCareerPathsInputEnvelope
    connect?: careerPathStepsWhereUniqueInput | careerPathStepsWhereUniqueInput[]
  }

  export type careerPathStepsUpdateManyWithoutCareerPathsNestedInput = {
    create?: XOR<careerPathStepsCreateWithoutCareerPathsInput, careerPathStepsUncheckedCreateWithoutCareerPathsInput> | careerPathStepsCreateWithoutCareerPathsInput[] | careerPathStepsUncheckedCreateWithoutCareerPathsInput[]
    connectOrCreate?: careerPathStepsCreateOrConnectWithoutCareerPathsInput | careerPathStepsCreateOrConnectWithoutCareerPathsInput[]
    upsert?: careerPathStepsUpsertWithWhereUniqueWithoutCareerPathsInput | careerPathStepsUpsertWithWhereUniqueWithoutCareerPathsInput[]
    createMany?: careerPathStepsCreateManyCareerPathsInputEnvelope
    set?: careerPathStepsWhereUniqueInput | careerPathStepsWhereUniqueInput[]
    disconnect?: careerPathStepsWhereUniqueInput | careerPathStepsWhereUniqueInput[]
    delete?: careerPathStepsWhereUniqueInput | careerPathStepsWhereUniqueInput[]
    connect?: careerPathStepsWhereUniqueInput | careerPathStepsWhereUniqueInput[]
    update?: careerPathStepsUpdateWithWhereUniqueWithoutCareerPathsInput | careerPathStepsUpdateWithWhereUniqueWithoutCareerPathsInput[]
    updateMany?: careerPathStepsUpdateManyWithWhereWithoutCareerPathsInput | careerPathStepsUpdateManyWithWhereWithoutCareerPathsInput[]
    deleteMany?: careerPathStepsScalarWhereInput | careerPathStepsScalarWhereInput[]
  }

  export type jobSpecializedUpdateOneRequiredWithoutCareerPathsNestedInput = {
    create?: XOR<jobSpecializedCreateWithoutCareerPathsInput, jobSpecializedUncheckedCreateWithoutCareerPathsInput>
    connectOrCreate?: jobSpecializedCreateOrConnectWithoutCareerPathsInput
    upsert?: jobSpecializedUpsertWithoutCareerPathsInput
    connect?: jobSpecializedWhereUniqueInput
    update?: XOR<XOR<jobSpecializedUpdateToOneWithWhereWithoutCareerPathsInput, jobSpecializedUpdateWithoutCareerPathsInput>, jobSpecializedUncheckedUpdateWithoutCareerPathsInput>
  }

  export type usersUpdateOneRequiredWithoutCareerPathsNestedInput = {
    create?: XOR<usersCreateWithoutCareerPathsInput, usersUncheckedCreateWithoutCareerPathsInput>
    connectOrCreate?: usersCreateOrConnectWithoutCareerPathsInput
    upsert?: usersUpsertWithoutCareerPathsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutCareerPathsInput, usersUpdateWithoutCareerPathsInput>, usersUncheckedUpdateWithoutCareerPathsInput>
  }

  export type careerPathStepsUncheckedUpdateManyWithoutCareerPathsNestedInput = {
    create?: XOR<careerPathStepsCreateWithoutCareerPathsInput, careerPathStepsUncheckedCreateWithoutCareerPathsInput> | careerPathStepsCreateWithoutCareerPathsInput[] | careerPathStepsUncheckedCreateWithoutCareerPathsInput[]
    connectOrCreate?: careerPathStepsCreateOrConnectWithoutCareerPathsInput | careerPathStepsCreateOrConnectWithoutCareerPathsInput[]
    upsert?: careerPathStepsUpsertWithWhereUniqueWithoutCareerPathsInput | careerPathStepsUpsertWithWhereUniqueWithoutCareerPathsInput[]
    createMany?: careerPathStepsCreateManyCareerPathsInputEnvelope
    set?: careerPathStepsWhereUniqueInput | careerPathStepsWhereUniqueInput[]
    disconnect?: careerPathStepsWhereUniqueInput | careerPathStepsWhereUniqueInput[]
    delete?: careerPathStepsWhereUniqueInput | careerPathStepsWhereUniqueInput[]
    connect?: careerPathStepsWhereUniqueInput | careerPathStepsWhereUniqueInput[]
    update?: careerPathStepsUpdateWithWhereUniqueWithoutCareerPathsInput | careerPathStepsUpdateWithWhereUniqueWithoutCareerPathsInput[]
    updateMany?: careerPathStepsUpdateManyWithWhereWithoutCareerPathsInput | careerPathStepsUpdateManyWithWhereWithoutCareerPathsInput[]
    deleteMany?: careerPathStepsScalarWhereInput | careerPathStepsScalarWhereInput[]
  }

  export type jobsCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<jobsCreateWithoutCategoriesInput, jobsUncheckedCreateWithoutCategoriesInput> | jobsCreateWithoutCategoriesInput[] | jobsUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: jobsCreateOrConnectWithoutCategoriesInput | jobsCreateOrConnectWithoutCategoriesInput[]
    createMany?: jobsCreateManyCategoriesInputEnvelope
    connect?: jobsWhereUniqueInput | jobsWhereUniqueInput[]
  }

  export type jobsUncheckedCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<jobsCreateWithoutCategoriesInput, jobsUncheckedCreateWithoutCategoriesInput> | jobsCreateWithoutCategoriesInput[] | jobsUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: jobsCreateOrConnectWithoutCategoriesInput | jobsCreateOrConnectWithoutCategoriesInput[]
    createMany?: jobsCreateManyCategoriesInputEnvelope
    connect?: jobsWhereUniqueInput | jobsWhereUniqueInput[]
  }

  export type jobsUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<jobsCreateWithoutCategoriesInput, jobsUncheckedCreateWithoutCategoriesInput> | jobsCreateWithoutCategoriesInput[] | jobsUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: jobsCreateOrConnectWithoutCategoriesInput | jobsCreateOrConnectWithoutCategoriesInput[]
    upsert?: jobsUpsertWithWhereUniqueWithoutCategoriesInput | jobsUpsertWithWhereUniqueWithoutCategoriesInput[]
    createMany?: jobsCreateManyCategoriesInputEnvelope
    set?: jobsWhereUniqueInput | jobsWhereUniqueInput[]
    disconnect?: jobsWhereUniqueInput | jobsWhereUniqueInput[]
    delete?: jobsWhereUniqueInput | jobsWhereUniqueInput[]
    connect?: jobsWhereUniqueInput | jobsWhereUniqueInput[]
    update?: jobsUpdateWithWhereUniqueWithoutCategoriesInput | jobsUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: jobsUpdateManyWithWhereWithoutCategoriesInput | jobsUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: jobsScalarWhereInput | jobsScalarWhereInput[]
  }

  export type jobsUncheckedUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<jobsCreateWithoutCategoriesInput, jobsUncheckedCreateWithoutCategoriesInput> | jobsCreateWithoutCategoriesInput[] | jobsUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: jobsCreateOrConnectWithoutCategoriesInput | jobsCreateOrConnectWithoutCategoriesInput[]
    upsert?: jobsUpsertWithWhereUniqueWithoutCategoriesInput | jobsUpsertWithWhereUniqueWithoutCategoriesInput[]
    createMany?: jobsCreateManyCategoriesInputEnvelope
    set?: jobsWhereUniqueInput | jobsWhereUniqueInput[]
    disconnect?: jobsWhereUniqueInput | jobsWhereUniqueInput[]
    delete?: jobsWhereUniqueInput | jobsWhereUniqueInput[]
    connect?: jobsWhereUniqueInput | jobsWhereUniqueInput[]
    update?: jobsUpdateWithWhereUniqueWithoutCategoriesInput | jobsUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: jobsUpdateManyWithWhereWithoutCategoriesInput | jobsUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: jobsScalarWhereInput | jobsScalarWhereInput[]
  }

  export type cvsCreateNestedOneWithoutCertificatesInput = {
    create?: XOR<cvsCreateWithoutCertificatesInput, cvsUncheckedCreateWithoutCertificatesInput>
    connectOrCreate?: cvsCreateOrConnectWithoutCertificatesInput
    connect?: cvsWhereUniqueInput
  }

  export type cvsUpdateOneRequiredWithoutCertificatesNestedInput = {
    create?: XOR<cvsCreateWithoutCertificatesInput, cvsUncheckedCreateWithoutCertificatesInput>
    connectOrCreate?: cvsCreateOrConnectWithoutCertificatesInput
    upsert?: cvsUpsertWithoutCertificatesInput
    connect?: cvsWhereUniqueInput
    update?: XOR<XOR<cvsUpdateToOneWithWhereWithoutCertificatesInput, cvsUpdateWithoutCertificatesInput>, cvsUncheckedUpdateWithoutCertificatesInput>
  }

  export type fieldsCreateNestedOneWithoutCompaniesInput = {
    create?: XOR<fieldsCreateWithoutCompaniesInput, fieldsUncheckedCreateWithoutCompaniesInput>
    connectOrCreate?: fieldsCreateOrConnectWithoutCompaniesInput
    connect?: fieldsWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutCompaniesInput = {
    create?: XOR<usersCreateWithoutCompaniesInput, usersUncheckedCreateWithoutCompaniesInput>
    connectOrCreate?: usersCreateOrConnectWithoutCompaniesInput
    connect?: usersWhereUniqueInput
  }

  export type companyLabelsCreateNestedOneWithoutCompaniesInput = {
    create?: XOR<companyLabelsCreateWithoutCompaniesInput, companyLabelsUncheckedCreateWithoutCompaniesInput>
    connectOrCreate?: companyLabelsCreateOrConnectWithoutCompaniesInput
    connect?: companyLabelsWhereUniqueInput
  }

  export type companyActivitiesHistoryCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<companyActivitiesHistoryCreateWithoutCompaniesInput, companyActivitiesHistoryUncheckedCreateWithoutCompaniesInput> | companyActivitiesHistoryCreateWithoutCompaniesInput[] | companyActivitiesHistoryUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: companyActivitiesHistoryCreateOrConnectWithoutCompaniesInput | companyActivitiesHistoryCreateOrConnectWithoutCompaniesInput[]
    createMany?: companyActivitiesHistoryCreateManyCompaniesInputEnvelope
    connect?: companyActivitiesHistoryWhereUniqueInput | companyActivitiesHistoryWhereUniqueInput[]
  }

  export type companyNotificationsCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<companyNotificationsCreateWithoutCompaniesInput, companyNotificationsUncheckedCreateWithoutCompaniesInput> | companyNotificationsCreateWithoutCompaniesInput[] | companyNotificationsUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: companyNotificationsCreateOrConnectWithoutCompaniesInput | companyNotificationsCreateOrConnectWithoutCompaniesInput[]
    createMany?: companyNotificationsCreateManyCompaniesInputEnvelope
    connect?: companyNotificationsWhereUniqueInput | companyNotificationsWhereUniqueInput[]
  }

  export type feedbacksCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<feedbacksCreateWithoutCompaniesInput, feedbacksUncheckedCreateWithoutCompaniesInput> | feedbacksCreateWithoutCompaniesInput[] | feedbacksUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: feedbacksCreateOrConnectWithoutCompaniesInput | feedbacksCreateOrConnectWithoutCompaniesInput[]
    createMany?: feedbacksCreateManyCompaniesInputEnvelope
    connect?: feedbacksWhereUniqueInput | feedbacksWhereUniqueInput[]
  }

  export type followedCompaniesCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<followedCompaniesCreateWithoutCompaniesInput, followedCompaniesUncheckedCreateWithoutCompaniesInput> | followedCompaniesCreateWithoutCompaniesInput[] | followedCompaniesUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: followedCompaniesCreateOrConnectWithoutCompaniesInput | followedCompaniesCreateOrConnectWithoutCompaniesInput[]
    createMany?: followedCompaniesCreateManyCompaniesInputEnvelope
    connect?: followedCompaniesWhereUniqueInput | followedCompaniesWhereUniqueInput[]
  }

  export type companyActivitiesHistoryUncheckedCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<companyActivitiesHistoryCreateWithoutCompaniesInput, companyActivitiesHistoryUncheckedCreateWithoutCompaniesInput> | companyActivitiesHistoryCreateWithoutCompaniesInput[] | companyActivitiesHistoryUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: companyActivitiesHistoryCreateOrConnectWithoutCompaniesInput | companyActivitiesHistoryCreateOrConnectWithoutCompaniesInput[]
    createMany?: companyActivitiesHistoryCreateManyCompaniesInputEnvelope
    connect?: companyActivitiesHistoryWhereUniqueInput | companyActivitiesHistoryWhereUniqueInput[]
  }

  export type companyNotificationsUncheckedCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<companyNotificationsCreateWithoutCompaniesInput, companyNotificationsUncheckedCreateWithoutCompaniesInput> | companyNotificationsCreateWithoutCompaniesInput[] | companyNotificationsUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: companyNotificationsCreateOrConnectWithoutCompaniesInput | companyNotificationsCreateOrConnectWithoutCompaniesInput[]
    createMany?: companyNotificationsCreateManyCompaniesInputEnvelope
    connect?: companyNotificationsWhereUniqueInput | companyNotificationsWhereUniqueInput[]
  }

  export type feedbacksUncheckedCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<feedbacksCreateWithoutCompaniesInput, feedbacksUncheckedCreateWithoutCompaniesInput> | feedbacksCreateWithoutCompaniesInput[] | feedbacksUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: feedbacksCreateOrConnectWithoutCompaniesInput | feedbacksCreateOrConnectWithoutCompaniesInput[]
    createMany?: feedbacksCreateManyCompaniesInputEnvelope
    connect?: feedbacksWhereUniqueInput | feedbacksWhereUniqueInput[]
  }

  export type followedCompaniesUncheckedCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<followedCompaniesCreateWithoutCompaniesInput, followedCompaniesUncheckedCreateWithoutCompaniesInput> | followedCompaniesCreateWithoutCompaniesInput[] | followedCompaniesUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: followedCompaniesCreateOrConnectWithoutCompaniesInput | followedCompaniesCreateOrConnectWithoutCompaniesInput[]
    createMany?: followedCompaniesCreateManyCompaniesInputEnvelope
    connect?: followedCompaniesWhereUniqueInput | followedCompaniesWhereUniqueInput[]
  }

  export type EnumCompany_TypeFieldUpdateOperationsInput = {
    set?: $Enums.Company_Type
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type fieldsUpdateOneWithoutCompaniesNestedInput = {
    create?: XOR<fieldsCreateWithoutCompaniesInput, fieldsUncheckedCreateWithoutCompaniesInput>
    connectOrCreate?: fieldsCreateOrConnectWithoutCompaniesInput
    upsert?: fieldsUpsertWithoutCompaniesInput
    disconnect?: fieldsWhereInput | boolean
    delete?: fieldsWhereInput | boolean
    connect?: fieldsWhereUniqueInput
    update?: XOR<XOR<fieldsUpdateToOneWithWhereWithoutCompaniesInput, fieldsUpdateWithoutCompaniesInput>, fieldsUncheckedUpdateWithoutCompaniesInput>
  }

  export type usersUpdateOneRequiredWithoutCompaniesNestedInput = {
    create?: XOR<usersCreateWithoutCompaniesInput, usersUncheckedCreateWithoutCompaniesInput>
    connectOrCreate?: usersCreateOrConnectWithoutCompaniesInput
    upsert?: usersUpsertWithoutCompaniesInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutCompaniesInput, usersUpdateWithoutCompaniesInput>, usersUncheckedUpdateWithoutCompaniesInput>
  }

  export type companyLabelsUpdateOneWithoutCompaniesNestedInput = {
    create?: XOR<companyLabelsCreateWithoutCompaniesInput, companyLabelsUncheckedCreateWithoutCompaniesInput>
    connectOrCreate?: companyLabelsCreateOrConnectWithoutCompaniesInput
    upsert?: companyLabelsUpsertWithoutCompaniesInput
    disconnect?: companyLabelsWhereInput | boolean
    delete?: companyLabelsWhereInput | boolean
    connect?: companyLabelsWhereUniqueInput
    update?: XOR<XOR<companyLabelsUpdateToOneWithWhereWithoutCompaniesInput, companyLabelsUpdateWithoutCompaniesInput>, companyLabelsUncheckedUpdateWithoutCompaniesInput>
  }

  export type companyActivitiesHistoryUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<companyActivitiesHistoryCreateWithoutCompaniesInput, companyActivitiesHistoryUncheckedCreateWithoutCompaniesInput> | companyActivitiesHistoryCreateWithoutCompaniesInput[] | companyActivitiesHistoryUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: companyActivitiesHistoryCreateOrConnectWithoutCompaniesInput | companyActivitiesHistoryCreateOrConnectWithoutCompaniesInput[]
    upsert?: companyActivitiesHistoryUpsertWithWhereUniqueWithoutCompaniesInput | companyActivitiesHistoryUpsertWithWhereUniqueWithoutCompaniesInput[]
    createMany?: companyActivitiesHistoryCreateManyCompaniesInputEnvelope
    set?: companyActivitiesHistoryWhereUniqueInput | companyActivitiesHistoryWhereUniqueInput[]
    disconnect?: companyActivitiesHistoryWhereUniqueInput | companyActivitiesHistoryWhereUniqueInput[]
    delete?: companyActivitiesHistoryWhereUniqueInput | companyActivitiesHistoryWhereUniqueInput[]
    connect?: companyActivitiesHistoryWhereUniqueInput | companyActivitiesHistoryWhereUniqueInput[]
    update?: companyActivitiesHistoryUpdateWithWhereUniqueWithoutCompaniesInput | companyActivitiesHistoryUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: companyActivitiesHistoryUpdateManyWithWhereWithoutCompaniesInput | companyActivitiesHistoryUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: companyActivitiesHistoryScalarWhereInput | companyActivitiesHistoryScalarWhereInput[]
  }

  export type companyNotificationsUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<companyNotificationsCreateWithoutCompaniesInput, companyNotificationsUncheckedCreateWithoutCompaniesInput> | companyNotificationsCreateWithoutCompaniesInput[] | companyNotificationsUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: companyNotificationsCreateOrConnectWithoutCompaniesInput | companyNotificationsCreateOrConnectWithoutCompaniesInput[]
    upsert?: companyNotificationsUpsertWithWhereUniqueWithoutCompaniesInput | companyNotificationsUpsertWithWhereUniqueWithoutCompaniesInput[]
    createMany?: companyNotificationsCreateManyCompaniesInputEnvelope
    set?: companyNotificationsWhereUniqueInput | companyNotificationsWhereUniqueInput[]
    disconnect?: companyNotificationsWhereUniqueInput | companyNotificationsWhereUniqueInput[]
    delete?: companyNotificationsWhereUniqueInput | companyNotificationsWhereUniqueInput[]
    connect?: companyNotificationsWhereUniqueInput | companyNotificationsWhereUniqueInput[]
    update?: companyNotificationsUpdateWithWhereUniqueWithoutCompaniesInput | companyNotificationsUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: companyNotificationsUpdateManyWithWhereWithoutCompaniesInput | companyNotificationsUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: companyNotificationsScalarWhereInput | companyNotificationsScalarWhereInput[]
  }

  export type feedbacksUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<feedbacksCreateWithoutCompaniesInput, feedbacksUncheckedCreateWithoutCompaniesInput> | feedbacksCreateWithoutCompaniesInput[] | feedbacksUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: feedbacksCreateOrConnectWithoutCompaniesInput | feedbacksCreateOrConnectWithoutCompaniesInput[]
    upsert?: feedbacksUpsertWithWhereUniqueWithoutCompaniesInput | feedbacksUpsertWithWhereUniqueWithoutCompaniesInput[]
    createMany?: feedbacksCreateManyCompaniesInputEnvelope
    set?: feedbacksWhereUniqueInput | feedbacksWhereUniqueInput[]
    disconnect?: feedbacksWhereUniqueInput | feedbacksWhereUniqueInput[]
    delete?: feedbacksWhereUniqueInput | feedbacksWhereUniqueInput[]
    connect?: feedbacksWhereUniqueInput | feedbacksWhereUniqueInput[]
    update?: feedbacksUpdateWithWhereUniqueWithoutCompaniesInput | feedbacksUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: feedbacksUpdateManyWithWhereWithoutCompaniesInput | feedbacksUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: feedbacksScalarWhereInput | feedbacksScalarWhereInput[]
  }

  export type followedCompaniesUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<followedCompaniesCreateWithoutCompaniesInput, followedCompaniesUncheckedCreateWithoutCompaniesInput> | followedCompaniesCreateWithoutCompaniesInput[] | followedCompaniesUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: followedCompaniesCreateOrConnectWithoutCompaniesInput | followedCompaniesCreateOrConnectWithoutCompaniesInput[]
    upsert?: followedCompaniesUpsertWithWhereUniqueWithoutCompaniesInput | followedCompaniesUpsertWithWhereUniqueWithoutCompaniesInput[]
    createMany?: followedCompaniesCreateManyCompaniesInputEnvelope
    set?: followedCompaniesWhereUniqueInput | followedCompaniesWhereUniqueInput[]
    disconnect?: followedCompaniesWhereUniqueInput | followedCompaniesWhereUniqueInput[]
    delete?: followedCompaniesWhereUniqueInput | followedCompaniesWhereUniqueInput[]
    connect?: followedCompaniesWhereUniqueInput | followedCompaniesWhereUniqueInput[]
    update?: followedCompaniesUpdateWithWhereUniqueWithoutCompaniesInput | followedCompaniesUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: followedCompaniesUpdateManyWithWhereWithoutCompaniesInput | followedCompaniesUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: followedCompaniesScalarWhereInput | followedCompaniesScalarWhereInput[]
  }

  export type companyActivitiesHistoryUncheckedUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<companyActivitiesHistoryCreateWithoutCompaniesInput, companyActivitiesHistoryUncheckedCreateWithoutCompaniesInput> | companyActivitiesHistoryCreateWithoutCompaniesInput[] | companyActivitiesHistoryUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: companyActivitiesHistoryCreateOrConnectWithoutCompaniesInput | companyActivitiesHistoryCreateOrConnectWithoutCompaniesInput[]
    upsert?: companyActivitiesHistoryUpsertWithWhereUniqueWithoutCompaniesInput | companyActivitiesHistoryUpsertWithWhereUniqueWithoutCompaniesInput[]
    createMany?: companyActivitiesHistoryCreateManyCompaniesInputEnvelope
    set?: companyActivitiesHistoryWhereUniqueInput | companyActivitiesHistoryWhereUniqueInput[]
    disconnect?: companyActivitiesHistoryWhereUniqueInput | companyActivitiesHistoryWhereUniqueInput[]
    delete?: companyActivitiesHistoryWhereUniqueInput | companyActivitiesHistoryWhereUniqueInput[]
    connect?: companyActivitiesHistoryWhereUniqueInput | companyActivitiesHistoryWhereUniqueInput[]
    update?: companyActivitiesHistoryUpdateWithWhereUniqueWithoutCompaniesInput | companyActivitiesHistoryUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: companyActivitiesHistoryUpdateManyWithWhereWithoutCompaniesInput | companyActivitiesHistoryUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: companyActivitiesHistoryScalarWhereInput | companyActivitiesHistoryScalarWhereInput[]
  }

  export type companyNotificationsUncheckedUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<companyNotificationsCreateWithoutCompaniesInput, companyNotificationsUncheckedCreateWithoutCompaniesInput> | companyNotificationsCreateWithoutCompaniesInput[] | companyNotificationsUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: companyNotificationsCreateOrConnectWithoutCompaniesInput | companyNotificationsCreateOrConnectWithoutCompaniesInput[]
    upsert?: companyNotificationsUpsertWithWhereUniqueWithoutCompaniesInput | companyNotificationsUpsertWithWhereUniqueWithoutCompaniesInput[]
    createMany?: companyNotificationsCreateManyCompaniesInputEnvelope
    set?: companyNotificationsWhereUniqueInput | companyNotificationsWhereUniqueInput[]
    disconnect?: companyNotificationsWhereUniqueInput | companyNotificationsWhereUniqueInput[]
    delete?: companyNotificationsWhereUniqueInput | companyNotificationsWhereUniqueInput[]
    connect?: companyNotificationsWhereUniqueInput | companyNotificationsWhereUniqueInput[]
    update?: companyNotificationsUpdateWithWhereUniqueWithoutCompaniesInput | companyNotificationsUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: companyNotificationsUpdateManyWithWhereWithoutCompaniesInput | companyNotificationsUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: companyNotificationsScalarWhereInput | companyNotificationsScalarWhereInput[]
  }

  export type feedbacksUncheckedUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<feedbacksCreateWithoutCompaniesInput, feedbacksUncheckedCreateWithoutCompaniesInput> | feedbacksCreateWithoutCompaniesInput[] | feedbacksUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: feedbacksCreateOrConnectWithoutCompaniesInput | feedbacksCreateOrConnectWithoutCompaniesInput[]
    upsert?: feedbacksUpsertWithWhereUniqueWithoutCompaniesInput | feedbacksUpsertWithWhereUniqueWithoutCompaniesInput[]
    createMany?: feedbacksCreateManyCompaniesInputEnvelope
    set?: feedbacksWhereUniqueInput | feedbacksWhereUniqueInput[]
    disconnect?: feedbacksWhereUniqueInput | feedbacksWhereUniqueInput[]
    delete?: feedbacksWhereUniqueInput | feedbacksWhereUniqueInput[]
    connect?: feedbacksWhereUniqueInput | feedbacksWhereUniqueInput[]
    update?: feedbacksUpdateWithWhereUniqueWithoutCompaniesInput | feedbacksUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: feedbacksUpdateManyWithWhereWithoutCompaniesInput | feedbacksUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: feedbacksScalarWhereInput | feedbacksScalarWhereInput[]
  }

  export type followedCompaniesUncheckedUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<followedCompaniesCreateWithoutCompaniesInput, followedCompaniesUncheckedCreateWithoutCompaniesInput> | followedCompaniesCreateWithoutCompaniesInput[] | followedCompaniesUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: followedCompaniesCreateOrConnectWithoutCompaniesInput | followedCompaniesCreateOrConnectWithoutCompaniesInput[]
    upsert?: followedCompaniesUpsertWithWhereUniqueWithoutCompaniesInput | followedCompaniesUpsertWithWhereUniqueWithoutCompaniesInput[]
    createMany?: followedCompaniesCreateManyCompaniesInputEnvelope
    set?: followedCompaniesWhereUniqueInput | followedCompaniesWhereUniqueInput[]
    disconnect?: followedCompaniesWhereUniqueInput | followedCompaniesWhereUniqueInput[]
    delete?: followedCompaniesWhereUniqueInput | followedCompaniesWhereUniqueInput[]
    connect?: followedCompaniesWhereUniqueInput | followedCompaniesWhereUniqueInput[]
    update?: followedCompaniesUpdateWithWhereUniqueWithoutCompaniesInput | followedCompaniesUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: followedCompaniesUpdateManyWithWhereWithoutCompaniesInput | followedCompaniesUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: followedCompaniesScalarWhereInput | followedCompaniesScalarWhereInput[]
  }

  export type companiesCreateNestedOneWithoutCompanyActivitiesHistoryInput = {
    create?: XOR<companiesCreateWithoutCompanyActivitiesHistoryInput, companiesUncheckedCreateWithoutCompanyActivitiesHistoryInput>
    connectOrCreate?: companiesCreateOrConnectWithoutCompanyActivitiesHistoryInput
    connect?: companiesWhereUniqueInput
  }

  export type companiesUpdateOneRequiredWithoutCompanyActivitiesHistoryNestedInput = {
    create?: XOR<companiesCreateWithoutCompanyActivitiesHistoryInput, companiesUncheckedCreateWithoutCompanyActivitiesHistoryInput>
    connectOrCreate?: companiesCreateOrConnectWithoutCompanyActivitiesHistoryInput
    upsert?: companiesUpsertWithoutCompanyActivitiesHistoryInput
    connect?: companiesWhereUniqueInput
    update?: XOR<XOR<companiesUpdateToOneWithWhereWithoutCompanyActivitiesHistoryInput, companiesUpdateWithoutCompanyActivitiesHistoryInput>, companiesUncheckedUpdateWithoutCompanyActivitiesHistoryInput>
  }

  export type companiesCreateNestedManyWithoutCompanyLabelsInput = {
    create?: XOR<companiesCreateWithoutCompanyLabelsInput, companiesUncheckedCreateWithoutCompanyLabelsInput> | companiesCreateWithoutCompanyLabelsInput[] | companiesUncheckedCreateWithoutCompanyLabelsInput[]
    connectOrCreate?: companiesCreateOrConnectWithoutCompanyLabelsInput | companiesCreateOrConnectWithoutCompanyLabelsInput[]
    createMany?: companiesCreateManyCompanyLabelsInputEnvelope
    connect?: companiesWhereUniqueInput | companiesWhereUniqueInput[]
  }

  export type companiesUncheckedCreateNestedManyWithoutCompanyLabelsInput = {
    create?: XOR<companiesCreateWithoutCompanyLabelsInput, companiesUncheckedCreateWithoutCompanyLabelsInput> | companiesCreateWithoutCompanyLabelsInput[] | companiesUncheckedCreateWithoutCompanyLabelsInput[]
    connectOrCreate?: companiesCreateOrConnectWithoutCompanyLabelsInput | companiesCreateOrConnectWithoutCompanyLabelsInput[]
    createMany?: companiesCreateManyCompanyLabelsInputEnvelope
    connect?: companiesWhereUniqueInput | companiesWhereUniqueInput[]
  }

  export type companiesUpdateManyWithoutCompanyLabelsNestedInput = {
    create?: XOR<companiesCreateWithoutCompanyLabelsInput, companiesUncheckedCreateWithoutCompanyLabelsInput> | companiesCreateWithoutCompanyLabelsInput[] | companiesUncheckedCreateWithoutCompanyLabelsInput[]
    connectOrCreate?: companiesCreateOrConnectWithoutCompanyLabelsInput | companiesCreateOrConnectWithoutCompanyLabelsInput[]
    upsert?: companiesUpsertWithWhereUniqueWithoutCompanyLabelsInput | companiesUpsertWithWhereUniqueWithoutCompanyLabelsInput[]
    createMany?: companiesCreateManyCompanyLabelsInputEnvelope
    set?: companiesWhereUniqueInput | companiesWhereUniqueInput[]
    disconnect?: companiesWhereUniqueInput | companiesWhereUniqueInput[]
    delete?: companiesWhereUniqueInput | companiesWhereUniqueInput[]
    connect?: companiesWhereUniqueInput | companiesWhereUniqueInput[]
    update?: companiesUpdateWithWhereUniqueWithoutCompanyLabelsInput | companiesUpdateWithWhereUniqueWithoutCompanyLabelsInput[]
    updateMany?: companiesUpdateManyWithWhereWithoutCompanyLabelsInput | companiesUpdateManyWithWhereWithoutCompanyLabelsInput[]
    deleteMany?: companiesScalarWhereInput | companiesScalarWhereInput[]
  }

  export type companiesUncheckedUpdateManyWithoutCompanyLabelsNestedInput = {
    create?: XOR<companiesCreateWithoutCompanyLabelsInput, companiesUncheckedCreateWithoutCompanyLabelsInput> | companiesCreateWithoutCompanyLabelsInput[] | companiesUncheckedCreateWithoutCompanyLabelsInput[]
    connectOrCreate?: companiesCreateOrConnectWithoutCompanyLabelsInput | companiesCreateOrConnectWithoutCompanyLabelsInput[]
    upsert?: companiesUpsertWithWhereUniqueWithoutCompanyLabelsInput | companiesUpsertWithWhereUniqueWithoutCompanyLabelsInput[]
    createMany?: companiesCreateManyCompanyLabelsInputEnvelope
    set?: companiesWhereUniqueInput | companiesWhereUniqueInput[]
    disconnect?: companiesWhereUniqueInput | companiesWhereUniqueInput[]
    delete?: companiesWhereUniqueInput | companiesWhereUniqueInput[]
    connect?: companiesWhereUniqueInput | companiesWhereUniqueInput[]
    update?: companiesUpdateWithWhereUniqueWithoutCompanyLabelsInput | companiesUpdateWithWhereUniqueWithoutCompanyLabelsInput[]
    updateMany?: companiesUpdateManyWithWhereWithoutCompanyLabelsInput | companiesUpdateManyWithWhereWithoutCompanyLabelsInput[]
    deleteMany?: companiesScalarWhereInput | companiesScalarWhereInput[]
  }

  export type companiesCreateNestedOneWithoutCompanyNotificationsInput = {
    create?: XOR<companiesCreateWithoutCompanyNotificationsInput, companiesUncheckedCreateWithoutCompanyNotificationsInput>
    connectOrCreate?: companiesCreateOrConnectWithoutCompanyNotificationsInput
    connect?: companiesWhereUniqueInput
  }

  export type EnumNotificationsTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationsType
  }

  export type companiesUpdateOneRequiredWithoutCompanyNotificationsNestedInput = {
    create?: XOR<companiesCreateWithoutCompanyNotificationsInput, companiesUncheckedCreateWithoutCompanyNotificationsInput>
    connectOrCreate?: companiesCreateOrConnectWithoutCompanyNotificationsInput
    upsert?: companiesUpsertWithoutCompanyNotificationsInput
    connect?: companiesWhereUniqueInput
    update?: XOR<XOR<companiesUpdateToOneWithWhereWithoutCompanyNotificationsInput, companiesUpdateWithoutCompanyNotificationsInput>, companiesUncheckedUpdateWithoutCompanyNotificationsInput>
  }

  export type cvsCreatesoft_skillsInput = {
    set: string[]
  }

  export type cvsCreateprimary_skillsInput = {
    set: string[]
  }

  export type applicantsCreateNestedManyWithoutCvsInput = {
    create?: XOR<applicantsCreateWithoutCvsInput, applicantsUncheckedCreateWithoutCvsInput> | applicantsCreateWithoutCvsInput[] | applicantsUncheckedCreateWithoutCvsInput[]
    connectOrCreate?: applicantsCreateOrConnectWithoutCvsInput | applicantsCreateOrConnectWithoutCvsInput[]
    createMany?: applicantsCreateManyCvsInputEnvelope
    connect?: applicantsWhereUniqueInput | applicantsWhereUniqueInput[]
  }

  export type awardsCreateNestedManyWithoutCvsInput = {
    create?: XOR<awardsCreateWithoutCvsInput, awardsUncheckedCreateWithoutCvsInput> | awardsCreateWithoutCvsInput[] | awardsUncheckedCreateWithoutCvsInput[]
    connectOrCreate?: awardsCreateOrConnectWithoutCvsInput | awardsCreateOrConnectWithoutCvsInput[]
    createMany?: awardsCreateManyCvsInputEnvelope
    connect?: awardsWhereUniqueInput | awardsWhereUniqueInput[]
  }

  export type certificatesCreateNestedManyWithoutCvsInput = {
    create?: XOR<certificatesCreateWithoutCvsInput, certificatesUncheckedCreateWithoutCvsInput> | certificatesCreateWithoutCvsInput[] | certificatesUncheckedCreateWithoutCvsInput[]
    connectOrCreate?: certificatesCreateOrConnectWithoutCvsInput | certificatesCreateOrConnectWithoutCvsInput[]
    createMany?: certificatesCreateManyCvsInputEnvelope
    connect?: certificatesWhereUniqueInput | certificatesWhereUniqueInput[]
  }

  export type educationsCreateNestedManyWithoutCvsInput = {
    create?: XOR<educationsCreateWithoutCvsInput, educationsUncheckedCreateWithoutCvsInput> | educationsCreateWithoutCvsInput[] | educationsUncheckedCreateWithoutCvsInput[]
    connectOrCreate?: educationsCreateOrConnectWithoutCvsInput | educationsCreateOrConnectWithoutCvsInput[]
    createMany?: educationsCreateManyCvsInputEnvelope
    connect?: educationsWhereUniqueInput | educationsWhereUniqueInput[]
  }

  export type experiencesCreateNestedManyWithoutCvsInput = {
    create?: XOR<experiencesCreateWithoutCvsInput, experiencesUncheckedCreateWithoutCvsInput> | experiencesCreateWithoutCvsInput[] | experiencesUncheckedCreateWithoutCvsInput[]
    connectOrCreate?: experiencesCreateOrConnectWithoutCvsInput | experiencesCreateOrConnectWithoutCvsInput[]
    createMany?: experiencesCreateManyCvsInputEnvelope
    connect?: experiencesWhereUniqueInput | experiencesWhereUniqueInput[]
  }

  export type projectsCreateNestedManyWithoutCvsInput = {
    create?: XOR<projectsCreateWithoutCvsInput, projectsUncheckedCreateWithoutCvsInput> | projectsCreateWithoutCvsInput[] | projectsUncheckedCreateWithoutCvsInput[]
    connectOrCreate?: projectsCreateOrConnectWithoutCvsInput | projectsCreateOrConnectWithoutCvsInput[]
    createMany?: projectsCreateManyCvsInputEnvelope
    connect?: projectsWhereUniqueInput | projectsWhereUniqueInput[]
  }

  export type referencesCreateNestedManyWithoutCvsInput = {
    create?: XOR<referencesCreateWithoutCvsInput, referencesUncheckedCreateWithoutCvsInput> | referencesCreateWithoutCvsInput[] | referencesUncheckedCreateWithoutCvsInput[]
    connectOrCreate?: referencesCreateOrConnectWithoutCvsInput | referencesCreateOrConnectWithoutCvsInput[]
    createMany?: referencesCreateManyCvsInputEnvelope
    connect?: referencesWhereUniqueInput | referencesWhereUniqueInput[]
  }

  export type applicantsUncheckedCreateNestedManyWithoutCvsInput = {
    create?: XOR<applicantsCreateWithoutCvsInput, applicantsUncheckedCreateWithoutCvsInput> | applicantsCreateWithoutCvsInput[] | applicantsUncheckedCreateWithoutCvsInput[]
    connectOrCreate?: applicantsCreateOrConnectWithoutCvsInput | applicantsCreateOrConnectWithoutCvsInput[]
    createMany?: applicantsCreateManyCvsInputEnvelope
    connect?: applicantsWhereUniqueInput | applicantsWhereUniqueInput[]
  }

  export type awardsUncheckedCreateNestedManyWithoutCvsInput = {
    create?: XOR<awardsCreateWithoutCvsInput, awardsUncheckedCreateWithoutCvsInput> | awardsCreateWithoutCvsInput[] | awardsUncheckedCreateWithoutCvsInput[]
    connectOrCreate?: awardsCreateOrConnectWithoutCvsInput | awardsCreateOrConnectWithoutCvsInput[]
    createMany?: awardsCreateManyCvsInputEnvelope
    connect?: awardsWhereUniqueInput | awardsWhereUniqueInput[]
  }

  export type certificatesUncheckedCreateNestedManyWithoutCvsInput = {
    create?: XOR<certificatesCreateWithoutCvsInput, certificatesUncheckedCreateWithoutCvsInput> | certificatesCreateWithoutCvsInput[] | certificatesUncheckedCreateWithoutCvsInput[]
    connectOrCreate?: certificatesCreateOrConnectWithoutCvsInput | certificatesCreateOrConnectWithoutCvsInput[]
    createMany?: certificatesCreateManyCvsInputEnvelope
    connect?: certificatesWhereUniqueInput | certificatesWhereUniqueInput[]
  }

  export type educationsUncheckedCreateNestedManyWithoutCvsInput = {
    create?: XOR<educationsCreateWithoutCvsInput, educationsUncheckedCreateWithoutCvsInput> | educationsCreateWithoutCvsInput[] | educationsUncheckedCreateWithoutCvsInput[]
    connectOrCreate?: educationsCreateOrConnectWithoutCvsInput | educationsCreateOrConnectWithoutCvsInput[]
    createMany?: educationsCreateManyCvsInputEnvelope
    connect?: educationsWhereUniqueInput | educationsWhereUniqueInput[]
  }

  export type experiencesUncheckedCreateNestedManyWithoutCvsInput = {
    create?: XOR<experiencesCreateWithoutCvsInput, experiencesUncheckedCreateWithoutCvsInput> | experiencesCreateWithoutCvsInput[] | experiencesUncheckedCreateWithoutCvsInput[]
    connectOrCreate?: experiencesCreateOrConnectWithoutCvsInput | experiencesCreateOrConnectWithoutCvsInput[]
    createMany?: experiencesCreateManyCvsInputEnvelope
    connect?: experiencesWhereUniqueInput | experiencesWhereUniqueInput[]
  }

  export type projectsUncheckedCreateNestedManyWithoutCvsInput = {
    create?: XOR<projectsCreateWithoutCvsInput, projectsUncheckedCreateWithoutCvsInput> | projectsCreateWithoutCvsInput[] | projectsUncheckedCreateWithoutCvsInput[]
    connectOrCreate?: projectsCreateOrConnectWithoutCvsInput | projectsCreateOrConnectWithoutCvsInput[]
    createMany?: projectsCreateManyCvsInputEnvelope
    connect?: projectsWhereUniqueInput | projectsWhereUniqueInput[]
  }

  export type referencesUncheckedCreateNestedManyWithoutCvsInput = {
    create?: XOR<referencesCreateWithoutCvsInput, referencesUncheckedCreateWithoutCvsInput> | referencesCreateWithoutCvsInput[] | referencesUncheckedCreateWithoutCvsInput[]
    connectOrCreate?: referencesCreateOrConnectWithoutCvsInput | referencesCreateOrConnectWithoutCvsInput[]
    createMany?: referencesCreateManyCvsInputEnvelope
    connect?: referencesWhereUniqueInput | referencesWhereUniqueInput[]
  }

  export type cvsUpdatesoft_skillsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type cvsUpdateprimary_skillsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type applicantsUpdateManyWithoutCvsNestedInput = {
    create?: XOR<applicantsCreateWithoutCvsInput, applicantsUncheckedCreateWithoutCvsInput> | applicantsCreateWithoutCvsInput[] | applicantsUncheckedCreateWithoutCvsInput[]
    connectOrCreate?: applicantsCreateOrConnectWithoutCvsInput | applicantsCreateOrConnectWithoutCvsInput[]
    upsert?: applicantsUpsertWithWhereUniqueWithoutCvsInput | applicantsUpsertWithWhereUniqueWithoutCvsInput[]
    createMany?: applicantsCreateManyCvsInputEnvelope
    set?: applicantsWhereUniqueInput | applicantsWhereUniqueInput[]
    disconnect?: applicantsWhereUniqueInput | applicantsWhereUniqueInput[]
    delete?: applicantsWhereUniqueInput | applicantsWhereUniqueInput[]
    connect?: applicantsWhereUniqueInput | applicantsWhereUniqueInput[]
    update?: applicantsUpdateWithWhereUniqueWithoutCvsInput | applicantsUpdateWithWhereUniqueWithoutCvsInput[]
    updateMany?: applicantsUpdateManyWithWhereWithoutCvsInput | applicantsUpdateManyWithWhereWithoutCvsInput[]
    deleteMany?: applicantsScalarWhereInput | applicantsScalarWhereInput[]
  }

  export type awardsUpdateManyWithoutCvsNestedInput = {
    create?: XOR<awardsCreateWithoutCvsInput, awardsUncheckedCreateWithoutCvsInput> | awardsCreateWithoutCvsInput[] | awardsUncheckedCreateWithoutCvsInput[]
    connectOrCreate?: awardsCreateOrConnectWithoutCvsInput | awardsCreateOrConnectWithoutCvsInput[]
    upsert?: awardsUpsertWithWhereUniqueWithoutCvsInput | awardsUpsertWithWhereUniqueWithoutCvsInput[]
    createMany?: awardsCreateManyCvsInputEnvelope
    set?: awardsWhereUniqueInput | awardsWhereUniqueInput[]
    disconnect?: awardsWhereUniqueInput | awardsWhereUniqueInput[]
    delete?: awardsWhereUniqueInput | awardsWhereUniqueInput[]
    connect?: awardsWhereUniqueInput | awardsWhereUniqueInput[]
    update?: awardsUpdateWithWhereUniqueWithoutCvsInput | awardsUpdateWithWhereUniqueWithoutCvsInput[]
    updateMany?: awardsUpdateManyWithWhereWithoutCvsInput | awardsUpdateManyWithWhereWithoutCvsInput[]
    deleteMany?: awardsScalarWhereInput | awardsScalarWhereInput[]
  }

  export type certificatesUpdateManyWithoutCvsNestedInput = {
    create?: XOR<certificatesCreateWithoutCvsInput, certificatesUncheckedCreateWithoutCvsInput> | certificatesCreateWithoutCvsInput[] | certificatesUncheckedCreateWithoutCvsInput[]
    connectOrCreate?: certificatesCreateOrConnectWithoutCvsInput | certificatesCreateOrConnectWithoutCvsInput[]
    upsert?: certificatesUpsertWithWhereUniqueWithoutCvsInput | certificatesUpsertWithWhereUniqueWithoutCvsInput[]
    createMany?: certificatesCreateManyCvsInputEnvelope
    set?: certificatesWhereUniqueInput | certificatesWhereUniqueInput[]
    disconnect?: certificatesWhereUniqueInput | certificatesWhereUniqueInput[]
    delete?: certificatesWhereUniqueInput | certificatesWhereUniqueInput[]
    connect?: certificatesWhereUniqueInput | certificatesWhereUniqueInput[]
    update?: certificatesUpdateWithWhereUniqueWithoutCvsInput | certificatesUpdateWithWhereUniqueWithoutCvsInput[]
    updateMany?: certificatesUpdateManyWithWhereWithoutCvsInput | certificatesUpdateManyWithWhereWithoutCvsInput[]
    deleteMany?: certificatesScalarWhereInput | certificatesScalarWhereInput[]
  }

  export type educationsUpdateManyWithoutCvsNestedInput = {
    create?: XOR<educationsCreateWithoutCvsInput, educationsUncheckedCreateWithoutCvsInput> | educationsCreateWithoutCvsInput[] | educationsUncheckedCreateWithoutCvsInput[]
    connectOrCreate?: educationsCreateOrConnectWithoutCvsInput | educationsCreateOrConnectWithoutCvsInput[]
    upsert?: educationsUpsertWithWhereUniqueWithoutCvsInput | educationsUpsertWithWhereUniqueWithoutCvsInput[]
    createMany?: educationsCreateManyCvsInputEnvelope
    set?: educationsWhereUniqueInput | educationsWhereUniqueInput[]
    disconnect?: educationsWhereUniqueInput | educationsWhereUniqueInput[]
    delete?: educationsWhereUniqueInput | educationsWhereUniqueInput[]
    connect?: educationsWhereUniqueInput | educationsWhereUniqueInput[]
    update?: educationsUpdateWithWhereUniqueWithoutCvsInput | educationsUpdateWithWhereUniqueWithoutCvsInput[]
    updateMany?: educationsUpdateManyWithWhereWithoutCvsInput | educationsUpdateManyWithWhereWithoutCvsInput[]
    deleteMany?: educationsScalarWhereInput | educationsScalarWhereInput[]
  }

  export type experiencesUpdateManyWithoutCvsNestedInput = {
    create?: XOR<experiencesCreateWithoutCvsInput, experiencesUncheckedCreateWithoutCvsInput> | experiencesCreateWithoutCvsInput[] | experiencesUncheckedCreateWithoutCvsInput[]
    connectOrCreate?: experiencesCreateOrConnectWithoutCvsInput | experiencesCreateOrConnectWithoutCvsInput[]
    upsert?: experiencesUpsertWithWhereUniqueWithoutCvsInput | experiencesUpsertWithWhereUniqueWithoutCvsInput[]
    createMany?: experiencesCreateManyCvsInputEnvelope
    set?: experiencesWhereUniqueInput | experiencesWhereUniqueInput[]
    disconnect?: experiencesWhereUniqueInput | experiencesWhereUniqueInput[]
    delete?: experiencesWhereUniqueInput | experiencesWhereUniqueInput[]
    connect?: experiencesWhereUniqueInput | experiencesWhereUniqueInput[]
    update?: experiencesUpdateWithWhereUniqueWithoutCvsInput | experiencesUpdateWithWhereUniqueWithoutCvsInput[]
    updateMany?: experiencesUpdateManyWithWhereWithoutCvsInput | experiencesUpdateManyWithWhereWithoutCvsInput[]
    deleteMany?: experiencesScalarWhereInput | experiencesScalarWhereInput[]
  }

  export type projectsUpdateManyWithoutCvsNestedInput = {
    create?: XOR<projectsCreateWithoutCvsInput, projectsUncheckedCreateWithoutCvsInput> | projectsCreateWithoutCvsInput[] | projectsUncheckedCreateWithoutCvsInput[]
    connectOrCreate?: projectsCreateOrConnectWithoutCvsInput | projectsCreateOrConnectWithoutCvsInput[]
    upsert?: projectsUpsertWithWhereUniqueWithoutCvsInput | projectsUpsertWithWhereUniqueWithoutCvsInput[]
    createMany?: projectsCreateManyCvsInputEnvelope
    set?: projectsWhereUniqueInput | projectsWhereUniqueInput[]
    disconnect?: projectsWhereUniqueInput | projectsWhereUniqueInput[]
    delete?: projectsWhereUniqueInput | projectsWhereUniqueInput[]
    connect?: projectsWhereUniqueInput | projectsWhereUniqueInput[]
    update?: projectsUpdateWithWhereUniqueWithoutCvsInput | projectsUpdateWithWhereUniqueWithoutCvsInput[]
    updateMany?: projectsUpdateManyWithWhereWithoutCvsInput | projectsUpdateManyWithWhereWithoutCvsInput[]
    deleteMany?: projectsScalarWhereInput | projectsScalarWhereInput[]
  }

  export type referencesUpdateManyWithoutCvsNestedInput = {
    create?: XOR<referencesCreateWithoutCvsInput, referencesUncheckedCreateWithoutCvsInput> | referencesCreateWithoutCvsInput[] | referencesUncheckedCreateWithoutCvsInput[]
    connectOrCreate?: referencesCreateOrConnectWithoutCvsInput | referencesCreateOrConnectWithoutCvsInput[]
    upsert?: referencesUpsertWithWhereUniqueWithoutCvsInput | referencesUpsertWithWhereUniqueWithoutCvsInput[]
    createMany?: referencesCreateManyCvsInputEnvelope
    set?: referencesWhereUniqueInput | referencesWhereUniqueInput[]
    disconnect?: referencesWhereUniqueInput | referencesWhereUniqueInput[]
    delete?: referencesWhereUniqueInput | referencesWhereUniqueInput[]
    connect?: referencesWhereUniqueInput | referencesWhereUniqueInput[]
    update?: referencesUpdateWithWhereUniqueWithoutCvsInput | referencesUpdateWithWhereUniqueWithoutCvsInput[]
    updateMany?: referencesUpdateManyWithWhereWithoutCvsInput | referencesUpdateManyWithWhereWithoutCvsInput[]
    deleteMany?: referencesScalarWhereInput | referencesScalarWhereInput[]
  }

  export type applicantsUncheckedUpdateManyWithoutCvsNestedInput = {
    create?: XOR<applicantsCreateWithoutCvsInput, applicantsUncheckedCreateWithoutCvsInput> | applicantsCreateWithoutCvsInput[] | applicantsUncheckedCreateWithoutCvsInput[]
    connectOrCreate?: applicantsCreateOrConnectWithoutCvsInput | applicantsCreateOrConnectWithoutCvsInput[]
    upsert?: applicantsUpsertWithWhereUniqueWithoutCvsInput | applicantsUpsertWithWhereUniqueWithoutCvsInput[]
    createMany?: applicantsCreateManyCvsInputEnvelope
    set?: applicantsWhereUniqueInput | applicantsWhereUniqueInput[]
    disconnect?: applicantsWhereUniqueInput | applicantsWhereUniqueInput[]
    delete?: applicantsWhereUniqueInput | applicantsWhereUniqueInput[]
    connect?: applicantsWhereUniqueInput | applicantsWhereUniqueInput[]
    update?: applicantsUpdateWithWhereUniqueWithoutCvsInput | applicantsUpdateWithWhereUniqueWithoutCvsInput[]
    updateMany?: applicantsUpdateManyWithWhereWithoutCvsInput | applicantsUpdateManyWithWhereWithoutCvsInput[]
    deleteMany?: applicantsScalarWhereInput | applicantsScalarWhereInput[]
  }

  export type awardsUncheckedUpdateManyWithoutCvsNestedInput = {
    create?: XOR<awardsCreateWithoutCvsInput, awardsUncheckedCreateWithoutCvsInput> | awardsCreateWithoutCvsInput[] | awardsUncheckedCreateWithoutCvsInput[]
    connectOrCreate?: awardsCreateOrConnectWithoutCvsInput | awardsCreateOrConnectWithoutCvsInput[]
    upsert?: awardsUpsertWithWhereUniqueWithoutCvsInput | awardsUpsertWithWhereUniqueWithoutCvsInput[]
    createMany?: awardsCreateManyCvsInputEnvelope
    set?: awardsWhereUniqueInput | awardsWhereUniqueInput[]
    disconnect?: awardsWhereUniqueInput | awardsWhereUniqueInput[]
    delete?: awardsWhereUniqueInput | awardsWhereUniqueInput[]
    connect?: awardsWhereUniqueInput | awardsWhereUniqueInput[]
    update?: awardsUpdateWithWhereUniqueWithoutCvsInput | awardsUpdateWithWhereUniqueWithoutCvsInput[]
    updateMany?: awardsUpdateManyWithWhereWithoutCvsInput | awardsUpdateManyWithWhereWithoutCvsInput[]
    deleteMany?: awardsScalarWhereInput | awardsScalarWhereInput[]
  }

  export type certificatesUncheckedUpdateManyWithoutCvsNestedInput = {
    create?: XOR<certificatesCreateWithoutCvsInput, certificatesUncheckedCreateWithoutCvsInput> | certificatesCreateWithoutCvsInput[] | certificatesUncheckedCreateWithoutCvsInput[]
    connectOrCreate?: certificatesCreateOrConnectWithoutCvsInput | certificatesCreateOrConnectWithoutCvsInput[]
    upsert?: certificatesUpsertWithWhereUniqueWithoutCvsInput | certificatesUpsertWithWhereUniqueWithoutCvsInput[]
    createMany?: certificatesCreateManyCvsInputEnvelope
    set?: certificatesWhereUniqueInput | certificatesWhereUniqueInput[]
    disconnect?: certificatesWhereUniqueInput | certificatesWhereUniqueInput[]
    delete?: certificatesWhereUniqueInput | certificatesWhereUniqueInput[]
    connect?: certificatesWhereUniqueInput | certificatesWhereUniqueInput[]
    update?: certificatesUpdateWithWhereUniqueWithoutCvsInput | certificatesUpdateWithWhereUniqueWithoutCvsInput[]
    updateMany?: certificatesUpdateManyWithWhereWithoutCvsInput | certificatesUpdateManyWithWhereWithoutCvsInput[]
    deleteMany?: certificatesScalarWhereInput | certificatesScalarWhereInput[]
  }

  export type educationsUncheckedUpdateManyWithoutCvsNestedInput = {
    create?: XOR<educationsCreateWithoutCvsInput, educationsUncheckedCreateWithoutCvsInput> | educationsCreateWithoutCvsInput[] | educationsUncheckedCreateWithoutCvsInput[]
    connectOrCreate?: educationsCreateOrConnectWithoutCvsInput | educationsCreateOrConnectWithoutCvsInput[]
    upsert?: educationsUpsertWithWhereUniqueWithoutCvsInput | educationsUpsertWithWhereUniqueWithoutCvsInput[]
    createMany?: educationsCreateManyCvsInputEnvelope
    set?: educationsWhereUniqueInput | educationsWhereUniqueInput[]
    disconnect?: educationsWhereUniqueInput | educationsWhereUniqueInput[]
    delete?: educationsWhereUniqueInput | educationsWhereUniqueInput[]
    connect?: educationsWhereUniqueInput | educationsWhereUniqueInput[]
    update?: educationsUpdateWithWhereUniqueWithoutCvsInput | educationsUpdateWithWhereUniqueWithoutCvsInput[]
    updateMany?: educationsUpdateManyWithWhereWithoutCvsInput | educationsUpdateManyWithWhereWithoutCvsInput[]
    deleteMany?: educationsScalarWhereInput | educationsScalarWhereInput[]
  }

  export type experiencesUncheckedUpdateManyWithoutCvsNestedInput = {
    create?: XOR<experiencesCreateWithoutCvsInput, experiencesUncheckedCreateWithoutCvsInput> | experiencesCreateWithoutCvsInput[] | experiencesUncheckedCreateWithoutCvsInput[]
    connectOrCreate?: experiencesCreateOrConnectWithoutCvsInput | experiencesCreateOrConnectWithoutCvsInput[]
    upsert?: experiencesUpsertWithWhereUniqueWithoutCvsInput | experiencesUpsertWithWhereUniqueWithoutCvsInput[]
    createMany?: experiencesCreateManyCvsInputEnvelope
    set?: experiencesWhereUniqueInput | experiencesWhereUniqueInput[]
    disconnect?: experiencesWhereUniqueInput | experiencesWhereUniqueInput[]
    delete?: experiencesWhereUniqueInput | experiencesWhereUniqueInput[]
    connect?: experiencesWhereUniqueInput | experiencesWhereUniqueInput[]
    update?: experiencesUpdateWithWhereUniqueWithoutCvsInput | experiencesUpdateWithWhereUniqueWithoutCvsInput[]
    updateMany?: experiencesUpdateManyWithWhereWithoutCvsInput | experiencesUpdateManyWithWhereWithoutCvsInput[]
    deleteMany?: experiencesScalarWhereInput | experiencesScalarWhereInput[]
  }

  export type projectsUncheckedUpdateManyWithoutCvsNestedInput = {
    create?: XOR<projectsCreateWithoutCvsInput, projectsUncheckedCreateWithoutCvsInput> | projectsCreateWithoutCvsInput[] | projectsUncheckedCreateWithoutCvsInput[]
    connectOrCreate?: projectsCreateOrConnectWithoutCvsInput | projectsCreateOrConnectWithoutCvsInput[]
    upsert?: projectsUpsertWithWhereUniqueWithoutCvsInput | projectsUpsertWithWhereUniqueWithoutCvsInput[]
    createMany?: projectsCreateManyCvsInputEnvelope
    set?: projectsWhereUniqueInput | projectsWhereUniqueInput[]
    disconnect?: projectsWhereUniqueInput | projectsWhereUniqueInput[]
    delete?: projectsWhereUniqueInput | projectsWhereUniqueInput[]
    connect?: projectsWhereUniqueInput | projectsWhereUniqueInput[]
    update?: projectsUpdateWithWhereUniqueWithoutCvsInput | projectsUpdateWithWhereUniqueWithoutCvsInput[]
    updateMany?: projectsUpdateManyWithWhereWithoutCvsInput | projectsUpdateManyWithWhereWithoutCvsInput[]
    deleteMany?: projectsScalarWhereInput | projectsScalarWhereInput[]
  }

  export type referencesUncheckedUpdateManyWithoutCvsNestedInput = {
    create?: XOR<referencesCreateWithoutCvsInput, referencesUncheckedCreateWithoutCvsInput> | referencesCreateWithoutCvsInput[] | referencesUncheckedCreateWithoutCvsInput[]
    connectOrCreate?: referencesCreateOrConnectWithoutCvsInput | referencesCreateOrConnectWithoutCvsInput[]
    upsert?: referencesUpsertWithWhereUniqueWithoutCvsInput | referencesUpsertWithWhereUniqueWithoutCvsInput[]
    createMany?: referencesCreateManyCvsInputEnvelope
    set?: referencesWhereUniqueInput | referencesWhereUniqueInput[]
    disconnect?: referencesWhereUniqueInput | referencesWhereUniqueInput[]
    delete?: referencesWhereUniqueInput | referencesWhereUniqueInput[]
    connect?: referencesWhereUniqueInput | referencesWhereUniqueInput[]
    update?: referencesUpdateWithWhereUniqueWithoutCvsInput | referencesUpdateWithWhereUniqueWithoutCvsInput[]
    updateMany?: referencesUpdateManyWithWhereWithoutCvsInput | referencesUpdateManyWithWhereWithoutCvsInput[]
    deleteMany?: referencesScalarWhereInput | referencesScalarWhereInput[]
  }

  export type cvsCreateNestedOneWithoutEducationsInput = {
    create?: XOR<cvsCreateWithoutEducationsInput, cvsUncheckedCreateWithoutEducationsInput>
    connectOrCreate?: cvsCreateOrConnectWithoutEducationsInput
    connect?: cvsWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type cvsUpdateOneRequiredWithoutEducationsNestedInput = {
    create?: XOR<cvsCreateWithoutEducationsInput, cvsUncheckedCreateWithoutEducationsInput>
    connectOrCreate?: cvsCreateOrConnectWithoutEducationsInput
    upsert?: cvsUpsertWithoutEducationsInput
    connect?: cvsWhereUniqueInput
    update?: XOR<XOR<cvsUpdateToOneWithWhereWithoutEducationsInput, cvsUpdateWithoutEducationsInput>, cvsUncheckedUpdateWithoutEducationsInput>
  }

  export type cvsCreateNestedOneWithoutExperiencesInput = {
    create?: XOR<cvsCreateWithoutExperiencesInput, cvsUncheckedCreateWithoutExperiencesInput>
    connectOrCreate?: cvsCreateOrConnectWithoutExperiencesInput
    connect?: cvsWhereUniqueInput
  }

  export type cvsUpdateOneRequiredWithoutExperiencesNestedInput = {
    create?: XOR<cvsCreateWithoutExperiencesInput, cvsUncheckedCreateWithoutExperiencesInput>
    connectOrCreate?: cvsCreateOrConnectWithoutExperiencesInput
    upsert?: cvsUpsertWithoutExperiencesInput
    connect?: cvsWhereUniqueInput
    update?: XOR<XOR<cvsUpdateToOneWithWhereWithoutExperiencesInput, cvsUpdateWithoutExperiencesInput>, cvsUncheckedUpdateWithoutExperiencesInput>
  }

  export type membershipPlansCreateNestedOneWithoutFeaturesInput = {
    create?: XOR<membershipPlansCreateWithoutFeaturesInput, membershipPlansUncheckedCreateWithoutFeaturesInput>
    connectOrCreate?: membershipPlansCreateOrConnectWithoutFeaturesInput
    connect?: membershipPlansWhereUniqueInput
  }

  export type membershipPlansUpdateOneWithoutFeaturesNestedInput = {
    create?: XOR<membershipPlansCreateWithoutFeaturesInput, membershipPlansUncheckedCreateWithoutFeaturesInput>
    connectOrCreate?: membershipPlansCreateOrConnectWithoutFeaturesInput
    upsert?: membershipPlansUpsertWithoutFeaturesInput
    disconnect?: membershipPlansWhereInput | boolean
    delete?: membershipPlansWhereInput | boolean
    connect?: membershipPlansWhereUniqueInput
    update?: XOR<XOR<membershipPlansUpdateToOneWithWhereWithoutFeaturesInput, membershipPlansUpdateWithoutFeaturesInput>, membershipPlansUncheckedUpdateWithoutFeaturesInput>
  }

  export type companiesCreateNestedOneWithoutFeedbacksInput = {
    create?: XOR<companiesCreateWithoutFeedbacksInput, companiesUncheckedCreateWithoutFeedbacksInput>
    connectOrCreate?: companiesCreateOrConnectWithoutFeedbacksInput
    connect?: companiesWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutFeedbacksInput = {
    create?: XOR<usersCreateWithoutFeedbacksInput, usersUncheckedCreateWithoutFeedbacksInput>
    connectOrCreate?: usersCreateOrConnectWithoutFeedbacksInput
    connect?: usersWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type companiesUpdateOneRequiredWithoutFeedbacksNestedInput = {
    create?: XOR<companiesCreateWithoutFeedbacksInput, companiesUncheckedCreateWithoutFeedbacksInput>
    connectOrCreate?: companiesCreateOrConnectWithoutFeedbacksInput
    upsert?: companiesUpsertWithoutFeedbacksInput
    connect?: companiesWhereUniqueInput
    update?: XOR<XOR<companiesUpdateToOneWithWhereWithoutFeedbacksInput, companiesUpdateWithoutFeedbacksInput>, companiesUncheckedUpdateWithoutFeedbacksInput>
  }

  export type usersUpdateOneRequiredWithoutFeedbacksNestedInput = {
    create?: XOR<usersCreateWithoutFeedbacksInput, usersUncheckedCreateWithoutFeedbacksInput>
    connectOrCreate?: usersCreateOrConnectWithoutFeedbacksInput
    upsert?: usersUpsertWithoutFeedbacksInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutFeedbacksInput, usersUpdateWithoutFeedbacksInput>, usersUncheckedUpdateWithoutFeedbacksInput>
  }

  export type companiesCreateNestedManyWithoutFieldsInput = {
    create?: XOR<companiesCreateWithoutFieldsInput, companiesUncheckedCreateWithoutFieldsInput> | companiesCreateWithoutFieldsInput[] | companiesUncheckedCreateWithoutFieldsInput[]
    connectOrCreate?: companiesCreateOrConnectWithoutFieldsInput | companiesCreateOrConnectWithoutFieldsInput[]
    createMany?: companiesCreateManyFieldsInputEnvelope
    connect?: companiesWhereUniqueInput | companiesWhereUniqueInput[]
  }

  export type companiesUncheckedCreateNestedManyWithoutFieldsInput = {
    create?: XOR<companiesCreateWithoutFieldsInput, companiesUncheckedCreateWithoutFieldsInput> | companiesCreateWithoutFieldsInput[] | companiesUncheckedCreateWithoutFieldsInput[]
    connectOrCreate?: companiesCreateOrConnectWithoutFieldsInput | companiesCreateOrConnectWithoutFieldsInput[]
    createMany?: companiesCreateManyFieldsInputEnvelope
    connect?: companiesWhereUniqueInput | companiesWhereUniqueInput[]
  }

  export type companiesUpdateManyWithoutFieldsNestedInput = {
    create?: XOR<companiesCreateWithoutFieldsInput, companiesUncheckedCreateWithoutFieldsInput> | companiesCreateWithoutFieldsInput[] | companiesUncheckedCreateWithoutFieldsInput[]
    connectOrCreate?: companiesCreateOrConnectWithoutFieldsInput | companiesCreateOrConnectWithoutFieldsInput[]
    upsert?: companiesUpsertWithWhereUniqueWithoutFieldsInput | companiesUpsertWithWhereUniqueWithoutFieldsInput[]
    createMany?: companiesCreateManyFieldsInputEnvelope
    set?: companiesWhereUniqueInput | companiesWhereUniqueInput[]
    disconnect?: companiesWhereUniqueInput | companiesWhereUniqueInput[]
    delete?: companiesWhereUniqueInput | companiesWhereUniqueInput[]
    connect?: companiesWhereUniqueInput | companiesWhereUniqueInput[]
    update?: companiesUpdateWithWhereUniqueWithoutFieldsInput | companiesUpdateWithWhereUniqueWithoutFieldsInput[]
    updateMany?: companiesUpdateManyWithWhereWithoutFieldsInput | companiesUpdateManyWithWhereWithoutFieldsInput[]
    deleteMany?: companiesScalarWhereInput | companiesScalarWhereInput[]
  }

  export type companiesUncheckedUpdateManyWithoutFieldsNestedInput = {
    create?: XOR<companiesCreateWithoutFieldsInput, companiesUncheckedCreateWithoutFieldsInput> | companiesCreateWithoutFieldsInput[] | companiesUncheckedCreateWithoutFieldsInput[]
    connectOrCreate?: companiesCreateOrConnectWithoutFieldsInput | companiesCreateOrConnectWithoutFieldsInput[]
    upsert?: companiesUpsertWithWhereUniqueWithoutFieldsInput | companiesUpsertWithWhereUniqueWithoutFieldsInput[]
    createMany?: companiesCreateManyFieldsInputEnvelope
    set?: companiesWhereUniqueInput | companiesWhereUniqueInput[]
    disconnect?: companiesWhereUniqueInput | companiesWhereUniqueInput[]
    delete?: companiesWhereUniqueInput | companiesWhereUniqueInput[]
    connect?: companiesWhereUniqueInput | companiesWhereUniqueInput[]
    update?: companiesUpdateWithWhereUniqueWithoutFieldsInput | companiesUpdateWithWhereUniqueWithoutFieldsInput[]
    updateMany?: companiesUpdateManyWithWhereWithoutFieldsInput | companiesUpdateManyWithWhereWithoutFieldsInput[]
    deleteMany?: companiesScalarWhereInput | companiesScalarWhereInput[]
  }

  export type companiesCreateNestedOneWithoutFollowedCompaniesInput = {
    create?: XOR<companiesCreateWithoutFollowedCompaniesInput, companiesUncheckedCreateWithoutFollowedCompaniesInput>
    connectOrCreate?: companiesCreateOrConnectWithoutFollowedCompaniesInput
    connect?: companiesWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutFollowedCompaniesInput = {
    create?: XOR<usersCreateWithoutFollowedCompaniesInput, usersUncheckedCreateWithoutFollowedCompaniesInput>
    connectOrCreate?: usersCreateOrConnectWithoutFollowedCompaniesInput
    connect?: usersWhereUniqueInput
  }

  export type companiesUpdateOneRequiredWithoutFollowedCompaniesNestedInput = {
    create?: XOR<companiesCreateWithoutFollowedCompaniesInput, companiesUncheckedCreateWithoutFollowedCompaniesInput>
    connectOrCreate?: companiesCreateOrConnectWithoutFollowedCompaniesInput
    upsert?: companiesUpsertWithoutFollowedCompaniesInput
    connect?: companiesWhereUniqueInput
    update?: XOR<XOR<companiesUpdateToOneWithWhereWithoutFollowedCompaniesInput, companiesUpdateWithoutFollowedCompaniesInput>, companiesUncheckedUpdateWithoutFollowedCompaniesInput>
  }

  export type usersUpdateOneRequiredWithoutFollowedCompaniesNestedInput = {
    create?: XOR<usersCreateWithoutFollowedCompaniesInput, usersUncheckedCreateWithoutFollowedCompaniesInput>
    connectOrCreate?: usersCreateOrConnectWithoutFollowedCompaniesInput
    upsert?: usersUpsertWithoutFollowedCompaniesInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutFollowedCompaniesInput, usersUpdateWithoutFollowedCompaniesInput>, usersUncheckedUpdateWithoutFollowedCompaniesInput>
  }

  export type jobSpecializedCreateNestedManyWithoutJobCategoriesInput = {
    create?: XOR<jobSpecializedCreateWithoutJobCategoriesInput, jobSpecializedUncheckedCreateWithoutJobCategoriesInput> | jobSpecializedCreateWithoutJobCategoriesInput[] | jobSpecializedUncheckedCreateWithoutJobCategoriesInput[]
    connectOrCreate?: jobSpecializedCreateOrConnectWithoutJobCategoriesInput | jobSpecializedCreateOrConnectWithoutJobCategoriesInput[]
    createMany?: jobSpecializedCreateManyJobCategoriesInputEnvelope
    connect?: jobSpecializedWhereUniqueInput | jobSpecializedWhereUniqueInput[]
  }

  export type jobSpecializedUncheckedCreateNestedManyWithoutJobCategoriesInput = {
    create?: XOR<jobSpecializedCreateWithoutJobCategoriesInput, jobSpecializedUncheckedCreateWithoutJobCategoriesInput> | jobSpecializedCreateWithoutJobCategoriesInput[] | jobSpecializedUncheckedCreateWithoutJobCategoriesInput[]
    connectOrCreate?: jobSpecializedCreateOrConnectWithoutJobCategoriesInput | jobSpecializedCreateOrConnectWithoutJobCategoriesInput[]
    createMany?: jobSpecializedCreateManyJobCategoriesInputEnvelope
    connect?: jobSpecializedWhereUniqueInput | jobSpecializedWhereUniqueInput[]
  }

  export type jobSpecializedUpdateManyWithoutJobCategoriesNestedInput = {
    create?: XOR<jobSpecializedCreateWithoutJobCategoriesInput, jobSpecializedUncheckedCreateWithoutJobCategoriesInput> | jobSpecializedCreateWithoutJobCategoriesInput[] | jobSpecializedUncheckedCreateWithoutJobCategoriesInput[]
    connectOrCreate?: jobSpecializedCreateOrConnectWithoutJobCategoriesInput | jobSpecializedCreateOrConnectWithoutJobCategoriesInput[]
    upsert?: jobSpecializedUpsertWithWhereUniqueWithoutJobCategoriesInput | jobSpecializedUpsertWithWhereUniqueWithoutJobCategoriesInput[]
    createMany?: jobSpecializedCreateManyJobCategoriesInputEnvelope
    set?: jobSpecializedWhereUniqueInput | jobSpecializedWhereUniqueInput[]
    disconnect?: jobSpecializedWhereUniqueInput | jobSpecializedWhereUniqueInput[]
    delete?: jobSpecializedWhereUniqueInput | jobSpecializedWhereUniqueInput[]
    connect?: jobSpecializedWhereUniqueInput | jobSpecializedWhereUniqueInput[]
    update?: jobSpecializedUpdateWithWhereUniqueWithoutJobCategoriesInput | jobSpecializedUpdateWithWhereUniqueWithoutJobCategoriesInput[]
    updateMany?: jobSpecializedUpdateManyWithWhereWithoutJobCategoriesInput | jobSpecializedUpdateManyWithWhereWithoutJobCategoriesInput[]
    deleteMany?: jobSpecializedScalarWhereInput | jobSpecializedScalarWhereInput[]
  }

  export type jobSpecializedUncheckedUpdateManyWithoutJobCategoriesNestedInput = {
    create?: XOR<jobSpecializedCreateWithoutJobCategoriesInput, jobSpecializedUncheckedCreateWithoutJobCategoriesInput> | jobSpecializedCreateWithoutJobCategoriesInput[] | jobSpecializedUncheckedCreateWithoutJobCategoriesInput[]
    connectOrCreate?: jobSpecializedCreateOrConnectWithoutJobCategoriesInput | jobSpecializedCreateOrConnectWithoutJobCategoriesInput[]
    upsert?: jobSpecializedUpsertWithWhereUniqueWithoutJobCategoriesInput | jobSpecializedUpsertWithWhereUniqueWithoutJobCategoriesInput[]
    createMany?: jobSpecializedCreateManyJobCategoriesInputEnvelope
    set?: jobSpecializedWhereUniqueInput | jobSpecializedWhereUniqueInput[]
    disconnect?: jobSpecializedWhereUniqueInput | jobSpecializedWhereUniqueInput[]
    delete?: jobSpecializedWhereUniqueInput | jobSpecializedWhereUniqueInput[]
    connect?: jobSpecializedWhereUniqueInput | jobSpecializedWhereUniqueInput[]
    update?: jobSpecializedUpdateWithWhereUniqueWithoutJobCategoriesInput | jobSpecializedUpdateWithWhereUniqueWithoutJobCategoriesInput[]
    updateMany?: jobSpecializedUpdateManyWithWhereWithoutJobCategoriesInput | jobSpecializedUpdateManyWithWhereWithoutJobCategoriesInput[]
    deleteMany?: jobSpecializedScalarWhereInput | jobSpecializedScalarWhereInput[]
  }

  export type jobsCreateNestedManyWithoutJobLabelsInput = {
    create?: XOR<jobsCreateWithoutJobLabelsInput, jobsUncheckedCreateWithoutJobLabelsInput> | jobsCreateWithoutJobLabelsInput[] | jobsUncheckedCreateWithoutJobLabelsInput[]
    connectOrCreate?: jobsCreateOrConnectWithoutJobLabelsInput | jobsCreateOrConnectWithoutJobLabelsInput[]
    createMany?: jobsCreateManyJobLabelsInputEnvelope
    connect?: jobsWhereUniqueInput | jobsWhereUniqueInput[]
  }

  export type jobsUncheckedCreateNestedManyWithoutJobLabelsInput = {
    create?: XOR<jobsCreateWithoutJobLabelsInput, jobsUncheckedCreateWithoutJobLabelsInput> | jobsCreateWithoutJobLabelsInput[] | jobsUncheckedCreateWithoutJobLabelsInput[]
    connectOrCreate?: jobsCreateOrConnectWithoutJobLabelsInput | jobsCreateOrConnectWithoutJobLabelsInput[]
    createMany?: jobsCreateManyJobLabelsInputEnvelope
    connect?: jobsWhereUniqueInput | jobsWhereUniqueInput[]
  }

  export type jobsUpdateManyWithoutJobLabelsNestedInput = {
    create?: XOR<jobsCreateWithoutJobLabelsInput, jobsUncheckedCreateWithoutJobLabelsInput> | jobsCreateWithoutJobLabelsInput[] | jobsUncheckedCreateWithoutJobLabelsInput[]
    connectOrCreate?: jobsCreateOrConnectWithoutJobLabelsInput | jobsCreateOrConnectWithoutJobLabelsInput[]
    upsert?: jobsUpsertWithWhereUniqueWithoutJobLabelsInput | jobsUpsertWithWhereUniqueWithoutJobLabelsInput[]
    createMany?: jobsCreateManyJobLabelsInputEnvelope
    set?: jobsWhereUniqueInput | jobsWhereUniqueInput[]
    disconnect?: jobsWhereUniqueInput | jobsWhereUniqueInput[]
    delete?: jobsWhereUniqueInput | jobsWhereUniqueInput[]
    connect?: jobsWhereUniqueInput | jobsWhereUniqueInput[]
    update?: jobsUpdateWithWhereUniqueWithoutJobLabelsInput | jobsUpdateWithWhereUniqueWithoutJobLabelsInput[]
    updateMany?: jobsUpdateManyWithWhereWithoutJobLabelsInput | jobsUpdateManyWithWhereWithoutJobLabelsInput[]
    deleteMany?: jobsScalarWhereInput | jobsScalarWhereInput[]
  }

  export type jobsUncheckedUpdateManyWithoutJobLabelsNestedInput = {
    create?: XOR<jobsCreateWithoutJobLabelsInput, jobsUncheckedCreateWithoutJobLabelsInput> | jobsCreateWithoutJobLabelsInput[] | jobsUncheckedCreateWithoutJobLabelsInput[]
    connectOrCreate?: jobsCreateOrConnectWithoutJobLabelsInput | jobsCreateOrConnectWithoutJobLabelsInput[]
    upsert?: jobsUpsertWithWhereUniqueWithoutJobLabelsInput | jobsUpsertWithWhereUniqueWithoutJobLabelsInput[]
    createMany?: jobsCreateManyJobLabelsInputEnvelope
    set?: jobsWhereUniqueInput | jobsWhereUniqueInput[]
    disconnect?: jobsWhereUniqueInput | jobsWhereUniqueInput[]
    delete?: jobsWhereUniqueInput | jobsWhereUniqueInput[]
    connect?: jobsWhereUniqueInput | jobsWhereUniqueInput[]
    update?: jobsUpdateWithWhereUniqueWithoutJobLabelsInput | jobsUpdateWithWhereUniqueWithoutJobLabelsInput[]
    updateMany?: jobsUpdateManyWithWhereWithoutJobLabelsInput | jobsUpdateManyWithWhereWithoutJobLabelsInput[]
    deleteMany?: jobsScalarWhereInput | jobsScalarWhereInput[]
  }

  export type careerPathsCreateNestedOneWithoutJobSpecializedInput = {
    create?: XOR<careerPathsCreateWithoutJobSpecializedInput, careerPathsUncheckedCreateWithoutJobSpecializedInput>
    connectOrCreate?: careerPathsCreateOrConnectWithoutJobSpecializedInput
    connect?: careerPathsWhereUniqueInput
  }

  export type jobCategoriesCreateNestedOneWithoutJobSpecializedInput = {
    create?: XOR<jobCategoriesCreateWithoutJobSpecializedInput, jobCategoriesUncheckedCreateWithoutJobSpecializedInput>
    connectOrCreate?: jobCategoriesCreateOrConnectWithoutJobSpecializedInput
    connect?: jobCategoriesWhereUniqueInput
  }

  export type careerPathsUncheckedCreateNestedOneWithoutJobSpecializedInput = {
    create?: XOR<careerPathsCreateWithoutJobSpecializedInput, careerPathsUncheckedCreateWithoutJobSpecializedInput>
    connectOrCreate?: careerPathsCreateOrConnectWithoutJobSpecializedInput
    connect?: careerPathsWhereUniqueInput
  }

  export type careerPathsUpdateOneWithoutJobSpecializedNestedInput = {
    create?: XOR<careerPathsCreateWithoutJobSpecializedInput, careerPathsUncheckedCreateWithoutJobSpecializedInput>
    connectOrCreate?: careerPathsCreateOrConnectWithoutJobSpecializedInput
    upsert?: careerPathsUpsertWithoutJobSpecializedInput
    disconnect?: careerPathsWhereInput | boolean
    delete?: careerPathsWhereInput | boolean
    connect?: careerPathsWhereUniqueInput
    update?: XOR<XOR<careerPathsUpdateToOneWithWhereWithoutJobSpecializedInput, careerPathsUpdateWithoutJobSpecializedInput>, careerPathsUncheckedUpdateWithoutJobSpecializedInput>
  }

  export type jobCategoriesUpdateOneRequiredWithoutJobSpecializedNestedInput = {
    create?: XOR<jobCategoriesCreateWithoutJobSpecializedInput, jobCategoriesUncheckedCreateWithoutJobSpecializedInput>
    connectOrCreate?: jobCategoriesCreateOrConnectWithoutJobSpecializedInput
    upsert?: jobCategoriesUpsertWithoutJobSpecializedInput
    connect?: jobCategoriesWhereUniqueInput
    update?: XOR<XOR<jobCategoriesUpdateToOneWithWhereWithoutJobSpecializedInput, jobCategoriesUpdateWithoutJobSpecializedInput>, jobCategoriesUncheckedUpdateWithoutJobSpecializedInput>
  }

  export type careerPathsUncheckedUpdateOneWithoutJobSpecializedNestedInput = {
    create?: XOR<careerPathsCreateWithoutJobSpecializedInput, careerPathsUncheckedCreateWithoutJobSpecializedInput>
    connectOrCreate?: careerPathsCreateOrConnectWithoutJobSpecializedInput
    upsert?: careerPathsUpsertWithoutJobSpecializedInput
    disconnect?: careerPathsWhereInput | boolean
    delete?: careerPathsWhereInput | boolean
    connect?: careerPathsWhereUniqueInput
    update?: XOR<XOR<careerPathsUpdateToOneWithWhereWithoutJobSpecializedInput, careerPathsUpdateWithoutJobSpecializedInput>, careerPathsUncheckedUpdateWithoutJobSpecializedInput>
  }

  export type jobsCreatesalaryInput = {
    set: string[]
  }

  export type jobsCreateskill_tagsInput = {
    set: string[]
  }

  export type applicantsCreateNestedManyWithoutJobsInput = {
    create?: XOR<applicantsCreateWithoutJobsInput, applicantsUncheckedCreateWithoutJobsInput> | applicantsCreateWithoutJobsInput[] | applicantsUncheckedCreateWithoutJobsInput[]
    connectOrCreate?: applicantsCreateOrConnectWithoutJobsInput | applicantsCreateOrConnectWithoutJobsInput[]
    createMany?: applicantsCreateManyJobsInputEnvelope
    connect?: applicantsWhereUniqueInput | applicantsWhereUniqueInput[]
  }

  export type categoriesCreateNestedOneWithoutJobsInput = {
    create?: XOR<categoriesCreateWithoutJobsInput, categoriesUncheckedCreateWithoutJobsInput>
    connectOrCreate?: categoriesCreateOrConnectWithoutJobsInput
    connect?: categoriesWhereUniqueInput
  }

  export type jobLabelsCreateNestedOneWithoutJobsInput = {
    create?: XOR<jobLabelsCreateWithoutJobsInput, jobLabelsUncheckedCreateWithoutJobsInput>
    connectOrCreate?: jobLabelsCreateOrConnectWithoutJobsInput
    connect?: jobLabelsWhereUniqueInput
  }

  export type savedJobsCreateNestedManyWithoutJobsInput = {
    create?: XOR<savedJobsCreateWithoutJobsInput, savedJobsUncheckedCreateWithoutJobsInput> | savedJobsCreateWithoutJobsInput[] | savedJobsUncheckedCreateWithoutJobsInput[]
    connectOrCreate?: savedJobsCreateOrConnectWithoutJobsInput | savedJobsCreateOrConnectWithoutJobsInput[]
    createMany?: savedJobsCreateManyJobsInputEnvelope
    connect?: savedJobsWhereUniqueInput | savedJobsWhereUniqueInput[]
  }

  export type applicantsUncheckedCreateNestedManyWithoutJobsInput = {
    create?: XOR<applicantsCreateWithoutJobsInput, applicantsUncheckedCreateWithoutJobsInput> | applicantsCreateWithoutJobsInput[] | applicantsUncheckedCreateWithoutJobsInput[]
    connectOrCreate?: applicantsCreateOrConnectWithoutJobsInput | applicantsCreateOrConnectWithoutJobsInput[]
    createMany?: applicantsCreateManyJobsInputEnvelope
    connect?: applicantsWhereUniqueInput | applicantsWhereUniqueInput[]
  }

  export type savedJobsUncheckedCreateNestedManyWithoutJobsInput = {
    create?: XOR<savedJobsCreateWithoutJobsInput, savedJobsUncheckedCreateWithoutJobsInput> | savedJobsCreateWithoutJobsInput[] | savedJobsUncheckedCreateWithoutJobsInput[]
    connectOrCreate?: savedJobsCreateOrConnectWithoutJobsInput | savedJobsCreateOrConnectWithoutJobsInput[]
    createMany?: savedJobsCreateManyJobsInputEnvelope
    connect?: savedJobsWhereUniqueInput | savedJobsWhereUniqueInput[]
  }

  export type jobsUpdatesalaryInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableEnumJob_TypeFieldUpdateOperationsInput = {
    set?: $Enums.Job_Type | null
  }

  export type NullableEnumJob_StatusFieldUpdateOperationsInput = {
    set?: $Enums.Job_Status | null
  }

  export type jobsUpdateskill_tagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableEnumEducationFieldUpdateOperationsInput = {
    set?: $Enums.Education | null
  }

  export type applicantsUpdateManyWithoutJobsNestedInput = {
    create?: XOR<applicantsCreateWithoutJobsInput, applicantsUncheckedCreateWithoutJobsInput> | applicantsCreateWithoutJobsInput[] | applicantsUncheckedCreateWithoutJobsInput[]
    connectOrCreate?: applicantsCreateOrConnectWithoutJobsInput | applicantsCreateOrConnectWithoutJobsInput[]
    upsert?: applicantsUpsertWithWhereUniqueWithoutJobsInput | applicantsUpsertWithWhereUniqueWithoutJobsInput[]
    createMany?: applicantsCreateManyJobsInputEnvelope
    set?: applicantsWhereUniqueInput | applicantsWhereUniqueInput[]
    disconnect?: applicantsWhereUniqueInput | applicantsWhereUniqueInput[]
    delete?: applicantsWhereUniqueInput | applicantsWhereUniqueInput[]
    connect?: applicantsWhereUniqueInput | applicantsWhereUniqueInput[]
    update?: applicantsUpdateWithWhereUniqueWithoutJobsInput | applicantsUpdateWithWhereUniqueWithoutJobsInput[]
    updateMany?: applicantsUpdateManyWithWhereWithoutJobsInput | applicantsUpdateManyWithWhereWithoutJobsInput[]
    deleteMany?: applicantsScalarWhereInput | applicantsScalarWhereInput[]
  }

  export type categoriesUpdateOneWithoutJobsNestedInput = {
    create?: XOR<categoriesCreateWithoutJobsInput, categoriesUncheckedCreateWithoutJobsInput>
    connectOrCreate?: categoriesCreateOrConnectWithoutJobsInput
    upsert?: categoriesUpsertWithoutJobsInput
    disconnect?: categoriesWhereInput | boolean
    delete?: categoriesWhereInput | boolean
    connect?: categoriesWhereUniqueInput
    update?: XOR<XOR<categoriesUpdateToOneWithWhereWithoutJobsInput, categoriesUpdateWithoutJobsInput>, categoriesUncheckedUpdateWithoutJobsInput>
  }

  export type jobLabelsUpdateOneWithoutJobsNestedInput = {
    create?: XOR<jobLabelsCreateWithoutJobsInput, jobLabelsUncheckedCreateWithoutJobsInput>
    connectOrCreate?: jobLabelsCreateOrConnectWithoutJobsInput
    upsert?: jobLabelsUpsertWithoutJobsInput
    disconnect?: jobLabelsWhereInput | boolean
    delete?: jobLabelsWhereInput | boolean
    connect?: jobLabelsWhereUniqueInput
    update?: XOR<XOR<jobLabelsUpdateToOneWithWhereWithoutJobsInput, jobLabelsUpdateWithoutJobsInput>, jobLabelsUncheckedUpdateWithoutJobsInput>
  }

  export type savedJobsUpdateManyWithoutJobsNestedInput = {
    create?: XOR<savedJobsCreateWithoutJobsInput, savedJobsUncheckedCreateWithoutJobsInput> | savedJobsCreateWithoutJobsInput[] | savedJobsUncheckedCreateWithoutJobsInput[]
    connectOrCreate?: savedJobsCreateOrConnectWithoutJobsInput | savedJobsCreateOrConnectWithoutJobsInput[]
    upsert?: savedJobsUpsertWithWhereUniqueWithoutJobsInput | savedJobsUpsertWithWhereUniqueWithoutJobsInput[]
    createMany?: savedJobsCreateManyJobsInputEnvelope
    set?: savedJobsWhereUniqueInput | savedJobsWhereUniqueInput[]
    disconnect?: savedJobsWhereUniqueInput | savedJobsWhereUniqueInput[]
    delete?: savedJobsWhereUniqueInput | savedJobsWhereUniqueInput[]
    connect?: savedJobsWhereUniqueInput | savedJobsWhereUniqueInput[]
    update?: savedJobsUpdateWithWhereUniqueWithoutJobsInput | savedJobsUpdateWithWhereUniqueWithoutJobsInput[]
    updateMany?: savedJobsUpdateManyWithWhereWithoutJobsInput | savedJobsUpdateManyWithWhereWithoutJobsInput[]
    deleteMany?: savedJobsScalarWhereInput | savedJobsScalarWhereInput[]
  }

  export type applicantsUncheckedUpdateManyWithoutJobsNestedInput = {
    create?: XOR<applicantsCreateWithoutJobsInput, applicantsUncheckedCreateWithoutJobsInput> | applicantsCreateWithoutJobsInput[] | applicantsUncheckedCreateWithoutJobsInput[]
    connectOrCreate?: applicantsCreateOrConnectWithoutJobsInput | applicantsCreateOrConnectWithoutJobsInput[]
    upsert?: applicantsUpsertWithWhereUniqueWithoutJobsInput | applicantsUpsertWithWhereUniqueWithoutJobsInput[]
    createMany?: applicantsCreateManyJobsInputEnvelope
    set?: applicantsWhereUniqueInput | applicantsWhereUniqueInput[]
    disconnect?: applicantsWhereUniqueInput | applicantsWhereUniqueInput[]
    delete?: applicantsWhereUniqueInput | applicantsWhereUniqueInput[]
    connect?: applicantsWhereUniqueInput | applicantsWhereUniqueInput[]
    update?: applicantsUpdateWithWhereUniqueWithoutJobsInput | applicantsUpdateWithWhereUniqueWithoutJobsInput[]
    updateMany?: applicantsUpdateManyWithWhereWithoutJobsInput | applicantsUpdateManyWithWhereWithoutJobsInput[]
    deleteMany?: applicantsScalarWhereInput | applicantsScalarWhereInput[]
  }

  export type savedJobsUncheckedUpdateManyWithoutJobsNestedInput = {
    create?: XOR<savedJobsCreateWithoutJobsInput, savedJobsUncheckedCreateWithoutJobsInput> | savedJobsCreateWithoutJobsInput[] | savedJobsUncheckedCreateWithoutJobsInput[]
    connectOrCreate?: savedJobsCreateOrConnectWithoutJobsInput | savedJobsCreateOrConnectWithoutJobsInput[]
    upsert?: savedJobsUpsertWithWhereUniqueWithoutJobsInput | savedJobsUpsertWithWhereUniqueWithoutJobsInput[]
    createMany?: savedJobsCreateManyJobsInputEnvelope
    set?: savedJobsWhereUniqueInput | savedJobsWhereUniqueInput[]
    disconnect?: savedJobsWhereUniqueInput | savedJobsWhereUniqueInput[]
    delete?: savedJobsWhereUniqueInput | savedJobsWhereUniqueInput[]
    connect?: savedJobsWhereUniqueInput | savedJobsWhereUniqueInput[]
    update?: savedJobsUpdateWithWhereUniqueWithoutJobsInput | savedJobsUpdateWithWhereUniqueWithoutJobsInput[]
    updateMany?: savedJobsUpdateManyWithWhereWithoutJobsInput | savedJobsUpdateManyWithWhereWithoutJobsInput[]
    deleteMany?: savedJobsScalarWhereInput | savedJobsScalarWhereInput[]
  }

  export type featuresCreateNestedManyWithoutMembershipPlansInput = {
    create?: XOR<featuresCreateWithoutMembershipPlansInput, featuresUncheckedCreateWithoutMembershipPlansInput> | featuresCreateWithoutMembershipPlansInput[] | featuresUncheckedCreateWithoutMembershipPlansInput[]
    connectOrCreate?: featuresCreateOrConnectWithoutMembershipPlansInput | featuresCreateOrConnectWithoutMembershipPlansInput[]
    createMany?: featuresCreateManyMembershipPlansInputEnvelope
    connect?: featuresWhereUniqueInput | featuresWhereUniqueInput[]
  }

  export type subscriptionsCreateNestedManyWithoutMembershipPlansInput = {
    create?: XOR<subscriptionsCreateWithoutMembershipPlansInput, subscriptionsUncheckedCreateWithoutMembershipPlansInput> | subscriptionsCreateWithoutMembershipPlansInput[] | subscriptionsUncheckedCreateWithoutMembershipPlansInput[]
    connectOrCreate?: subscriptionsCreateOrConnectWithoutMembershipPlansInput | subscriptionsCreateOrConnectWithoutMembershipPlansInput[]
    createMany?: subscriptionsCreateManyMembershipPlansInputEnvelope
    connect?: subscriptionsWhereUniqueInput | subscriptionsWhereUniqueInput[]
  }

  export type featuresUncheckedCreateNestedManyWithoutMembershipPlansInput = {
    create?: XOR<featuresCreateWithoutMembershipPlansInput, featuresUncheckedCreateWithoutMembershipPlansInput> | featuresCreateWithoutMembershipPlansInput[] | featuresUncheckedCreateWithoutMembershipPlansInput[]
    connectOrCreate?: featuresCreateOrConnectWithoutMembershipPlansInput | featuresCreateOrConnectWithoutMembershipPlansInput[]
    createMany?: featuresCreateManyMembershipPlansInputEnvelope
    connect?: featuresWhereUniqueInput | featuresWhereUniqueInput[]
  }

  export type subscriptionsUncheckedCreateNestedManyWithoutMembershipPlansInput = {
    create?: XOR<subscriptionsCreateWithoutMembershipPlansInput, subscriptionsUncheckedCreateWithoutMembershipPlansInput> | subscriptionsCreateWithoutMembershipPlansInput[] | subscriptionsUncheckedCreateWithoutMembershipPlansInput[]
    connectOrCreate?: subscriptionsCreateOrConnectWithoutMembershipPlansInput | subscriptionsCreateOrConnectWithoutMembershipPlansInput[]
    createMany?: subscriptionsCreateManyMembershipPlansInputEnvelope
    connect?: subscriptionsWhereUniqueInput | subscriptionsWhereUniqueInput[]
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type featuresUpdateManyWithoutMembershipPlansNestedInput = {
    create?: XOR<featuresCreateWithoutMembershipPlansInput, featuresUncheckedCreateWithoutMembershipPlansInput> | featuresCreateWithoutMembershipPlansInput[] | featuresUncheckedCreateWithoutMembershipPlansInput[]
    connectOrCreate?: featuresCreateOrConnectWithoutMembershipPlansInput | featuresCreateOrConnectWithoutMembershipPlansInput[]
    upsert?: featuresUpsertWithWhereUniqueWithoutMembershipPlansInput | featuresUpsertWithWhereUniqueWithoutMembershipPlansInput[]
    createMany?: featuresCreateManyMembershipPlansInputEnvelope
    set?: featuresWhereUniqueInput | featuresWhereUniqueInput[]
    disconnect?: featuresWhereUniqueInput | featuresWhereUniqueInput[]
    delete?: featuresWhereUniqueInput | featuresWhereUniqueInput[]
    connect?: featuresWhereUniqueInput | featuresWhereUniqueInput[]
    update?: featuresUpdateWithWhereUniqueWithoutMembershipPlansInput | featuresUpdateWithWhereUniqueWithoutMembershipPlansInput[]
    updateMany?: featuresUpdateManyWithWhereWithoutMembershipPlansInput | featuresUpdateManyWithWhereWithoutMembershipPlansInput[]
    deleteMany?: featuresScalarWhereInput | featuresScalarWhereInput[]
  }

  export type subscriptionsUpdateManyWithoutMembershipPlansNestedInput = {
    create?: XOR<subscriptionsCreateWithoutMembershipPlansInput, subscriptionsUncheckedCreateWithoutMembershipPlansInput> | subscriptionsCreateWithoutMembershipPlansInput[] | subscriptionsUncheckedCreateWithoutMembershipPlansInput[]
    connectOrCreate?: subscriptionsCreateOrConnectWithoutMembershipPlansInput | subscriptionsCreateOrConnectWithoutMembershipPlansInput[]
    upsert?: subscriptionsUpsertWithWhereUniqueWithoutMembershipPlansInput | subscriptionsUpsertWithWhereUniqueWithoutMembershipPlansInput[]
    createMany?: subscriptionsCreateManyMembershipPlansInputEnvelope
    set?: subscriptionsWhereUniqueInput | subscriptionsWhereUniqueInput[]
    disconnect?: subscriptionsWhereUniqueInput | subscriptionsWhereUniqueInput[]
    delete?: subscriptionsWhereUniqueInput | subscriptionsWhereUniqueInput[]
    connect?: subscriptionsWhereUniqueInput | subscriptionsWhereUniqueInput[]
    update?: subscriptionsUpdateWithWhereUniqueWithoutMembershipPlansInput | subscriptionsUpdateWithWhereUniqueWithoutMembershipPlansInput[]
    updateMany?: subscriptionsUpdateManyWithWhereWithoutMembershipPlansInput | subscriptionsUpdateManyWithWhereWithoutMembershipPlansInput[]
    deleteMany?: subscriptionsScalarWhereInput | subscriptionsScalarWhereInput[]
  }

  export type featuresUncheckedUpdateManyWithoutMembershipPlansNestedInput = {
    create?: XOR<featuresCreateWithoutMembershipPlansInput, featuresUncheckedCreateWithoutMembershipPlansInput> | featuresCreateWithoutMembershipPlansInput[] | featuresUncheckedCreateWithoutMembershipPlansInput[]
    connectOrCreate?: featuresCreateOrConnectWithoutMembershipPlansInput | featuresCreateOrConnectWithoutMembershipPlansInput[]
    upsert?: featuresUpsertWithWhereUniqueWithoutMembershipPlansInput | featuresUpsertWithWhereUniqueWithoutMembershipPlansInput[]
    createMany?: featuresCreateManyMembershipPlansInputEnvelope
    set?: featuresWhereUniqueInput | featuresWhereUniqueInput[]
    disconnect?: featuresWhereUniqueInput | featuresWhereUniqueInput[]
    delete?: featuresWhereUniqueInput | featuresWhereUniqueInput[]
    connect?: featuresWhereUniqueInput | featuresWhereUniqueInput[]
    update?: featuresUpdateWithWhereUniqueWithoutMembershipPlansInput | featuresUpdateWithWhereUniqueWithoutMembershipPlansInput[]
    updateMany?: featuresUpdateManyWithWhereWithoutMembershipPlansInput | featuresUpdateManyWithWhereWithoutMembershipPlansInput[]
    deleteMany?: featuresScalarWhereInput | featuresScalarWhereInput[]
  }

  export type subscriptionsUncheckedUpdateManyWithoutMembershipPlansNestedInput = {
    create?: XOR<subscriptionsCreateWithoutMembershipPlansInput, subscriptionsUncheckedCreateWithoutMembershipPlansInput> | subscriptionsCreateWithoutMembershipPlansInput[] | subscriptionsUncheckedCreateWithoutMembershipPlansInput[]
    connectOrCreate?: subscriptionsCreateOrConnectWithoutMembershipPlansInput | subscriptionsCreateOrConnectWithoutMembershipPlansInput[]
    upsert?: subscriptionsUpsertWithWhereUniqueWithoutMembershipPlansInput | subscriptionsUpsertWithWhereUniqueWithoutMembershipPlansInput[]
    createMany?: subscriptionsCreateManyMembershipPlansInputEnvelope
    set?: subscriptionsWhereUniqueInput | subscriptionsWhereUniqueInput[]
    disconnect?: subscriptionsWhereUniqueInput | subscriptionsWhereUniqueInput[]
    delete?: subscriptionsWhereUniqueInput | subscriptionsWhereUniqueInput[]
    connect?: subscriptionsWhereUniqueInput | subscriptionsWhereUniqueInput[]
    update?: subscriptionsUpdateWithWhereUniqueWithoutMembershipPlansInput | subscriptionsUpdateWithWhereUniqueWithoutMembershipPlansInput[]
    updateMany?: subscriptionsUpdateManyWithWhereWithoutMembershipPlansInput | subscriptionsUpdateManyWithWhereWithoutMembershipPlansInput[]
    deleteMany?: subscriptionsScalarWhereInput | subscriptionsScalarWhereInput[]
  }

  export type usersCreateNestedOneWithoutMessagesInput = {
    create?: XOR<usersCreateWithoutMessagesInput, usersUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: usersCreateOrConnectWithoutMessagesInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<usersCreateWithoutMessagesInput, usersUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: usersCreateOrConnectWithoutMessagesInput
    upsert?: usersUpsertWithoutMessagesInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutMessagesInput, usersUpdateWithoutMessagesInput>, usersUncheckedUpdateWithoutMessagesInput>
  }

  export type usersCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<usersCreateWithoutPaymentsInput, usersUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: usersCreateOrConnectWithoutPaymentsInput
    connect?: usersWhereUniqueInput
  }

  export type subscriptionsCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<subscriptionsCreateWithoutPaymentsInput, subscriptionsUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: subscriptionsCreateOrConnectWithoutPaymentsInput
    connect?: subscriptionsWhereUniqueInput
  }

  export type subscriptionsUncheckedCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<subscriptionsCreateWithoutPaymentsInput, subscriptionsUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: subscriptionsCreateOrConnectWithoutPaymentsInput
    connect?: subscriptionsWhereUniqueInput
  }

  export type EnumPaymentGatewayFieldUpdateOperationsInput = {
    set?: $Enums.PaymentGateway
  }

  export type EnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type usersUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<usersCreateWithoutPaymentsInput, usersUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: usersCreateOrConnectWithoutPaymentsInput
    upsert?: usersUpsertWithoutPaymentsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutPaymentsInput, usersUpdateWithoutPaymentsInput>, usersUncheckedUpdateWithoutPaymentsInput>
  }

  export type subscriptionsUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<subscriptionsCreateWithoutPaymentsInput, subscriptionsUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: subscriptionsCreateOrConnectWithoutPaymentsInput
    upsert?: subscriptionsUpsertWithoutPaymentsInput
    disconnect?: subscriptionsWhereInput | boolean
    delete?: subscriptionsWhereInput | boolean
    connect?: subscriptionsWhereUniqueInput
    update?: XOR<XOR<subscriptionsUpdateToOneWithWhereWithoutPaymentsInput, subscriptionsUpdateWithoutPaymentsInput>, subscriptionsUncheckedUpdateWithoutPaymentsInput>
  }

  export type subscriptionsUncheckedUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<subscriptionsCreateWithoutPaymentsInput, subscriptionsUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: subscriptionsCreateOrConnectWithoutPaymentsInput
    upsert?: subscriptionsUpsertWithoutPaymentsInput
    disconnect?: subscriptionsWhereInput | boolean
    delete?: subscriptionsWhereInput | boolean
    connect?: subscriptionsWhereUniqueInput
    update?: XOR<XOR<subscriptionsUpdateToOneWithWhereWithoutPaymentsInput, subscriptionsUpdateWithoutPaymentsInput>, subscriptionsUncheckedUpdateWithoutPaymentsInput>
  }

  export type answersCreateNestedOneWithoutPersonalityTestResultsInput = {
    create?: XOR<answersCreateWithoutPersonalityTestResultsInput, answersUncheckedCreateWithoutPersonalityTestResultsInput>
    connectOrCreate?: answersCreateOrConnectWithoutPersonalityTestResultsInput
    connect?: answersWhereUniqueInput
  }

  export type questionsCreateNestedOneWithoutPersonalityTestResultsInput = {
    create?: XOR<questionsCreateWithoutPersonalityTestResultsInput, questionsUncheckedCreateWithoutPersonalityTestResultsInput>
    connectOrCreate?: questionsCreateOrConnectWithoutPersonalityTestResultsInput
    connect?: questionsWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutPersonalityTestResultsInput = {
    create?: XOR<usersCreateWithoutPersonalityTestResultsInput, usersUncheckedCreateWithoutPersonalityTestResultsInput>
    connectOrCreate?: usersCreateOrConnectWithoutPersonalityTestResultsInput
    connect?: usersWhereUniqueInput
  }

  export type answersUpdateOneRequiredWithoutPersonalityTestResultsNestedInput = {
    create?: XOR<answersCreateWithoutPersonalityTestResultsInput, answersUncheckedCreateWithoutPersonalityTestResultsInput>
    connectOrCreate?: answersCreateOrConnectWithoutPersonalityTestResultsInput
    upsert?: answersUpsertWithoutPersonalityTestResultsInput
    connect?: answersWhereUniqueInput
    update?: XOR<XOR<answersUpdateToOneWithWhereWithoutPersonalityTestResultsInput, answersUpdateWithoutPersonalityTestResultsInput>, answersUncheckedUpdateWithoutPersonalityTestResultsInput>
  }

  export type questionsUpdateOneRequiredWithoutPersonalityTestResultsNestedInput = {
    create?: XOR<questionsCreateWithoutPersonalityTestResultsInput, questionsUncheckedCreateWithoutPersonalityTestResultsInput>
    connectOrCreate?: questionsCreateOrConnectWithoutPersonalityTestResultsInput
    upsert?: questionsUpsertWithoutPersonalityTestResultsInput
    connect?: questionsWhereUniqueInput
    update?: XOR<XOR<questionsUpdateToOneWithWhereWithoutPersonalityTestResultsInput, questionsUpdateWithoutPersonalityTestResultsInput>, questionsUncheckedUpdateWithoutPersonalityTestResultsInput>
  }

  export type usersUpdateOneRequiredWithoutPersonalityTestResultsNestedInput = {
    create?: XOR<usersCreateWithoutPersonalityTestResultsInput, usersUncheckedCreateWithoutPersonalityTestResultsInput>
    connectOrCreate?: usersCreateOrConnectWithoutPersonalityTestResultsInput
    upsert?: usersUpsertWithoutPersonalityTestResultsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutPersonalityTestResultsInput, usersUpdateWithoutPersonalityTestResultsInput>, usersUncheckedUpdateWithoutPersonalityTestResultsInput>
  }

  export type cvsCreateNestedOneWithoutProjectsInput = {
    create?: XOR<cvsCreateWithoutProjectsInput, cvsUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: cvsCreateOrConnectWithoutProjectsInput
    connect?: cvsWhereUniqueInput
  }

  export type cvsUpdateOneRequiredWithoutProjectsNestedInput = {
    create?: XOR<cvsCreateWithoutProjectsInput, cvsUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: cvsCreateOrConnectWithoutProjectsInput
    upsert?: cvsUpsertWithoutProjectsInput
    connect?: cvsWhereUniqueInput
    update?: XOR<XOR<cvsUpdateToOneWithWhereWithoutProjectsInput, cvsUpdateWithoutProjectsInput>, cvsUncheckedUpdateWithoutProjectsInput>
  }

  export type answersCreateNestedManyWithoutQuestionsInput = {
    create?: XOR<answersCreateWithoutQuestionsInput, answersUncheckedCreateWithoutQuestionsInput> | answersCreateWithoutQuestionsInput[] | answersUncheckedCreateWithoutQuestionsInput[]
    connectOrCreate?: answersCreateOrConnectWithoutQuestionsInput | answersCreateOrConnectWithoutQuestionsInput[]
    createMany?: answersCreateManyQuestionsInputEnvelope
    connect?: answersWhereUniqueInput | answersWhereUniqueInput[]
  }

  export type personalityTestResultsCreateNestedManyWithoutQuestionsInput = {
    create?: XOR<personalityTestResultsCreateWithoutQuestionsInput, personalityTestResultsUncheckedCreateWithoutQuestionsInput> | personalityTestResultsCreateWithoutQuestionsInput[] | personalityTestResultsUncheckedCreateWithoutQuestionsInput[]
    connectOrCreate?: personalityTestResultsCreateOrConnectWithoutQuestionsInput | personalityTestResultsCreateOrConnectWithoutQuestionsInput[]
    createMany?: personalityTestResultsCreateManyQuestionsInputEnvelope
    connect?: personalityTestResultsWhereUniqueInput | personalityTestResultsWhereUniqueInput[]
  }

  export type answersUncheckedCreateNestedManyWithoutQuestionsInput = {
    create?: XOR<answersCreateWithoutQuestionsInput, answersUncheckedCreateWithoutQuestionsInput> | answersCreateWithoutQuestionsInput[] | answersUncheckedCreateWithoutQuestionsInput[]
    connectOrCreate?: answersCreateOrConnectWithoutQuestionsInput | answersCreateOrConnectWithoutQuestionsInput[]
    createMany?: answersCreateManyQuestionsInputEnvelope
    connect?: answersWhereUniqueInput | answersWhereUniqueInput[]
  }

  export type personalityTestResultsUncheckedCreateNestedManyWithoutQuestionsInput = {
    create?: XOR<personalityTestResultsCreateWithoutQuestionsInput, personalityTestResultsUncheckedCreateWithoutQuestionsInput> | personalityTestResultsCreateWithoutQuestionsInput[] | personalityTestResultsUncheckedCreateWithoutQuestionsInput[]
    connectOrCreate?: personalityTestResultsCreateOrConnectWithoutQuestionsInput | personalityTestResultsCreateOrConnectWithoutQuestionsInput[]
    createMany?: personalityTestResultsCreateManyQuestionsInputEnvelope
    connect?: personalityTestResultsWhereUniqueInput | personalityTestResultsWhereUniqueInput[]
  }

  export type answersUpdateManyWithoutQuestionsNestedInput = {
    create?: XOR<answersCreateWithoutQuestionsInput, answersUncheckedCreateWithoutQuestionsInput> | answersCreateWithoutQuestionsInput[] | answersUncheckedCreateWithoutQuestionsInput[]
    connectOrCreate?: answersCreateOrConnectWithoutQuestionsInput | answersCreateOrConnectWithoutQuestionsInput[]
    upsert?: answersUpsertWithWhereUniqueWithoutQuestionsInput | answersUpsertWithWhereUniqueWithoutQuestionsInput[]
    createMany?: answersCreateManyQuestionsInputEnvelope
    set?: answersWhereUniqueInput | answersWhereUniqueInput[]
    disconnect?: answersWhereUniqueInput | answersWhereUniqueInput[]
    delete?: answersWhereUniqueInput | answersWhereUniqueInput[]
    connect?: answersWhereUniqueInput | answersWhereUniqueInput[]
    update?: answersUpdateWithWhereUniqueWithoutQuestionsInput | answersUpdateWithWhereUniqueWithoutQuestionsInput[]
    updateMany?: answersUpdateManyWithWhereWithoutQuestionsInput | answersUpdateManyWithWhereWithoutQuestionsInput[]
    deleteMany?: answersScalarWhereInput | answersScalarWhereInput[]
  }

  export type personalityTestResultsUpdateManyWithoutQuestionsNestedInput = {
    create?: XOR<personalityTestResultsCreateWithoutQuestionsInput, personalityTestResultsUncheckedCreateWithoutQuestionsInput> | personalityTestResultsCreateWithoutQuestionsInput[] | personalityTestResultsUncheckedCreateWithoutQuestionsInput[]
    connectOrCreate?: personalityTestResultsCreateOrConnectWithoutQuestionsInput | personalityTestResultsCreateOrConnectWithoutQuestionsInput[]
    upsert?: personalityTestResultsUpsertWithWhereUniqueWithoutQuestionsInput | personalityTestResultsUpsertWithWhereUniqueWithoutQuestionsInput[]
    createMany?: personalityTestResultsCreateManyQuestionsInputEnvelope
    set?: personalityTestResultsWhereUniqueInput | personalityTestResultsWhereUniqueInput[]
    disconnect?: personalityTestResultsWhereUniqueInput | personalityTestResultsWhereUniqueInput[]
    delete?: personalityTestResultsWhereUniqueInput | personalityTestResultsWhereUniqueInput[]
    connect?: personalityTestResultsWhereUniqueInput | personalityTestResultsWhereUniqueInput[]
    update?: personalityTestResultsUpdateWithWhereUniqueWithoutQuestionsInput | personalityTestResultsUpdateWithWhereUniqueWithoutQuestionsInput[]
    updateMany?: personalityTestResultsUpdateManyWithWhereWithoutQuestionsInput | personalityTestResultsUpdateManyWithWhereWithoutQuestionsInput[]
    deleteMany?: personalityTestResultsScalarWhereInput | personalityTestResultsScalarWhereInput[]
  }

  export type answersUncheckedUpdateManyWithoutQuestionsNestedInput = {
    create?: XOR<answersCreateWithoutQuestionsInput, answersUncheckedCreateWithoutQuestionsInput> | answersCreateWithoutQuestionsInput[] | answersUncheckedCreateWithoutQuestionsInput[]
    connectOrCreate?: answersCreateOrConnectWithoutQuestionsInput | answersCreateOrConnectWithoutQuestionsInput[]
    upsert?: answersUpsertWithWhereUniqueWithoutQuestionsInput | answersUpsertWithWhereUniqueWithoutQuestionsInput[]
    createMany?: answersCreateManyQuestionsInputEnvelope
    set?: answersWhereUniqueInput | answersWhereUniqueInput[]
    disconnect?: answersWhereUniqueInput | answersWhereUniqueInput[]
    delete?: answersWhereUniqueInput | answersWhereUniqueInput[]
    connect?: answersWhereUniqueInput | answersWhereUniqueInput[]
    update?: answersUpdateWithWhereUniqueWithoutQuestionsInput | answersUpdateWithWhereUniqueWithoutQuestionsInput[]
    updateMany?: answersUpdateManyWithWhereWithoutQuestionsInput | answersUpdateManyWithWhereWithoutQuestionsInput[]
    deleteMany?: answersScalarWhereInput | answersScalarWhereInput[]
  }

  export type personalityTestResultsUncheckedUpdateManyWithoutQuestionsNestedInput = {
    create?: XOR<personalityTestResultsCreateWithoutQuestionsInput, personalityTestResultsUncheckedCreateWithoutQuestionsInput> | personalityTestResultsCreateWithoutQuestionsInput[] | personalityTestResultsUncheckedCreateWithoutQuestionsInput[]
    connectOrCreate?: personalityTestResultsCreateOrConnectWithoutQuestionsInput | personalityTestResultsCreateOrConnectWithoutQuestionsInput[]
    upsert?: personalityTestResultsUpsertWithWhereUniqueWithoutQuestionsInput | personalityTestResultsUpsertWithWhereUniqueWithoutQuestionsInput[]
    createMany?: personalityTestResultsCreateManyQuestionsInputEnvelope
    set?: personalityTestResultsWhereUniqueInput | personalityTestResultsWhereUniqueInput[]
    disconnect?: personalityTestResultsWhereUniqueInput | personalityTestResultsWhereUniqueInput[]
    delete?: personalityTestResultsWhereUniqueInput | personalityTestResultsWhereUniqueInput[]
    connect?: personalityTestResultsWhereUniqueInput | personalityTestResultsWhereUniqueInput[]
    update?: personalityTestResultsUpdateWithWhereUniqueWithoutQuestionsInput | personalityTestResultsUpdateWithWhereUniqueWithoutQuestionsInput[]
    updateMany?: personalityTestResultsUpdateManyWithWhereWithoutQuestionsInput | personalityTestResultsUpdateManyWithWhereWithoutQuestionsInput[]
    deleteMany?: personalityTestResultsScalarWhereInput | personalityTestResultsScalarWhereInput[]
  }

  export type cvsCreateNestedOneWithoutReferencesInput = {
    create?: XOR<cvsCreateWithoutReferencesInput, cvsUncheckedCreateWithoutReferencesInput>
    connectOrCreate?: cvsCreateOrConnectWithoutReferencesInput
    connect?: cvsWhereUniqueInput
  }

  export type cvsUpdateOneRequiredWithoutReferencesNestedInput = {
    create?: XOR<cvsCreateWithoutReferencesInput, cvsUncheckedCreateWithoutReferencesInput>
    connectOrCreate?: cvsCreateOrConnectWithoutReferencesInput
    upsert?: cvsUpsertWithoutReferencesInput
    connect?: cvsWhereUniqueInput
    update?: XOR<XOR<cvsUpdateToOneWithWhereWithoutReferencesInput, cvsUpdateWithoutReferencesInput>, cvsUncheckedUpdateWithoutReferencesInput>
  }

  export type usersCreateNestedManyWithoutRolesInput = {
    create?: XOR<usersCreateWithoutRolesInput, usersUncheckedCreateWithoutRolesInput> | usersCreateWithoutRolesInput[] | usersUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: usersCreateOrConnectWithoutRolesInput | usersCreateOrConnectWithoutRolesInput[]
    createMany?: usersCreateManyRolesInputEnvelope
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type usersUncheckedCreateNestedManyWithoutRolesInput = {
    create?: XOR<usersCreateWithoutRolesInput, usersUncheckedCreateWithoutRolesInput> | usersCreateWithoutRolesInput[] | usersUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: usersCreateOrConnectWithoutRolesInput | usersCreateOrConnectWithoutRolesInput[]
    createMany?: usersCreateManyRolesInputEnvelope
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type usersUpdateManyWithoutRolesNestedInput = {
    create?: XOR<usersCreateWithoutRolesInput, usersUncheckedCreateWithoutRolesInput> | usersCreateWithoutRolesInput[] | usersUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: usersCreateOrConnectWithoutRolesInput | usersCreateOrConnectWithoutRolesInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutRolesInput | usersUpsertWithWhereUniqueWithoutRolesInput[]
    createMany?: usersCreateManyRolesInputEnvelope
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutRolesInput | usersUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: usersUpdateManyWithWhereWithoutRolesInput | usersUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type usersUncheckedUpdateManyWithoutRolesNestedInput = {
    create?: XOR<usersCreateWithoutRolesInput, usersUncheckedCreateWithoutRolesInput> | usersCreateWithoutRolesInput[] | usersUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: usersCreateOrConnectWithoutRolesInput | usersCreateOrConnectWithoutRolesInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutRolesInput | usersUpsertWithWhereUniqueWithoutRolesInput[]
    createMany?: usersCreateManyRolesInputEnvelope
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutRolesInput | usersUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: usersUpdateManyWithWhereWithoutRolesInput | usersUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type jobsCreateNestedOneWithoutSavedJobsInput = {
    create?: XOR<jobsCreateWithoutSavedJobsInput, jobsUncheckedCreateWithoutSavedJobsInput>
    connectOrCreate?: jobsCreateOrConnectWithoutSavedJobsInput
    connect?: jobsWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutSavedJobsInput = {
    create?: XOR<usersCreateWithoutSavedJobsInput, usersUncheckedCreateWithoutSavedJobsInput>
    connectOrCreate?: usersCreateOrConnectWithoutSavedJobsInput
    connect?: usersWhereUniqueInput
  }

  export type jobsUpdateOneRequiredWithoutSavedJobsNestedInput = {
    create?: XOR<jobsCreateWithoutSavedJobsInput, jobsUncheckedCreateWithoutSavedJobsInput>
    connectOrCreate?: jobsCreateOrConnectWithoutSavedJobsInput
    upsert?: jobsUpsertWithoutSavedJobsInput
    connect?: jobsWhereUniqueInput
    update?: XOR<XOR<jobsUpdateToOneWithWhereWithoutSavedJobsInput, jobsUpdateWithoutSavedJobsInput>, jobsUncheckedUpdateWithoutSavedJobsInput>
  }

  export type usersUpdateOneRequiredWithoutSavedJobsNestedInput = {
    create?: XOR<usersCreateWithoutSavedJobsInput, usersUncheckedCreateWithoutSavedJobsInput>
    connectOrCreate?: usersCreateOrConnectWithoutSavedJobsInput
    upsert?: usersUpsertWithoutSavedJobsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutSavedJobsInput, usersUpdateWithoutSavedJobsInput>, usersUncheckedUpdateWithoutSavedJobsInput>
  }

  export type paymentsCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<paymentsCreateWithoutSubscriptionsInput, paymentsUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: paymentsCreateOrConnectWithoutSubscriptionsInput
    connect?: paymentsWhereUniqueInput
  }

  export type membershipPlansCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<membershipPlansCreateWithoutSubscriptionsInput, membershipPlansUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: membershipPlansCreateOrConnectWithoutSubscriptionsInput
    connect?: membershipPlansWhereUniqueInput
  }

  export type usersCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<usersCreateWithoutSubscriptionsInput, usersUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: usersCreateOrConnectWithoutSubscriptionsInput
    connect?: usersWhereUniqueInput
  }

  export type EnumSubscriptionStatusFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionStatus
  }

  export type paymentsUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<paymentsCreateWithoutSubscriptionsInput, paymentsUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: paymentsCreateOrConnectWithoutSubscriptionsInput
    upsert?: paymentsUpsertWithoutSubscriptionsInput
    connect?: paymentsWhereUniqueInput
    update?: XOR<XOR<paymentsUpdateToOneWithWhereWithoutSubscriptionsInput, paymentsUpdateWithoutSubscriptionsInput>, paymentsUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type membershipPlansUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<membershipPlansCreateWithoutSubscriptionsInput, membershipPlansUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: membershipPlansCreateOrConnectWithoutSubscriptionsInput
    upsert?: membershipPlansUpsertWithoutSubscriptionsInput
    connect?: membershipPlansWhereUniqueInput
    update?: XOR<XOR<membershipPlansUpdateToOneWithWhereWithoutSubscriptionsInput, membershipPlansUpdateWithoutSubscriptionsInput>, membershipPlansUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type usersUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<usersCreateWithoutSubscriptionsInput, usersUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: usersCreateOrConnectWithoutSubscriptionsInput
    upsert?: usersUpsertWithoutSubscriptionsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutSubscriptionsInput, usersUpdateWithoutSubscriptionsInput>, usersUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type usersCreateNestedOneWithoutUserActivitiesHistoryInput = {
    create?: XOR<usersCreateWithoutUserActivitiesHistoryInput, usersUncheckedCreateWithoutUserActivitiesHistoryInput>
    connectOrCreate?: usersCreateOrConnectWithoutUserActivitiesHistoryInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutUserActivitiesHistoryNestedInput = {
    create?: XOR<usersCreateWithoutUserActivitiesHistoryInput, usersUncheckedCreateWithoutUserActivitiesHistoryInput>
    connectOrCreate?: usersCreateOrConnectWithoutUserActivitiesHistoryInput
    upsert?: usersUpsertWithoutUserActivitiesHistoryInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutUserActivitiesHistoryInput, usersUpdateWithoutUserActivitiesHistoryInput>, usersUncheckedUpdateWithoutUserActivitiesHistoryInput>
  }

  export type usersCreateNestedOneWithoutUserNotificationsInput = {
    create?: XOR<usersCreateWithoutUserNotificationsInput, usersUncheckedCreateWithoutUserNotificationsInput>
    connectOrCreate?: usersCreateOrConnectWithoutUserNotificationsInput
    connect?: usersWhereUniqueInput
  }

  export type usersUpdateOneRequiredWithoutUserNotificationsNestedInput = {
    create?: XOR<usersCreateWithoutUserNotificationsInput, usersUncheckedCreateWithoutUserNotificationsInput>
    connectOrCreate?: usersCreateOrConnectWithoutUserNotificationsInput
    upsert?: usersUpsertWithoutUserNotificationsInput
    connect?: usersWhereUniqueInput
    update?: XOR<XOR<usersUpdateToOneWithWhereWithoutUserNotificationsInput, usersUpdateWithoutUserNotificationsInput>, usersUncheckedUpdateWithoutUserNotificationsInput>
  }

  export type blogsCreateNestedManyWithoutUsersInput = {
    create?: XOR<blogsCreateWithoutUsersInput, blogsUncheckedCreateWithoutUsersInput> | blogsCreateWithoutUsersInput[] | blogsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: blogsCreateOrConnectWithoutUsersInput | blogsCreateOrConnectWithoutUsersInput[]
    createMany?: blogsCreateManyUsersInputEnvelope
    connect?: blogsWhereUniqueInput | blogsWhereUniqueInput[]
  }

  export type careerPathsCreateNestedManyWithoutUsersInput = {
    create?: XOR<careerPathsCreateWithoutUsersInput, careerPathsUncheckedCreateWithoutUsersInput> | careerPathsCreateWithoutUsersInput[] | careerPathsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: careerPathsCreateOrConnectWithoutUsersInput | careerPathsCreateOrConnectWithoutUsersInput[]
    createMany?: careerPathsCreateManyUsersInputEnvelope
    connect?: careerPathsWhereUniqueInput | careerPathsWhereUniqueInput[]
  }

  export type companiesCreateNestedOneWithoutUsersInput = {
    create?: XOR<companiesCreateWithoutUsersInput, companiesUncheckedCreateWithoutUsersInput>
    connectOrCreate?: companiesCreateOrConnectWithoutUsersInput
    connect?: companiesWhereUniqueInput
  }

  export type feedbacksCreateNestedManyWithoutUsersInput = {
    create?: XOR<feedbacksCreateWithoutUsersInput, feedbacksUncheckedCreateWithoutUsersInput> | feedbacksCreateWithoutUsersInput[] | feedbacksUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: feedbacksCreateOrConnectWithoutUsersInput | feedbacksCreateOrConnectWithoutUsersInput[]
    createMany?: feedbacksCreateManyUsersInputEnvelope
    connect?: feedbacksWhereUniqueInput | feedbacksWhereUniqueInput[]
  }

  export type followedCompaniesCreateNestedManyWithoutUsersInput = {
    create?: XOR<followedCompaniesCreateWithoutUsersInput, followedCompaniesUncheckedCreateWithoutUsersInput> | followedCompaniesCreateWithoutUsersInput[] | followedCompaniesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: followedCompaniesCreateOrConnectWithoutUsersInput | followedCompaniesCreateOrConnectWithoutUsersInput[]
    createMany?: followedCompaniesCreateManyUsersInputEnvelope
    connect?: followedCompaniesWhereUniqueInput | followedCompaniesWhereUniqueInput[]
  }

  export type messagesCreateNestedManyWithoutUsersInput = {
    create?: XOR<messagesCreateWithoutUsersInput, messagesUncheckedCreateWithoutUsersInput> | messagesCreateWithoutUsersInput[] | messagesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: messagesCreateOrConnectWithoutUsersInput | messagesCreateOrConnectWithoutUsersInput[]
    createMany?: messagesCreateManyUsersInputEnvelope
    connect?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
  }

  export type paymentsCreateNestedManyWithoutUsersInput = {
    create?: XOR<paymentsCreateWithoutUsersInput, paymentsUncheckedCreateWithoutUsersInput> | paymentsCreateWithoutUsersInput[] | paymentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutUsersInput | paymentsCreateOrConnectWithoutUsersInput[]
    createMany?: paymentsCreateManyUsersInputEnvelope
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
  }

  export type personalityTestResultsCreateNestedManyWithoutUsersInput = {
    create?: XOR<personalityTestResultsCreateWithoutUsersInput, personalityTestResultsUncheckedCreateWithoutUsersInput> | personalityTestResultsCreateWithoutUsersInput[] | personalityTestResultsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: personalityTestResultsCreateOrConnectWithoutUsersInput | personalityTestResultsCreateOrConnectWithoutUsersInput[]
    createMany?: personalityTestResultsCreateManyUsersInputEnvelope
    connect?: personalityTestResultsWhereUniqueInput | personalityTestResultsWhereUniqueInput[]
  }

  export type savedJobsCreateNestedManyWithoutUsersInput = {
    create?: XOR<savedJobsCreateWithoutUsersInput, savedJobsUncheckedCreateWithoutUsersInput> | savedJobsCreateWithoutUsersInput[] | savedJobsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: savedJobsCreateOrConnectWithoutUsersInput | savedJobsCreateOrConnectWithoutUsersInput[]
    createMany?: savedJobsCreateManyUsersInputEnvelope
    connect?: savedJobsWhereUniqueInput | savedJobsWhereUniqueInput[]
  }

  export type subscriptionsCreateNestedManyWithoutUsersInput = {
    create?: XOR<subscriptionsCreateWithoutUsersInput, subscriptionsUncheckedCreateWithoutUsersInput> | subscriptionsCreateWithoutUsersInput[] | subscriptionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: subscriptionsCreateOrConnectWithoutUsersInput | subscriptionsCreateOrConnectWithoutUsersInput[]
    createMany?: subscriptionsCreateManyUsersInputEnvelope
    connect?: subscriptionsWhereUniqueInput | subscriptionsWhereUniqueInput[]
  }

  export type userActivitiesHistoryCreateNestedManyWithoutUsersInput = {
    create?: XOR<userActivitiesHistoryCreateWithoutUsersInput, userActivitiesHistoryUncheckedCreateWithoutUsersInput> | userActivitiesHistoryCreateWithoutUsersInput[] | userActivitiesHistoryUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: userActivitiesHistoryCreateOrConnectWithoutUsersInput | userActivitiesHistoryCreateOrConnectWithoutUsersInput[]
    createMany?: userActivitiesHistoryCreateManyUsersInputEnvelope
    connect?: userActivitiesHistoryWhereUniqueInput | userActivitiesHistoryWhereUniqueInput[]
  }

  export type userNotificationsCreateNestedManyWithoutUsersInput = {
    create?: XOR<userNotificationsCreateWithoutUsersInput, userNotificationsUncheckedCreateWithoutUsersInput> | userNotificationsCreateWithoutUsersInput[] | userNotificationsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: userNotificationsCreateOrConnectWithoutUsersInput | userNotificationsCreateOrConnectWithoutUsersInput[]
    createMany?: userNotificationsCreateManyUsersInputEnvelope
    connect?: userNotificationsWhereUniqueInput | userNotificationsWhereUniqueInput[]
  }

  export type rolesCreateNestedOneWithoutUsersInput = {
    create?: XOR<rolesCreateWithoutUsersInput, rolesUncheckedCreateWithoutUsersInput>
    connectOrCreate?: rolesCreateOrConnectWithoutUsersInput
    connect?: rolesWhereUniqueInput
  }

  export type blogsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<blogsCreateWithoutUsersInput, blogsUncheckedCreateWithoutUsersInput> | blogsCreateWithoutUsersInput[] | blogsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: blogsCreateOrConnectWithoutUsersInput | blogsCreateOrConnectWithoutUsersInput[]
    createMany?: blogsCreateManyUsersInputEnvelope
    connect?: blogsWhereUniqueInput | blogsWhereUniqueInput[]
  }

  export type careerPathsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<careerPathsCreateWithoutUsersInput, careerPathsUncheckedCreateWithoutUsersInput> | careerPathsCreateWithoutUsersInput[] | careerPathsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: careerPathsCreateOrConnectWithoutUsersInput | careerPathsCreateOrConnectWithoutUsersInput[]
    createMany?: careerPathsCreateManyUsersInputEnvelope
    connect?: careerPathsWhereUniqueInput | careerPathsWhereUniqueInput[]
  }

  export type companiesUncheckedCreateNestedOneWithoutUsersInput = {
    create?: XOR<companiesCreateWithoutUsersInput, companiesUncheckedCreateWithoutUsersInput>
    connectOrCreate?: companiesCreateOrConnectWithoutUsersInput
    connect?: companiesWhereUniqueInput
  }

  export type feedbacksUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<feedbacksCreateWithoutUsersInput, feedbacksUncheckedCreateWithoutUsersInput> | feedbacksCreateWithoutUsersInput[] | feedbacksUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: feedbacksCreateOrConnectWithoutUsersInput | feedbacksCreateOrConnectWithoutUsersInput[]
    createMany?: feedbacksCreateManyUsersInputEnvelope
    connect?: feedbacksWhereUniqueInput | feedbacksWhereUniqueInput[]
  }

  export type followedCompaniesUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<followedCompaniesCreateWithoutUsersInput, followedCompaniesUncheckedCreateWithoutUsersInput> | followedCompaniesCreateWithoutUsersInput[] | followedCompaniesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: followedCompaniesCreateOrConnectWithoutUsersInput | followedCompaniesCreateOrConnectWithoutUsersInput[]
    createMany?: followedCompaniesCreateManyUsersInputEnvelope
    connect?: followedCompaniesWhereUniqueInput | followedCompaniesWhereUniqueInput[]
  }

  export type messagesUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<messagesCreateWithoutUsersInput, messagesUncheckedCreateWithoutUsersInput> | messagesCreateWithoutUsersInput[] | messagesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: messagesCreateOrConnectWithoutUsersInput | messagesCreateOrConnectWithoutUsersInput[]
    createMany?: messagesCreateManyUsersInputEnvelope
    connect?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
  }

  export type paymentsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<paymentsCreateWithoutUsersInput, paymentsUncheckedCreateWithoutUsersInput> | paymentsCreateWithoutUsersInput[] | paymentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutUsersInput | paymentsCreateOrConnectWithoutUsersInput[]
    createMany?: paymentsCreateManyUsersInputEnvelope
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
  }

  export type personalityTestResultsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<personalityTestResultsCreateWithoutUsersInput, personalityTestResultsUncheckedCreateWithoutUsersInput> | personalityTestResultsCreateWithoutUsersInput[] | personalityTestResultsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: personalityTestResultsCreateOrConnectWithoutUsersInput | personalityTestResultsCreateOrConnectWithoutUsersInput[]
    createMany?: personalityTestResultsCreateManyUsersInputEnvelope
    connect?: personalityTestResultsWhereUniqueInput | personalityTestResultsWhereUniqueInput[]
  }

  export type savedJobsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<savedJobsCreateWithoutUsersInput, savedJobsUncheckedCreateWithoutUsersInput> | savedJobsCreateWithoutUsersInput[] | savedJobsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: savedJobsCreateOrConnectWithoutUsersInput | savedJobsCreateOrConnectWithoutUsersInput[]
    createMany?: savedJobsCreateManyUsersInputEnvelope
    connect?: savedJobsWhereUniqueInput | savedJobsWhereUniqueInput[]
  }

  export type subscriptionsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<subscriptionsCreateWithoutUsersInput, subscriptionsUncheckedCreateWithoutUsersInput> | subscriptionsCreateWithoutUsersInput[] | subscriptionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: subscriptionsCreateOrConnectWithoutUsersInput | subscriptionsCreateOrConnectWithoutUsersInput[]
    createMany?: subscriptionsCreateManyUsersInputEnvelope
    connect?: subscriptionsWhereUniqueInput | subscriptionsWhereUniqueInput[]
  }

  export type userActivitiesHistoryUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<userActivitiesHistoryCreateWithoutUsersInput, userActivitiesHistoryUncheckedCreateWithoutUsersInput> | userActivitiesHistoryCreateWithoutUsersInput[] | userActivitiesHistoryUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: userActivitiesHistoryCreateOrConnectWithoutUsersInput | userActivitiesHistoryCreateOrConnectWithoutUsersInput[]
    createMany?: userActivitiesHistoryCreateManyUsersInputEnvelope
    connect?: userActivitiesHistoryWhereUniqueInput | userActivitiesHistoryWhereUniqueInput[]
  }

  export type userNotificationsUncheckedCreateNestedManyWithoutUsersInput = {
    create?: XOR<userNotificationsCreateWithoutUsersInput, userNotificationsUncheckedCreateWithoutUsersInput> | userNotificationsCreateWithoutUsersInput[] | userNotificationsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: userNotificationsCreateOrConnectWithoutUsersInput | userNotificationsCreateOrConnectWithoutUsersInput[]
    createMany?: userNotificationsCreateManyUsersInputEnvelope
    connect?: userNotificationsWhereUniqueInput | userNotificationsWhereUniqueInput[]
  }

  export type NullableEnumGenderFieldUpdateOperationsInput = {
    set?: $Enums.Gender | null
  }

  export type blogsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<blogsCreateWithoutUsersInput, blogsUncheckedCreateWithoutUsersInput> | blogsCreateWithoutUsersInput[] | blogsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: blogsCreateOrConnectWithoutUsersInput | blogsCreateOrConnectWithoutUsersInput[]
    upsert?: blogsUpsertWithWhereUniqueWithoutUsersInput | blogsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: blogsCreateManyUsersInputEnvelope
    set?: blogsWhereUniqueInput | blogsWhereUniqueInput[]
    disconnect?: blogsWhereUniqueInput | blogsWhereUniqueInput[]
    delete?: blogsWhereUniqueInput | blogsWhereUniqueInput[]
    connect?: blogsWhereUniqueInput | blogsWhereUniqueInput[]
    update?: blogsUpdateWithWhereUniqueWithoutUsersInput | blogsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: blogsUpdateManyWithWhereWithoutUsersInput | blogsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: blogsScalarWhereInput | blogsScalarWhereInput[]
  }

  export type careerPathsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<careerPathsCreateWithoutUsersInput, careerPathsUncheckedCreateWithoutUsersInput> | careerPathsCreateWithoutUsersInput[] | careerPathsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: careerPathsCreateOrConnectWithoutUsersInput | careerPathsCreateOrConnectWithoutUsersInput[]
    upsert?: careerPathsUpsertWithWhereUniqueWithoutUsersInput | careerPathsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: careerPathsCreateManyUsersInputEnvelope
    set?: careerPathsWhereUniqueInput | careerPathsWhereUniqueInput[]
    disconnect?: careerPathsWhereUniqueInput | careerPathsWhereUniqueInput[]
    delete?: careerPathsWhereUniqueInput | careerPathsWhereUniqueInput[]
    connect?: careerPathsWhereUniqueInput | careerPathsWhereUniqueInput[]
    update?: careerPathsUpdateWithWhereUniqueWithoutUsersInput | careerPathsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: careerPathsUpdateManyWithWhereWithoutUsersInput | careerPathsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: careerPathsScalarWhereInput | careerPathsScalarWhereInput[]
  }

  export type companiesUpdateOneWithoutUsersNestedInput = {
    create?: XOR<companiesCreateWithoutUsersInput, companiesUncheckedCreateWithoutUsersInput>
    connectOrCreate?: companiesCreateOrConnectWithoutUsersInput
    upsert?: companiesUpsertWithoutUsersInput
    disconnect?: companiesWhereInput | boolean
    delete?: companiesWhereInput | boolean
    connect?: companiesWhereUniqueInput
    update?: XOR<XOR<companiesUpdateToOneWithWhereWithoutUsersInput, companiesUpdateWithoutUsersInput>, companiesUncheckedUpdateWithoutUsersInput>
  }

  export type feedbacksUpdateManyWithoutUsersNestedInput = {
    create?: XOR<feedbacksCreateWithoutUsersInput, feedbacksUncheckedCreateWithoutUsersInput> | feedbacksCreateWithoutUsersInput[] | feedbacksUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: feedbacksCreateOrConnectWithoutUsersInput | feedbacksCreateOrConnectWithoutUsersInput[]
    upsert?: feedbacksUpsertWithWhereUniqueWithoutUsersInput | feedbacksUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: feedbacksCreateManyUsersInputEnvelope
    set?: feedbacksWhereUniqueInput | feedbacksWhereUniqueInput[]
    disconnect?: feedbacksWhereUniqueInput | feedbacksWhereUniqueInput[]
    delete?: feedbacksWhereUniqueInput | feedbacksWhereUniqueInput[]
    connect?: feedbacksWhereUniqueInput | feedbacksWhereUniqueInput[]
    update?: feedbacksUpdateWithWhereUniqueWithoutUsersInput | feedbacksUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: feedbacksUpdateManyWithWhereWithoutUsersInput | feedbacksUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: feedbacksScalarWhereInput | feedbacksScalarWhereInput[]
  }

  export type followedCompaniesUpdateManyWithoutUsersNestedInput = {
    create?: XOR<followedCompaniesCreateWithoutUsersInput, followedCompaniesUncheckedCreateWithoutUsersInput> | followedCompaniesCreateWithoutUsersInput[] | followedCompaniesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: followedCompaniesCreateOrConnectWithoutUsersInput | followedCompaniesCreateOrConnectWithoutUsersInput[]
    upsert?: followedCompaniesUpsertWithWhereUniqueWithoutUsersInput | followedCompaniesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: followedCompaniesCreateManyUsersInputEnvelope
    set?: followedCompaniesWhereUniqueInput | followedCompaniesWhereUniqueInput[]
    disconnect?: followedCompaniesWhereUniqueInput | followedCompaniesWhereUniqueInput[]
    delete?: followedCompaniesWhereUniqueInput | followedCompaniesWhereUniqueInput[]
    connect?: followedCompaniesWhereUniqueInput | followedCompaniesWhereUniqueInput[]
    update?: followedCompaniesUpdateWithWhereUniqueWithoutUsersInput | followedCompaniesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: followedCompaniesUpdateManyWithWhereWithoutUsersInput | followedCompaniesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: followedCompaniesScalarWhereInput | followedCompaniesScalarWhereInput[]
  }

  export type messagesUpdateManyWithoutUsersNestedInput = {
    create?: XOR<messagesCreateWithoutUsersInput, messagesUncheckedCreateWithoutUsersInput> | messagesCreateWithoutUsersInput[] | messagesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: messagesCreateOrConnectWithoutUsersInput | messagesCreateOrConnectWithoutUsersInput[]
    upsert?: messagesUpsertWithWhereUniqueWithoutUsersInput | messagesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: messagesCreateManyUsersInputEnvelope
    set?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    disconnect?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    delete?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    connect?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    update?: messagesUpdateWithWhereUniqueWithoutUsersInput | messagesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: messagesUpdateManyWithWhereWithoutUsersInput | messagesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: messagesScalarWhereInput | messagesScalarWhereInput[]
  }

  export type paymentsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<paymentsCreateWithoutUsersInput, paymentsUncheckedCreateWithoutUsersInput> | paymentsCreateWithoutUsersInput[] | paymentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutUsersInput | paymentsCreateOrConnectWithoutUsersInput[]
    upsert?: paymentsUpsertWithWhereUniqueWithoutUsersInput | paymentsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: paymentsCreateManyUsersInputEnvelope
    set?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    disconnect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    delete?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    update?: paymentsUpdateWithWhereUniqueWithoutUsersInput | paymentsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: paymentsUpdateManyWithWhereWithoutUsersInput | paymentsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
  }

  export type personalityTestResultsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<personalityTestResultsCreateWithoutUsersInput, personalityTestResultsUncheckedCreateWithoutUsersInput> | personalityTestResultsCreateWithoutUsersInput[] | personalityTestResultsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: personalityTestResultsCreateOrConnectWithoutUsersInput | personalityTestResultsCreateOrConnectWithoutUsersInput[]
    upsert?: personalityTestResultsUpsertWithWhereUniqueWithoutUsersInput | personalityTestResultsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: personalityTestResultsCreateManyUsersInputEnvelope
    set?: personalityTestResultsWhereUniqueInput | personalityTestResultsWhereUniqueInput[]
    disconnect?: personalityTestResultsWhereUniqueInput | personalityTestResultsWhereUniqueInput[]
    delete?: personalityTestResultsWhereUniqueInput | personalityTestResultsWhereUniqueInput[]
    connect?: personalityTestResultsWhereUniqueInput | personalityTestResultsWhereUniqueInput[]
    update?: personalityTestResultsUpdateWithWhereUniqueWithoutUsersInput | personalityTestResultsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: personalityTestResultsUpdateManyWithWhereWithoutUsersInput | personalityTestResultsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: personalityTestResultsScalarWhereInput | personalityTestResultsScalarWhereInput[]
  }

  export type savedJobsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<savedJobsCreateWithoutUsersInput, savedJobsUncheckedCreateWithoutUsersInput> | savedJobsCreateWithoutUsersInput[] | savedJobsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: savedJobsCreateOrConnectWithoutUsersInput | savedJobsCreateOrConnectWithoutUsersInput[]
    upsert?: savedJobsUpsertWithWhereUniqueWithoutUsersInput | savedJobsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: savedJobsCreateManyUsersInputEnvelope
    set?: savedJobsWhereUniqueInput | savedJobsWhereUniqueInput[]
    disconnect?: savedJobsWhereUniqueInput | savedJobsWhereUniqueInput[]
    delete?: savedJobsWhereUniqueInput | savedJobsWhereUniqueInput[]
    connect?: savedJobsWhereUniqueInput | savedJobsWhereUniqueInput[]
    update?: savedJobsUpdateWithWhereUniqueWithoutUsersInput | savedJobsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: savedJobsUpdateManyWithWhereWithoutUsersInput | savedJobsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: savedJobsScalarWhereInput | savedJobsScalarWhereInput[]
  }

  export type subscriptionsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<subscriptionsCreateWithoutUsersInput, subscriptionsUncheckedCreateWithoutUsersInput> | subscriptionsCreateWithoutUsersInput[] | subscriptionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: subscriptionsCreateOrConnectWithoutUsersInput | subscriptionsCreateOrConnectWithoutUsersInput[]
    upsert?: subscriptionsUpsertWithWhereUniqueWithoutUsersInput | subscriptionsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: subscriptionsCreateManyUsersInputEnvelope
    set?: subscriptionsWhereUniqueInput | subscriptionsWhereUniqueInput[]
    disconnect?: subscriptionsWhereUniqueInput | subscriptionsWhereUniqueInput[]
    delete?: subscriptionsWhereUniqueInput | subscriptionsWhereUniqueInput[]
    connect?: subscriptionsWhereUniqueInput | subscriptionsWhereUniqueInput[]
    update?: subscriptionsUpdateWithWhereUniqueWithoutUsersInput | subscriptionsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: subscriptionsUpdateManyWithWhereWithoutUsersInput | subscriptionsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: subscriptionsScalarWhereInput | subscriptionsScalarWhereInput[]
  }

  export type userActivitiesHistoryUpdateManyWithoutUsersNestedInput = {
    create?: XOR<userActivitiesHistoryCreateWithoutUsersInput, userActivitiesHistoryUncheckedCreateWithoutUsersInput> | userActivitiesHistoryCreateWithoutUsersInput[] | userActivitiesHistoryUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: userActivitiesHistoryCreateOrConnectWithoutUsersInput | userActivitiesHistoryCreateOrConnectWithoutUsersInput[]
    upsert?: userActivitiesHistoryUpsertWithWhereUniqueWithoutUsersInput | userActivitiesHistoryUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: userActivitiesHistoryCreateManyUsersInputEnvelope
    set?: userActivitiesHistoryWhereUniqueInput | userActivitiesHistoryWhereUniqueInput[]
    disconnect?: userActivitiesHistoryWhereUniqueInput | userActivitiesHistoryWhereUniqueInput[]
    delete?: userActivitiesHistoryWhereUniqueInput | userActivitiesHistoryWhereUniqueInput[]
    connect?: userActivitiesHistoryWhereUniqueInput | userActivitiesHistoryWhereUniqueInput[]
    update?: userActivitiesHistoryUpdateWithWhereUniqueWithoutUsersInput | userActivitiesHistoryUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: userActivitiesHistoryUpdateManyWithWhereWithoutUsersInput | userActivitiesHistoryUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: userActivitiesHistoryScalarWhereInput | userActivitiesHistoryScalarWhereInput[]
  }

  export type userNotificationsUpdateManyWithoutUsersNestedInput = {
    create?: XOR<userNotificationsCreateWithoutUsersInput, userNotificationsUncheckedCreateWithoutUsersInput> | userNotificationsCreateWithoutUsersInput[] | userNotificationsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: userNotificationsCreateOrConnectWithoutUsersInput | userNotificationsCreateOrConnectWithoutUsersInput[]
    upsert?: userNotificationsUpsertWithWhereUniqueWithoutUsersInput | userNotificationsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: userNotificationsCreateManyUsersInputEnvelope
    set?: userNotificationsWhereUniqueInput | userNotificationsWhereUniqueInput[]
    disconnect?: userNotificationsWhereUniqueInput | userNotificationsWhereUniqueInput[]
    delete?: userNotificationsWhereUniqueInput | userNotificationsWhereUniqueInput[]
    connect?: userNotificationsWhereUniqueInput | userNotificationsWhereUniqueInput[]
    update?: userNotificationsUpdateWithWhereUniqueWithoutUsersInput | userNotificationsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: userNotificationsUpdateManyWithWhereWithoutUsersInput | userNotificationsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: userNotificationsScalarWhereInput | userNotificationsScalarWhereInput[]
  }

  export type rolesUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<rolesCreateWithoutUsersInput, rolesUncheckedCreateWithoutUsersInput>
    connectOrCreate?: rolesCreateOrConnectWithoutUsersInput
    upsert?: rolesUpsertWithoutUsersInput
    connect?: rolesWhereUniqueInput
    update?: XOR<XOR<rolesUpdateToOneWithWhereWithoutUsersInput, rolesUpdateWithoutUsersInput>, rolesUncheckedUpdateWithoutUsersInput>
  }

  export type blogsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<blogsCreateWithoutUsersInput, blogsUncheckedCreateWithoutUsersInput> | blogsCreateWithoutUsersInput[] | blogsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: blogsCreateOrConnectWithoutUsersInput | blogsCreateOrConnectWithoutUsersInput[]
    upsert?: blogsUpsertWithWhereUniqueWithoutUsersInput | blogsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: blogsCreateManyUsersInputEnvelope
    set?: blogsWhereUniqueInput | blogsWhereUniqueInput[]
    disconnect?: blogsWhereUniqueInput | blogsWhereUniqueInput[]
    delete?: blogsWhereUniqueInput | blogsWhereUniqueInput[]
    connect?: blogsWhereUniqueInput | blogsWhereUniqueInput[]
    update?: blogsUpdateWithWhereUniqueWithoutUsersInput | blogsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: blogsUpdateManyWithWhereWithoutUsersInput | blogsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: blogsScalarWhereInput | blogsScalarWhereInput[]
  }

  export type careerPathsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<careerPathsCreateWithoutUsersInput, careerPathsUncheckedCreateWithoutUsersInput> | careerPathsCreateWithoutUsersInput[] | careerPathsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: careerPathsCreateOrConnectWithoutUsersInput | careerPathsCreateOrConnectWithoutUsersInput[]
    upsert?: careerPathsUpsertWithWhereUniqueWithoutUsersInput | careerPathsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: careerPathsCreateManyUsersInputEnvelope
    set?: careerPathsWhereUniqueInput | careerPathsWhereUniqueInput[]
    disconnect?: careerPathsWhereUniqueInput | careerPathsWhereUniqueInput[]
    delete?: careerPathsWhereUniqueInput | careerPathsWhereUniqueInput[]
    connect?: careerPathsWhereUniqueInput | careerPathsWhereUniqueInput[]
    update?: careerPathsUpdateWithWhereUniqueWithoutUsersInput | careerPathsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: careerPathsUpdateManyWithWhereWithoutUsersInput | careerPathsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: careerPathsScalarWhereInput | careerPathsScalarWhereInput[]
  }

  export type companiesUncheckedUpdateOneWithoutUsersNestedInput = {
    create?: XOR<companiesCreateWithoutUsersInput, companiesUncheckedCreateWithoutUsersInput>
    connectOrCreate?: companiesCreateOrConnectWithoutUsersInput
    upsert?: companiesUpsertWithoutUsersInput
    disconnect?: companiesWhereInput | boolean
    delete?: companiesWhereInput | boolean
    connect?: companiesWhereUniqueInput
    update?: XOR<XOR<companiesUpdateToOneWithWhereWithoutUsersInput, companiesUpdateWithoutUsersInput>, companiesUncheckedUpdateWithoutUsersInput>
  }

  export type feedbacksUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<feedbacksCreateWithoutUsersInput, feedbacksUncheckedCreateWithoutUsersInput> | feedbacksCreateWithoutUsersInput[] | feedbacksUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: feedbacksCreateOrConnectWithoutUsersInput | feedbacksCreateOrConnectWithoutUsersInput[]
    upsert?: feedbacksUpsertWithWhereUniqueWithoutUsersInput | feedbacksUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: feedbacksCreateManyUsersInputEnvelope
    set?: feedbacksWhereUniqueInput | feedbacksWhereUniqueInput[]
    disconnect?: feedbacksWhereUniqueInput | feedbacksWhereUniqueInput[]
    delete?: feedbacksWhereUniqueInput | feedbacksWhereUniqueInput[]
    connect?: feedbacksWhereUniqueInput | feedbacksWhereUniqueInput[]
    update?: feedbacksUpdateWithWhereUniqueWithoutUsersInput | feedbacksUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: feedbacksUpdateManyWithWhereWithoutUsersInput | feedbacksUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: feedbacksScalarWhereInput | feedbacksScalarWhereInput[]
  }

  export type followedCompaniesUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<followedCompaniesCreateWithoutUsersInput, followedCompaniesUncheckedCreateWithoutUsersInput> | followedCompaniesCreateWithoutUsersInput[] | followedCompaniesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: followedCompaniesCreateOrConnectWithoutUsersInput | followedCompaniesCreateOrConnectWithoutUsersInput[]
    upsert?: followedCompaniesUpsertWithWhereUniqueWithoutUsersInput | followedCompaniesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: followedCompaniesCreateManyUsersInputEnvelope
    set?: followedCompaniesWhereUniqueInput | followedCompaniesWhereUniqueInput[]
    disconnect?: followedCompaniesWhereUniqueInput | followedCompaniesWhereUniqueInput[]
    delete?: followedCompaniesWhereUniqueInput | followedCompaniesWhereUniqueInput[]
    connect?: followedCompaniesWhereUniqueInput | followedCompaniesWhereUniqueInput[]
    update?: followedCompaniesUpdateWithWhereUniqueWithoutUsersInput | followedCompaniesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: followedCompaniesUpdateManyWithWhereWithoutUsersInput | followedCompaniesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: followedCompaniesScalarWhereInput | followedCompaniesScalarWhereInput[]
  }

  export type messagesUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<messagesCreateWithoutUsersInput, messagesUncheckedCreateWithoutUsersInput> | messagesCreateWithoutUsersInput[] | messagesUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: messagesCreateOrConnectWithoutUsersInput | messagesCreateOrConnectWithoutUsersInput[]
    upsert?: messagesUpsertWithWhereUniqueWithoutUsersInput | messagesUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: messagesCreateManyUsersInputEnvelope
    set?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    disconnect?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    delete?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    connect?: messagesWhereUniqueInput | messagesWhereUniqueInput[]
    update?: messagesUpdateWithWhereUniqueWithoutUsersInput | messagesUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: messagesUpdateManyWithWhereWithoutUsersInput | messagesUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: messagesScalarWhereInput | messagesScalarWhereInput[]
  }

  export type paymentsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<paymentsCreateWithoutUsersInput, paymentsUncheckedCreateWithoutUsersInput> | paymentsCreateWithoutUsersInput[] | paymentsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutUsersInput | paymentsCreateOrConnectWithoutUsersInput[]
    upsert?: paymentsUpsertWithWhereUniqueWithoutUsersInput | paymentsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: paymentsCreateManyUsersInputEnvelope
    set?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    disconnect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    delete?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    update?: paymentsUpdateWithWhereUniqueWithoutUsersInput | paymentsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: paymentsUpdateManyWithWhereWithoutUsersInput | paymentsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
  }

  export type personalityTestResultsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<personalityTestResultsCreateWithoutUsersInput, personalityTestResultsUncheckedCreateWithoutUsersInput> | personalityTestResultsCreateWithoutUsersInput[] | personalityTestResultsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: personalityTestResultsCreateOrConnectWithoutUsersInput | personalityTestResultsCreateOrConnectWithoutUsersInput[]
    upsert?: personalityTestResultsUpsertWithWhereUniqueWithoutUsersInput | personalityTestResultsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: personalityTestResultsCreateManyUsersInputEnvelope
    set?: personalityTestResultsWhereUniqueInput | personalityTestResultsWhereUniqueInput[]
    disconnect?: personalityTestResultsWhereUniqueInput | personalityTestResultsWhereUniqueInput[]
    delete?: personalityTestResultsWhereUniqueInput | personalityTestResultsWhereUniqueInput[]
    connect?: personalityTestResultsWhereUniqueInput | personalityTestResultsWhereUniqueInput[]
    update?: personalityTestResultsUpdateWithWhereUniqueWithoutUsersInput | personalityTestResultsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: personalityTestResultsUpdateManyWithWhereWithoutUsersInput | personalityTestResultsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: personalityTestResultsScalarWhereInput | personalityTestResultsScalarWhereInput[]
  }

  export type savedJobsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<savedJobsCreateWithoutUsersInput, savedJobsUncheckedCreateWithoutUsersInput> | savedJobsCreateWithoutUsersInput[] | savedJobsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: savedJobsCreateOrConnectWithoutUsersInput | savedJobsCreateOrConnectWithoutUsersInput[]
    upsert?: savedJobsUpsertWithWhereUniqueWithoutUsersInput | savedJobsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: savedJobsCreateManyUsersInputEnvelope
    set?: savedJobsWhereUniqueInput | savedJobsWhereUniqueInput[]
    disconnect?: savedJobsWhereUniqueInput | savedJobsWhereUniqueInput[]
    delete?: savedJobsWhereUniqueInput | savedJobsWhereUniqueInput[]
    connect?: savedJobsWhereUniqueInput | savedJobsWhereUniqueInput[]
    update?: savedJobsUpdateWithWhereUniqueWithoutUsersInput | savedJobsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: savedJobsUpdateManyWithWhereWithoutUsersInput | savedJobsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: savedJobsScalarWhereInput | savedJobsScalarWhereInput[]
  }

  export type subscriptionsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<subscriptionsCreateWithoutUsersInput, subscriptionsUncheckedCreateWithoutUsersInput> | subscriptionsCreateWithoutUsersInput[] | subscriptionsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: subscriptionsCreateOrConnectWithoutUsersInput | subscriptionsCreateOrConnectWithoutUsersInput[]
    upsert?: subscriptionsUpsertWithWhereUniqueWithoutUsersInput | subscriptionsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: subscriptionsCreateManyUsersInputEnvelope
    set?: subscriptionsWhereUniqueInput | subscriptionsWhereUniqueInput[]
    disconnect?: subscriptionsWhereUniqueInput | subscriptionsWhereUniqueInput[]
    delete?: subscriptionsWhereUniqueInput | subscriptionsWhereUniqueInput[]
    connect?: subscriptionsWhereUniqueInput | subscriptionsWhereUniqueInput[]
    update?: subscriptionsUpdateWithWhereUniqueWithoutUsersInput | subscriptionsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: subscriptionsUpdateManyWithWhereWithoutUsersInput | subscriptionsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: subscriptionsScalarWhereInput | subscriptionsScalarWhereInput[]
  }

  export type userActivitiesHistoryUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<userActivitiesHistoryCreateWithoutUsersInput, userActivitiesHistoryUncheckedCreateWithoutUsersInput> | userActivitiesHistoryCreateWithoutUsersInput[] | userActivitiesHistoryUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: userActivitiesHistoryCreateOrConnectWithoutUsersInput | userActivitiesHistoryCreateOrConnectWithoutUsersInput[]
    upsert?: userActivitiesHistoryUpsertWithWhereUniqueWithoutUsersInput | userActivitiesHistoryUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: userActivitiesHistoryCreateManyUsersInputEnvelope
    set?: userActivitiesHistoryWhereUniqueInput | userActivitiesHistoryWhereUniqueInput[]
    disconnect?: userActivitiesHistoryWhereUniqueInput | userActivitiesHistoryWhereUniqueInput[]
    delete?: userActivitiesHistoryWhereUniqueInput | userActivitiesHistoryWhereUniqueInput[]
    connect?: userActivitiesHistoryWhereUniqueInput | userActivitiesHistoryWhereUniqueInput[]
    update?: userActivitiesHistoryUpdateWithWhereUniqueWithoutUsersInput | userActivitiesHistoryUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: userActivitiesHistoryUpdateManyWithWhereWithoutUsersInput | userActivitiesHistoryUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: userActivitiesHistoryScalarWhereInput | userActivitiesHistoryScalarWhereInput[]
  }

  export type userNotificationsUncheckedUpdateManyWithoutUsersNestedInput = {
    create?: XOR<userNotificationsCreateWithoutUsersInput, userNotificationsUncheckedCreateWithoutUsersInput> | userNotificationsCreateWithoutUsersInput[] | userNotificationsUncheckedCreateWithoutUsersInput[]
    connectOrCreate?: userNotificationsCreateOrConnectWithoutUsersInput | userNotificationsCreateOrConnectWithoutUsersInput[]
    upsert?: userNotificationsUpsertWithWhereUniqueWithoutUsersInput | userNotificationsUpsertWithWhereUniqueWithoutUsersInput[]
    createMany?: userNotificationsCreateManyUsersInputEnvelope
    set?: userNotificationsWhereUniqueInput | userNotificationsWhereUniqueInput[]
    disconnect?: userNotificationsWhereUniqueInput | userNotificationsWhereUniqueInput[]
    delete?: userNotificationsWhereUniqueInput | userNotificationsWhereUniqueInput[]
    connect?: userNotificationsWhereUniqueInput | userNotificationsWhereUniqueInput[]
    update?: userNotificationsUpdateWithWhereUniqueWithoutUsersInput | userNotificationsUpdateWithWhereUniqueWithoutUsersInput[]
    updateMany?: userNotificationsUpdateManyWithWhereWithoutUsersInput | userNotificationsUpdateManyWithWhereWithoutUsersInput[]
    deleteMany?: userNotificationsScalarWhereInput | userNotificationsScalarWhereInput[]
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedEnumApplicantsStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicantsStatus | EnumApplicantsStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicantsStatus[] | ListEnumApplicantsStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicantsStatus[] | ListEnumApplicantsStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicantsStatusFilter<$PrismaModel> | $Enums.ApplicantsStatus
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumApplicantsStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApplicantsStatus | EnumApplicantsStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ApplicantsStatus[] | ListEnumApplicantsStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ApplicantsStatus[] | ListEnumApplicantsStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumApplicantsStatusWithAggregatesFilter<$PrismaModel> | $Enums.ApplicantsStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApplicantsStatusFilter<$PrismaModel>
    _max?: NestedEnumApplicantsStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumCompany_TypeFilter<$PrismaModel = never> = {
    equals?: $Enums.Company_Type | EnumCompany_TypeFieldRefInput<$PrismaModel>
    in?: $Enums.Company_Type[] | ListEnumCompany_TypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.Company_Type[] | ListEnumCompany_TypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCompany_TypeFilter<$PrismaModel> | $Enums.Company_Type
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumCompany_TypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Company_Type | EnumCompany_TypeFieldRefInput<$PrismaModel>
    in?: $Enums.Company_Type[] | ListEnumCompany_TypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.Company_Type[] | ListEnumCompany_TypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCompany_TypeWithAggregatesFilter<$PrismaModel> | $Enums.Company_Type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCompany_TypeFilter<$PrismaModel>
    _max?: NestedEnumCompany_TypeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumNotificationsTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationsType | EnumNotificationsTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationsType[] | ListEnumNotificationsTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationsType[] | ListEnumNotificationsTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationsTypeFilter<$PrismaModel> | $Enums.NotificationsType
  }

  export type NestedEnumNotificationsTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationsType | EnumNotificationsTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationsType[] | ListEnumNotificationsTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationsType[] | ListEnumNotificationsTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationsTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationsType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationsTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationsTypeFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumJob_TypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Job_Type | EnumJob_TypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.Job_Type[] | ListEnumJob_TypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Job_Type[] | ListEnumJob_TypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumJob_TypeNullableFilter<$PrismaModel> | $Enums.Job_Type | null
  }

  export type NestedEnumJob_StatusNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Job_Status | EnumJob_StatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.Job_Status[] | ListEnumJob_StatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Job_Status[] | ListEnumJob_StatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumJob_StatusNullableFilter<$PrismaModel> | $Enums.Job_Status | null
  }

  export type NestedEnumEducationNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Education | EnumEducationFieldRefInput<$PrismaModel> | null
    in?: $Enums.Education[] | ListEnumEducationFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Education[] | ListEnumEducationFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEducationNullableFilter<$PrismaModel> | $Enums.Education | null
  }

  export type NestedEnumJob_TypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Job_Type | EnumJob_TypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.Job_Type[] | ListEnumJob_TypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Job_Type[] | ListEnumJob_TypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumJob_TypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.Job_Type | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumJob_TypeNullableFilter<$PrismaModel>
    _max?: NestedEnumJob_TypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumJob_StatusNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Job_Status | EnumJob_StatusFieldRefInput<$PrismaModel> | null
    in?: $Enums.Job_Status[] | ListEnumJob_StatusFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Job_Status[] | ListEnumJob_StatusFieldRefInput<$PrismaModel> | null
    not?: NestedEnumJob_StatusNullableWithAggregatesFilter<$PrismaModel> | $Enums.Job_Status | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumJob_StatusNullableFilter<$PrismaModel>
    _max?: NestedEnumJob_StatusNullableFilter<$PrismaModel>
  }

  export type NestedEnumEducationNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Education | EnumEducationFieldRefInput<$PrismaModel> | null
    in?: $Enums.Education[] | ListEnumEducationFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Education[] | ListEnumEducationFieldRefInput<$PrismaModel> | null
    not?: NestedEnumEducationNullableWithAggregatesFilter<$PrismaModel> | $Enums.Education | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumEducationNullableFilter<$PrismaModel>
    _max?: NestedEnumEducationNullableFilter<$PrismaModel>
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedEnumPaymentGatewayFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentGateway | EnumPaymentGatewayFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentGateway[] | ListEnumPaymentGatewayFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentGateway[] | ListEnumPaymentGatewayFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentGatewayFilter<$PrismaModel> | $Enums.PaymentGateway
  }

  export type NestedEnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedEnumPaymentGatewayWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentGateway | EnumPaymentGatewayFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentGateway[] | ListEnumPaymentGatewayFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentGateway[] | ListEnumPaymentGatewayFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentGatewayWithAggregatesFilter<$PrismaModel> | $Enums.PaymentGateway
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentGatewayFilter<$PrismaModel>
    _max?: NestedEnumPaymentGatewayFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SubscriptionStatus[] | ListEnumSubscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type NestedEnumGenderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableFilter<$PrismaModel> | $Enums.Gender | null
  }

  export type NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel> | $Enums.Gender | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGenderNullableFilter<$PrismaModel>
    _max?: NestedEnumGenderNullableFilter<$PrismaModel>
  }

  export type questionsCreateWithoutAnswersInput = {
    question: string
    personalityTestResults?: personalityTestResultsCreateNestedManyWithoutQuestionsInput
  }

  export type questionsUncheckedCreateWithoutAnswersInput = {
    id?: number
    question: string
    personalityTestResults?: personalityTestResultsUncheckedCreateNestedManyWithoutQuestionsInput
  }

  export type questionsCreateOrConnectWithoutAnswersInput = {
    where: questionsWhereUniqueInput
    create: XOR<questionsCreateWithoutAnswersInput, questionsUncheckedCreateWithoutAnswersInput>
  }

  export type personalityTestResultsCreateWithoutAnswersInput = {
    questions: questionsCreateNestedOneWithoutPersonalityTestResultsInput
    users: usersCreateNestedOneWithoutPersonalityTestResultsInput
  }

  export type personalityTestResultsUncheckedCreateWithoutAnswersInput = {
    user_id: string
    question_id: number
  }

  export type personalityTestResultsCreateOrConnectWithoutAnswersInput = {
    where: personalityTestResultsWhereUniqueInput
    create: XOR<personalityTestResultsCreateWithoutAnswersInput, personalityTestResultsUncheckedCreateWithoutAnswersInput>
  }

  export type personalityTestResultsCreateManyAnswersInputEnvelope = {
    data: personalityTestResultsCreateManyAnswersInput | personalityTestResultsCreateManyAnswersInput[]
    skipDuplicates?: boolean
  }

  export type questionsUpsertWithoutAnswersInput = {
    update: XOR<questionsUpdateWithoutAnswersInput, questionsUncheckedUpdateWithoutAnswersInput>
    create: XOR<questionsCreateWithoutAnswersInput, questionsUncheckedCreateWithoutAnswersInput>
    where?: questionsWhereInput
  }

  export type questionsUpdateToOneWithWhereWithoutAnswersInput = {
    where?: questionsWhereInput
    data: XOR<questionsUpdateWithoutAnswersInput, questionsUncheckedUpdateWithoutAnswersInput>
  }

  export type questionsUpdateWithoutAnswersInput = {
    question?: StringFieldUpdateOperationsInput | string
    personalityTestResults?: personalityTestResultsUpdateManyWithoutQuestionsNestedInput
  }

  export type questionsUncheckedUpdateWithoutAnswersInput = {
    id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    personalityTestResults?: personalityTestResultsUncheckedUpdateManyWithoutQuestionsNestedInput
  }

  export type personalityTestResultsUpsertWithWhereUniqueWithoutAnswersInput = {
    where: personalityTestResultsWhereUniqueInput
    update: XOR<personalityTestResultsUpdateWithoutAnswersInput, personalityTestResultsUncheckedUpdateWithoutAnswersInput>
    create: XOR<personalityTestResultsCreateWithoutAnswersInput, personalityTestResultsUncheckedCreateWithoutAnswersInput>
  }

  export type personalityTestResultsUpdateWithWhereUniqueWithoutAnswersInput = {
    where: personalityTestResultsWhereUniqueInput
    data: XOR<personalityTestResultsUpdateWithoutAnswersInput, personalityTestResultsUncheckedUpdateWithoutAnswersInput>
  }

  export type personalityTestResultsUpdateManyWithWhereWithoutAnswersInput = {
    where: personalityTestResultsScalarWhereInput
    data: XOR<personalityTestResultsUpdateManyMutationInput, personalityTestResultsUncheckedUpdateManyWithoutAnswersInput>
  }

  export type personalityTestResultsScalarWhereInput = {
    AND?: personalityTestResultsScalarWhereInput | personalityTestResultsScalarWhereInput[]
    OR?: personalityTestResultsScalarWhereInput[]
    NOT?: personalityTestResultsScalarWhereInput | personalityTestResultsScalarWhereInput[]
    user_id?: StringFilter<"personalityTestResults"> | string
    question_id?: IntFilter<"personalityTestResults"> | number
    answer_id?: IntFilter<"personalityTestResults"> | number
  }

  export type cvsCreateWithoutApplicantsInput = {
    fullname: string
    age?: number | null
    gender?: string | null
    address?: string | null
    email?: string | null
    introduction?: string | null
    soft_skills?: cvsCreatesoft_skillsInput | string[]
    primary_skills?: cvsCreateprimary_skillsInput | string[]
    phone?: string | null
    hobbies?: string | null
    others?: string | null
    awards?: awardsCreateNestedManyWithoutCvsInput
    certificates?: certificatesCreateNestedManyWithoutCvsInput
    educations?: educationsCreateNestedManyWithoutCvsInput
    experiences?: experiencesCreateNestedManyWithoutCvsInput
    projects?: projectsCreateNestedManyWithoutCvsInput
    references?: referencesCreateNestedManyWithoutCvsInput
  }

  export type cvsUncheckedCreateWithoutApplicantsInput = {
    id?: number
    fullname: string
    age?: number | null
    gender?: string | null
    address?: string | null
    email?: string | null
    introduction?: string | null
    soft_skills?: cvsCreatesoft_skillsInput | string[]
    primary_skills?: cvsCreateprimary_skillsInput | string[]
    phone?: string | null
    hobbies?: string | null
    others?: string | null
    awards?: awardsUncheckedCreateNestedManyWithoutCvsInput
    certificates?: certificatesUncheckedCreateNestedManyWithoutCvsInput
    educations?: educationsUncheckedCreateNestedManyWithoutCvsInput
    experiences?: experiencesUncheckedCreateNestedManyWithoutCvsInput
    projects?: projectsUncheckedCreateNestedManyWithoutCvsInput
    references?: referencesUncheckedCreateNestedManyWithoutCvsInput
  }

  export type cvsCreateOrConnectWithoutApplicantsInput = {
    where: cvsWhereUniqueInput
    create: XOR<cvsCreateWithoutApplicantsInput, cvsUncheckedCreateWithoutApplicantsInput>
  }

  export type jobsCreateWithoutApplicantsInput = {
    id: string
    job_title: string
    description: string
    location?: string | null
    benefit?: string | null
    working_time?: string | null
    salary?: jobsCreatesalaryInput | string[]
    currency?: string | null
    job_type?: $Enums.Job_Type | null
    status?: $Enums.Job_Status | null
    job_level: string
    quantity?: number | null
    skill_tags?: jobsCreateskill_tagsInput | string[]
    education?: $Enums.Education | null
    experience?: string | null
    start_date?: Date | string
    end_date?: Date | string | null
    created_at?: Date | string
    updated_at: Date | string
    categories?: categoriesCreateNestedOneWithoutJobsInput
    jobLabels?: jobLabelsCreateNestedOneWithoutJobsInput
    savedJobs?: savedJobsCreateNestedManyWithoutJobsInput
  }

  export type jobsUncheckedCreateWithoutApplicantsInput = {
    id: string
    job_title: string
    description: string
    location?: string | null
    benefit?: string | null
    working_time?: string | null
    salary?: jobsCreatesalaryInput | string[]
    currency?: string | null
    job_type?: $Enums.Job_Type | null
    status?: $Enums.Job_Status | null
    job_level: string
    quantity?: number | null
    skill_tags?: jobsCreateskill_tagsInput | string[]
    education?: $Enums.Education | null
    experience?: string | null
    start_date?: Date | string
    end_date?: Date | string | null
    created_at?: Date | string
    updated_at: Date | string
    category_id?: number | null
    label_id?: number | null
    savedJobs?: savedJobsUncheckedCreateNestedManyWithoutJobsInput
  }

  export type jobsCreateOrConnectWithoutApplicantsInput = {
    where: jobsWhereUniqueInput
    create: XOR<jobsCreateWithoutApplicantsInput, jobsUncheckedCreateWithoutApplicantsInput>
  }

  export type cvsUpsertWithoutApplicantsInput = {
    update: XOR<cvsUpdateWithoutApplicantsInput, cvsUncheckedUpdateWithoutApplicantsInput>
    create: XOR<cvsCreateWithoutApplicantsInput, cvsUncheckedCreateWithoutApplicantsInput>
    where?: cvsWhereInput
  }

  export type cvsUpdateToOneWithWhereWithoutApplicantsInput = {
    where?: cvsWhereInput
    data: XOR<cvsUpdateWithoutApplicantsInput, cvsUncheckedUpdateWithoutApplicantsInput>
  }

  export type cvsUpdateWithoutApplicantsInput = {
    fullname?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    soft_skills?: cvsUpdatesoft_skillsInput | string[]
    primary_skills?: cvsUpdateprimary_skillsInput | string[]
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    hobbies?: NullableStringFieldUpdateOperationsInput | string | null
    others?: NullableStringFieldUpdateOperationsInput | string | null
    awards?: awardsUpdateManyWithoutCvsNestedInput
    certificates?: certificatesUpdateManyWithoutCvsNestedInput
    educations?: educationsUpdateManyWithoutCvsNestedInput
    experiences?: experiencesUpdateManyWithoutCvsNestedInput
    projects?: projectsUpdateManyWithoutCvsNestedInput
    references?: referencesUpdateManyWithoutCvsNestedInput
  }

  export type cvsUncheckedUpdateWithoutApplicantsInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullname?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    soft_skills?: cvsUpdatesoft_skillsInput | string[]
    primary_skills?: cvsUpdateprimary_skillsInput | string[]
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    hobbies?: NullableStringFieldUpdateOperationsInput | string | null
    others?: NullableStringFieldUpdateOperationsInput | string | null
    awards?: awardsUncheckedUpdateManyWithoutCvsNestedInput
    certificates?: certificatesUncheckedUpdateManyWithoutCvsNestedInput
    educations?: educationsUncheckedUpdateManyWithoutCvsNestedInput
    experiences?: experiencesUncheckedUpdateManyWithoutCvsNestedInput
    projects?: projectsUncheckedUpdateManyWithoutCvsNestedInput
    references?: referencesUncheckedUpdateManyWithoutCvsNestedInput
  }

  export type jobsUpsertWithoutApplicantsInput = {
    update: XOR<jobsUpdateWithoutApplicantsInput, jobsUncheckedUpdateWithoutApplicantsInput>
    create: XOR<jobsCreateWithoutApplicantsInput, jobsUncheckedCreateWithoutApplicantsInput>
    where?: jobsWhereInput
  }

  export type jobsUpdateToOneWithWhereWithoutApplicantsInput = {
    where?: jobsWhereInput
    data: XOR<jobsUpdateWithoutApplicantsInput, jobsUncheckedUpdateWithoutApplicantsInput>
  }

  export type jobsUpdateWithoutApplicantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    job_title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    benefit?: NullableStringFieldUpdateOperationsInput | string | null
    working_time?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: jobsUpdatesalaryInput | string[]
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    job_type?: NullableEnumJob_TypeFieldUpdateOperationsInput | $Enums.Job_Type | null
    status?: NullableEnumJob_StatusFieldUpdateOperationsInput | $Enums.Job_Status | null
    job_level?: StringFieldUpdateOperationsInput | string
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    skill_tags?: jobsUpdateskill_tagsInput | string[]
    education?: NullableEnumEducationFieldUpdateOperationsInput | $Enums.Education | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    categories?: categoriesUpdateOneWithoutJobsNestedInput
    jobLabels?: jobLabelsUpdateOneWithoutJobsNestedInput
    savedJobs?: savedJobsUpdateManyWithoutJobsNestedInput
  }

  export type jobsUncheckedUpdateWithoutApplicantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    job_title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    benefit?: NullableStringFieldUpdateOperationsInput | string | null
    working_time?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: jobsUpdatesalaryInput | string[]
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    job_type?: NullableEnumJob_TypeFieldUpdateOperationsInput | $Enums.Job_Type | null
    status?: NullableEnumJob_StatusFieldUpdateOperationsInput | $Enums.Job_Status | null
    job_level?: StringFieldUpdateOperationsInput | string
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    skill_tags?: jobsUpdateskill_tagsInput | string[]
    education?: NullableEnumEducationFieldUpdateOperationsInput | $Enums.Education | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    label_id?: NullableIntFieldUpdateOperationsInput | number | null
    savedJobs?: savedJobsUncheckedUpdateManyWithoutJobsNestedInput
  }

  export type cvsCreateWithoutAwardsInput = {
    fullname: string
    age?: number | null
    gender?: string | null
    address?: string | null
    email?: string | null
    introduction?: string | null
    soft_skills?: cvsCreatesoft_skillsInput | string[]
    primary_skills?: cvsCreateprimary_skillsInput | string[]
    phone?: string | null
    hobbies?: string | null
    others?: string | null
    applicants?: applicantsCreateNestedManyWithoutCvsInput
    certificates?: certificatesCreateNestedManyWithoutCvsInput
    educations?: educationsCreateNestedManyWithoutCvsInput
    experiences?: experiencesCreateNestedManyWithoutCvsInput
    projects?: projectsCreateNestedManyWithoutCvsInput
    references?: referencesCreateNestedManyWithoutCvsInput
  }

  export type cvsUncheckedCreateWithoutAwardsInput = {
    id?: number
    fullname: string
    age?: number | null
    gender?: string | null
    address?: string | null
    email?: string | null
    introduction?: string | null
    soft_skills?: cvsCreatesoft_skillsInput | string[]
    primary_skills?: cvsCreateprimary_skillsInput | string[]
    phone?: string | null
    hobbies?: string | null
    others?: string | null
    applicants?: applicantsUncheckedCreateNestedManyWithoutCvsInput
    certificates?: certificatesUncheckedCreateNestedManyWithoutCvsInput
    educations?: educationsUncheckedCreateNestedManyWithoutCvsInput
    experiences?: experiencesUncheckedCreateNestedManyWithoutCvsInput
    projects?: projectsUncheckedCreateNestedManyWithoutCvsInput
    references?: referencesUncheckedCreateNestedManyWithoutCvsInput
  }

  export type cvsCreateOrConnectWithoutAwardsInput = {
    where: cvsWhereUniqueInput
    create: XOR<cvsCreateWithoutAwardsInput, cvsUncheckedCreateWithoutAwardsInput>
  }

  export type cvsUpsertWithoutAwardsInput = {
    update: XOR<cvsUpdateWithoutAwardsInput, cvsUncheckedUpdateWithoutAwardsInput>
    create: XOR<cvsCreateWithoutAwardsInput, cvsUncheckedCreateWithoutAwardsInput>
    where?: cvsWhereInput
  }

  export type cvsUpdateToOneWithWhereWithoutAwardsInput = {
    where?: cvsWhereInput
    data: XOR<cvsUpdateWithoutAwardsInput, cvsUncheckedUpdateWithoutAwardsInput>
  }

  export type cvsUpdateWithoutAwardsInput = {
    fullname?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    soft_skills?: cvsUpdatesoft_skillsInput | string[]
    primary_skills?: cvsUpdateprimary_skillsInput | string[]
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    hobbies?: NullableStringFieldUpdateOperationsInput | string | null
    others?: NullableStringFieldUpdateOperationsInput | string | null
    applicants?: applicantsUpdateManyWithoutCvsNestedInput
    certificates?: certificatesUpdateManyWithoutCvsNestedInput
    educations?: educationsUpdateManyWithoutCvsNestedInput
    experiences?: experiencesUpdateManyWithoutCvsNestedInput
    projects?: projectsUpdateManyWithoutCvsNestedInput
    references?: referencesUpdateManyWithoutCvsNestedInput
  }

  export type cvsUncheckedUpdateWithoutAwardsInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullname?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    soft_skills?: cvsUpdatesoft_skillsInput | string[]
    primary_skills?: cvsUpdateprimary_skillsInput | string[]
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    hobbies?: NullableStringFieldUpdateOperationsInput | string | null
    others?: NullableStringFieldUpdateOperationsInput | string | null
    applicants?: applicantsUncheckedUpdateManyWithoutCvsNestedInput
    certificates?: certificatesUncheckedUpdateManyWithoutCvsNestedInput
    educations?: educationsUncheckedUpdateManyWithoutCvsNestedInput
    experiences?: experiencesUncheckedUpdateManyWithoutCvsNestedInput
    projects?: projectsUncheckedUpdateManyWithoutCvsNestedInput
    references?: referencesUncheckedUpdateManyWithoutCvsNestedInput
  }

  export type usersCreateWithoutBlogsInput = {
    id: string
    username: string
    password: string
    avatar_url?: string | null
    email: string
    phone?: string | null
    address_street?: string | null
    address_ward?: string | null
    address_city?: string | null
    address_country?: string | null
    gender?: $Enums.Gender | null
    is_deleted?: boolean
    created_at?: Date | string
    updated_at: Date | string
    careerPaths?: careerPathsCreateNestedManyWithoutUsersInput
    companies?: companiesCreateNestedOneWithoutUsersInput
    feedbacks?: feedbacksCreateNestedManyWithoutUsersInput
    followedCompanies?: followedCompaniesCreateNestedManyWithoutUsersInput
    messages?: messagesCreateNestedManyWithoutUsersInput
    payments?: paymentsCreateNestedManyWithoutUsersInput
    personalityTestResults?: personalityTestResultsCreateNestedManyWithoutUsersInput
    savedJobs?: savedJobsCreateNestedManyWithoutUsersInput
    subscriptions?: subscriptionsCreateNestedManyWithoutUsersInput
    userActivitiesHistory?: userActivitiesHistoryCreateNestedManyWithoutUsersInput
    userNotifications?: userNotificationsCreateNestedManyWithoutUsersInput
    roles: rolesCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutBlogsInput = {
    id: string
    username: string
    password: string
    avatar_url?: string | null
    email: string
    phone?: string | null
    address_street?: string | null
    address_ward?: string | null
    address_city?: string | null
    address_country?: string | null
    gender?: $Enums.Gender | null
    is_deleted?: boolean
    created_at?: Date | string
    updated_at: Date | string
    role_id: number
    careerPaths?: careerPathsUncheckedCreateNestedManyWithoutUsersInput
    companies?: companiesUncheckedCreateNestedOneWithoutUsersInput
    feedbacks?: feedbacksUncheckedCreateNestedManyWithoutUsersInput
    followedCompanies?: followedCompaniesUncheckedCreateNestedManyWithoutUsersInput
    messages?: messagesUncheckedCreateNestedManyWithoutUsersInput
    payments?: paymentsUncheckedCreateNestedManyWithoutUsersInput
    personalityTestResults?: personalityTestResultsUncheckedCreateNestedManyWithoutUsersInput
    savedJobs?: savedJobsUncheckedCreateNestedManyWithoutUsersInput
    subscriptions?: subscriptionsUncheckedCreateNestedManyWithoutUsersInput
    userActivitiesHistory?: userActivitiesHistoryUncheckedCreateNestedManyWithoutUsersInput
    userNotifications?: userNotificationsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutBlogsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutBlogsInput, usersUncheckedCreateWithoutBlogsInput>
  }

  export type usersUpsertWithoutBlogsInput = {
    update: XOR<usersUpdateWithoutBlogsInput, usersUncheckedUpdateWithoutBlogsInput>
    create: XOR<usersCreateWithoutBlogsInput, usersUncheckedCreateWithoutBlogsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutBlogsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutBlogsInput, usersUncheckedUpdateWithoutBlogsInput>
  }

  export type usersUpdateWithoutBlogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: NullableStringFieldUpdateOperationsInput | string | null
    address_ward?: NullableStringFieldUpdateOperationsInput | string | null
    address_city?: NullableStringFieldUpdateOperationsInput | string | null
    address_country?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    careerPaths?: careerPathsUpdateManyWithoutUsersNestedInput
    companies?: companiesUpdateOneWithoutUsersNestedInput
    feedbacks?: feedbacksUpdateManyWithoutUsersNestedInput
    followedCompanies?: followedCompaniesUpdateManyWithoutUsersNestedInput
    messages?: messagesUpdateManyWithoutUsersNestedInput
    payments?: paymentsUpdateManyWithoutUsersNestedInput
    personalityTestResults?: personalityTestResultsUpdateManyWithoutUsersNestedInput
    savedJobs?: savedJobsUpdateManyWithoutUsersNestedInput
    subscriptions?: subscriptionsUpdateManyWithoutUsersNestedInput
    userActivitiesHistory?: userActivitiesHistoryUpdateManyWithoutUsersNestedInput
    userNotifications?: userNotificationsUpdateManyWithoutUsersNestedInput
    roles?: rolesUpdateOneRequiredWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutBlogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: NullableStringFieldUpdateOperationsInput | string | null
    address_ward?: NullableStringFieldUpdateOperationsInput | string | null
    address_city?: NullableStringFieldUpdateOperationsInput | string | null
    address_country?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role_id?: IntFieldUpdateOperationsInput | number
    careerPaths?: careerPathsUncheckedUpdateManyWithoutUsersNestedInput
    companies?: companiesUncheckedUpdateOneWithoutUsersNestedInput
    feedbacks?: feedbacksUncheckedUpdateManyWithoutUsersNestedInput
    followedCompanies?: followedCompaniesUncheckedUpdateManyWithoutUsersNestedInput
    messages?: messagesUncheckedUpdateManyWithoutUsersNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutUsersNestedInput
    personalityTestResults?: personalityTestResultsUncheckedUpdateManyWithoutUsersNestedInput
    savedJobs?: savedJobsUncheckedUpdateManyWithoutUsersNestedInput
    subscriptions?: subscriptionsUncheckedUpdateManyWithoutUsersNestedInput
    userActivitiesHistory?: userActivitiesHistoryUncheckedUpdateManyWithoutUsersNestedInput
    userNotifications?: userNotificationsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type careerPathsCreateWithoutCareerPathStepsInput = {
    title: string
    description?: string | null
    resources?: string | null
    level?: string | null
    estimate_duration?: string | null
    jobSpecialized: jobSpecializedCreateNestedOneWithoutCareerPathsInput
    users: usersCreateNestedOneWithoutCareerPathsInput
  }

  export type careerPathsUncheckedCreateWithoutCareerPathStepsInput = {
    id?: number
    title: string
    description?: string | null
    resources?: string | null
    level?: string | null
    estimate_duration?: string | null
    user_id: string
    jobspecialized_id: number
  }

  export type careerPathsCreateOrConnectWithoutCareerPathStepsInput = {
    where: careerPathsWhereUniqueInput
    create: XOR<careerPathsCreateWithoutCareerPathStepsInput, careerPathsUncheckedCreateWithoutCareerPathStepsInput>
  }

  export type careerPathsUpsertWithoutCareerPathStepsInput = {
    update: XOR<careerPathsUpdateWithoutCareerPathStepsInput, careerPathsUncheckedUpdateWithoutCareerPathStepsInput>
    create: XOR<careerPathsCreateWithoutCareerPathStepsInput, careerPathsUncheckedCreateWithoutCareerPathStepsInput>
    where?: careerPathsWhereInput
  }

  export type careerPathsUpdateToOneWithWhereWithoutCareerPathStepsInput = {
    where?: careerPathsWhereInput
    data: XOR<careerPathsUpdateWithoutCareerPathStepsInput, careerPathsUncheckedUpdateWithoutCareerPathStepsInput>
  }

  export type careerPathsUpdateWithoutCareerPathStepsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resources?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    estimate_duration?: NullableStringFieldUpdateOperationsInput | string | null
    jobSpecialized?: jobSpecializedUpdateOneRequiredWithoutCareerPathsNestedInput
    users?: usersUpdateOneRequiredWithoutCareerPathsNestedInput
  }

  export type careerPathsUncheckedUpdateWithoutCareerPathStepsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resources?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    estimate_duration?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    jobspecialized_id?: IntFieldUpdateOperationsInput | number
  }

  export type careerPathStepsCreateWithoutCareerPathsInput = {
    title: string
    description?: string | null
    resources?: string | null
  }

  export type careerPathStepsUncheckedCreateWithoutCareerPathsInput = {
    id?: number
    title: string
    description?: string | null
    resources?: string | null
  }

  export type careerPathStepsCreateOrConnectWithoutCareerPathsInput = {
    where: careerPathStepsWhereUniqueInput
    create: XOR<careerPathStepsCreateWithoutCareerPathsInput, careerPathStepsUncheckedCreateWithoutCareerPathsInput>
  }

  export type careerPathStepsCreateManyCareerPathsInputEnvelope = {
    data: careerPathStepsCreateManyCareerPathsInput | careerPathStepsCreateManyCareerPathsInput[]
    skipDuplicates?: boolean
  }

  export type jobSpecializedCreateWithoutCareerPathsInput = {
    job_type: string
    description?: string | null
    jobCategories: jobCategoriesCreateNestedOneWithoutJobSpecializedInput
  }

  export type jobSpecializedUncheckedCreateWithoutCareerPathsInput = {
    id?: number
    job_type: string
    description?: string | null
    jobcategory_id: number
  }

  export type jobSpecializedCreateOrConnectWithoutCareerPathsInput = {
    where: jobSpecializedWhereUniqueInput
    create: XOR<jobSpecializedCreateWithoutCareerPathsInput, jobSpecializedUncheckedCreateWithoutCareerPathsInput>
  }

  export type usersCreateWithoutCareerPathsInput = {
    id: string
    username: string
    password: string
    avatar_url?: string | null
    email: string
    phone?: string | null
    address_street?: string | null
    address_ward?: string | null
    address_city?: string | null
    address_country?: string | null
    gender?: $Enums.Gender | null
    is_deleted?: boolean
    created_at?: Date | string
    updated_at: Date | string
    blogs?: blogsCreateNestedManyWithoutUsersInput
    companies?: companiesCreateNestedOneWithoutUsersInput
    feedbacks?: feedbacksCreateNestedManyWithoutUsersInput
    followedCompanies?: followedCompaniesCreateNestedManyWithoutUsersInput
    messages?: messagesCreateNestedManyWithoutUsersInput
    payments?: paymentsCreateNestedManyWithoutUsersInput
    personalityTestResults?: personalityTestResultsCreateNestedManyWithoutUsersInput
    savedJobs?: savedJobsCreateNestedManyWithoutUsersInput
    subscriptions?: subscriptionsCreateNestedManyWithoutUsersInput
    userActivitiesHistory?: userActivitiesHistoryCreateNestedManyWithoutUsersInput
    userNotifications?: userNotificationsCreateNestedManyWithoutUsersInput
    roles: rolesCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutCareerPathsInput = {
    id: string
    username: string
    password: string
    avatar_url?: string | null
    email: string
    phone?: string | null
    address_street?: string | null
    address_ward?: string | null
    address_city?: string | null
    address_country?: string | null
    gender?: $Enums.Gender | null
    is_deleted?: boolean
    created_at?: Date | string
    updated_at: Date | string
    role_id: number
    blogs?: blogsUncheckedCreateNestedManyWithoutUsersInput
    companies?: companiesUncheckedCreateNestedOneWithoutUsersInput
    feedbacks?: feedbacksUncheckedCreateNestedManyWithoutUsersInput
    followedCompanies?: followedCompaniesUncheckedCreateNestedManyWithoutUsersInput
    messages?: messagesUncheckedCreateNestedManyWithoutUsersInput
    payments?: paymentsUncheckedCreateNestedManyWithoutUsersInput
    personalityTestResults?: personalityTestResultsUncheckedCreateNestedManyWithoutUsersInput
    savedJobs?: savedJobsUncheckedCreateNestedManyWithoutUsersInput
    subscriptions?: subscriptionsUncheckedCreateNestedManyWithoutUsersInput
    userActivitiesHistory?: userActivitiesHistoryUncheckedCreateNestedManyWithoutUsersInput
    userNotifications?: userNotificationsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutCareerPathsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutCareerPathsInput, usersUncheckedCreateWithoutCareerPathsInput>
  }

  export type careerPathStepsUpsertWithWhereUniqueWithoutCareerPathsInput = {
    where: careerPathStepsWhereUniqueInput
    update: XOR<careerPathStepsUpdateWithoutCareerPathsInput, careerPathStepsUncheckedUpdateWithoutCareerPathsInput>
    create: XOR<careerPathStepsCreateWithoutCareerPathsInput, careerPathStepsUncheckedCreateWithoutCareerPathsInput>
  }

  export type careerPathStepsUpdateWithWhereUniqueWithoutCareerPathsInput = {
    where: careerPathStepsWhereUniqueInput
    data: XOR<careerPathStepsUpdateWithoutCareerPathsInput, careerPathStepsUncheckedUpdateWithoutCareerPathsInput>
  }

  export type careerPathStepsUpdateManyWithWhereWithoutCareerPathsInput = {
    where: careerPathStepsScalarWhereInput
    data: XOR<careerPathStepsUpdateManyMutationInput, careerPathStepsUncheckedUpdateManyWithoutCareerPathsInput>
  }

  export type careerPathStepsScalarWhereInput = {
    AND?: careerPathStepsScalarWhereInput | careerPathStepsScalarWhereInput[]
    OR?: careerPathStepsScalarWhereInput[]
    NOT?: careerPathStepsScalarWhereInput | careerPathStepsScalarWhereInput[]
    id?: IntFilter<"careerPathSteps"> | number
    title?: StringFilter<"careerPathSteps"> | string
    description?: StringNullableFilter<"careerPathSteps"> | string | null
    resources?: StringNullableFilter<"careerPathSteps"> | string | null
    career_id?: IntFilter<"careerPathSteps"> | number
  }

  export type jobSpecializedUpsertWithoutCareerPathsInput = {
    update: XOR<jobSpecializedUpdateWithoutCareerPathsInput, jobSpecializedUncheckedUpdateWithoutCareerPathsInput>
    create: XOR<jobSpecializedCreateWithoutCareerPathsInput, jobSpecializedUncheckedCreateWithoutCareerPathsInput>
    where?: jobSpecializedWhereInput
  }

  export type jobSpecializedUpdateToOneWithWhereWithoutCareerPathsInput = {
    where?: jobSpecializedWhereInput
    data: XOR<jobSpecializedUpdateWithoutCareerPathsInput, jobSpecializedUncheckedUpdateWithoutCareerPathsInput>
  }

  export type jobSpecializedUpdateWithoutCareerPathsInput = {
    job_type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    jobCategories?: jobCategoriesUpdateOneRequiredWithoutJobSpecializedNestedInput
  }

  export type jobSpecializedUncheckedUpdateWithoutCareerPathsInput = {
    id?: IntFieldUpdateOperationsInput | number
    job_type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    jobcategory_id?: IntFieldUpdateOperationsInput | number
  }

  export type usersUpsertWithoutCareerPathsInput = {
    update: XOR<usersUpdateWithoutCareerPathsInput, usersUncheckedUpdateWithoutCareerPathsInput>
    create: XOR<usersCreateWithoutCareerPathsInput, usersUncheckedCreateWithoutCareerPathsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutCareerPathsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutCareerPathsInput, usersUncheckedUpdateWithoutCareerPathsInput>
  }

  export type usersUpdateWithoutCareerPathsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: NullableStringFieldUpdateOperationsInput | string | null
    address_ward?: NullableStringFieldUpdateOperationsInput | string | null
    address_city?: NullableStringFieldUpdateOperationsInput | string | null
    address_country?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    blogs?: blogsUpdateManyWithoutUsersNestedInput
    companies?: companiesUpdateOneWithoutUsersNestedInput
    feedbacks?: feedbacksUpdateManyWithoutUsersNestedInput
    followedCompanies?: followedCompaniesUpdateManyWithoutUsersNestedInput
    messages?: messagesUpdateManyWithoutUsersNestedInput
    payments?: paymentsUpdateManyWithoutUsersNestedInput
    personalityTestResults?: personalityTestResultsUpdateManyWithoutUsersNestedInput
    savedJobs?: savedJobsUpdateManyWithoutUsersNestedInput
    subscriptions?: subscriptionsUpdateManyWithoutUsersNestedInput
    userActivitiesHistory?: userActivitiesHistoryUpdateManyWithoutUsersNestedInput
    userNotifications?: userNotificationsUpdateManyWithoutUsersNestedInput
    roles?: rolesUpdateOneRequiredWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutCareerPathsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: NullableStringFieldUpdateOperationsInput | string | null
    address_ward?: NullableStringFieldUpdateOperationsInput | string | null
    address_city?: NullableStringFieldUpdateOperationsInput | string | null
    address_country?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role_id?: IntFieldUpdateOperationsInput | number
    blogs?: blogsUncheckedUpdateManyWithoutUsersNestedInput
    companies?: companiesUncheckedUpdateOneWithoutUsersNestedInput
    feedbacks?: feedbacksUncheckedUpdateManyWithoutUsersNestedInput
    followedCompanies?: followedCompaniesUncheckedUpdateManyWithoutUsersNestedInput
    messages?: messagesUncheckedUpdateManyWithoutUsersNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutUsersNestedInput
    personalityTestResults?: personalityTestResultsUncheckedUpdateManyWithoutUsersNestedInput
    savedJobs?: savedJobsUncheckedUpdateManyWithoutUsersNestedInput
    subscriptions?: subscriptionsUncheckedUpdateManyWithoutUsersNestedInput
    userActivitiesHistory?: userActivitiesHistoryUncheckedUpdateManyWithoutUsersNestedInput
    userNotifications?: userNotificationsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type jobsCreateWithoutCategoriesInput = {
    id: string
    job_title: string
    description: string
    location?: string | null
    benefit?: string | null
    working_time?: string | null
    salary?: jobsCreatesalaryInput | string[]
    currency?: string | null
    job_type?: $Enums.Job_Type | null
    status?: $Enums.Job_Status | null
    job_level: string
    quantity?: number | null
    skill_tags?: jobsCreateskill_tagsInput | string[]
    education?: $Enums.Education | null
    experience?: string | null
    start_date?: Date | string
    end_date?: Date | string | null
    created_at?: Date | string
    updated_at: Date | string
    applicants?: applicantsCreateNestedManyWithoutJobsInput
    jobLabels?: jobLabelsCreateNestedOneWithoutJobsInput
    savedJobs?: savedJobsCreateNestedManyWithoutJobsInput
  }

  export type jobsUncheckedCreateWithoutCategoriesInput = {
    id: string
    job_title: string
    description: string
    location?: string | null
    benefit?: string | null
    working_time?: string | null
    salary?: jobsCreatesalaryInput | string[]
    currency?: string | null
    job_type?: $Enums.Job_Type | null
    status?: $Enums.Job_Status | null
    job_level: string
    quantity?: number | null
    skill_tags?: jobsCreateskill_tagsInput | string[]
    education?: $Enums.Education | null
    experience?: string | null
    start_date?: Date | string
    end_date?: Date | string | null
    created_at?: Date | string
    updated_at: Date | string
    label_id?: number | null
    applicants?: applicantsUncheckedCreateNestedManyWithoutJobsInput
    savedJobs?: savedJobsUncheckedCreateNestedManyWithoutJobsInput
  }

  export type jobsCreateOrConnectWithoutCategoriesInput = {
    where: jobsWhereUniqueInput
    create: XOR<jobsCreateWithoutCategoriesInput, jobsUncheckedCreateWithoutCategoriesInput>
  }

  export type jobsCreateManyCategoriesInputEnvelope = {
    data: jobsCreateManyCategoriesInput | jobsCreateManyCategoriesInput[]
    skipDuplicates?: boolean
  }

  export type jobsUpsertWithWhereUniqueWithoutCategoriesInput = {
    where: jobsWhereUniqueInput
    update: XOR<jobsUpdateWithoutCategoriesInput, jobsUncheckedUpdateWithoutCategoriesInput>
    create: XOR<jobsCreateWithoutCategoriesInput, jobsUncheckedCreateWithoutCategoriesInput>
  }

  export type jobsUpdateWithWhereUniqueWithoutCategoriesInput = {
    where: jobsWhereUniqueInput
    data: XOR<jobsUpdateWithoutCategoriesInput, jobsUncheckedUpdateWithoutCategoriesInput>
  }

  export type jobsUpdateManyWithWhereWithoutCategoriesInput = {
    where: jobsScalarWhereInput
    data: XOR<jobsUpdateManyMutationInput, jobsUncheckedUpdateManyWithoutCategoriesInput>
  }

  export type jobsScalarWhereInput = {
    AND?: jobsScalarWhereInput | jobsScalarWhereInput[]
    OR?: jobsScalarWhereInput[]
    NOT?: jobsScalarWhereInput | jobsScalarWhereInput[]
    id?: StringFilter<"jobs"> | string
    job_title?: StringFilter<"jobs"> | string
    description?: StringFilter<"jobs"> | string
    location?: StringNullableFilter<"jobs"> | string | null
    benefit?: StringNullableFilter<"jobs"> | string | null
    working_time?: StringNullableFilter<"jobs"> | string | null
    salary?: StringNullableListFilter<"jobs">
    currency?: StringNullableFilter<"jobs"> | string | null
    job_type?: EnumJob_TypeNullableFilter<"jobs"> | $Enums.Job_Type | null
    status?: EnumJob_StatusNullableFilter<"jobs"> | $Enums.Job_Status | null
    job_level?: StringFilter<"jobs"> | string
    quantity?: IntNullableFilter<"jobs"> | number | null
    skill_tags?: StringNullableListFilter<"jobs">
    education?: EnumEducationNullableFilter<"jobs"> | $Enums.Education | null
    experience?: StringNullableFilter<"jobs"> | string | null
    start_date?: DateTimeFilter<"jobs"> | Date | string
    end_date?: DateTimeNullableFilter<"jobs"> | Date | string | null
    created_at?: DateTimeFilter<"jobs"> | Date | string
    updated_at?: DateTimeFilter<"jobs"> | Date | string
    category_id?: IntNullableFilter<"jobs"> | number | null
    label_id?: IntNullableFilter<"jobs"> | number | null
  }

  export type cvsCreateWithoutCertificatesInput = {
    fullname: string
    age?: number | null
    gender?: string | null
    address?: string | null
    email?: string | null
    introduction?: string | null
    soft_skills?: cvsCreatesoft_skillsInput | string[]
    primary_skills?: cvsCreateprimary_skillsInput | string[]
    phone?: string | null
    hobbies?: string | null
    others?: string | null
    applicants?: applicantsCreateNestedManyWithoutCvsInput
    awards?: awardsCreateNestedManyWithoutCvsInput
    educations?: educationsCreateNestedManyWithoutCvsInput
    experiences?: experiencesCreateNestedManyWithoutCvsInput
    projects?: projectsCreateNestedManyWithoutCvsInput
    references?: referencesCreateNestedManyWithoutCvsInput
  }

  export type cvsUncheckedCreateWithoutCertificatesInput = {
    id?: number
    fullname: string
    age?: number | null
    gender?: string | null
    address?: string | null
    email?: string | null
    introduction?: string | null
    soft_skills?: cvsCreatesoft_skillsInput | string[]
    primary_skills?: cvsCreateprimary_skillsInput | string[]
    phone?: string | null
    hobbies?: string | null
    others?: string | null
    applicants?: applicantsUncheckedCreateNestedManyWithoutCvsInput
    awards?: awardsUncheckedCreateNestedManyWithoutCvsInput
    educations?: educationsUncheckedCreateNestedManyWithoutCvsInput
    experiences?: experiencesUncheckedCreateNestedManyWithoutCvsInput
    projects?: projectsUncheckedCreateNestedManyWithoutCvsInput
    references?: referencesUncheckedCreateNestedManyWithoutCvsInput
  }

  export type cvsCreateOrConnectWithoutCertificatesInput = {
    where: cvsWhereUniqueInput
    create: XOR<cvsCreateWithoutCertificatesInput, cvsUncheckedCreateWithoutCertificatesInput>
  }

  export type cvsUpsertWithoutCertificatesInput = {
    update: XOR<cvsUpdateWithoutCertificatesInput, cvsUncheckedUpdateWithoutCertificatesInput>
    create: XOR<cvsCreateWithoutCertificatesInput, cvsUncheckedCreateWithoutCertificatesInput>
    where?: cvsWhereInput
  }

  export type cvsUpdateToOneWithWhereWithoutCertificatesInput = {
    where?: cvsWhereInput
    data: XOR<cvsUpdateWithoutCertificatesInput, cvsUncheckedUpdateWithoutCertificatesInput>
  }

  export type cvsUpdateWithoutCertificatesInput = {
    fullname?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    soft_skills?: cvsUpdatesoft_skillsInput | string[]
    primary_skills?: cvsUpdateprimary_skillsInput | string[]
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    hobbies?: NullableStringFieldUpdateOperationsInput | string | null
    others?: NullableStringFieldUpdateOperationsInput | string | null
    applicants?: applicantsUpdateManyWithoutCvsNestedInput
    awards?: awardsUpdateManyWithoutCvsNestedInput
    educations?: educationsUpdateManyWithoutCvsNestedInput
    experiences?: experiencesUpdateManyWithoutCvsNestedInput
    projects?: projectsUpdateManyWithoutCvsNestedInput
    references?: referencesUpdateManyWithoutCvsNestedInput
  }

  export type cvsUncheckedUpdateWithoutCertificatesInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullname?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    soft_skills?: cvsUpdatesoft_skillsInput | string[]
    primary_skills?: cvsUpdateprimary_skillsInput | string[]
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    hobbies?: NullableStringFieldUpdateOperationsInput | string | null
    others?: NullableStringFieldUpdateOperationsInput | string | null
    applicants?: applicantsUncheckedUpdateManyWithoutCvsNestedInput
    awards?: awardsUncheckedUpdateManyWithoutCvsNestedInput
    educations?: educationsUncheckedUpdateManyWithoutCvsNestedInput
    experiences?: experiencesUncheckedUpdateManyWithoutCvsNestedInput
    projects?: projectsUncheckedUpdateManyWithoutCvsNestedInput
    references?: referencesUncheckedUpdateManyWithoutCvsNestedInput
  }

  export type fieldsCreateWithoutCompaniesInput = {
    field_name: string
  }

  export type fieldsUncheckedCreateWithoutCompaniesInput = {
    id?: number
    field_name: string
  }

  export type fieldsCreateOrConnectWithoutCompaniesInput = {
    where: fieldsWhereUniqueInput
    create: XOR<fieldsCreateWithoutCompaniesInput, fieldsUncheckedCreateWithoutCompaniesInput>
  }

  export type usersCreateWithoutCompaniesInput = {
    id: string
    username: string
    password: string
    avatar_url?: string | null
    email: string
    phone?: string | null
    address_street?: string | null
    address_ward?: string | null
    address_city?: string | null
    address_country?: string | null
    gender?: $Enums.Gender | null
    is_deleted?: boolean
    created_at?: Date | string
    updated_at: Date | string
    blogs?: blogsCreateNestedManyWithoutUsersInput
    careerPaths?: careerPathsCreateNestedManyWithoutUsersInput
    feedbacks?: feedbacksCreateNestedManyWithoutUsersInput
    followedCompanies?: followedCompaniesCreateNestedManyWithoutUsersInput
    messages?: messagesCreateNestedManyWithoutUsersInput
    payments?: paymentsCreateNestedManyWithoutUsersInput
    personalityTestResults?: personalityTestResultsCreateNestedManyWithoutUsersInput
    savedJobs?: savedJobsCreateNestedManyWithoutUsersInput
    subscriptions?: subscriptionsCreateNestedManyWithoutUsersInput
    userActivitiesHistory?: userActivitiesHistoryCreateNestedManyWithoutUsersInput
    userNotifications?: userNotificationsCreateNestedManyWithoutUsersInput
    roles: rolesCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutCompaniesInput = {
    id: string
    username: string
    password: string
    avatar_url?: string | null
    email: string
    phone?: string | null
    address_street?: string | null
    address_ward?: string | null
    address_city?: string | null
    address_country?: string | null
    gender?: $Enums.Gender | null
    is_deleted?: boolean
    created_at?: Date | string
    updated_at: Date | string
    role_id: number
    blogs?: blogsUncheckedCreateNestedManyWithoutUsersInput
    careerPaths?: careerPathsUncheckedCreateNestedManyWithoutUsersInput
    feedbacks?: feedbacksUncheckedCreateNestedManyWithoutUsersInput
    followedCompanies?: followedCompaniesUncheckedCreateNestedManyWithoutUsersInput
    messages?: messagesUncheckedCreateNestedManyWithoutUsersInput
    payments?: paymentsUncheckedCreateNestedManyWithoutUsersInput
    personalityTestResults?: personalityTestResultsUncheckedCreateNestedManyWithoutUsersInput
    savedJobs?: savedJobsUncheckedCreateNestedManyWithoutUsersInput
    subscriptions?: subscriptionsUncheckedCreateNestedManyWithoutUsersInput
    userActivitiesHistory?: userActivitiesHistoryUncheckedCreateNestedManyWithoutUsersInput
    userNotifications?: userNotificationsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutCompaniesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutCompaniesInput, usersUncheckedCreateWithoutCompaniesInput>
  }

  export type companyLabelsCreateWithoutCompaniesInput = {
    label_name: string
  }

  export type companyLabelsUncheckedCreateWithoutCompaniesInput = {
    id?: number
    label_name: string
  }

  export type companyLabelsCreateOrConnectWithoutCompaniesInput = {
    where: companyLabelsWhereUniqueInput
    create: XOR<companyLabelsCreateWithoutCompaniesInput, companyLabelsUncheckedCreateWithoutCompaniesInput>
  }

  export type companyActivitiesHistoryCreateWithoutCompaniesInput = {
    id?: number
    activity_name: string
    time?: Date | string
  }

  export type companyActivitiesHistoryUncheckedCreateWithoutCompaniesInput = {
    id?: number
    activity_name: string
    time?: Date | string
  }

  export type companyActivitiesHistoryCreateOrConnectWithoutCompaniesInput = {
    where: companyActivitiesHistoryWhereUniqueInput
    create: XOR<companyActivitiesHistoryCreateWithoutCompaniesInput, companyActivitiesHistoryUncheckedCreateWithoutCompaniesInput>
  }

  export type companyActivitiesHistoryCreateManyCompaniesInputEnvelope = {
    data: companyActivitiesHistoryCreateManyCompaniesInput | companyActivitiesHistoryCreateManyCompaniesInput[]
    skipDuplicates?: boolean
  }

  export type companyNotificationsCreateWithoutCompaniesInput = {
    id?: number
    title: string
    content?: string | null
    type?: $Enums.NotificationsType
    is_read?: boolean
    sent_at?: Date | string
    read_at?: Date | string | null
  }

  export type companyNotificationsUncheckedCreateWithoutCompaniesInput = {
    id?: number
    title: string
    content?: string | null
    type?: $Enums.NotificationsType
    is_read?: boolean
    sent_at?: Date | string
    read_at?: Date | string | null
  }

  export type companyNotificationsCreateOrConnectWithoutCompaniesInput = {
    where: companyNotificationsWhereUniqueInput
    create: XOR<companyNotificationsCreateWithoutCompaniesInput, companyNotificationsUncheckedCreateWithoutCompaniesInput>
  }

  export type companyNotificationsCreateManyCompaniesInputEnvelope = {
    data: companyNotificationsCreateManyCompaniesInput | companyNotificationsCreateManyCompaniesInput[]
    skipDuplicates?: boolean
  }

  export type feedbacksCreateWithoutCompaniesInput = {
    description: string
    stars: number
    work_environment?: string | null
    benefit?: string | null
    created_at?: Date | string
    users: usersCreateNestedOneWithoutFeedbacksInput
  }

  export type feedbacksUncheckedCreateWithoutCompaniesInput = {
    user_id: string
    description: string
    stars: number
    work_environment?: string | null
    benefit?: string | null
    created_at?: Date | string
  }

  export type feedbacksCreateOrConnectWithoutCompaniesInput = {
    where: feedbacksWhereUniqueInput
    create: XOR<feedbacksCreateWithoutCompaniesInput, feedbacksUncheckedCreateWithoutCompaniesInput>
  }

  export type feedbacksCreateManyCompaniesInputEnvelope = {
    data: feedbacksCreateManyCompaniesInput | feedbacksCreateManyCompaniesInput[]
    skipDuplicates?: boolean
  }

  export type followedCompaniesCreateWithoutCompaniesInput = {
    followed_at?: Date | string
    is_notified?: boolean
    users: usersCreateNestedOneWithoutFollowedCompaniesInput
  }

  export type followedCompaniesUncheckedCreateWithoutCompaniesInput = {
    user_id: string
    followed_at?: Date | string
    is_notified?: boolean
  }

  export type followedCompaniesCreateOrConnectWithoutCompaniesInput = {
    where: followedCompaniesWhereUniqueInput
    create: XOR<followedCompaniesCreateWithoutCompaniesInput, followedCompaniesUncheckedCreateWithoutCompaniesInput>
  }

  export type followedCompaniesCreateManyCompaniesInputEnvelope = {
    data: followedCompaniesCreateManyCompaniesInput | followedCompaniesCreateManyCompaniesInput[]
    skipDuplicates?: boolean
  }

  export type fieldsUpsertWithoutCompaniesInput = {
    update: XOR<fieldsUpdateWithoutCompaniesInput, fieldsUncheckedUpdateWithoutCompaniesInput>
    create: XOR<fieldsCreateWithoutCompaniesInput, fieldsUncheckedCreateWithoutCompaniesInput>
    where?: fieldsWhereInput
  }

  export type fieldsUpdateToOneWithWhereWithoutCompaniesInput = {
    where?: fieldsWhereInput
    data: XOR<fieldsUpdateWithoutCompaniesInput, fieldsUncheckedUpdateWithoutCompaniesInput>
  }

  export type fieldsUpdateWithoutCompaniesInput = {
    field_name?: StringFieldUpdateOperationsInput | string
  }

  export type fieldsUncheckedUpdateWithoutCompaniesInput = {
    id?: IntFieldUpdateOperationsInput | number
    field_name?: StringFieldUpdateOperationsInput | string
  }

  export type usersUpsertWithoutCompaniesInput = {
    update: XOR<usersUpdateWithoutCompaniesInput, usersUncheckedUpdateWithoutCompaniesInput>
    create: XOR<usersCreateWithoutCompaniesInput, usersUncheckedCreateWithoutCompaniesInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutCompaniesInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutCompaniesInput, usersUncheckedUpdateWithoutCompaniesInput>
  }

  export type usersUpdateWithoutCompaniesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: NullableStringFieldUpdateOperationsInput | string | null
    address_ward?: NullableStringFieldUpdateOperationsInput | string | null
    address_city?: NullableStringFieldUpdateOperationsInput | string | null
    address_country?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    blogs?: blogsUpdateManyWithoutUsersNestedInput
    careerPaths?: careerPathsUpdateManyWithoutUsersNestedInput
    feedbacks?: feedbacksUpdateManyWithoutUsersNestedInput
    followedCompanies?: followedCompaniesUpdateManyWithoutUsersNestedInput
    messages?: messagesUpdateManyWithoutUsersNestedInput
    payments?: paymentsUpdateManyWithoutUsersNestedInput
    personalityTestResults?: personalityTestResultsUpdateManyWithoutUsersNestedInput
    savedJobs?: savedJobsUpdateManyWithoutUsersNestedInput
    subscriptions?: subscriptionsUpdateManyWithoutUsersNestedInput
    userActivitiesHistory?: userActivitiesHistoryUpdateManyWithoutUsersNestedInput
    userNotifications?: userNotificationsUpdateManyWithoutUsersNestedInput
    roles?: rolesUpdateOneRequiredWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutCompaniesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: NullableStringFieldUpdateOperationsInput | string | null
    address_ward?: NullableStringFieldUpdateOperationsInput | string | null
    address_city?: NullableStringFieldUpdateOperationsInput | string | null
    address_country?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role_id?: IntFieldUpdateOperationsInput | number
    blogs?: blogsUncheckedUpdateManyWithoutUsersNestedInput
    careerPaths?: careerPathsUncheckedUpdateManyWithoutUsersNestedInput
    feedbacks?: feedbacksUncheckedUpdateManyWithoutUsersNestedInput
    followedCompanies?: followedCompaniesUncheckedUpdateManyWithoutUsersNestedInput
    messages?: messagesUncheckedUpdateManyWithoutUsersNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutUsersNestedInput
    personalityTestResults?: personalityTestResultsUncheckedUpdateManyWithoutUsersNestedInput
    savedJobs?: savedJobsUncheckedUpdateManyWithoutUsersNestedInput
    subscriptions?: subscriptionsUncheckedUpdateManyWithoutUsersNestedInput
    userActivitiesHistory?: userActivitiesHistoryUncheckedUpdateManyWithoutUsersNestedInput
    userNotifications?: userNotificationsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type companyLabelsUpsertWithoutCompaniesInput = {
    update: XOR<companyLabelsUpdateWithoutCompaniesInput, companyLabelsUncheckedUpdateWithoutCompaniesInput>
    create: XOR<companyLabelsCreateWithoutCompaniesInput, companyLabelsUncheckedCreateWithoutCompaniesInput>
    where?: companyLabelsWhereInput
  }

  export type companyLabelsUpdateToOneWithWhereWithoutCompaniesInput = {
    where?: companyLabelsWhereInput
    data: XOR<companyLabelsUpdateWithoutCompaniesInput, companyLabelsUncheckedUpdateWithoutCompaniesInput>
  }

  export type companyLabelsUpdateWithoutCompaniesInput = {
    label_name?: StringFieldUpdateOperationsInput | string
  }

  export type companyLabelsUncheckedUpdateWithoutCompaniesInput = {
    id?: IntFieldUpdateOperationsInput | number
    label_name?: StringFieldUpdateOperationsInput | string
  }

  export type companyActivitiesHistoryUpsertWithWhereUniqueWithoutCompaniesInput = {
    where: companyActivitiesHistoryWhereUniqueInput
    update: XOR<companyActivitiesHistoryUpdateWithoutCompaniesInput, companyActivitiesHistoryUncheckedUpdateWithoutCompaniesInput>
    create: XOR<companyActivitiesHistoryCreateWithoutCompaniesInput, companyActivitiesHistoryUncheckedCreateWithoutCompaniesInput>
  }

  export type companyActivitiesHistoryUpdateWithWhereUniqueWithoutCompaniesInput = {
    where: companyActivitiesHistoryWhereUniqueInput
    data: XOR<companyActivitiesHistoryUpdateWithoutCompaniesInput, companyActivitiesHistoryUncheckedUpdateWithoutCompaniesInput>
  }

  export type companyActivitiesHistoryUpdateManyWithWhereWithoutCompaniesInput = {
    where: companyActivitiesHistoryScalarWhereInput
    data: XOR<companyActivitiesHistoryUpdateManyMutationInput, companyActivitiesHistoryUncheckedUpdateManyWithoutCompaniesInput>
  }

  export type companyActivitiesHistoryScalarWhereInput = {
    AND?: companyActivitiesHistoryScalarWhereInput | companyActivitiesHistoryScalarWhereInput[]
    OR?: companyActivitiesHistoryScalarWhereInput[]
    NOT?: companyActivitiesHistoryScalarWhereInput | companyActivitiesHistoryScalarWhereInput[]
    id?: IntFilter<"companyActivitiesHistory"> | number
    activity_name?: StringFilter<"companyActivitiesHistory"> | string
    time?: DateTimeFilter<"companyActivitiesHistory"> | Date | string
    company_id?: StringFilter<"companyActivitiesHistory"> | string
  }

  export type companyNotificationsUpsertWithWhereUniqueWithoutCompaniesInput = {
    where: companyNotificationsWhereUniqueInput
    update: XOR<companyNotificationsUpdateWithoutCompaniesInput, companyNotificationsUncheckedUpdateWithoutCompaniesInput>
    create: XOR<companyNotificationsCreateWithoutCompaniesInput, companyNotificationsUncheckedCreateWithoutCompaniesInput>
  }

  export type companyNotificationsUpdateWithWhereUniqueWithoutCompaniesInput = {
    where: companyNotificationsWhereUniqueInput
    data: XOR<companyNotificationsUpdateWithoutCompaniesInput, companyNotificationsUncheckedUpdateWithoutCompaniesInput>
  }

  export type companyNotificationsUpdateManyWithWhereWithoutCompaniesInput = {
    where: companyNotificationsScalarWhereInput
    data: XOR<companyNotificationsUpdateManyMutationInput, companyNotificationsUncheckedUpdateManyWithoutCompaniesInput>
  }

  export type companyNotificationsScalarWhereInput = {
    AND?: companyNotificationsScalarWhereInput | companyNotificationsScalarWhereInput[]
    OR?: companyNotificationsScalarWhereInput[]
    NOT?: companyNotificationsScalarWhereInput | companyNotificationsScalarWhereInput[]
    id?: IntFilter<"companyNotifications"> | number
    company_id?: StringFilter<"companyNotifications"> | string
    title?: StringFilter<"companyNotifications"> | string
    content?: StringNullableFilter<"companyNotifications"> | string | null
    type?: EnumNotificationsTypeFilter<"companyNotifications"> | $Enums.NotificationsType
    is_read?: BoolFilter<"companyNotifications"> | boolean
    sent_at?: DateTimeFilter<"companyNotifications"> | Date | string
    read_at?: DateTimeNullableFilter<"companyNotifications"> | Date | string | null
  }

  export type feedbacksUpsertWithWhereUniqueWithoutCompaniesInput = {
    where: feedbacksWhereUniqueInput
    update: XOR<feedbacksUpdateWithoutCompaniesInput, feedbacksUncheckedUpdateWithoutCompaniesInput>
    create: XOR<feedbacksCreateWithoutCompaniesInput, feedbacksUncheckedCreateWithoutCompaniesInput>
  }

  export type feedbacksUpdateWithWhereUniqueWithoutCompaniesInput = {
    where: feedbacksWhereUniqueInput
    data: XOR<feedbacksUpdateWithoutCompaniesInput, feedbacksUncheckedUpdateWithoutCompaniesInput>
  }

  export type feedbacksUpdateManyWithWhereWithoutCompaniesInput = {
    where: feedbacksScalarWhereInput
    data: XOR<feedbacksUpdateManyMutationInput, feedbacksUncheckedUpdateManyWithoutCompaniesInput>
  }

  export type feedbacksScalarWhereInput = {
    AND?: feedbacksScalarWhereInput | feedbacksScalarWhereInput[]
    OR?: feedbacksScalarWhereInput[]
    NOT?: feedbacksScalarWhereInput | feedbacksScalarWhereInput[]
    user_id?: StringFilter<"feedbacks"> | string
    company_id?: StringFilter<"feedbacks"> | string
    description?: StringFilter<"feedbacks"> | string
    stars?: FloatFilter<"feedbacks"> | number
    work_environment?: StringNullableFilter<"feedbacks"> | string | null
    benefit?: StringNullableFilter<"feedbacks"> | string | null
    created_at?: DateTimeFilter<"feedbacks"> | Date | string
  }

  export type followedCompaniesUpsertWithWhereUniqueWithoutCompaniesInput = {
    where: followedCompaniesWhereUniqueInput
    update: XOR<followedCompaniesUpdateWithoutCompaniesInput, followedCompaniesUncheckedUpdateWithoutCompaniesInput>
    create: XOR<followedCompaniesCreateWithoutCompaniesInput, followedCompaniesUncheckedCreateWithoutCompaniesInput>
  }

  export type followedCompaniesUpdateWithWhereUniqueWithoutCompaniesInput = {
    where: followedCompaniesWhereUniqueInput
    data: XOR<followedCompaniesUpdateWithoutCompaniesInput, followedCompaniesUncheckedUpdateWithoutCompaniesInput>
  }

  export type followedCompaniesUpdateManyWithWhereWithoutCompaniesInput = {
    where: followedCompaniesScalarWhereInput
    data: XOR<followedCompaniesUpdateManyMutationInput, followedCompaniesUncheckedUpdateManyWithoutCompaniesInput>
  }

  export type followedCompaniesScalarWhereInput = {
    AND?: followedCompaniesScalarWhereInput | followedCompaniesScalarWhereInput[]
    OR?: followedCompaniesScalarWhereInput[]
    NOT?: followedCompaniesScalarWhereInput | followedCompaniesScalarWhereInput[]
    user_id?: StringFilter<"followedCompanies"> | string
    company_id?: StringFilter<"followedCompanies"> | string
    followed_at?: DateTimeFilter<"followedCompanies"> | Date | string
    is_notified?: BoolFilter<"followedCompanies"> | boolean
  }

  export type companiesCreateWithoutCompanyActivitiesHistoryInput = {
    company_name: string
    company_website?: string | null
    address_street: string
    address_ward: string
    address_city: string
    address_country: string
    email: string
    phone: string
    business_certificate?: string | null
    company_type?: $Enums.Company_Type
    description?: string | null
    logo_url?: string | null
    background_url?: string | null
    employees?: number | null
    is_verified?: boolean
    fax_code?: string | null
    is_deleted?: boolean
    created_at?: Date | string
    updated_at: Date | string
    fields?: fieldsCreateNestedOneWithoutCompaniesInput
    users: usersCreateNestedOneWithoutCompaniesInput
    companyLabels?: companyLabelsCreateNestedOneWithoutCompaniesInput
    companyNotifications?: companyNotificationsCreateNestedManyWithoutCompaniesInput
    feedbacks?: feedbacksCreateNestedManyWithoutCompaniesInput
    followedCompanies?: followedCompaniesCreateNestedManyWithoutCompaniesInput
  }

  export type companiesUncheckedCreateWithoutCompanyActivitiesHistoryInput = {
    id: string
    company_name: string
    company_website?: string | null
    address_street: string
    address_ward: string
    address_city: string
    address_country: string
    email: string
    phone: string
    business_certificate?: string | null
    company_type?: $Enums.Company_Type
    description?: string | null
    logo_url?: string | null
    background_url?: string | null
    employees?: number | null
    is_verified?: boolean
    fax_code?: string | null
    is_deleted?: boolean
    created_at?: Date | string
    updated_at: Date | string
    field_id?: number | null
    label_id?: number | null
    companyNotifications?: companyNotificationsUncheckedCreateNestedManyWithoutCompaniesInput
    feedbacks?: feedbacksUncheckedCreateNestedManyWithoutCompaniesInput
    followedCompanies?: followedCompaniesUncheckedCreateNestedManyWithoutCompaniesInput
  }

  export type companiesCreateOrConnectWithoutCompanyActivitiesHistoryInput = {
    where: companiesWhereUniqueInput
    create: XOR<companiesCreateWithoutCompanyActivitiesHistoryInput, companiesUncheckedCreateWithoutCompanyActivitiesHistoryInput>
  }

  export type companiesUpsertWithoutCompanyActivitiesHistoryInput = {
    update: XOR<companiesUpdateWithoutCompanyActivitiesHistoryInput, companiesUncheckedUpdateWithoutCompanyActivitiesHistoryInput>
    create: XOR<companiesCreateWithoutCompanyActivitiesHistoryInput, companiesUncheckedCreateWithoutCompanyActivitiesHistoryInput>
    where?: companiesWhereInput
  }

  export type companiesUpdateToOneWithWhereWithoutCompanyActivitiesHistoryInput = {
    where?: companiesWhereInput
    data: XOR<companiesUpdateWithoutCompanyActivitiesHistoryInput, companiesUncheckedUpdateWithoutCompanyActivitiesHistoryInput>
  }

  export type companiesUpdateWithoutCompanyActivitiesHistoryInput = {
    company_name?: StringFieldUpdateOperationsInput | string
    company_website?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: StringFieldUpdateOperationsInput | string
    address_ward?: StringFieldUpdateOperationsInput | string
    address_city?: StringFieldUpdateOperationsInput | string
    address_country?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    business_certificate?: NullableStringFieldUpdateOperationsInput | string | null
    company_type?: EnumCompany_TypeFieldUpdateOperationsInput | $Enums.Company_Type
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    background_url?: NullableStringFieldUpdateOperationsInput | string | null
    employees?: NullableIntFieldUpdateOperationsInput | number | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    fax_code?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    fields?: fieldsUpdateOneWithoutCompaniesNestedInput
    users?: usersUpdateOneRequiredWithoutCompaniesNestedInput
    companyLabels?: companyLabelsUpdateOneWithoutCompaniesNestedInput
    companyNotifications?: companyNotificationsUpdateManyWithoutCompaniesNestedInput
    feedbacks?: feedbacksUpdateManyWithoutCompaniesNestedInput
    followedCompanies?: followedCompaniesUpdateManyWithoutCompaniesNestedInput
  }

  export type companiesUncheckedUpdateWithoutCompanyActivitiesHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    company_name?: StringFieldUpdateOperationsInput | string
    company_website?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: StringFieldUpdateOperationsInput | string
    address_ward?: StringFieldUpdateOperationsInput | string
    address_city?: StringFieldUpdateOperationsInput | string
    address_country?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    business_certificate?: NullableStringFieldUpdateOperationsInput | string | null
    company_type?: EnumCompany_TypeFieldUpdateOperationsInput | $Enums.Company_Type
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    background_url?: NullableStringFieldUpdateOperationsInput | string | null
    employees?: NullableIntFieldUpdateOperationsInput | number | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    fax_code?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    field_id?: NullableIntFieldUpdateOperationsInput | number | null
    label_id?: NullableIntFieldUpdateOperationsInput | number | null
    companyNotifications?: companyNotificationsUncheckedUpdateManyWithoutCompaniesNestedInput
    feedbacks?: feedbacksUncheckedUpdateManyWithoutCompaniesNestedInput
    followedCompanies?: followedCompaniesUncheckedUpdateManyWithoutCompaniesNestedInput
  }

  export type companiesCreateWithoutCompanyLabelsInput = {
    company_name: string
    company_website?: string | null
    address_street: string
    address_ward: string
    address_city: string
    address_country: string
    email: string
    phone: string
    business_certificate?: string | null
    company_type?: $Enums.Company_Type
    description?: string | null
    logo_url?: string | null
    background_url?: string | null
    employees?: number | null
    is_verified?: boolean
    fax_code?: string | null
    is_deleted?: boolean
    created_at?: Date | string
    updated_at: Date | string
    fields?: fieldsCreateNestedOneWithoutCompaniesInput
    users: usersCreateNestedOneWithoutCompaniesInput
    companyActivitiesHistory?: companyActivitiesHistoryCreateNestedManyWithoutCompaniesInput
    companyNotifications?: companyNotificationsCreateNestedManyWithoutCompaniesInput
    feedbacks?: feedbacksCreateNestedManyWithoutCompaniesInput
    followedCompanies?: followedCompaniesCreateNestedManyWithoutCompaniesInput
  }

  export type companiesUncheckedCreateWithoutCompanyLabelsInput = {
    id: string
    company_name: string
    company_website?: string | null
    address_street: string
    address_ward: string
    address_city: string
    address_country: string
    email: string
    phone: string
    business_certificate?: string | null
    company_type?: $Enums.Company_Type
    description?: string | null
    logo_url?: string | null
    background_url?: string | null
    employees?: number | null
    is_verified?: boolean
    fax_code?: string | null
    is_deleted?: boolean
    created_at?: Date | string
    updated_at: Date | string
    field_id?: number | null
    companyActivitiesHistory?: companyActivitiesHistoryUncheckedCreateNestedManyWithoutCompaniesInput
    companyNotifications?: companyNotificationsUncheckedCreateNestedManyWithoutCompaniesInput
    feedbacks?: feedbacksUncheckedCreateNestedManyWithoutCompaniesInput
    followedCompanies?: followedCompaniesUncheckedCreateNestedManyWithoutCompaniesInput
  }

  export type companiesCreateOrConnectWithoutCompanyLabelsInput = {
    where: companiesWhereUniqueInput
    create: XOR<companiesCreateWithoutCompanyLabelsInput, companiesUncheckedCreateWithoutCompanyLabelsInput>
  }

  export type companiesCreateManyCompanyLabelsInputEnvelope = {
    data: companiesCreateManyCompanyLabelsInput | companiesCreateManyCompanyLabelsInput[]
    skipDuplicates?: boolean
  }

  export type companiesUpsertWithWhereUniqueWithoutCompanyLabelsInput = {
    where: companiesWhereUniqueInput
    update: XOR<companiesUpdateWithoutCompanyLabelsInput, companiesUncheckedUpdateWithoutCompanyLabelsInput>
    create: XOR<companiesCreateWithoutCompanyLabelsInput, companiesUncheckedCreateWithoutCompanyLabelsInput>
  }

  export type companiesUpdateWithWhereUniqueWithoutCompanyLabelsInput = {
    where: companiesWhereUniqueInput
    data: XOR<companiesUpdateWithoutCompanyLabelsInput, companiesUncheckedUpdateWithoutCompanyLabelsInput>
  }

  export type companiesUpdateManyWithWhereWithoutCompanyLabelsInput = {
    where: companiesScalarWhereInput
    data: XOR<companiesUpdateManyMutationInput, companiesUncheckedUpdateManyWithoutCompanyLabelsInput>
  }

  export type companiesScalarWhereInput = {
    AND?: companiesScalarWhereInput | companiesScalarWhereInput[]
    OR?: companiesScalarWhereInput[]
    NOT?: companiesScalarWhereInput | companiesScalarWhereInput[]
    id?: StringFilter<"companies"> | string
    company_name?: StringFilter<"companies"> | string
    company_website?: StringNullableFilter<"companies"> | string | null
    address_street?: StringFilter<"companies"> | string
    address_ward?: StringFilter<"companies"> | string
    address_city?: StringFilter<"companies"> | string
    address_country?: StringFilter<"companies"> | string
    email?: StringFilter<"companies"> | string
    phone?: StringFilter<"companies"> | string
    business_certificate?: StringNullableFilter<"companies"> | string | null
    company_type?: EnumCompany_TypeFilter<"companies"> | $Enums.Company_Type
    description?: StringNullableFilter<"companies"> | string | null
    logo_url?: StringNullableFilter<"companies"> | string | null
    background_url?: StringNullableFilter<"companies"> | string | null
    employees?: IntNullableFilter<"companies"> | number | null
    is_verified?: BoolFilter<"companies"> | boolean
    fax_code?: StringNullableFilter<"companies"> | string | null
    is_deleted?: BoolFilter<"companies"> | boolean
    created_at?: DateTimeFilter<"companies"> | Date | string
    updated_at?: DateTimeFilter<"companies"> | Date | string
    field_id?: IntNullableFilter<"companies"> | number | null
    label_id?: IntNullableFilter<"companies"> | number | null
  }

  export type companiesCreateWithoutCompanyNotificationsInput = {
    company_name: string
    company_website?: string | null
    address_street: string
    address_ward: string
    address_city: string
    address_country: string
    email: string
    phone: string
    business_certificate?: string | null
    company_type?: $Enums.Company_Type
    description?: string | null
    logo_url?: string | null
    background_url?: string | null
    employees?: number | null
    is_verified?: boolean
    fax_code?: string | null
    is_deleted?: boolean
    created_at?: Date | string
    updated_at: Date | string
    fields?: fieldsCreateNestedOneWithoutCompaniesInput
    users: usersCreateNestedOneWithoutCompaniesInput
    companyLabels?: companyLabelsCreateNestedOneWithoutCompaniesInput
    companyActivitiesHistory?: companyActivitiesHistoryCreateNestedManyWithoutCompaniesInput
    feedbacks?: feedbacksCreateNestedManyWithoutCompaniesInput
    followedCompanies?: followedCompaniesCreateNestedManyWithoutCompaniesInput
  }

  export type companiesUncheckedCreateWithoutCompanyNotificationsInput = {
    id: string
    company_name: string
    company_website?: string | null
    address_street: string
    address_ward: string
    address_city: string
    address_country: string
    email: string
    phone: string
    business_certificate?: string | null
    company_type?: $Enums.Company_Type
    description?: string | null
    logo_url?: string | null
    background_url?: string | null
    employees?: number | null
    is_verified?: boolean
    fax_code?: string | null
    is_deleted?: boolean
    created_at?: Date | string
    updated_at: Date | string
    field_id?: number | null
    label_id?: number | null
    companyActivitiesHistory?: companyActivitiesHistoryUncheckedCreateNestedManyWithoutCompaniesInput
    feedbacks?: feedbacksUncheckedCreateNestedManyWithoutCompaniesInput
    followedCompanies?: followedCompaniesUncheckedCreateNestedManyWithoutCompaniesInput
  }

  export type companiesCreateOrConnectWithoutCompanyNotificationsInput = {
    where: companiesWhereUniqueInput
    create: XOR<companiesCreateWithoutCompanyNotificationsInput, companiesUncheckedCreateWithoutCompanyNotificationsInput>
  }

  export type companiesUpsertWithoutCompanyNotificationsInput = {
    update: XOR<companiesUpdateWithoutCompanyNotificationsInput, companiesUncheckedUpdateWithoutCompanyNotificationsInput>
    create: XOR<companiesCreateWithoutCompanyNotificationsInput, companiesUncheckedCreateWithoutCompanyNotificationsInput>
    where?: companiesWhereInput
  }

  export type companiesUpdateToOneWithWhereWithoutCompanyNotificationsInput = {
    where?: companiesWhereInput
    data: XOR<companiesUpdateWithoutCompanyNotificationsInput, companiesUncheckedUpdateWithoutCompanyNotificationsInput>
  }

  export type companiesUpdateWithoutCompanyNotificationsInput = {
    company_name?: StringFieldUpdateOperationsInput | string
    company_website?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: StringFieldUpdateOperationsInput | string
    address_ward?: StringFieldUpdateOperationsInput | string
    address_city?: StringFieldUpdateOperationsInput | string
    address_country?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    business_certificate?: NullableStringFieldUpdateOperationsInput | string | null
    company_type?: EnumCompany_TypeFieldUpdateOperationsInput | $Enums.Company_Type
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    background_url?: NullableStringFieldUpdateOperationsInput | string | null
    employees?: NullableIntFieldUpdateOperationsInput | number | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    fax_code?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    fields?: fieldsUpdateOneWithoutCompaniesNestedInput
    users?: usersUpdateOneRequiredWithoutCompaniesNestedInput
    companyLabels?: companyLabelsUpdateOneWithoutCompaniesNestedInput
    companyActivitiesHistory?: companyActivitiesHistoryUpdateManyWithoutCompaniesNestedInput
    feedbacks?: feedbacksUpdateManyWithoutCompaniesNestedInput
    followedCompanies?: followedCompaniesUpdateManyWithoutCompaniesNestedInput
  }

  export type companiesUncheckedUpdateWithoutCompanyNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    company_name?: StringFieldUpdateOperationsInput | string
    company_website?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: StringFieldUpdateOperationsInput | string
    address_ward?: StringFieldUpdateOperationsInput | string
    address_city?: StringFieldUpdateOperationsInput | string
    address_country?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    business_certificate?: NullableStringFieldUpdateOperationsInput | string | null
    company_type?: EnumCompany_TypeFieldUpdateOperationsInput | $Enums.Company_Type
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    background_url?: NullableStringFieldUpdateOperationsInput | string | null
    employees?: NullableIntFieldUpdateOperationsInput | number | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    fax_code?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    field_id?: NullableIntFieldUpdateOperationsInput | number | null
    label_id?: NullableIntFieldUpdateOperationsInput | number | null
    companyActivitiesHistory?: companyActivitiesHistoryUncheckedUpdateManyWithoutCompaniesNestedInput
    feedbacks?: feedbacksUncheckedUpdateManyWithoutCompaniesNestedInput
    followedCompanies?: followedCompaniesUncheckedUpdateManyWithoutCompaniesNestedInput
  }

  export type applicantsCreateWithoutCvsInput = {
    description?: string | null
    apply_date?: Date | string
    verified_date: Date | string
    status?: $Enums.ApplicantsStatus
    feedback?: string | null
    jobs: jobsCreateNestedOneWithoutApplicantsInput
  }

  export type applicantsUncheckedCreateWithoutCvsInput = {
    job_id: string
    description?: string | null
    apply_date?: Date | string
    verified_date: Date | string
    status?: $Enums.ApplicantsStatus
    feedback?: string | null
  }

  export type applicantsCreateOrConnectWithoutCvsInput = {
    where: applicantsWhereUniqueInput
    create: XOR<applicantsCreateWithoutCvsInput, applicantsUncheckedCreateWithoutCvsInput>
  }

  export type applicantsCreateManyCvsInputEnvelope = {
    data: applicantsCreateManyCvsInput | applicantsCreateManyCvsInput[]
    skipDuplicates?: boolean
  }

  export type awardsCreateWithoutCvsInput = {
    title: string
    description?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
  }

  export type awardsUncheckedCreateWithoutCvsInput = {
    id?: number
    title: string
    description?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
  }

  export type awardsCreateOrConnectWithoutCvsInput = {
    where: awardsWhereUniqueInput
    create: XOR<awardsCreateWithoutCvsInput, awardsUncheckedCreateWithoutCvsInput>
  }

  export type awardsCreateManyCvsInputEnvelope = {
    data: awardsCreateManyCvsInput | awardsCreateManyCvsInput[]
    skipDuplicates?: boolean
  }

  export type certificatesCreateWithoutCvsInput = {
    title: string
    link?: string | null
    description?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
  }

  export type certificatesUncheckedCreateWithoutCvsInput = {
    id?: number
    title: string
    link?: string | null
    description?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
  }

  export type certificatesCreateOrConnectWithoutCvsInput = {
    where: certificatesWhereUniqueInput
    create: XOR<certificatesCreateWithoutCvsInput, certificatesUncheckedCreateWithoutCvsInput>
  }

  export type certificatesCreateManyCvsInputEnvelope = {
    data: certificatesCreateManyCvsInput | certificatesCreateManyCvsInput[]
    skipDuplicates?: boolean
  }

  export type educationsCreateWithoutCvsInput = {
    school: string
    graduated_type?: string | null
    gpa?: number | null
    start_date?: Date | string | null
    end_date?: Date | string | null
  }

  export type educationsUncheckedCreateWithoutCvsInput = {
    id?: number
    school: string
    graduated_type?: string | null
    gpa?: number | null
    start_date?: Date | string | null
    end_date?: Date | string | null
  }

  export type educationsCreateOrConnectWithoutCvsInput = {
    where: educationsWhereUniqueInput
    create: XOR<educationsCreateWithoutCvsInput, educationsUncheckedCreateWithoutCvsInput>
  }

  export type educationsCreateManyCvsInputEnvelope = {
    data: educationsCreateManyCvsInput | educationsCreateManyCvsInput[]
    skipDuplicates?: boolean
  }

  export type experiencesCreateWithoutCvsInput = {
    company_name?: string | null
    title?: string | null
    description?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
  }

  export type experiencesUncheckedCreateWithoutCvsInput = {
    id?: number
    company_name?: string | null
    title?: string | null
    description?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
  }

  export type experiencesCreateOrConnectWithoutCvsInput = {
    where: experiencesWhereUniqueInput
    create: XOR<experiencesCreateWithoutCvsInput, experiencesUncheckedCreateWithoutCvsInput>
  }

  export type experiencesCreateManyCvsInputEnvelope = {
    data: experiencesCreateManyCvsInput | experiencesCreateManyCvsInput[]
    skipDuplicates?: boolean
  }

  export type projectsCreateWithoutCvsInput = {
    title: string
    description?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
  }

  export type projectsUncheckedCreateWithoutCvsInput = {
    id?: number
    title: string
    description?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
  }

  export type projectsCreateOrConnectWithoutCvsInput = {
    where: projectsWhereUniqueInput
    create: XOR<projectsCreateWithoutCvsInput, projectsUncheckedCreateWithoutCvsInput>
  }

  export type projectsCreateManyCvsInputEnvelope = {
    data: projectsCreateManyCvsInput | projectsCreateManyCvsInput[]
    skipDuplicates?: boolean
  }

  export type referencesCreateWithoutCvsInput = {
    name: string
    phone?: string | null
    email?: string | null
  }

  export type referencesUncheckedCreateWithoutCvsInput = {
    id?: number
    name: string
    phone?: string | null
    email?: string | null
  }

  export type referencesCreateOrConnectWithoutCvsInput = {
    where: referencesWhereUniqueInput
    create: XOR<referencesCreateWithoutCvsInput, referencesUncheckedCreateWithoutCvsInput>
  }

  export type referencesCreateManyCvsInputEnvelope = {
    data: referencesCreateManyCvsInput | referencesCreateManyCvsInput[]
    skipDuplicates?: boolean
  }

  export type applicantsUpsertWithWhereUniqueWithoutCvsInput = {
    where: applicantsWhereUniqueInput
    update: XOR<applicantsUpdateWithoutCvsInput, applicantsUncheckedUpdateWithoutCvsInput>
    create: XOR<applicantsCreateWithoutCvsInput, applicantsUncheckedCreateWithoutCvsInput>
  }

  export type applicantsUpdateWithWhereUniqueWithoutCvsInput = {
    where: applicantsWhereUniqueInput
    data: XOR<applicantsUpdateWithoutCvsInput, applicantsUncheckedUpdateWithoutCvsInput>
  }

  export type applicantsUpdateManyWithWhereWithoutCvsInput = {
    where: applicantsScalarWhereInput
    data: XOR<applicantsUpdateManyMutationInput, applicantsUncheckedUpdateManyWithoutCvsInput>
  }

  export type applicantsScalarWhereInput = {
    AND?: applicantsScalarWhereInput | applicantsScalarWhereInput[]
    OR?: applicantsScalarWhereInput[]
    NOT?: applicantsScalarWhereInput | applicantsScalarWhereInput[]
    cv_id?: IntFilter<"applicants"> | number
    job_id?: StringFilter<"applicants"> | string
    description?: StringNullableFilter<"applicants"> | string | null
    apply_date?: DateTimeFilter<"applicants"> | Date | string
    verified_date?: DateTimeFilter<"applicants"> | Date | string
    status?: EnumApplicantsStatusFilter<"applicants"> | $Enums.ApplicantsStatus
    feedback?: StringNullableFilter<"applicants"> | string | null
  }

  export type awardsUpsertWithWhereUniqueWithoutCvsInput = {
    where: awardsWhereUniqueInput
    update: XOR<awardsUpdateWithoutCvsInput, awardsUncheckedUpdateWithoutCvsInput>
    create: XOR<awardsCreateWithoutCvsInput, awardsUncheckedCreateWithoutCvsInput>
  }

  export type awardsUpdateWithWhereUniqueWithoutCvsInput = {
    where: awardsWhereUniqueInput
    data: XOR<awardsUpdateWithoutCvsInput, awardsUncheckedUpdateWithoutCvsInput>
  }

  export type awardsUpdateManyWithWhereWithoutCvsInput = {
    where: awardsScalarWhereInput
    data: XOR<awardsUpdateManyMutationInput, awardsUncheckedUpdateManyWithoutCvsInput>
  }

  export type awardsScalarWhereInput = {
    AND?: awardsScalarWhereInput | awardsScalarWhereInput[]
    OR?: awardsScalarWhereInput[]
    NOT?: awardsScalarWhereInput | awardsScalarWhereInput[]
    id?: IntFilter<"awards"> | number
    title?: StringFilter<"awards"> | string
    description?: StringNullableFilter<"awards"> | string | null
    start_date?: DateTimeNullableFilter<"awards"> | Date | string | null
    end_date?: DateTimeNullableFilter<"awards"> | Date | string | null
    cv_id?: IntFilter<"awards"> | number
  }

  export type certificatesUpsertWithWhereUniqueWithoutCvsInput = {
    where: certificatesWhereUniqueInput
    update: XOR<certificatesUpdateWithoutCvsInput, certificatesUncheckedUpdateWithoutCvsInput>
    create: XOR<certificatesCreateWithoutCvsInput, certificatesUncheckedCreateWithoutCvsInput>
  }

  export type certificatesUpdateWithWhereUniqueWithoutCvsInput = {
    where: certificatesWhereUniqueInput
    data: XOR<certificatesUpdateWithoutCvsInput, certificatesUncheckedUpdateWithoutCvsInput>
  }

  export type certificatesUpdateManyWithWhereWithoutCvsInput = {
    where: certificatesScalarWhereInput
    data: XOR<certificatesUpdateManyMutationInput, certificatesUncheckedUpdateManyWithoutCvsInput>
  }

  export type certificatesScalarWhereInput = {
    AND?: certificatesScalarWhereInput | certificatesScalarWhereInput[]
    OR?: certificatesScalarWhereInput[]
    NOT?: certificatesScalarWhereInput | certificatesScalarWhereInput[]
    id?: IntFilter<"certificates"> | number
    title?: StringFilter<"certificates"> | string
    link?: StringNullableFilter<"certificates"> | string | null
    description?: StringNullableFilter<"certificates"> | string | null
    start_date?: DateTimeNullableFilter<"certificates"> | Date | string | null
    end_date?: DateTimeNullableFilter<"certificates"> | Date | string | null
    cv_id?: IntFilter<"certificates"> | number
  }

  export type educationsUpsertWithWhereUniqueWithoutCvsInput = {
    where: educationsWhereUniqueInput
    update: XOR<educationsUpdateWithoutCvsInput, educationsUncheckedUpdateWithoutCvsInput>
    create: XOR<educationsCreateWithoutCvsInput, educationsUncheckedCreateWithoutCvsInput>
  }

  export type educationsUpdateWithWhereUniqueWithoutCvsInput = {
    where: educationsWhereUniqueInput
    data: XOR<educationsUpdateWithoutCvsInput, educationsUncheckedUpdateWithoutCvsInput>
  }

  export type educationsUpdateManyWithWhereWithoutCvsInput = {
    where: educationsScalarWhereInput
    data: XOR<educationsUpdateManyMutationInput, educationsUncheckedUpdateManyWithoutCvsInput>
  }

  export type educationsScalarWhereInput = {
    AND?: educationsScalarWhereInput | educationsScalarWhereInput[]
    OR?: educationsScalarWhereInput[]
    NOT?: educationsScalarWhereInput | educationsScalarWhereInput[]
    id?: IntFilter<"educations"> | number
    school?: StringFilter<"educations"> | string
    graduated_type?: StringNullableFilter<"educations"> | string | null
    gpa?: FloatNullableFilter<"educations"> | number | null
    start_date?: DateTimeNullableFilter<"educations"> | Date | string | null
    end_date?: DateTimeNullableFilter<"educations"> | Date | string | null
    cv_id?: IntFilter<"educations"> | number
  }

  export type experiencesUpsertWithWhereUniqueWithoutCvsInput = {
    where: experiencesWhereUniqueInput
    update: XOR<experiencesUpdateWithoutCvsInput, experiencesUncheckedUpdateWithoutCvsInput>
    create: XOR<experiencesCreateWithoutCvsInput, experiencesUncheckedCreateWithoutCvsInput>
  }

  export type experiencesUpdateWithWhereUniqueWithoutCvsInput = {
    where: experiencesWhereUniqueInput
    data: XOR<experiencesUpdateWithoutCvsInput, experiencesUncheckedUpdateWithoutCvsInput>
  }

  export type experiencesUpdateManyWithWhereWithoutCvsInput = {
    where: experiencesScalarWhereInput
    data: XOR<experiencesUpdateManyMutationInput, experiencesUncheckedUpdateManyWithoutCvsInput>
  }

  export type experiencesScalarWhereInput = {
    AND?: experiencesScalarWhereInput | experiencesScalarWhereInput[]
    OR?: experiencesScalarWhereInput[]
    NOT?: experiencesScalarWhereInput | experiencesScalarWhereInput[]
    id?: IntFilter<"experiences"> | number
    company_name?: StringNullableFilter<"experiences"> | string | null
    title?: StringNullableFilter<"experiences"> | string | null
    description?: StringNullableFilter<"experiences"> | string | null
    start_date?: DateTimeNullableFilter<"experiences"> | Date | string | null
    end_date?: DateTimeNullableFilter<"experiences"> | Date | string | null
    cv_id?: IntFilter<"experiences"> | number
  }

  export type projectsUpsertWithWhereUniqueWithoutCvsInput = {
    where: projectsWhereUniqueInput
    update: XOR<projectsUpdateWithoutCvsInput, projectsUncheckedUpdateWithoutCvsInput>
    create: XOR<projectsCreateWithoutCvsInput, projectsUncheckedCreateWithoutCvsInput>
  }

  export type projectsUpdateWithWhereUniqueWithoutCvsInput = {
    where: projectsWhereUniqueInput
    data: XOR<projectsUpdateWithoutCvsInput, projectsUncheckedUpdateWithoutCvsInput>
  }

  export type projectsUpdateManyWithWhereWithoutCvsInput = {
    where: projectsScalarWhereInput
    data: XOR<projectsUpdateManyMutationInput, projectsUncheckedUpdateManyWithoutCvsInput>
  }

  export type projectsScalarWhereInput = {
    AND?: projectsScalarWhereInput | projectsScalarWhereInput[]
    OR?: projectsScalarWhereInput[]
    NOT?: projectsScalarWhereInput | projectsScalarWhereInput[]
    id?: IntFilter<"projects"> | number
    title?: StringFilter<"projects"> | string
    description?: StringNullableFilter<"projects"> | string | null
    start_date?: DateTimeNullableFilter<"projects"> | Date | string | null
    end_date?: DateTimeNullableFilter<"projects"> | Date | string | null
    cv_id?: IntFilter<"projects"> | number
  }

  export type referencesUpsertWithWhereUniqueWithoutCvsInput = {
    where: referencesWhereUniqueInput
    update: XOR<referencesUpdateWithoutCvsInput, referencesUncheckedUpdateWithoutCvsInput>
    create: XOR<referencesCreateWithoutCvsInput, referencesUncheckedCreateWithoutCvsInput>
  }

  export type referencesUpdateWithWhereUniqueWithoutCvsInput = {
    where: referencesWhereUniqueInput
    data: XOR<referencesUpdateWithoutCvsInput, referencesUncheckedUpdateWithoutCvsInput>
  }

  export type referencesUpdateManyWithWhereWithoutCvsInput = {
    where: referencesScalarWhereInput
    data: XOR<referencesUpdateManyMutationInput, referencesUncheckedUpdateManyWithoutCvsInput>
  }

  export type referencesScalarWhereInput = {
    AND?: referencesScalarWhereInput | referencesScalarWhereInput[]
    OR?: referencesScalarWhereInput[]
    NOT?: referencesScalarWhereInput | referencesScalarWhereInput[]
    id?: IntFilter<"references"> | number
    name?: StringFilter<"references"> | string
    phone?: StringNullableFilter<"references"> | string | null
    email?: StringNullableFilter<"references"> | string | null
    cv_id?: IntFilter<"references"> | number
  }

  export type cvsCreateWithoutEducationsInput = {
    fullname: string
    age?: number | null
    gender?: string | null
    address?: string | null
    email?: string | null
    introduction?: string | null
    soft_skills?: cvsCreatesoft_skillsInput | string[]
    primary_skills?: cvsCreateprimary_skillsInput | string[]
    phone?: string | null
    hobbies?: string | null
    others?: string | null
    applicants?: applicantsCreateNestedManyWithoutCvsInput
    awards?: awardsCreateNestedManyWithoutCvsInput
    certificates?: certificatesCreateNestedManyWithoutCvsInput
    experiences?: experiencesCreateNestedManyWithoutCvsInput
    projects?: projectsCreateNestedManyWithoutCvsInput
    references?: referencesCreateNestedManyWithoutCvsInput
  }

  export type cvsUncheckedCreateWithoutEducationsInput = {
    id?: number
    fullname: string
    age?: number | null
    gender?: string | null
    address?: string | null
    email?: string | null
    introduction?: string | null
    soft_skills?: cvsCreatesoft_skillsInput | string[]
    primary_skills?: cvsCreateprimary_skillsInput | string[]
    phone?: string | null
    hobbies?: string | null
    others?: string | null
    applicants?: applicantsUncheckedCreateNestedManyWithoutCvsInput
    awards?: awardsUncheckedCreateNestedManyWithoutCvsInput
    certificates?: certificatesUncheckedCreateNestedManyWithoutCvsInput
    experiences?: experiencesUncheckedCreateNestedManyWithoutCvsInput
    projects?: projectsUncheckedCreateNestedManyWithoutCvsInput
    references?: referencesUncheckedCreateNestedManyWithoutCvsInput
  }

  export type cvsCreateOrConnectWithoutEducationsInput = {
    where: cvsWhereUniqueInput
    create: XOR<cvsCreateWithoutEducationsInput, cvsUncheckedCreateWithoutEducationsInput>
  }

  export type cvsUpsertWithoutEducationsInput = {
    update: XOR<cvsUpdateWithoutEducationsInput, cvsUncheckedUpdateWithoutEducationsInput>
    create: XOR<cvsCreateWithoutEducationsInput, cvsUncheckedCreateWithoutEducationsInput>
    where?: cvsWhereInput
  }

  export type cvsUpdateToOneWithWhereWithoutEducationsInput = {
    where?: cvsWhereInput
    data: XOR<cvsUpdateWithoutEducationsInput, cvsUncheckedUpdateWithoutEducationsInput>
  }

  export type cvsUpdateWithoutEducationsInput = {
    fullname?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    soft_skills?: cvsUpdatesoft_skillsInput | string[]
    primary_skills?: cvsUpdateprimary_skillsInput | string[]
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    hobbies?: NullableStringFieldUpdateOperationsInput | string | null
    others?: NullableStringFieldUpdateOperationsInput | string | null
    applicants?: applicantsUpdateManyWithoutCvsNestedInput
    awards?: awardsUpdateManyWithoutCvsNestedInput
    certificates?: certificatesUpdateManyWithoutCvsNestedInput
    experiences?: experiencesUpdateManyWithoutCvsNestedInput
    projects?: projectsUpdateManyWithoutCvsNestedInput
    references?: referencesUpdateManyWithoutCvsNestedInput
  }

  export type cvsUncheckedUpdateWithoutEducationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullname?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    soft_skills?: cvsUpdatesoft_skillsInput | string[]
    primary_skills?: cvsUpdateprimary_skillsInput | string[]
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    hobbies?: NullableStringFieldUpdateOperationsInput | string | null
    others?: NullableStringFieldUpdateOperationsInput | string | null
    applicants?: applicantsUncheckedUpdateManyWithoutCvsNestedInput
    awards?: awardsUncheckedUpdateManyWithoutCvsNestedInput
    certificates?: certificatesUncheckedUpdateManyWithoutCvsNestedInput
    experiences?: experiencesUncheckedUpdateManyWithoutCvsNestedInput
    projects?: projectsUncheckedUpdateManyWithoutCvsNestedInput
    references?: referencesUncheckedUpdateManyWithoutCvsNestedInput
  }

  export type cvsCreateWithoutExperiencesInput = {
    fullname: string
    age?: number | null
    gender?: string | null
    address?: string | null
    email?: string | null
    introduction?: string | null
    soft_skills?: cvsCreatesoft_skillsInput | string[]
    primary_skills?: cvsCreateprimary_skillsInput | string[]
    phone?: string | null
    hobbies?: string | null
    others?: string | null
    applicants?: applicantsCreateNestedManyWithoutCvsInput
    awards?: awardsCreateNestedManyWithoutCvsInput
    certificates?: certificatesCreateNestedManyWithoutCvsInput
    educations?: educationsCreateNestedManyWithoutCvsInput
    projects?: projectsCreateNestedManyWithoutCvsInput
    references?: referencesCreateNestedManyWithoutCvsInput
  }

  export type cvsUncheckedCreateWithoutExperiencesInput = {
    id?: number
    fullname: string
    age?: number | null
    gender?: string | null
    address?: string | null
    email?: string | null
    introduction?: string | null
    soft_skills?: cvsCreatesoft_skillsInput | string[]
    primary_skills?: cvsCreateprimary_skillsInput | string[]
    phone?: string | null
    hobbies?: string | null
    others?: string | null
    applicants?: applicantsUncheckedCreateNestedManyWithoutCvsInput
    awards?: awardsUncheckedCreateNestedManyWithoutCvsInput
    certificates?: certificatesUncheckedCreateNestedManyWithoutCvsInput
    educations?: educationsUncheckedCreateNestedManyWithoutCvsInput
    projects?: projectsUncheckedCreateNestedManyWithoutCvsInput
    references?: referencesUncheckedCreateNestedManyWithoutCvsInput
  }

  export type cvsCreateOrConnectWithoutExperiencesInput = {
    where: cvsWhereUniqueInput
    create: XOR<cvsCreateWithoutExperiencesInput, cvsUncheckedCreateWithoutExperiencesInput>
  }

  export type cvsUpsertWithoutExperiencesInput = {
    update: XOR<cvsUpdateWithoutExperiencesInput, cvsUncheckedUpdateWithoutExperiencesInput>
    create: XOR<cvsCreateWithoutExperiencesInput, cvsUncheckedCreateWithoutExperiencesInput>
    where?: cvsWhereInput
  }

  export type cvsUpdateToOneWithWhereWithoutExperiencesInput = {
    where?: cvsWhereInput
    data: XOR<cvsUpdateWithoutExperiencesInput, cvsUncheckedUpdateWithoutExperiencesInput>
  }

  export type cvsUpdateWithoutExperiencesInput = {
    fullname?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    soft_skills?: cvsUpdatesoft_skillsInput | string[]
    primary_skills?: cvsUpdateprimary_skillsInput | string[]
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    hobbies?: NullableStringFieldUpdateOperationsInput | string | null
    others?: NullableStringFieldUpdateOperationsInput | string | null
    applicants?: applicantsUpdateManyWithoutCvsNestedInput
    awards?: awardsUpdateManyWithoutCvsNestedInput
    certificates?: certificatesUpdateManyWithoutCvsNestedInput
    educations?: educationsUpdateManyWithoutCvsNestedInput
    projects?: projectsUpdateManyWithoutCvsNestedInput
    references?: referencesUpdateManyWithoutCvsNestedInput
  }

  export type cvsUncheckedUpdateWithoutExperiencesInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullname?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    soft_skills?: cvsUpdatesoft_skillsInput | string[]
    primary_skills?: cvsUpdateprimary_skillsInput | string[]
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    hobbies?: NullableStringFieldUpdateOperationsInput | string | null
    others?: NullableStringFieldUpdateOperationsInput | string | null
    applicants?: applicantsUncheckedUpdateManyWithoutCvsNestedInput
    awards?: awardsUncheckedUpdateManyWithoutCvsNestedInput
    certificates?: certificatesUncheckedUpdateManyWithoutCvsNestedInput
    educations?: educationsUncheckedUpdateManyWithoutCvsNestedInput
    projects?: projectsUncheckedUpdateManyWithoutCvsNestedInput
    references?: referencesUncheckedUpdateManyWithoutCvsNestedInput
  }

  export type membershipPlansCreateWithoutFeaturesInput = {
    plan_name: string
    description?: string | null
    price: bigint | number
    duration_days: number
    is_active?: boolean
    created_at?: Date | string
    updated_at: Date | string
    subscriptions?: subscriptionsCreateNestedManyWithoutMembershipPlansInput
  }

  export type membershipPlansUncheckedCreateWithoutFeaturesInput = {
    id?: number
    plan_name: string
    description?: string | null
    price: bigint | number
    duration_days: number
    is_active?: boolean
    created_at?: Date | string
    updated_at: Date | string
    subscriptions?: subscriptionsUncheckedCreateNestedManyWithoutMembershipPlansInput
  }

  export type membershipPlansCreateOrConnectWithoutFeaturesInput = {
    where: membershipPlansWhereUniqueInput
    create: XOR<membershipPlansCreateWithoutFeaturesInput, membershipPlansUncheckedCreateWithoutFeaturesInput>
  }

  export type membershipPlansUpsertWithoutFeaturesInput = {
    update: XOR<membershipPlansUpdateWithoutFeaturesInput, membershipPlansUncheckedUpdateWithoutFeaturesInput>
    create: XOR<membershipPlansCreateWithoutFeaturesInput, membershipPlansUncheckedCreateWithoutFeaturesInput>
    where?: membershipPlansWhereInput
  }

  export type membershipPlansUpdateToOneWithWhereWithoutFeaturesInput = {
    where?: membershipPlansWhereInput
    data: XOR<membershipPlansUpdateWithoutFeaturesInput, membershipPlansUncheckedUpdateWithoutFeaturesInput>
  }

  export type membershipPlansUpdateWithoutFeaturesInput = {
    plan_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: BigIntFieldUpdateOperationsInput | bigint | number
    duration_days?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: subscriptionsUpdateManyWithoutMembershipPlansNestedInput
  }

  export type membershipPlansUncheckedUpdateWithoutFeaturesInput = {
    id?: IntFieldUpdateOperationsInput | number
    plan_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: BigIntFieldUpdateOperationsInput | bigint | number
    duration_days?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: subscriptionsUncheckedUpdateManyWithoutMembershipPlansNestedInput
  }

  export type companiesCreateWithoutFeedbacksInput = {
    company_name: string
    company_website?: string | null
    address_street: string
    address_ward: string
    address_city: string
    address_country: string
    email: string
    phone: string
    business_certificate?: string | null
    company_type?: $Enums.Company_Type
    description?: string | null
    logo_url?: string | null
    background_url?: string | null
    employees?: number | null
    is_verified?: boolean
    fax_code?: string | null
    is_deleted?: boolean
    created_at?: Date | string
    updated_at: Date | string
    fields?: fieldsCreateNestedOneWithoutCompaniesInput
    users: usersCreateNestedOneWithoutCompaniesInput
    companyLabels?: companyLabelsCreateNestedOneWithoutCompaniesInput
    companyActivitiesHistory?: companyActivitiesHistoryCreateNestedManyWithoutCompaniesInput
    companyNotifications?: companyNotificationsCreateNestedManyWithoutCompaniesInput
    followedCompanies?: followedCompaniesCreateNestedManyWithoutCompaniesInput
  }

  export type companiesUncheckedCreateWithoutFeedbacksInput = {
    id: string
    company_name: string
    company_website?: string | null
    address_street: string
    address_ward: string
    address_city: string
    address_country: string
    email: string
    phone: string
    business_certificate?: string | null
    company_type?: $Enums.Company_Type
    description?: string | null
    logo_url?: string | null
    background_url?: string | null
    employees?: number | null
    is_verified?: boolean
    fax_code?: string | null
    is_deleted?: boolean
    created_at?: Date | string
    updated_at: Date | string
    field_id?: number | null
    label_id?: number | null
    companyActivitiesHistory?: companyActivitiesHistoryUncheckedCreateNestedManyWithoutCompaniesInput
    companyNotifications?: companyNotificationsUncheckedCreateNestedManyWithoutCompaniesInput
    followedCompanies?: followedCompaniesUncheckedCreateNestedManyWithoutCompaniesInput
  }

  export type companiesCreateOrConnectWithoutFeedbacksInput = {
    where: companiesWhereUniqueInput
    create: XOR<companiesCreateWithoutFeedbacksInput, companiesUncheckedCreateWithoutFeedbacksInput>
  }

  export type usersCreateWithoutFeedbacksInput = {
    id: string
    username: string
    password: string
    avatar_url?: string | null
    email: string
    phone?: string | null
    address_street?: string | null
    address_ward?: string | null
    address_city?: string | null
    address_country?: string | null
    gender?: $Enums.Gender | null
    is_deleted?: boolean
    created_at?: Date | string
    updated_at: Date | string
    blogs?: blogsCreateNestedManyWithoutUsersInput
    careerPaths?: careerPathsCreateNestedManyWithoutUsersInput
    companies?: companiesCreateNestedOneWithoutUsersInput
    followedCompanies?: followedCompaniesCreateNestedManyWithoutUsersInput
    messages?: messagesCreateNestedManyWithoutUsersInput
    payments?: paymentsCreateNestedManyWithoutUsersInput
    personalityTestResults?: personalityTestResultsCreateNestedManyWithoutUsersInput
    savedJobs?: savedJobsCreateNestedManyWithoutUsersInput
    subscriptions?: subscriptionsCreateNestedManyWithoutUsersInput
    userActivitiesHistory?: userActivitiesHistoryCreateNestedManyWithoutUsersInput
    userNotifications?: userNotificationsCreateNestedManyWithoutUsersInput
    roles: rolesCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutFeedbacksInput = {
    id: string
    username: string
    password: string
    avatar_url?: string | null
    email: string
    phone?: string | null
    address_street?: string | null
    address_ward?: string | null
    address_city?: string | null
    address_country?: string | null
    gender?: $Enums.Gender | null
    is_deleted?: boolean
    created_at?: Date | string
    updated_at: Date | string
    role_id: number
    blogs?: blogsUncheckedCreateNestedManyWithoutUsersInput
    careerPaths?: careerPathsUncheckedCreateNestedManyWithoutUsersInput
    companies?: companiesUncheckedCreateNestedOneWithoutUsersInput
    followedCompanies?: followedCompaniesUncheckedCreateNestedManyWithoutUsersInput
    messages?: messagesUncheckedCreateNestedManyWithoutUsersInput
    payments?: paymentsUncheckedCreateNestedManyWithoutUsersInput
    personalityTestResults?: personalityTestResultsUncheckedCreateNestedManyWithoutUsersInput
    savedJobs?: savedJobsUncheckedCreateNestedManyWithoutUsersInput
    subscriptions?: subscriptionsUncheckedCreateNestedManyWithoutUsersInput
    userActivitiesHistory?: userActivitiesHistoryUncheckedCreateNestedManyWithoutUsersInput
    userNotifications?: userNotificationsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutFeedbacksInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutFeedbacksInput, usersUncheckedCreateWithoutFeedbacksInput>
  }

  export type companiesUpsertWithoutFeedbacksInput = {
    update: XOR<companiesUpdateWithoutFeedbacksInput, companiesUncheckedUpdateWithoutFeedbacksInput>
    create: XOR<companiesCreateWithoutFeedbacksInput, companiesUncheckedCreateWithoutFeedbacksInput>
    where?: companiesWhereInput
  }

  export type companiesUpdateToOneWithWhereWithoutFeedbacksInput = {
    where?: companiesWhereInput
    data: XOR<companiesUpdateWithoutFeedbacksInput, companiesUncheckedUpdateWithoutFeedbacksInput>
  }

  export type companiesUpdateWithoutFeedbacksInput = {
    company_name?: StringFieldUpdateOperationsInput | string
    company_website?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: StringFieldUpdateOperationsInput | string
    address_ward?: StringFieldUpdateOperationsInput | string
    address_city?: StringFieldUpdateOperationsInput | string
    address_country?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    business_certificate?: NullableStringFieldUpdateOperationsInput | string | null
    company_type?: EnumCompany_TypeFieldUpdateOperationsInput | $Enums.Company_Type
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    background_url?: NullableStringFieldUpdateOperationsInput | string | null
    employees?: NullableIntFieldUpdateOperationsInput | number | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    fax_code?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    fields?: fieldsUpdateOneWithoutCompaniesNestedInput
    users?: usersUpdateOneRequiredWithoutCompaniesNestedInput
    companyLabels?: companyLabelsUpdateOneWithoutCompaniesNestedInput
    companyActivitiesHistory?: companyActivitiesHistoryUpdateManyWithoutCompaniesNestedInput
    companyNotifications?: companyNotificationsUpdateManyWithoutCompaniesNestedInput
    followedCompanies?: followedCompaniesUpdateManyWithoutCompaniesNestedInput
  }

  export type companiesUncheckedUpdateWithoutFeedbacksInput = {
    id?: StringFieldUpdateOperationsInput | string
    company_name?: StringFieldUpdateOperationsInput | string
    company_website?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: StringFieldUpdateOperationsInput | string
    address_ward?: StringFieldUpdateOperationsInput | string
    address_city?: StringFieldUpdateOperationsInput | string
    address_country?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    business_certificate?: NullableStringFieldUpdateOperationsInput | string | null
    company_type?: EnumCompany_TypeFieldUpdateOperationsInput | $Enums.Company_Type
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    background_url?: NullableStringFieldUpdateOperationsInput | string | null
    employees?: NullableIntFieldUpdateOperationsInput | number | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    fax_code?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    field_id?: NullableIntFieldUpdateOperationsInput | number | null
    label_id?: NullableIntFieldUpdateOperationsInput | number | null
    companyActivitiesHistory?: companyActivitiesHistoryUncheckedUpdateManyWithoutCompaniesNestedInput
    companyNotifications?: companyNotificationsUncheckedUpdateManyWithoutCompaniesNestedInput
    followedCompanies?: followedCompaniesUncheckedUpdateManyWithoutCompaniesNestedInput
  }

  export type usersUpsertWithoutFeedbacksInput = {
    update: XOR<usersUpdateWithoutFeedbacksInput, usersUncheckedUpdateWithoutFeedbacksInput>
    create: XOR<usersCreateWithoutFeedbacksInput, usersUncheckedCreateWithoutFeedbacksInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutFeedbacksInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutFeedbacksInput, usersUncheckedUpdateWithoutFeedbacksInput>
  }

  export type usersUpdateWithoutFeedbacksInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: NullableStringFieldUpdateOperationsInput | string | null
    address_ward?: NullableStringFieldUpdateOperationsInput | string | null
    address_city?: NullableStringFieldUpdateOperationsInput | string | null
    address_country?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    blogs?: blogsUpdateManyWithoutUsersNestedInput
    careerPaths?: careerPathsUpdateManyWithoutUsersNestedInput
    companies?: companiesUpdateOneWithoutUsersNestedInput
    followedCompanies?: followedCompaniesUpdateManyWithoutUsersNestedInput
    messages?: messagesUpdateManyWithoutUsersNestedInput
    payments?: paymentsUpdateManyWithoutUsersNestedInput
    personalityTestResults?: personalityTestResultsUpdateManyWithoutUsersNestedInput
    savedJobs?: savedJobsUpdateManyWithoutUsersNestedInput
    subscriptions?: subscriptionsUpdateManyWithoutUsersNestedInput
    userActivitiesHistory?: userActivitiesHistoryUpdateManyWithoutUsersNestedInput
    userNotifications?: userNotificationsUpdateManyWithoutUsersNestedInput
    roles?: rolesUpdateOneRequiredWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutFeedbacksInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: NullableStringFieldUpdateOperationsInput | string | null
    address_ward?: NullableStringFieldUpdateOperationsInput | string | null
    address_city?: NullableStringFieldUpdateOperationsInput | string | null
    address_country?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role_id?: IntFieldUpdateOperationsInput | number
    blogs?: blogsUncheckedUpdateManyWithoutUsersNestedInput
    careerPaths?: careerPathsUncheckedUpdateManyWithoutUsersNestedInput
    companies?: companiesUncheckedUpdateOneWithoutUsersNestedInput
    followedCompanies?: followedCompaniesUncheckedUpdateManyWithoutUsersNestedInput
    messages?: messagesUncheckedUpdateManyWithoutUsersNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutUsersNestedInput
    personalityTestResults?: personalityTestResultsUncheckedUpdateManyWithoutUsersNestedInput
    savedJobs?: savedJobsUncheckedUpdateManyWithoutUsersNestedInput
    subscriptions?: subscriptionsUncheckedUpdateManyWithoutUsersNestedInput
    userActivitiesHistory?: userActivitiesHistoryUncheckedUpdateManyWithoutUsersNestedInput
    userNotifications?: userNotificationsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type companiesCreateWithoutFieldsInput = {
    company_name: string
    company_website?: string | null
    address_street: string
    address_ward: string
    address_city: string
    address_country: string
    email: string
    phone: string
    business_certificate?: string | null
    company_type?: $Enums.Company_Type
    description?: string | null
    logo_url?: string | null
    background_url?: string | null
    employees?: number | null
    is_verified?: boolean
    fax_code?: string | null
    is_deleted?: boolean
    created_at?: Date | string
    updated_at: Date | string
    users: usersCreateNestedOneWithoutCompaniesInput
    companyLabels?: companyLabelsCreateNestedOneWithoutCompaniesInput
    companyActivitiesHistory?: companyActivitiesHistoryCreateNestedManyWithoutCompaniesInput
    companyNotifications?: companyNotificationsCreateNestedManyWithoutCompaniesInput
    feedbacks?: feedbacksCreateNestedManyWithoutCompaniesInput
    followedCompanies?: followedCompaniesCreateNestedManyWithoutCompaniesInput
  }

  export type companiesUncheckedCreateWithoutFieldsInput = {
    id: string
    company_name: string
    company_website?: string | null
    address_street: string
    address_ward: string
    address_city: string
    address_country: string
    email: string
    phone: string
    business_certificate?: string | null
    company_type?: $Enums.Company_Type
    description?: string | null
    logo_url?: string | null
    background_url?: string | null
    employees?: number | null
    is_verified?: boolean
    fax_code?: string | null
    is_deleted?: boolean
    created_at?: Date | string
    updated_at: Date | string
    label_id?: number | null
    companyActivitiesHistory?: companyActivitiesHistoryUncheckedCreateNestedManyWithoutCompaniesInput
    companyNotifications?: companyNotificationsUncheckedCreateNestedManyWithoutCompaniesInput
    feedbacks?: feedbacksUncheckedCreateNestedManyWithoutCompaniesInput
    followedCompanies?: followedCompaniesUncheckedCreateNestedManyWithoutCompaniesInput
  }

  export type companiesCreateOrConnectWithoutFieldsInput = {
    where: companiesWhereUniqueInput
    create: XOR<companiesCreateWithoutFieldsInput, companiesUncheckedCreateWithoutFieldsInput>
  }

  export type companiesCreateManyFieldsInputEnvelope = {
    data: companiesCreateManyFieldsInput | companiesCreateManyFieldsInput[]
    skipDuplicates?: boolean
  }

  export type companiesUpsertWithWhereUniqueWithoutFieldsInput = {
    where: companiesWhereUniqueInput
    update: XOR<companiesUpdateWithoutFieldsInput, companiesUncheckedUpdateWithoutFieldsInput>
    create: XOR<companiesCreateWithoutFieldsInput, companiesUncheckedCreateWithoutFieldsInput>
  }

  export type companiesUpdateWithWhereUniqueWithoutFieldsInput = {
    where: companiesWhereUniqueInput
    data: XOR<companiesUpdateWithoutFieldsInput, companiesUncheckedUpdateWithoutFieldsInput>
  }

  export type companiesUpdateManyWithWhereWithoutFieldsInput = {
    where: companiesScalarWhereInput
    data: XOR<companiesUpdateManyMutationInput, companiesUncheckedUpdateManyWithoutFieldsInput>
  }

  export type companiesCreateWithoutFollowedCompaniesInput = {
    company_name: string
    company_website?: string | null
    address_street: string
    address_ward: string
    address_city: string
    address_country: string
    email: string
    phone: string
    business_certificate?: string | null
    company_type?: $Enums.Company_Type
    description?: string | null
    logo_url?: string | null
    background_url?: string | null
    employees?: number | null
    is_verified?: boolean
    fax_code?: string | null
    is_deleted?: boolean
    created_at?: Date | string
    updated_at: Date | string
    fields?: fieldsCreateNestedOneWithoutCompaniesInput
    users: usersCreateNestedOneWithoutCompaniesInput
    companyLabels?: companyLabelsCreateNestedOneWithoutCompaniesInput
    companyActivitiesHistory?: companyActivitiesHistoryCreateNestedManyWithoutCompaniesInput
    companyNotifications?: companyNotificationsCreateNestedManyWithoutCompaniesInput
    feedbacks?: feedbacksCreateNestedManyWithoutCompaniesInput
  }

  export type companiesUncheckedCreateWithoutFollowedCompaniesInput = {
    id: string
    company_name: string
    company_website?: string | null
    address_street: string
    address_ward: string
    address_city: string
    address_country: string
    email: string
    phone: string
    business_certificate?: string | null
    company_type?: $Enums.Company_Type
    description?: string | null
    logo_url?: string | null
    background_url?: string | null
    employees?: number | null
    is_verified?: boolean
    fax_code?: string | null
    is_deleted?: boolean
    created_at?: Date | string
    updated_at: Date | string
    field_id?: number | null
    label_id?: number | null
    companyActivitiesHistory?: companyActivitiesHistoryUncheckedCreateNestedManyWithoutCompaniesInput
    companyNotifications?: companyNotificationsUncheckedCreateNestedManyWithoutCompaniesInput
    feedbacks?: feedbacksUncheckedCreateNestedManyWithoutCompaniesInput
  }

  export type companiesCreateOrConnectWithoutFollowedCompaniesInput = {
    where: companiesWhereUniqueInput
    create: XOR<companiesCreateWithoutFollowedCompaniesInput, companiesUncheckedCreateWithoutFollowedCompaniesInput>
  }

  export type usersCreateWithoutFollowedCompaniesInput = {
    id: string
    username: string
    password: string
    avatar_url?: string | null
    email: string
    phone?: string | null
    address_street?: string | null
    address_ward?: string | null
    address_city?: string | null
    address_country?: string | null
    gender?: $Enums.Gender | null
    is_deleted?: boolean
    created_at?: Date | string
    updated_at: Date | string
    blogs?: blogsCreateNestedManyWithoutUsersInput
    careerPaths?: careerPathsCreateNestedManyWithoutUsersInput
    companies?: companiesCreateNestedOneWithoutUsersInput
    feedbacks?: feedbacksCreateNestedManyWithoutUsersInput
    messages?: messagesCreateNestedManyWithoutUsersInput
    payments?: paymentsCreateNestedManyWithoutUsersInput
    personalityTestResults?: personalityTestResultsCreateNestedManyWithoutUsersInput
    savedJobs?: savedJobsCreateNestedManyWithoutUsersInput
    subscriptions?: subscriptionsCreateNestedManyWithoutUsersInput
    userActivitiesHistory?: userActivitiesHistoryCreateNestedManyWithoutUsersInput
    userNotifications?: userNotificationsCreateNestedManyWithoutUsersInput
    roles: rolesCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutFollowedCompaniesInput = {
    id: string
    username: string
    password: string
    avatar_url?: string | null
    email: string
    phone?: string | null
    address_street?: string | null
    address_ward?: string | null
    address_city?: string | null
    address_country?: string | null
    gender?: $Enums.Gender | null
    is_deleted?: boolean
    created_at?: Date | string
    updated_at: Date | string
    role_id: number
    blogs?: blogsUncheckedCreateNestedManyWithoutUsersInput
    careerPaths?: careerPathsUncheckedCreateNestedManyWithoutUsersInput
    companies?: companiesUncheckedCreateNestedOneWithoutUsersInput
    feedbacks?: feedbacksUncheckedCreateNestedManyWithoutUsersInput
    messages?: messagesUncheckedCreateNestedManyWithoutUsersInput
    payments?: paymentsUncheckedCreateNestedManyWithoutUsersInput
    personalityTestResults?: personalityTestResultsUncheckedCreateNestedManyWithoutUsersInput
    savedJobs?: savedJobsUncheckedCreateNestedManyWithoutUsersInput
    subscriptions?: subscriptionsUncheckedCreateNestedManyWithoutUsersInput
    userActivitiesHistory?: userActivitiesHistoryUncheckedCreateNestedManyWithoutUsersInput
    userNotifications?: userNotificationsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutFollowedCompaniesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutFollowedCompaniesInput, usersUncheckedCreateWithoutFollowedCompaniesInput>
  }

  export type companiesUpsertWithoutFollowedCompaniesInput = {
    update: XOR<companiesUpdateWithoutFollowedCompaniesInput, companiesUncheckedUpdateWithoutFollowedCompaniesInput>
    create: XOR<companiesCreateWithoutFollowedCompaniesInput, companiesUncheckedCreateWithoutFollowedCompaniesInput>
    where?: companiesWhereInput
  }

  export type companiesUpdateToOneWithWhereWithoutFollowedCompaniesInput = {
    where?: companiesWhereInput
    data: XOR<companiesUpdateWithoutFollowedCompaniesInput, companiesUncheckedUpdateWithoutFollowedCompaniesInput>
  }

  export type companiesUpdateWithoutFollowedCompaniesInput = {
    company_name?: StringFieldUpdateOperationsInput | string
    company_website?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: StringFieldUpdateOperationsInput | string
    address_ward?: StringFieldUpdateOperationsInput | string
    address_city?: StringFieldUpdateOperationsInput | string
    address_country?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    business_certificate?: NullableStringFieldUpdateOperationsInput | string | null
    company_type?: EnumCompany_TypeFieldUpdateOperationsInput | $Enums.Company_Type
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    background_url?: NullableStringFieldUpdateOperationsInput | string | null
    employees?: NullableIntFieldUpdateOperationsInput | number | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    fax_code?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    fields?: fieldsUpdateOneWithoutCompaniesNestedInput
    users?: usersUpdateOneRequiredWithoutCompaniesNestedInput
    companyLabels?: companyLabelsUpdateOneWithoutCompaniesNestedInput
    companyActivitiesHistory?: companyActivitiesHistoryUpdateManyWithoutCompaniesNestedInput
    companyNotifications?: companyNotificationsUpdateManyWithoutCompaniesNestedInput
    feedbacks?: feedbacksUpdateManyWithoutCompaniesNestedInput
  }

  export type companiesUncheckedUpdateWithoutFollowedCompaniesInput = {
    id?: StringFieldUpdateOperationsInput | string
    company_name?: StringFieldUpdateOperationsInput | string
    company_website?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: StringFieldUpdateOperationsInput | string
    address_ward?: StringFieldUpdateOperationsInput | string
    address_city?: StringFieldUpdateOperationsInput | string
    address_country?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    business_certificate?: NullableStringFieldUpdateOperationsInput | string | null
    company_type?: EnumCompany_TypeFieldUpdateOperationsInput | $Enums.Company_Type
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    background_url?: NullableStringFieldUpdateOperationsInput | string | null
    employees?: NullableIntFieldUpdateOperationsInput | number | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    fax_code?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    field_id?: NullableIntFieldUpdateOperationsInput | number | null
    label_id?: NullableIntFieldUpdateOperationsInput | number | null
    companyActivitiesHistory?: companyActivitiesHistoryUncheckedUpdateManyWithoutCompaniesNestedInput
    companyNotifications?: companyNotificationsUncheckedUpdateManyWithoutCompaniesNestedInput
    feedbacks?: feedbacksUncheckedUpdateManyWithoutCompaniesNestedInput
  }

  export type usersUpsertWithoutFollowedCompaniesInput = {
    update: XOR<usersUpdateWithoutFollowedCompaniesInput, usersUncheckedUpdateWithoutFollowedCompaniesInput>
    create: XOR<usersCreateWithoutFollowedCompaniesInput, usersUncheckedCreateWithoutFollowedCompaniesInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutFollowedCompaniesInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutFollowedCompaniesInput, usersUncheckedUpdateWithoutFollowedCompaniesInput>
  }

  export type usersUpdateWithoutFollowedCompaniesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: NullableStringFieldUpdateOperationsInput | string | null
    address_ward?: NullableStringFieldUpdateOperationsInput | string | null
    address_city?: NullableStringFieldUpdateOperationsInput | string | null
    address_country?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    blogs?: blogsUpdateManyWithoutUsersNestedInput
    careerPaths?: careerPathsUpdateManyWithoutUsersNestedInput
    companies?: companiesUpdateOneWithoutUsersNestedInput
    feedbacks?: feedbacksUpdateManyWithoutUsersNestedInput
    messages?: messagesUpdateManyWithoutUsersNestedInput
    payments?: paymentsUpdateManyWithoutUsersNestedInput
    personalityTestResults?: personalityTestResultsUpdateManyWithoutUsersNestedInput
    savedJobs?: savedJobsUpdateManyWithoutUsersNestedInput
    subscriptions?: subscriptionsUpdateManyWithoutUsersNestedInput
    userActivitiesHistory?: userActivitiesHistoryUpdateManyWithoutUsersNestedInput
    userNotifications?: userNotificationsUpdateManyWithoutUsersNestedInput
    roles?: rolesUpdateOneRequiredWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutFollowedCompaniesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: NullableStringFieldUpdateOperationsInput | string | null
    address_ward?: NullableStringFieldUpdateOperationsInput | string | null
    address_city?: NullableStringFieldUpdateOperationsInput | string | null
    address_country?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role_id?: IntFieldUpdateOperationsInput | number
    blogs?: blogsUncheckedUpdateManyWithoutUsersNestedInput
    careerPaths?: careerPathsUncheckedUpdateManyWithoutUsersNestedInput
    companies?: companiesUncheckedUpdateOneWithoutUsersNestedInput
    feedbacks?: feedbacksUncheckedUpdateManyWithoutUsersNestedInput
    messages?: messagesUncheckedUpdateManyWithoutUsersNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutUsersNestedInput
    personalityTestResults?: personalityTestResultsUncheckedUpdateManyWithoutUsersNestedInput
    savedJobs?: savedJobsUncheckedUpdateManyWithoutUsersNestedInput
    subscriptions?: subscriptionsUncheckedUpdateManyWithoutUsersNestedInput
    userActivitiesHistory?: userActivitiesHistoryUncheckedUpdateManyWithoutUsersNestedInput
    userNotifications?: userNotificationsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type jobSpecializedCreateWithoutJobCategoriesInput = {
    job_type: string
    description?: string | null
    careerPaths?: careerPathsCreateNestedOneWithoutJobSpecializedInput
  }

  export type jobSpecializedUncheckedCreateWithoutJobCategoriesInput = {
    id?: number
    job_type: string
    description?: string | null
    careerPaths?: careerPathsUncheckedCreateNestedOneWithoutJobSpecializedInput
  }

  export type jobSpecializedCreateOrConnectWithoutJobCategoriesInput = {
    where: jobSpecializedWhereUniqueInput
    create: XOR<jobSpecializedCreateWithoutJobCategoriesInput, jobSpecializedUncheckedCreateWithoutJobCategoriesInput>
  }

  export type jobSpecializedCreateManyJobCategoriesInputEnvelope = {
    data: jobSpecializedCreateManyJobCategoriesInput | jobSpecializedCreateManyJobCategoriesInput[]
    skipDuplicates?: boolean
  }

  export type jobSpecializedUpsertWithWhereUniqueWithoutJobCategoriesInput = {
    where: jobSpecializedWhereUniqueInput
    update: XOR<jobSpecializedUpdateWithoutJobCategoriesInput, jobSpecializedUncheckedUpdateWithoutJobCategoriesInput>
    create: XOR<jobSpecializedCreateWithoutJobCategoriesInput, jobSpecializedUncheckedCreateWithoutJobCategoriesInput>
  }

  export type jobSpecializedUpdateWithWhereUniqueWithoutJobCategoriesInput = {
    where: jobSpecializedWhereUniqueInput
    data: XOR<jobSpecializedUpdateWithoutJobCategoriesInput, jobSpecializedUncheckedUpdateWithoutJobCategoriesInput>
  }

  export type jobSpecializedUpdateManyWithWhereWithoutJobCategoriesInput = {
    where: jobSpecializedScalarWhereInput
    data: XOR<jobSpecializedUpdateManyMutationInput, jobSpecializedUncheckedUpdateManyWithoutJobCategoriesInput>
  }

  export type jobSpecializedScalarWhereInput = {
    AND?: jobSpecializedScalarWhereInput | jobSpecializedScalarWhereInput[]
    OR?: jobSpecializedScalarWhereInput[]
    NOT?: jobSpecializedScalarWhereInput | jobSpecializedScalarWhereInput[]
    id?: IntFilter<"jobSpecialized"> | number
    job_type?: StringFilter<"jobSpecialized"> | string
    description?: StringNullableFilter<"jobSpecialized"> | string | null
    jobcategory_id?: IntFilter<"jobSpecialized"> | number
  }

  export type jobsCreateWithoutJobLabelsInput = {
    id: string
    job_title: string
    description: string
    location?: string | null
    benefit?: string | null
    working_time?: string | null
    salary?: jobsCreatesalaryInput | string[]
    currency?: string | null
    job_type?: $Enums.Job_Type | null
    status?: $Enums.Job_Status | null
    job_level: string
    quantity?: number | null
    skill_tags?: jobsCreateskill_tagsInput | string[]
    education?: $Enums.Education | null
    experience?: string | null
    start_date?: Date | string
    end_date?: Date | string | null
    created_at?: Date | string
    updated_at: Date | string
    applicants?: applicantsCreateNestedManyWithoutJobsInput
    categories?: categoriesCreateNestedOneWithoutJobsInput
    savedJobs?: savedJobsCreateNestedManyWithoutJobsInput
  }

  export type jobsUncheckedCreateWithoutJobLabelsInput = {
    id: string
    job_title: string
    description: string
    location?: string | null
    benefit?: string | null
    working_time?: string | null
    salary?: jobsCreatesalaryInput | string[]
    currency?: string | null
    job_type?: $Enums.Job_Type | null
    status?: $Enums.Job_Status | null
    job_level: string
    quantity?: number | null
    skill_tags?: jobsCreateskill_tagsInput | string[]
    education?: $Enums.Education | null
    experience?: string | null
    start_date?: Date | string
    end_date?: Date | string | null
    created_at?: Date | string
    updated_at: Date | string
    category_id?: number | null
    applicants?: applicantsUncheckedCreateNestedManyWithoutJobsInput
    savedJobs?: savedJobsUncheckedCreateNestedManyWithoutJobsInput
  }

  export type jobsCreateOrConnectWithoutJobLabelsInput = {
    where: jobsWhereUniqueInput
    create: XOR<jobsCreateWithoutJobLabelsInput, jobsUncheckedCreateWithoutJobLabelsInput>
  }

  export type jobsCreateManyJobLabelsInputEnvelope = {
    data: jobsCreateManyJobLabelsInput | jobsCreateManyJobLabelsInput[]
    skipDuplicates?: boolean
  }

  export type jobsUpsertWithWhereUniqueWithoutJobLabelsInput = {
    where: jobsWhereUniqueInput
    update: XOR<jobsUpdateWithoutJobLabelsInput, jobsUncheckedUpdateWithoutJobLabelsInput>
    create: XOR<jobsCreateWithoutJobLabelsInput, jobsUncheckedCreateWithoutJobLabelsInput>
  }

  export type jobsUpdateWithWhereUniqueWithoutJobLabelsInput = {
    where: jobsWhereUniqueInput
    data: XOR<jobsUpdateWithoutJobLabelsInput, jobsUncheckedUpdateWithoutJobLabelsInput>
  }

  export type jobsUpdateManyWithWhereWithoutJobLabelsInput = {
    where: jobsScalarWhereInput
    data: XOR<jobsUpdateManyMutationInput, jobsUncheckedUpdateManyWithoutJobLabelsInput>
  }

  export type careerPathsCreateWithoutJobSpecializedInput = {
    title: string
    description?: string | null
    resources?: string | null
    level?: string | null
    estimate_duration?: string | null
    careerPathSteps?: careerPathStepsCreateNestedManyWithoutCareerPathsInput
    users: usersCreateNestedOneWithoutCareerPathsInput
  }

  export type careerPathsUncheckedCreateWithoutJobSpecializedInput = {
    id?: number
    title: string
    description?: string | null
    resources?: string | null
    level?: string | null
    estimate_duration?: string | null
    user_id: string
    careerPathSteps?: careerPathStepsUncheckedCreateNestedManyWithoutCareerPathsInput
  }

  export type careerPathsCreateOrConnectWithoutJobSpecializedInput = {
    where: careerPathsWhereUniqueInput
    create: XOR<careerPathsCreateWithoutJobSpecializedInput, careerPathsUncheckedCreateWithoutJobSpecializedInput>
  }

  export type jobCategoriesCreateWithoutJobSpecializedInput = {
    job_category: string
    description?: string | null
  }

  export type jobCategoriesUncheckedCreateWithoutJobSpecializedInput = {
    id?: number
    job_category: string
    description?: string | null
  }

  export type jobCategoriesCreateOrConnectWithoutJobSpecializedInput = {
    where: jobCategoriesWhereUniqueInput
    create: XOR<jobCategoriesCreateWithoutJobSpecializedInput, jobCategoriesUncheckedCreateWithoutJobSpecializedInput>
  }

  export type careerPathsUpsertWithoutJobSpecializedInput = {
    update: XOR<careerPathsUpdateWithoutJobSpecializedInput, careerPathsUncheckedUpdateWithoutJobSpecializedInput>
    create: XOR<careerPathsCreateWithoutJobSpecializedInput, careerPathsUncheckedCreateWithoutJobSpecializedInput>
    where?: careerPathsWhereInput
  }

  export type careerPathsUpdateToOneWithWhereWithoutJobSpecializedInput = {
    where?: careerPathsWhereInput
    data: XOR<careerPathsUpdateWithoutJobSpecializedInput, careerPathsUncheckedUpdateWithoutJobSpecializedInput>
  }

  export type careerPathsUpdateWithoutJobSpecializedInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resources?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    estimate_duration?: NullableStringFieldUpdateOperationsInput | string | null
    careerPathSteps?: careerPathStepsUpdateManyWithoutCareerPathsNestedInput
    users?: usersUpdateOneRequiredWithoutCareerPathsNestedInput
  }

  export type careerPathsUncheckedUpdateWithoutJobSpecializedInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resources?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    estimate_duration?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    careerPathSteps?: careerPathStepsUncheckedUpdateManyWithoutCareerPathsNestedInput
  }

  export type jobCategoriesUpsertWithoutJobSpecializedInput = {
    update: XOR<jobCategoriesUpdateWithoutJobSpecializedInput, jobCategoriesUncheckedUpdateWithoutJobSpecializedInput>
    create: XOR<jobCategoriesCreateWithoutJobSpecializedInput, jobCategoriesUncheckedCreateWithoutJobSpecializedInput>
    where?: jobCategoriesWhereInput
  }

  export type jobCategoriesUpdateToOneWithWhereWithoutJobSpecializedInput = {
    where?: jobCategoriesWhereInput
    data: XOR<jobCategoriesUpdateWithoutJobSpecializedInput, jobCategoriesUncheckedUpdateWithoutJobSpecializedInput>
  }

  export type jobCategoriesUpdateWithoutJobSpecializedInput = {
    job_category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type jobCategoriesUncheckedUpdateWithoutJobSpecializedInput = {
    id?: IntFieldUpdateOperationsInput | number
    job_category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type applicantsCreateWithoutJobsInput = {
    description?: string | null
    apply_date?: Date | string
    verified_date: Date | string
    status?: $Enums.ApplicantsStatus
    feedback?: string | null
    cvs: cvsCreateNestedOneWithoutApplicantsInput
  }

  export type applicantsUncheckedCreateWithoutJobsInput = {
    cv_id: number
    description?: string | null
    apply_date?: Date | string
    verified_date: Date | string
    status?: $Enums.ApplicantsStatus
    feedback?: string | null
  }

  export type applicantsCreateOrConnectWithoutJobsInput = {
    where: applicantsWhereUniqueInput
    create: XOR<applicantsCreateWithoutJobsInput, applicantsUncheckedCreateWithoutJobsInput>
  }

  export type applicantsCreateManyJobsInputEnvelope = {
    data: applicantsCreateManyJobsInput | applicantsCreateManyJobsInput[]
    skipDuplicates?: boolean
  }

  export type categoriesCreateWithoutJobsInput = {
    category_name: string
  }

  export type categoriesUncheckedCreateWithoutJobsInput = {
    id?: number
    category_name: string
  }

  export type categoriesCreateOrConnectWithoutJobsInput = {
    where: categoriesWhereUniqueInput
    create: XOR<categoriesCreateWithoutJobsInput, categoriesUncheckedCreateWithoutJobsInput>
  }

  export type jobLabelsCreateWithoutJobsInput = {
    label_name: string
  }

  export type jobLabelsUncheckedCreateWithoutJobsInput = {
    id?: number
    label_name: string
  }

  export type jobLabelsCreateOrConnectWithoutJobsInput = {
    where: jobLabelsWhereUniqueInput
    create: XOR<jobLabelsCreateWithoutJobsInput, jobLabelsUncheckedCreateWithoutJobsInput>
  }

  export type savedJobsCreateWithoutJobsInput = {
    saved_at?: Date | string
    users: usersCreateNestedOneWithoutSavedJobsInput
  }

  export type savedJobsUncheckedCreateWithoutJobsInput = {
    user_id: string
    saved_at?: Date | string
  }

  export type savedJobsCreateOrConnectWithoutJobsInput = {
    where: savedJobsWhereUniqueInput
    create: XOR<savedJobsCreateWithoutJobsInput, savedJobsUncheckedCreateWithoutJobsInput>
  }

  export type savedJobsCreateManyJobsInputEnvelope = {
    data: savedJobsCreateManyJobsInput | savedJobsCreateManyJobsInput[]
    skipDuplicates?: boolean
  }

  export type applicantsUpsertWithWhereUniqueWithoutJobsInput = {
    where: applicantsWhereUniqueInput
    update: XOR<applicantsUpdateWithoutJobsInput, applicantsUncheckedUpdateWithoutJobsInput>
    create: XOR<applicantsCreateWithoutJobsInput, applicantsUncheckedCreateWithoutJobsInput>
  }

  export type applicantsUpdateWithWhereUniqueWithoutJobsInput = {
    where: applicantsWhereUniqueInput
    data: XOR<applicantsUpdateWithoutJobsInput, applicantsUncheckedUpdateWithoutJobsInput>
  }

  export type applicantsUpdateManyWithWhereWithoutJobsInput = {
    where: applicantsScalarWhereInput
    data: XOR<applicantsUpdateManyMutationInput, applicantsUncheckedUpdateManyWithoutJobsInput>
  }

  export type categoriesUpsertWithoutJobsInput = {
    update: XOR<categoriesUpdateWithoutJobsInput, categoriesUncheckedUpdateWithoutJobsInput>
    create: XOR<categoriesCreateWithoutJobsInput, categoriesUncheckedCreateWithoutJobsInput>
    where?: categoriesWhereInput
  }

  export type categoriesUpdateToOneWithWhereWithoutJobsInput = {
    where?: categoriesWhereInput
    data: XOR<categoriesUpdateWithoutJobsInput, categoriesUncheckedUpdateWithoutJobsInput>
  }

  export type categoriesUpdateWithoutJobsInput = {
    category_name?: StringFieldUpdateOperationsInput | string
  }

  export type categoriesUncheckedUpdateWithoutJobsInput = {
    id?: IntFieldUpdateOperationsInput | number
    category_name?: StringFieldUpdateOperationsInput | string
  }

  export type jobLabelsUpsertWithoutJobsInput = {
    update: XOR<jobLabelsUpdateWithoutJobsInput, jobLabelsUncheckedUpdateWithoutJobsInput>
    create: XOR<jobLabelsCreateWithoutJobsInput, jobLabelsUncheckedCreateWithoutJobsInput>
    where?: jobLabelsWhereInput
  }

  export type jobLabelsUpdateToOneWithWhereWithoutJobsInput = {
    where?: jobLabelsWhereInput
    data: XOR<jobLabelsUpdateWithoutJobsInput, jobLabelsUncheckedUpdateWithoutJobsInput>
  }

  export type jobLabelsUpdateWithoutJobsInput = {
    label_name?: StringFieldUpdateOperationsInput | string
  }

  export type jobLabelsUncheckedUpdateWithoutJobsInput = {
    id?: IntFieldUpdateOperationsInput | number
    label_name?: StringFieldUpdateOperationsInput | string
  }

  export type savedJobsUpsertWithWhereUniqueWithoutJobsInput = {
    where: savedJobsWhereUniqueInput
    update: XOR<savedJobsUpdateWithoutJobsInput, savedJobsUncheckedUpdateWithoutJobsInput>
    create: XOR<savedJobsCreateWithoutJobsInput, savedJobsUncheckedCreateWithoutJobsInput>
  }

  export type savedJobsUpdateWithWhereUniqueWithoutJobsInput = {
    where: savedJobsWhereUniqueInput
    data: XOR<savedJobsUpdateWithoutJobsInput, savedJobsUncheckedUpdateWithoutJobsInput>
  }

  export type savedJobsUpdateManyWithWhereWithoutJobsInput = {
    where: savedJobsScalarWhereInput
    data: XOR<savedJobsUpdateManyMutationInput, savedJobsUncheckedUpdateManyWithoutJobsInput>
  }

  export type savedJobsScalarWhereInput = {
    AND?: savedJobsScalarWhereInput | savedJobsScalarWhereInput[]
    OR?: savedJobsScalarWhereInput[]
    NOT?: savedJobsScalarWhereInput | savedJobsScalarWhereInput[]
    user_id?: StringFilter<"savedJobs"> | string
    job_id?: StringFilter<"savedJobs"> | string
    saved_at?: DateTimeFilter<"savedJobs"> | Date | string
  }

  export type featuresCreateWithoutMembershipPlansInput = {
    feature_name: string
    description?: string | null
  }

  export type featuresUncheckedCreateWithoutMembershipPlansInput = {
    id?: number
    feature_name: string
    description?: string | null
  }

  export type featuresCreateOrConnectWithoutMembershipPlansInput = {
    where: featuresWhereUniqueInput
    create: XOR<featuresCreateWithoutMembershipPlansInput, featuresUncheckedCreateWithoutMembershipPlansInput>
  }

  export type featuresCreateManyMembershipPlansInputEnvelope = {
    data: featuresCreateManyMembershipPlansInput | featuresCreateManyMembershipPlansInput[]
    skipDuplicates?: boolean
  }

  export type subscriptionsCreateWithoutMembershipPlansInput = {
    id: string
    start_date?: Date | string
    end_date: Date | string
    amount_paid: bigint | number
    is_extended?: boolean
    status?: $Enums.SubscriptionStatus
    payments: paymentsCreateNestedOneWithoutSubscriptionsInput
    users: usersCreateNestedOneWithoutSubscriptionsInput
  }

  export type subscriptionsUncheckedCreateWithoutMembershipPlansInput = {
    id: string
    start_date?: Date | string
    end_date: Date | string
    amount_paid: bigint | number
    is_extended?: boolean
    status?: $Enums.SubscriptionStatus
    user_id: string
    payment_id: string
  }

  export type subscriptionsCreateOrConnectWithoutMembershipPlansInput = {
    where: subscriptionsWhereUniqueInput
    create: XOR<subscriptionsCreateWithoutMembershipPlansInput, subscriptionsUncheckedCreateWithoutMembershipPlansInput>
  }

  export type subscriptionsCreateManyMembershipPlansInputEnvelope = {
    data: subscriptionsCreateManyMembershipPlansInput | subscriptionsCreateManyMembershipPlansInput[]
    skipDuplicates?: boolean
  }

  export type featuresUpsertWithWhereUniqueWithoutMembershipPlansInput = {
    where: featuresWhereUniqueInput
    update: XOR<featuresUpdateWithoutMembershipPlansInput, featuresUncheckedUpdateWithoutMembershipPlansInput>
    create: XOR<featuresCreateWithoutMembershipPlansInput, featuresUncheckedCreateWithoutMembershipPlansInput>
  }

  export type featuresUpdateWithWhereUniqueWithoutMembershipPlansInput = {
    where: featuresWhereUniqueInput
    data: XOR<featuresUpdateWithoutMembershipPlansInput, featuresUncheckedUpdateWithoutMembershipPlansInput>
  }

  export type featuresUpdateManyWithWhereWithoutMembershipPlansInput = {
    where: featuresScalarWhereInput
    data: XOR<featuresUpdateManyMutationInput, featuresUncheckedUpdateManyWithoutMembershipPlansInput>
  }

  export type featuresScalarWhereInput = {
    AND?: featuresScalarWhereInput | featuresScalarWhereInput[]
    OR?: featuresScalarWhereInput[]
    NOT?: featuresScalarWhereInput | featuresScalarWhereInput[]
    id?: IntFilter<"features"> | number
    feature_name?: StringFilter<"features"> | string
    description?: StringNullableFilter<"features"> | string | null
    plan_id?: IntNullableFilter<"features"> | number | null
  }

  export type subscriptionsUpsertWithWhereUniqueWithoutMembershipPlansInput = {
    where: subscriptionsWhereUniqueInput
    update: XOR<subscriptionsUpdateWithoutMembershipPlansInput, subscriptionsUncheckedUpdateWithoutMembershipPlansInput>
    create: XOR<subscriptionsCreateWithoutMembershipPlansInput, subscriptionsUncheckedCreateWithoutMembershipPlansInput>
  }

  export type subscriptionsUpdateWithWhereUniqueWithoutMembershipPlansInput = {
    where: subscriptionsWhereUniqueInput
    data: XOR<subscriptionsUpdateWithoutMembershipPlansInput, subscriptionsUncheckedUpdateWithoutMembershipPlansInput>
  }

  export type subscriptionsUpdateManyWithWhereWithoutMembershipPlansInput = {
    where: subscriptionsScalarWhereInput
    data: XOR<subscriptionsUpdateManyMutationInput, subscriptionsUncheckedUpdateManyWithoutMembershipPlansInput>
  }

  export type subscriptionsScalarWhereInput = {
    AND?: subscriptionsScalarWhereInput | subscriptionsScalarWhereInput[]
    OR?: subscriptionsScalarWhereInput[]
    NOT?: subscriptionsScalarWhereInput | subscriptionsScalarWhereInput[]
    id?: StringFilter<"subscriptions"> | string
    start_date?: DateTimeFilter<"subscriptions"> | Date | string
    end_date?: DateTimeFilter<"subscriptions"> | Date | string
    amount_paid?: BigIntFilter<"subscriptions"> | bigint | number
    is_extended?: BoolFilter<"subscriptions"> | boolean
    status?: EnumSubscriptionStatusFilter<"subscriptions"> | $Enums.SubscriptionStatus
    user_id?: StringFilter<"subscriptions"> | string
    plan_id?: IntFilter<"subscriptions"> | number
    payment_id?: StringFilter<"subscriptions"> | string
  }

  export type usersCreateWithoutMessagesInput = {
    id: string
    username: string
    password: string
    avatar_url?: string | null
    email: string
    phone?: string | null
    address_street?: string | null
    address_ward?: string | null
    address_city?: string | null
    address_country?: string | null
    gender?: $Enums.Gender | null
    is_deleted?: boolean
    created_at?: Date | string
    updated_at: Date | string
    blogs?: blogsCreateNestedManyWithoutUsersInput
    careerPaths?: careerPathsCreateNestedManyWithoutUsersInput
    companies?: companiesCreateNestedOneWithoutUsersInput
    feedbacks?: feedbacksCreateNestedManyWithoutUsersInput
    followedCompanies?: followedCompaniesCreateNestedManyWithoutUsersInput
    payments?: paymentsCreateNestedManyWithoutUsersInput
    personalityTestResults?: personalityTestResultsCreateNestedManyWithoutUsersInput
    savedJobs?: savedJobsCreateNestedManyWithoutUsersInput
    subscriptions?: subscriptionsCreateNestedManyWithoutUsersInput
    userActivitiesHistory?: userActivitiesHistoryCreateNestedManyWithoutUsersInput
    userNotifications?: userNotificationsCreateNestedManyWithoutUsersInput
    roles: rolesCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutMessagesInput = {
    id: string
    username: string
    password: string
    avatar_url?: string | null
    email: string
    phone?: string | null
    address_street?: string | null
    address_ward?: string | null
    address_city?: string | null
    address_country?: string | null
    gender?: $Enums.Gender | null
    is_deleted?: boolean
    created_at?: Date | string
    updated_at: Date | string
    role_id: number
    blogs?: blogsUncheckedCreateNestedManyWithoutUsersInput
    careerPaths?: careerPathsUncheckedCreateNestedManyWithoutUsersInput
    companies?: companiesUncheckedCreateNestedOneWithoutUsersInput
    feedbacks?: feedbacksUncheckedCreateNestedManyWithoutUsersInput
    followedCompanies?: followedCompaniesUncheckedCreateNestedManyWithoutUsersInput
    payments?: paymentsUncheckedCreateNestedManyWithoutUsersInput
    personalityTestResults?: personalityTestResultsUncheckedCreateNestedManyWithoutUsersInput
    savedJobs?: savedJobsUncheckedCreateNestedManyWithoutUsersInput
    subscriptions?: subscriptionsUncheckedCreateNestedManyWithoutUsersInput
    userActivitiesHistory?: userActivitiesHistoryUncheckedCreateNestedManyWithoutUsersInput
    userNotifications?: userNotificationsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutMessagesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutMessagesInput, usersUncheckedCreateWithoutMessagesInput>
  }

  export type usersUpsertWithoutMessagesInput = {
    update: XOR<usersUpdateWithoutMessagesInput, usersUncheckedUpdateWithoutMessagesInput>
    create: XOR<usersCreateWithoutMessagesInput, usersUncheckedCreateWithoutMessagesInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutMessagesInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutMessagesInput, usersUncheckedUpdateWithoutMessagesInput>
  }

  export type usersUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: NullableStringFieldUpdateOperationsInput | string | null
    address_ward?: NullableStringFieldUpdateOperationsInput | string | null
    address_city?: NullableStringFieldUpdateOperationsInput | string | null
    address_country?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    blogs?: blogsUpdateManyWithoutUsersNestedInput
    careerPaths?: careerPathsUpdateManyWithoutUsersNestedInput
    companies?: companiesUpdateOneWithoutUsersNestedInput
    feedbacks?: feedbacksUpdateManyWithoutUsersNestedInput
    followedCompanies?: followedCompaniesUpdateManyWithoutUsersNestedInput
    payments?: paymentsUpdateManyWithoutUsersNestedInput
    personalityTestResults?: personalityTestResultsUpdateManyWithoutUsersNestedInput
    savedJobs?: savedJobsUpdateManyWithoutUsersNestedInput
    subscriptions?: subscriptionsUpdateManyWithoutUsersNestedInput
    userActivitiesHistory?: userActivitiesHistoryUpdateManyWithoutUsersNestedInput
    userNotifications?: userNotificationsUpdateManyWithoutUsersNestedInput
    roles?: rolesUpdateOneRequiredWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: NullableStringFieldUpdateOperationsInput | string | null
    address_ward?: NullableStringFieldUpdateOperationsInput | string | null
    address_city?: NullableStringFieldUpdateOperationsInput | string | null
    address_country?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role_id?: IntFieldUpdateOperationsInput | number
    blogs?: blogsUncheckedUpdateManyWithoutUsersNestedInput
    careerPaths?: careerPathsUncheckedUpdateManyWithoutUsersNestedInput
    companies?: companiesUncheckedUpdateOneWithoutUsersNestedInput
    feedbacks?: feedbacksUncheckedUpdateManyWithoutUsersNestedInput
    followedCompanies?: followedCompaniesUncheckedUpdateManyWithoutUsersNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutUsersNestedInput
    personalityTestResults?: personalityTestResultsUncheckedUpdateManyWithoutUsersNestedInput
    savedJobs?: savedJobsUncheckedUpdateManyWithoutUsersNestedInput
    subscriptions?: subscriptionsUncheckedUpdateManyWithoutUsersNestedInput
    userActivitiesHistory?: userActivitiesHistoryUncheckedUpdateManyWithoutUsersNestedInput
    userNotifications?: userNotificationsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersCreateWithoutPaymentsInput = {
    id: string
    username: string
    password: string
    avatar_url?: string | null
    email: string
    phone?: string | null
    address_street?: string | null
    address_ward?: string | null
    address_city?: string | null
    address_country?: string | null
    gender?: $Enums.Gender | null
    is_deleted?: boolean
    created_at?: Date | string
    updated_at: Date | string
    blogs?: blogsCreateNestedManyWithoutUsersInput
    careerPaths?: careerPathsCreateNestedManyWithoutUsersInput
    companies?: companiesCreateNestedOneWithoutUsersInput
    feedbacks?: feedbacksCreateNestedManyWithoutUsersInput
    followedCompanies?: followedCompaniesCreateNestedManyWithoutUsersInput
    messages?: messagesCreateNestedManyWithoutUsersInput
    personalityTestResults?: personalityTestResultsCreateNestedManyWithoutUsersInput
    savedJobs?: savedJobsCreateNestedManyWithoutUsersInput
    subscriptions?: subscriptionsCreateNestedManyWithoutUsersInput
    userActivitiesHistory?: userActivitiesHistoryCreateNestedManyWithoutUsersInput
    userNotifications?: userNotificationsCreateNestedManyWithoutUsersInput
    roles: rolesCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutPaymentsInput = {
    id: string
    username: string
    password: string
    avatar_url?: string | null
    email: string
    phone?: string | null
    address_street?: string | null
    address_ward?: string | null
    address_city?: string | null
    address_country?: string | null
    gender?: $Enums.Gender | null
    is_deleted?: boolean
    created_at?: Date | string
    updated_at: Date | string
    role_id: number
    blogs?: blogsUncheckedCreateNestedManyWithoutUsersInput
    careerPaths?: careerPathsUncheckedCreateNestedManyWithoutUsersInput
    companies?: companiesUncheckedCreateNestedOneWithoutUsersInput
    feedbacks?: feedbacksUncheckedCreateNestedManyWithoutUsersInput
    followedCompanies?: followedCompaniesUncheckedCreateNestedManyWithoutUsersInput
    messages?: messagesUncheckedCreateNestedManyWithoutUsersInput
    personalityTestResults?: personalityTestResultsUncheckedCreateNestedManyWithoutUsersInput
    savedJobs?: savedJobsUncheckedCreateNestedManyWithoutUsersInput
    subscriptions?: subscriptionsUncheckedCreateNestedManyWithoutUsersInput
    userActivitiesHistory?: userActivitiesHistoryUncheckedCreateNestedManyWithoutUsersInput
    userNotifications?: userNotificationsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutPaymentsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutPaymentsInput, usersUncheckedCreateWithoutPaymentsInput>
  }

  export type subscriptionsCreateWithoutPaymentsInput = {
    id: string
    start_date?: Date | string
    end_date: Date | string
    amount_paid: bigint | number
    is_extended?: boolean
    status?: $Enums.SubscriptionStatus
    membershipPlans: membershipPlansCreateNestedOneWithoutSubscriptionsInput
    users: usersCreateNestedOneWithoutSubscriptionsInput
  }

  export type subscriptionsUncheckedCreateWithoutPaymentsInput = {
    id: string
    start_date?: Date | string
    end_date: Date | string
    amount_paid: bigint | number
    is_extended?: boolean
    status?: $Enums.SubscriptionStatus
    user_id: string
    plan_id: number
  }

  export type subscriptionsCreateOrConnectWithoutPaymentsInput = {
    where: subscriptionsWhereUniqueInput
    create: XOR<subscriptionsCreateWithoutPaymentsInput, subscriptionsUncheckedCreateWithoutPaymentsInput>
  }

  export type usersUpsertWithoutPaymentsInput = {
    update: XOR<usersUpdateWithoutPaymentsInput, usersUncheckedUpdateWithoutPaymentsInput>
    create: XOR<usersCreateWithoutPaymentsInput, usersUncheckedCreateWithoutPaymentsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutPaymentsInput, usersUncheckedUpdateWithoutPaymentsInput>
  }

  export type usersUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: NullableStringFieldUpdateOperationsInput | string | null
    address_ward?: NullableStringFieldUpdateOperationsInput | string | null
    address_city?: NullableStringFieldUpdateOperationsInput | string | null
    address_country?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    blogs?: blogsUpdateManyWithoutUsersNestedInput
    careerPaths?: careerPathsUpdateManyWithoutUsersNestedInput
    companies?: companiesUpdateOneWithoutUsersNestedInput
    feedbacks?: feedbacksUpdateManyWithoutUsersNestedInput
    followedCompanies?: followedCompaniesUpdateManyWithoutUsersNestedInput
    messages?: messagesUpdateManyWithoutUsersNestedInput
    personalityTestResults?: personalityTestResultsUpdateManyWithoutUsersNestedInput
    savedJobs?: savedJobsUpdateManyWithoutUsersNestedInput
    subscriptions?: subscriptionsUpdateManyWithoutUsersNestedInput
    userActivitiesHistory?: userActivitiesHistoryUpdateManyWithoutUsersNestedInput
    userNotifications?: userNotificationsUpdateManyWithoutUsersNestedInput
    roles?: rolesUpdateOneRequiredWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: NullableStringFieldUpdateOperationsInput | string | null
    address_ward?: NullableStringFieldUpdateOperationsInput | string | null
    address_city?: NullableStringFieldUpdateOperationsInput | string | null
    address_country?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role_id?: IntFieldUpdateOperationsInput | number
    blogs?: blogsUncheckedUpdateManyWithoutUsersNestedInput
    careerPaths?: careerPathsUncheckedUpdateManyWithoutUsersNestedInput
    companies?: companiesUncheckedUpdateOneWithoutUsersNestedInput
    feedbacks?: feedbacksUncheckedUpdateManyWithoutUsersNestedInput
    followedCompanies?: followedCompaniesUncheckedUpdateManyWithoutUsersNestedInput
    messages?: messagesUncheckedUpdateManyWithoutUsersNestedInput
    personalityTestResults?: personalityTestResultsUncheckedUpdateManyWithoutUsersNestedInput
    savedJobs?: savedJobsUncheckedUpdateManyWithoutUsersNestedInput
    subscriptions?: subscriptionsUncheckedUpdateManyWithoutUsersNestedInput
    userActivitiesHistory?: userActivitiesHistoryUncheckedUpdateManyWithoutUsersNestedInput
    userNotifications?: userNotificationsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type subscriptionsUpsertWithoutPaymentsInput = {
    update: XOR<subscriptionsUpdateWithoutPaymentsInput, subscriptionsUncheckedUpdateWithoutPaymentsInput>
    create: XOR<subscriptionsCreateWithoutPaymentsInput, subscriptionsUncheckedCreateWithoutPaymentsInput>
    where?: subscriptionsWhereInput
  }

  export type subscriptionsUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: subscriptionsWhereInput
    data: XOR<subscriptionsUpdateWithoutPaymentsInput, subscriptionsUncheckedUpdateWithoutPaymentsInput>
  }

  export type subscriptionsUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount_paid?: BigIntFieldUpdateOperationsInput | bigint | number
    is_extended?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    membershipPlans?: membershipPlansUpdateOneRequiredWithoutSubscriptionsNestedInput
    users?: usersUpdateOneRequiredWithoutSubscriptionsNestedInput
  }

  export type subscriptionsUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount_paid?: BigIntFieldUpdateOperationsInput | bigint | number
    is_extended?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    user_id?: StringFieldUpdateOperationsInput | string
    plan_id?: IntFieldUpdateOperationsInput | number
  }

  export type answersCreateWithoutPersonalityTestResultsInput = {
    answer: string
    questions: questionsCreateNestedOneWithoutAnswersInput
  }

  export type answersUncheckedCreateWithoutPersonalityTestResultsInput = {
    id?: number
    answer: string
    question_id: number
  }

  export type answersCreateOrConnectWithoutPersonalityTestResultsInput = {
    where: answersWhereUniqueInput
    create: XOR<answersCreateWithoutPersonalityTestResultsInput, answersUncheckedCreateWithoutPersonalityTestResultsInput>
  }

  export type questionsCreateWithoutPersonalityTestResultsInput = {
    question: string
    answers?: answersCreateNestedManyWithoutQuestionsInput
  }

  export type questionsUncheckedCreateWithoutPersonalityTestResultsInput = {
    id?: number
    question: string
    answers?: answersUncheckedCreateNestedManyWithoutQuestionsInput
  }

  export type questionsCreateOrConnectWithoutPersonalityTestResultsInput = {
    where: questionsWhereUniqueInput
    create: XOR<questionsCreateWithoutPersonalityTestResultsInput, questionsUncheckedCreateWithoutPersonalityTestResultsInput>
  }

  export type usersCreateWithoutPersonalityTestResultsInput = {
    id: string
    username: string
    password: string
    avatar_url?: string | null
    email: string
    phone?: string | null
    address_street?: string | null
    address_ward?: string | null
    address_city?: string | null
    address_country?: string | null
    gender?: $Enums.Gender | null
    is_deleted?: boolean
    created_at?: Date | string
    updated_at: Date | string
    blogs?: blogsCreateNestedManyWithoutUsersInput
    careerPaths?: careerPathsCreateNestedManyWithoutUsersInput
    companies?: companiesCreateNestedOneWithoutUsersInput
    feedbacks?: feedbacksCreateNestedManyWithoutUsersInput
    followedCompanies?: followedCompaniesCreateNestedManyWithoutUsersInput
    messages?: messagesCreateNestedManyWithoutUsersInput
    payments?: paymentsCreateNestedManyWithoutUsersInput
    savedJobs?: savedJobsCreateNestedManyWithoutUsersInput
    subscriptions?: subscriptionsCreateNestedManyWithoutUsersInput
    userActivitiesHistory?: userActivitiesHistoryCreateNestedManyWithoutUsersInput
    userNotifications?: userNotificationsCreateNestedManyWithoutUsersInput
    roles: rolesCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutPersonalityTestResultsInput = {
    id: string
    username: string
    password: string
    avatar_url?: string | null
    email: string
    phone?: string | null
    address_street?: string | null
    address_ward?: string | null
    address_city?: string | null
    address_country?: string | null
    gender?: $Enums.Gender | null
    is_deleted?: boolean
    created_at?: Date | string
    updated_at: Date | string
    role_id: number
    blogs?: blogsUncheckedCreateNestedManyWithoutUsersInput
    careerPaths?: careerPathsUncheckedCreateNestedManyWithoutUsersInput
    companies?: companiesUncheckedCreateNestedOneWithoutUsersInput
    feedbacks?: feedbacksUncheckedCreateNestedManyWithoutUsersInput
    followedCompanies?: followedCompaniesUncheckedCreateNestedManyWithoutUsersInput
    messages?: messagesUncheckedCreateNestedManyWithoutUsersInput
    payments?: paymentsUncheckedCreateNestedManyWithoutUsersInput
    savedJobs?: savedJobsUncheckedCreateNestedManyWithoutUsersInput
    subscriptions?: subscriptionsUncheckedCreateNestedManyWithoutUsersInput
    userActivitiesHistory?: userActivitiesHistoryUncheckedCreateNestedManyWithoutUsersInput
    userNotifications?: userNotificationsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutPersonalityTestResultsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutPersonalityTestResultsInput, usersUncheckedCreateWithoutPersonalityTestResultsInput>
  }

  export type answersUpsertWithoutPersonalityTestResultsInput = {
    update: XOR<answersUpdateWithoutPersonalityTestResultsInput, answersUncheckedUpdateWithoutPersonalityTestResultsInput>
    create: XOR<answersCreateWithoutPersonalityTestResultsInput, answersUncheckedCreateWithoutPersonalityTestResultsInput>
    where?: answersWhereInput
  }

  export type answersUpdateToOneWithWhereWithoutPersonalityTestResultsInput = {
    where?: answersWhereInput
    data: XOR<answersUpdateWithoutPersonalityTestResultsInput, answersUncheckedUpdateWithoutPersonalityTestResultsInput>
  }

  export type answersUpdateWithoutPersonalityTestResultsInput = {
    answer?: StringFieldUpdateOperationsInput | string
    questions?: questionsUpdateOneRequiredWithoutAnswersNestedInput
  }

  export type answersUncheckedUpdateWithoutPersonalityTestResultsInput = {
    id?: IntFieldUpdateOperationsInput | number
    answer?: StringFieldUpdateOperationsInput | string
    question_id?: IntFieldUpdateOperationsInput | number
  }

  export type questionsUpsertWithoutPersonalityTestResultsInput = {
    update: XOR<questionsUpdateWithoutPersonalityTestResultsInput, questionsUncheckedUpdateWithoutPersonalityTestResultsInput>
    create: XOR<questionsCreateWithoutPersonalityTestResultsInput, questionsUncheckedCreateWithoutPersonalityTestResultsInput>
    where?: questionsWhereInput
  }

  export type questionsUpdateToOneWithWhereWithoutPersonalityTestResultsInput = {
    where?: questionsWhereInput
    data: XOR<questionsUpdateWithoutPersonalityTestResultsInput, questionsUncheckedUpdateWithoutPersonalityTestResultsInput>
  }

  export type questionsUpdateWithoutPersonalityTestResultsInput = {
    question?: StringFieldUpdateOperationsInput | string
    answers?: answersUpdateManyWithoutQuestionsNestedInput
  }

  export type questionsUncheckedUpdateWithoutPersonalityTestResultsInput = {
    id?: IntFieldUpdateOperationsInput | number
    question?: StringFieldUpdateOperationsInput | string
    answers?: answersUncheckedUpdateManyWithoutQuestionsNestedInput
  }

  export type usersUpsertWithoutPersonalityTestResultsInput = {
    update: XOR<usersUpdateWithoutPersonalityTestResultsInput, usersUncheckedUpdateWithoutPersonalityTestResultsInput>
    create: XOR<usersCreateWithoutPersonalityTestResultsInput, usersUncheckedCreateWithoutPersonalityTestResultsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutPersonalityTestResultsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutPersonalityTestResultsInput, usersUncheckedUpdateWithoutPersonalityTestResultsInput>
  }

  export type usersUpdateWithoutPersonalityTestResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: NullableStringFieldUpdateOperationsInput | string | null
    address_ward?: NullableStringFieldUpdateOperationsInput | string | null
    address_city?: NullableStringFieldUpdateOperationsInput | string | null
    address_country?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    blogs?: blogsUpdateManyWithoutUsersNestedInput
    careerPaths?: careerPathsUpdateManyWithoutUsersNestedInput
    companies?: companiesUpdateOneWithoutUsersNestedInput
    feedbacks?: feedbacksUpdateManyWithoutUsersNestedInput
    followedCompanies?: followedCompaniesUpdateManyWithoutUsersNestedInput
    messages?: messagesUpdateManyWithoutUsersNestedInput
    payments?: paymentsUpdateManyWithoutUsersNestedInput
    savedJobs?: savedJobsUpdateManyWithoutUsersNestedInput
    subscriptions?: subscriptionsUpdateManyWithoutUsersNestedInput
    userActivitiesHistory?: userActivitiesHistoryUpdateManyWithoutUsersNestedInput
    userNotifications?: userNotificationsUpdateManyWithoutUsersNestedInput
    roles?: rolesUpdateOneRequiredWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutPersonalityTestResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: NullableStringFieldUpdateOperationsInput | string | null
    address_ward?: NullableStringFieldUpdateOperationsInput | string | null
    address_city?: NullableStringFieldUpdateOperationsInput | string | null
    address_country?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role_id?: IntFieldUpdateOperationsInput | number
    blogs?: blogsUncheckedUpdateManyWithoutUsersNestedInput
    careerPaths?: careerPathsUncheckedUpdateManyWithoutUsersNestedInput
    companies?: companiesUncheckedUpdateOneWithoutUsersNestedInput
    feedbacks?: feedbacksUncheckedUpdateManyWithoutUsersNestedInput
    followedCompanies?: followedCompaniesUncheckedUpdateManyWithoutUsersNestedInput
    messages?: messagesUncheckedUpdateManyWithoutUsersNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutUsersNestedInput
    savedJobs?: savedJobsUncheckedUpdateManyWithoutUsersNestedInput
    subscriptions?: subscriptionsUncheckedUpdateManyWithoutUsersNestedInput
    userActivitiesHistory?: userActivitiesHistoryUncheckedUpdateManyWithoutUsersNestedInput
    userNotifications?: userNotificationsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type cvsCreateWithoutProjectsInput = {
    fullname: string
    age?: number | null
    gender?: string | null
    address?: string | null
    email?: string | null
    introduction?: string | null
    soft_skills?: cvsCreatesoft_skillsInput | string[]
    primary_skills?: cvsCreateprimary_skillsInput | string[]
    phone?: string | null
    hobbies?: string | null
    others?: string | null
    applicants?: applicantsCreateNestedManyWithoutCvsInput
    awards?: awardsCreateNestedManyWithoutCvsInput
    certificates?: certificatesCreateNestedManyWithoutCvsInput
    educations?: educationsCreateNestedManyWithoutCvsInput
    experiences?: experiencesCreateNestedManyWithoutCvsInput
    references?: referencesCreateNestedManyWithoutCvsInput
  }

  export type cvsUncheckedCreateWithoutProjectsInput = {
    id?: number
    fullname: string
    age?: number | null
    gender?: string | null
    address?: string | null
    email?: string | null
    introduction?: string | null
    soft_skills?: cvsCreatesoft_skillsInput | string[]
    primary_skills?: cvsCreateprimary_skillsInput | string[]
    phone?: string | null
    hobbies?: string | null
    others?: string | null
    applicants?: applicantsUncheckedCreateNestedManyWithoutCvsInput
    awards?: awardsUncheckedCreateNestedManyWithoutCvsInput
    certificates?: certificatesUncheckedCreateNestedManyWithoutCvsInput
    educations?: educationsUncheckedCreateNestedManyWithoutCvsInput
    experiences?: experiencesUncheckedCreateNestedManyWithoutCvsInput
    references?: referencesUncheckedCreateNestedManyWithoutCvsInput
  }

  export type cvsCreateOrConnectWithoutProjectsInput = {
    where: cvsWhereUniqueInput
    create: XOR<cvsCreateWithoutProjectsInput, cvsUncheckedCreateWithoutProjectsInput>
  }

  export type cvsUpsertWithoutProjectsInput = {
    update: XOR<cvsUpdateWithoutProjectsInput, cvsUncheckedUpdateWithoutProjectsInput>
    create: XOR<cvsCreateWithoutProjectsInput, cvsUncheckedCreateWithoutProjectsInput>
    where?: cvsWhereInput
  }

  export type cvsUpdateToOneWithWhereWithoutProjectsInput = {
    where?: cvsWhereInput
    data: XOR<cvsUpdateWithoutProjectsInput, cvsUncheckedUpdateWithoutProjectsInput>
  }

  export type cvsUpdateWithoutProjectsInput = {
    fullname?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    soft_skills?: cvsUpdatesoft_skillsInput | string[]
    primary_skills?: cvsUpdateprimary_skillsInput | string[]
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    hobbies?: NullableStringFieldUpdateOperationsInput | string | null
    others?: NullableStringFieldUpdateOperationsInput | string | null
    applicants?: applicantsUpdateManyWithoutCvsNestedInput
    awards?: awardsUpdateManyWithoutCvsNestedInput
    certificates?: certificatesUpdateManyWithoutCvsNestedInput
    educations?: educationsUpdateManyWithoutCvsNestedInput
    experiences?: experiencesUpdateManyWithoutCvsNestedInput
    references?: referencesUpdateManyWithoutCvsNestedInput
  }

  export type cvsUncheckedUpdateWithoutProjectsInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullname?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    soft_skills?: cvsUpdatesoft_skillsInput | string[]
    primary_skills?: cvsUpdateprimary_skillsInput | string[]
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    hobbies?: NullableStringFieldUpdateOperationsInput | string | null
    others?: NullableStringFieldUpdateOperationsInput | string | null
    applicants?: applicantsUncheckedUpdateManyWithoutCvsNestedInput
    awards?: awardsUncheckedUpdateManyWithoutCvsNestedInput
    certificates?: certificatesUncheckedUpdateManyWithoutCvsNestedInput
    educations?: educationsUncheckedUpdateManyWithoutCvsNestedInput
    experiences?: experiencesUncheckedUpdateManyWithoutCvsNestedInput
    references?: referencesUncheckedUpdateManyWithoutCvsNestedInput
  }

  export type answersCreateWithoutQuestionsInput = {
    answer: string
    personalityTestResults?: personalityTestResultsCreateNestedManyWithoutAnswersInput
  }

  export type answersUncheckedCreateWithoutQuestionsInput = {
    id?: number
    answer: string
    personalityTestResults?: personalityTestResultsUncheckedCreateNestedManyWithoutAnswersInput
  }

  export type answersCreateOrConnectWithoutQuestionsInput = {
    where: answersWhereUniqueInput
    create: XOR<answersCreateWithoutQuestionsInput, answersUncheckedCreateWithoutQuestionsInput>
  }

  export type answersCreateManyQuestionsInputEnvelope = {
    data: answersCreateManyQuestionsInput | answersCreateManyQuestionsInput[]
    skipDuplicates?: boolean
  }

  export type personalityTestResultsCreateWithoutQuestionsInput = {
    answers: answersCreateNestedOneWithoutPersonalityTestResultsInput
    users: usersCreateNestedOneWithoutPersonalityTestResultsInput
  }

  export type personalityTestResultsUncheckedCreateWithoutQuestionsInput = {
    user_id: string
    answer_id: number
  }

  export type personalityTestResultsCreateOrConnectWithoutQuestionsInput = {
    where: personalityTestResultsWhereUniqueInput
    create: XOR<personalityTestResultsCreateWithoutQuestionsInput, personalityTestResultsUncheckedCreateWithoutQuestionsInput>
  }

  export type personalityTestResultsCreateManyQuestionsInputEnvelope = {
    data: personalityTestResultsCreateManyQuestionsInput | personalityTestResultsCreateManyQuestionsInput[]
    skipDuplicates?: boolean
  }

  export type answersUpsertWithWhereUniqueWithoutQuestionsInput = {
    where: answersWhereUniqueInput
    update: XOR<answersUpdateWithoutQuestionsInput, answersUncheckedUpdateWithoutQuestionsInput>
    create: XOR<answersCreateWithoutQuestionsInput, answersUncheckedCreateWithoutQuestionsInput>
  }

  export type answersUpdateWithWhereUniqueWithoutQuestionsInput = {
    where: answersWhereUniqueInput
    data: XOR<answersUpdateWithoutQuestionsInput, answersUncheckedUpdateWithoutQuestionsInput>
  }

  export type answersUpdateManyWithWhereWithoutQuestionsInput = {
    where: answersScalarWhereInput
    data: XOR<answersUpdateManyMutationInput, answersUncheckedUpdateManyWithoutQuestionsInput>
  }

  export type answersScalarWhereInput = {
    AND?: answersScalarWhereInput | answersScalarWhereInput[]
    OR?: answersScalarWhereInput[]
    NOT?: answersScalarWhereInput | answersScalarWhereInput[]
    id?: IntFilter<"answers"> | number
    answer?: StringFilter<"answers"> | string
    question_id?: IntFilter<"answers"> | number
  }

  export type personalityTestResultsUpsertWithWhereUniqueWithoutQuestionsInput = {
    where: personalityTestResultsWhereUniqueInput
    update: XOR<personalityTestResultsUpdateWithoutQuestionsInput, personalityTestResultsUncheckedUpdateWithoutQuestionsInput>
    create: XOR<personalityTestResultsCreateWithoutQuestionsInput, personalityTestResultsUncheckedCreateWithoutQuestionsInput>
  }

  export type personalityTestResultsUpdateWithWhereUniqueWithoutQuestionsInput = {
    where: personalityTestResultsWhereUniqueInput
    data: XOR<personalityTestResultsUpdateWithoutQuestionsInput, personalityTestResultsUncheckedUpdateWithoutQuestionsInput>
  }

  export type personalityTestResultsUpdateManyWithWhereWithoutQuestionsInput = {
    where: personalityTestResultsScalarWhereInput
    data: XOR<personalityTestResultsUpdateManyMutationInput, personalityTestResultsUncheckedUpdateManyWithoutQuestionsInput>
  }

  export type cvsCreateWithoutReferencesInput = {
    fullname: string
    age?: number | null
    gender?: string | null
    address?: string | null
    email?: string | null
    introduction?: string | null
    soft_skills?: cvsCreatesoft_skillsInput | string[]
    primary_skills?: cvsCreateprimary_skillsInput | string[]
    phone?: string | null
    hobbies?: string | null
    others?: string | null
    applicants?: applicantsCreateNestedManyWithoutCvsInput
    awards?: awardsCreateNestedManyWithoutCvsInput
    certificates?: certificatesCreateNestedManyWithoutCvsInput
    educations?: educationsCreateNestedManyWithoutCvsInput
    experiences?: experiencesCreateNestedManyWithoutCvsInput
    projects?: projectsCreateNestedManyWithoutCvsInput
  }

  export type cvsUncheckedCreateWithoutReferencesInput = {
    id?: number
    fullname: string
    age?: number | null
    gender?: string | null
    address?: string | null
    email?: string | null
    introduction?: string | null
    soft_skills?: cvsCreatesoft_skillsInput | string[]
    primary_skills?: cvsCreateprimary_skillsInput | string[]
    phone?: string | null
    hobbies?: string | null
    others?: string | null
    applicants?: applicantsUncheckedCreateNestedManyWithoutCvsInput
    awards?: awardsUncheckedCreateNestedManyWithoutCvsInput
    certificates?: certificatesUncheckedCreateNestedManyWithoutCvsInput
    educations?: educationsUncheckedCreateNestedManyWithoutCvsInput
    experiences?: experiencesUncheckedCreateNestedManyWithoutCvsInput
    projects?: projectsUncheckedCreateNestedManyWithoutCvsInput
  }

  export type cvsCreateOrConnectWithoutReferencesInput = {
    where: cvsWhereUniqueInput
    create: XOR<cvsCreateWithoutReferencesInput, cvsUncheckedCreateWithoutReferencesInput>
  }

  export type cvsUpsertWithoutReferencesInput = {
    update: XOR<cvsUpdateWithoutReferencesInput, cvsUncheckedUpdateWithoutReferencesInput>
    create: XOR<cvsCreateWithoutReferencesInput, cvsUncheckedCreateWithoutReferencesInput>
    where?: cvsWhereInput
  }

  export type cvsUpdateToOneWithWhereWithoutReferencesInput = {
    where?: cvsWhereInput
    data: XOR<cvsUpdateWithoutReferencesInput, cvsUncheckedUpdateWithoutReferencesInput>
  }

  export type cvsUpdateWithoutReferencesInput = {
    fullname?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    soft_skills?: cvsUpdatesoft_skillsInput | string[]
    primary_skills?: cvsUpdateprimary_skillsInput | string[]
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    hobbies?: NullableStringFieldUpdateOperationsInput | string | null
    others?: NullableStringFieldUpdateOperationsInput | string | null
    applicants?: applicantsUpdateManyWithoutCvsNestedInput
    awards?: awardsUpdateManyWithoutCvsNestedInput
    certificates?: certificatesUpdateManyWithoutCvsNestedInput
    educations?: educationsUpdateManyWithoutCvsNestedInput
    experiences?: experiencesUpdateManyWithoutCvsNestedInput
    projects?: projectsUpdateManyWithoutCvsNestedInput
  }

  export type cvsUncheckedUpdateWithoutReferencesInput = {
    id?: IntFieldUpdateOperationsInput | number
    fullname?: StringFieldUpdateOperationsInput | string
    age?: NullableIntFieldUpdateOperationsInput | number | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    introduction?: NullableStringFieldUpdateOperationsInput | string | null
    soft_skills?: cvsUpdatesoft_skillsInput | string[]
    primary_skills?: cvsUpdateprimary_skillsInput | string[]
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    hobbies?: NullableStringFieldUpdateOperationsInput | string | null
    others?: NullableStringFieldUpdateOperationsInput | string | null
    applicants?: applicantsUncheckedUpdateManyWithoutCvsNestedInput
    awards?: awardsUncheckedUpdateManyWithoutCvsNestedInput
    certificates?: certificatesUncheckedUpdateManyWithoutCvsNestedInput
    educations?: educationsUncheckedUpdateManyWithoutCvsNestedInput
    experiences?: experiencesUncheckedUpdateManyWithoutCvsNestedInput
    projects?: projectsUncheckedUpdateManyWithoutCvsNestedInput
  }

  export type usersCreateWithoutRolesInput = {
    id: string
    username: string
    password: string
    avatar_url?: string | null
    email: string
    phone?: string | null
    address_street?: string | null
    address_ward?: string | null
    address_city?: string | null
    address_country?: string | null
    gender?: $Enums.Gender | null
    is_deleted?: boolean
    created_at?: Date | string
    updated_at: Date | string
    blogs?: blogsCreateNestedManyWithoutUsersInput
    careerPaths?: careerPathsCreateNestedManyWithoutUsersInput
    companies?: companiesCreateNestedOneWithoutUsersInput
    feedbacks?: feedbacksCreateNestedManyWithoutUsersInput
    followedCompanies?: followedCompaniesCreateNestedManyWithoutUsersInput
    messages?: messagesCreateNestedManyWithoutUsersInput
    payments?: paymentsCreateNestedManyWithoutUsersInput
    personalityTestResults?: personalityTestResultsCreateNestedManyWithoutUsersInput
    savedJobs?: savedJobsCreateNestedManyWithoutUsersInput
    subscriptions?: subscriptionsCreateNestedManyWithoutUsersInput
    userActivitiesHistory?: userActivitiesHistoryCreateNestedManyWithoutUsersInput
    userNotifications?: userNotificationsCreateNestedManyWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutRolesInput = {
    id: string
    username: string
    password: string
    avatar_url?: string | null
    email: string
    phone?: string | null
    address_street?: string | null
    address_ward?: string | null
    address_city?: string | null
    address_country?: string | null
    gender?: $Enums.Gender | null
    is_deleted?: boolean
    created_at?: Date | string
    updated_at: Date | string
    blogs?: blogsUncheckedCreateNestedManyWithoutUsersInput
    careerPaths?: careerPathsUncheckedCreateNestedManyWithoutUsersInput
    companies?: companiesUncheckedCreateNestedOneWithoutUsersInput
    feedbacks?: feedbacksUncheckedCreateNestedManyWithoutUsersInput
    followedCompanies?: followedCompaniesUncheckedCreateNestedManyWithoutUsersInput
    messages?: messagesUncheckedCreateNestedManyWithoutUsersInput
    payments?: paymentsUncheckedCreateNestedManyWithoutUsersInput
    personalityTestResults?: personalityTestResultsUncheckedCreateNestedManyWithoutUsersInput
    savedJobs?: savedJobsUncheckedCreateNestedManyWithoutUsersInput
    subscriptions?: subscriptionsUncheckedCreateNestedManyWithoutUsersInput
    userActivitiesHistory?: userActivitiesHistoryUncheckedCreateNestedManyWithoutUsersInput
    userNotifications?: userNotificationsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutRolesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutRolesInput, usersUncheckedCreateWithoutRolesInput>
  }

  export type usersCreateManyRolesInputEnvelope = {
    data: usersCreateManyRolesInput | usersCreateManyRolesInput[]
    skipDuplicates?: boolean
  }

  export type usersUpsertWithWhereUniqueWithoutRolesInput = {
    where: usersWhereUniqueInput
    update: XOR<usersUpdateWithoutRolesInput, usersUncheckedUpdateWithoutRolesInput>
    create: XOR<usersCreateWithoutRolesInput, usersUncheckedCreateWithoutRolesInput>
  }

  export type usersUpdateWithWhereUniqueWithoutRolesInput = {
    where: usersWhereUniqueInput
    data: XOR<usersUpdateWithoutRolesInput, usersUncheckedUpdateWithoutRolesInput>
  }

  export type usersUpdateManyWithWhereWithoutRolesInput = {
    where: usersScalarWhereInput
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyWithoutRolesInput>
  }

  export type usersScalarWhereInput = {
    AND?: usersScalarWhereInput | usersScalarWhereInput[]
    OR?: usersScalarWhereInput[]
    NOT?: usersScalarWhereInput | usersScalarWhereInput[]
    id?: StringFilter<"users"> | string
    username?: StringFilter<"users"> | string
    password?: StringFilter<"users"> | string
    avatar_url?: StringNullableFilter<"users"> | string | null
    email?: StringFilter<"users"> | string
    phone?: StringNullableFilter<"users"> | string | null
    address_street?: StringNullableFilter<"users"> | string | null
    address_ward?: StringNullableFilter<"users"> | string | null
    address_city?: StringNullableFilter<"users"> | string | null
    address_country?: StringNullableFilter<"users"> | string | null
    gender?: EnumGenderNullableFilter<"users"> | $Enums.Gender | null
    is_deleted?: BoolFilter<"users"> | boolean
    created_at?: DateTimeFilter<"users"> | Date | string
    updated_at?: DateTimeFilter<"users"> | Date | string
    role_id?: IntFilter<"users"> | number
  }

  export type jobsCreateWithoutSavedJobsInput = {
    id: string
    job_title: string
    description: string
    location?: string | null
    benefit?: string | null
    working_time?: string | null
    salary?: jobsCreatesalaryInput | string[]
    currency?: string | null
    job_type?: $Enums.Job_Type | null
    status?: $Enums.Job_Status | null
    job_level: string
    quantity?: number | null
    skill_tags?: jobsCreateskill_tagsInput | string[]
    education?: $Enums.Education | null
    experience?: string | null
    start_date?: Date | string
    end_date?: Date | string | null
    created_at?: Date | string
    updated_at: Date | string
    applicants?: applicantsCreateNestedManyWithoutJobsInput
    categories?: categoriesCreateNestedOneWithoutJobsInput
    jobLabels?: jobLabelsCreateNestedOneWithoutJobsInput
  }

  export type jobsUncheckedCreateWithoutSavedJobsInput = {
    id: string
    job_title: string
    description: string
    location?: string | null
    benefit?: string | null
    working_time?: string | null
    salary?: jobsCreatesalaryInput | string[]
    currency?: string | null
    job_type?: $Enums.Job_Type | null
    status?: $Enums.Job_Status | null
    job_level: string
    quantity?: number | null
    skill_tags?: jobsCreateskill_tagsInput | string[]
    education?: $Enums.Education | null
    experience?: string | null
    start_date?: Date | string
    end_date?: Date | string | null
    created_at?: Date | string
    updated_at: Date | string
    category_id?: number | null
    label_id?: number | null
    applicants?: applicantsUncheckedCreateNestedManyWithoutJobsInput
  }

  export type jobsCreateOrConnectWithoutSavedJobsInput = {
    where: jobsWhereUniqueInput
    create: XOR<jobsCreateWithoutSavedJobsInput, jobsUncheckedCreateWithoutSavedJobsInput>
  }

  export type usersCreateWithoutSavedJobsInput = {
    id: string
    username: string
    password: string
    avatar_url?: string | null
    email: string
    phone?: string | null
    address_street?: string | null
    address_ward?: string | null
    address_city?: string | null
    address_country?: string | null
    gender?: $Enums.Gender | null
    is_deleted?: boolean
    created_at?: Date | string
    updated_at: Date | string
    blogs?: blogsCreateNestedManyWithoutUsersInput
    careerPaths?: careerPathsCreateNestedManyWithoutUsersInput
    companies?: companiesCreateNestedOneWithoutUsersInput
    feedbacks?: feedbacksCreateNestedManyWithoutUsersInput
    followedCompanies?: followedCompaniesCreateNestedManyWithoutUsersInput
    messages?: messagesCreateNestedManyWithoutUsersInput
    payments?: paymentsCreateNestedManyWithoutUsersInput
    personalityTestResults?: personalityTestResultsCreateNestedManyWithoutUsersInput
    subscriptions?: subscriptionsCreateNestedManyWithoutUsersInput
    userActivitiesHistory?: userActivitiesHistoryCreateNestedManyWithoutUsersInput
    userNotifications?: userNotificationsCreateNestedManyWithoutUsersInput
    roles: rolesCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutSavedJobsInput = {
    id: string
    username: string
    password: string
    avatar_url?: string | null
    email: string
    phone?: string | null
    address_street?: string | null
    address_ward?: string | null
    address_city?: string | null
    address_country?: string | null
    gender?: $Enums.Gender | null
    is_deleted?: boolean
    created_at?: Date | string
    updated_at: Date | string
    role_id: number
    blogs?: blogsUncheckedCreateNestedManyWithoutUsersInput
    careerPaths?: careerPathsUncheckedCreateNestedManyWithoutUsersInput
    companies?: companiesUncheckedCreateNestedOneWithoutUsersInput
    feedbacks?: feedbacksUncheckedCreateNestedManyWithoutUsersInput
    followedCompanies?: followedCompaniesUncheckedCreateNestedManyWithoutUsersInput
    messages?: messagesUncheckedCreateNestedManyWithoutUsersInput
    payments?: paymentsUncheckedCreateNestedManyWithoutUsersInput
    personalityTestResults?: personalityTestResultsUncheckedCreateNestedManyWithoutUsersInput
    subscriptions?: subscriptionsUncheckedCreateNestedManyWithoutUsersInput
    userActivitiesHistory?: userActivitiesHistoryUncheckedCreateNestedManyWithoutUsersInput
    userNotifications?: userNotificationsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutSavedJobsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutSavedJobsInput, usersUncheckedCreateWithoutSavedJobsInput>
  }

  export type jobsUpsertWithoutSavedJobsInput = {
    update: XOR<jobsUpdateWithoutSavedJobsInput, jobsUncheckedUpdateWithoutSavedJobsInput>
    create: XOR<jobsCreateWithoutSavedJobsInput, jobsUncheckedCreateWithoutSavedJobsInput>
    where?: jobsWhereInput
  }

  export type jobsUpdateToOneWithWhereWithoutSavedJobsInput = {
    where?: jobsWhereInput
    data: XOR<jobsUpdateWithoutSavedJobsInput, jobsUncheckedUpdateWithoutSavedJobsInput>
  }

  export type jobsUpdateWithoutSavedJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    job_title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    benefit?: NullableStringFieldUpdateOperationsInput | string | null
    working_time?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: jobsUpdatesalaryInput | string[]
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    job_type?: NullableEnumJob_TypeFieldUpdateOperationsInput | $Enums.Job_Type | null
    status?: NullableEnumJob_StatusFieldUpdateOperationsInput | $Enums.Job_Status | null
    job_level?: StringFieldUpdateOperationsInput | string
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    skill_tags?: jobsUpdateskill_tagsInput | string[]
    education?: NullableEnumEducationFieldUpdateOperationsInput | $Enums.Education | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    applicants?: applicantsUpdateManyWithoutJobsNestedInput
    categories?: categoriesUpdateOneWithoutJobsNestedInput
    jobLabels?: jobLabelsUpdateOneWithoutJobsNestedInput
  }

  export type jobsUncheckedUpdateWithoutSavedJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    job_title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    benefit?: NullableStringFieldUpdateOperationsInput | string | null
    working_time?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: jobsUpdatesalaryInput | string[]
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    job_type?: NullableEnumJob_TypeFieldUpdateOperationsInput | $Enums.Job_Type | null
    status?: NullableEnumJob_StatusFieldUpdateOperationsInput | $Enums.Job_Status | null
    job_level?: StringFieldUpdateOperationsInput | string
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    skill_tags?: jobsUpdateskill_tagsInput | string[]
    education?: NullableEnumEducationFieldUpdateOperationsInput | $Enums.Education | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    label_id?: NullableIntFieldUpdateOperationsInput | number | null
    applicants?: applicantsUncheckedUpdateManyWithoutJobsNestedInput
  }

  export type usersUpsertWithoutSavedJobsInput = {
    update: XOR<usersUpdateWithoutSavedJobsInput, usersUncheckedUpdateWithoutSavedJobsInput>
    create: XOR<usersCreateWithoutSavedJobsInput, usersUncheckedCreateWithoutSavedJobsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutSavedJobsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutSavedJobsInput, usersUncheckedUpdateWithoutSavedJobsInput>
  }

  export type usersUpdateWithoutSavedJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: NullableStringFieldUpdateOperationsInput | string | null
    address_ward?: NullableStringFieldUpdateOperationsInput | string | null
    address_city?: NullableStringFieldUpdateOperationsInput | string | null
    address_country?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    blogs?: blogsUpdateManyWithoutUsersNestedInput
    careerPaths?: careerPathsUpdateManyWithoutUsersNestedInput
    companies?: companiesUpdateOneWithoutUsersNestedInput
    feedbacks?: feedbacksUpdateManyWithoutUsersNestedInput
    followedCompanies?: followedCompaniesUpdateManyWithoutUsersNestedInput
    messages?: messagesUpdateManyWithoutUsersNestedInput
    payments?: paymentsUpdateManyWithoutUsersNestedInput
    personalityTestResults?: personalityTestResultsUpdateManyWithoutUsersNestedInput
    subscriptions?: subscriptionsUpdateManyWithoutUsersNestedInput
    userActivitiesHistory?: userActivitiesHistoryUpdateManyWithoutUsersNestedInput
    userNotifications?: userNotificationsUpdateManyWithoutUsersNestedInput
    roles?: rolesUpdateOneRequiredWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutSavedJobsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: NullableStringFieldUpdateOperationsInput | string | null
    address_ward?: NullableStringFieldUpdateOperationsInput | string | null
    address_city?: NullableStringFieldUpdateOperationsInput | string | null
    address_country?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role_id?: IntFieldUpdateOperationsInput | number
    blogs?: blogsUncheckedUpdateManyWithoutUsersNestedInput
    careerPaths?: careerPathsUncheckedUpdateManyWithoutUsersNestedInput
    companies?: companiesUncheckedUpdateOneWithoutUsersNestedInput
    feedbacks?: feedbacksUncheckedUpdateManyWithoutUsersNestedInput
    followedCompanies?: followedCompaniesUncheckedUpdateManyWithoutUsersNestedInput
    messages?: messagesUncheckedUpdateManyWithoutUsersNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutUsersNestedInput
    personalityTestResults?: personalityTestResultsUncheckedUpdateManyWithoutUsersNestedInput
    subscriptions?: subscriptionsUncheckedUpdateManyWithoutUsersNestedInput
    userActivitiesHistory?: userActivitiesHistoryUncheckedUpdateManyWithoutUsersNestedInput
    userNotifications?: userNotificationsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type paymentsCreateWithoutSubscriptionsInput = {
    id: string
    amount: bigint | number
    currency?: string | null
    payment_gateway: $Enums.PaymentGateway
    payment_method: $Enums.PaymentMethod
    transaction_id?: string | null
    status: $Enums.PaymentStatus
    created_at?: Date | string
    users: usersCreateNestedOneWithoutPaymentsInput
  }

  export type paymentsUncheckedCreateWithoutSubscriptionsInput = {
    id: string
    amount: bigint | number
    currency?: string | null
    payment_gateway: $Enums.PaymentGateway
    payment_method: $Enums.PaymentMethod
    transaction_id?: string | null
    status: $Enums.PaymentStatus
    created_at?: Date | string
    user_id: string
  }

  export type paymentsCreateOrConnectWithoutSubscriptionsInput = {
    where: paymentsWhereUniqueInput
    create: XOR<paymentsCreateWithoutSubscriptionsInput, paymentsUncheckedCreateWithoutSubscriptionsInput>
  }

  export type membershipPlansCreateWithoutSubscriptionsInput = {
    plan_name: string
    description?: string | null
    price: bigint | number
    duration_days: number
    is_active?: boolean
    created_at?: Date | string
    updated_at: Date | string
    features?: featuresCreateNestedManyWithoutMembershipPlansInput
  }

  export type membershipPlansUncheckedCreateWithoutSubscriptionsInput = {
    id?: number
    plan_name: string
    description?: string | null
    price: bigint | number
    duration_days: number
    is_active?: boolean
    created_at?: Date | string
    updated_at: Date | string
    features?: featuresUncheckedCreateNestedManyWithoutMembershipPlansInput
  }

  export type membershipPlansCreateOrConnectWithoutSubscriptionsInput = {
    where: membershipPlansWhereUniqueInput
    create: XOR<membershipPlansCreateWithoutSubscriptionsInput, membershipPlansUncheckedCreateWithoutSubscriptionsInput>
  }

  export type usersCreateWithoutSubscriptionsInput = {
    id: string
    username: string
    password: string
    avatar_url?: string | null
    email: string
    phone?: string | null
    address_street?: string | null
    address_ward?: string | null
    address_city?: string | null
    address_country?: string | null
    gender?: $Enums.Gender | null
    is_deleted?: boolean
    created_at?: Date | string
    updated_at: Date | string
    blogs?: blogsCreateNestedManyWithoutUsersInput
    careerPaths?: careerPathsCreateNestedManyWithoutUsersInput
    companies?: companiesCreateNestedOneWithoutUsersInput
    feedbacks?: feedbacksCreateNestedManyWithoutUsersInput
    followedCompanies?: followedCompaniesCreateNestedManyWithoutUsersInput
    messages?: messagesCreateNestedManyWithoutUsersInput
    payments?: paymentsCreateNestedManyWithoutUsersInput
    personalityTestResults?: personalityTestResultsCreateNestedManyWithoutUsersInput
    savedJobs?: savedJobsCreateNestedManyWithoutUsersInput
    userActivitiesHistory?: userActivitiesHistoryCreateNestedManyWithoutUsersInput
    userNotifications?: userNotificationsCreateNestedManyWithoutUsersInput
    roles: rolesCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutSubscriptionsInput = {
    id: string
    username: string
    password: string
    avatar_url?: string | null
    email: string
    phone?: string | null
    address_street?: string | null
    address_ward?: string | null
    address_city?: string | null
    address_country?: string | null
    gender?: $Enums.Gender | null
    is_deleted?: boolean
    created_at?: Date | string
    updated_at: Date | string
    role_id: number
    blogs?: blogsUncheckedCreateNestedManyWithoutUsersInput
    careerPaths?: careerPathsUncheckedCreateNestedManyWithoutUsersInput
    companies?: companiesUncheckedCreateNestedOneWithoutUsersInput
    feedbacks?: feedbacksUncheckedCreateNestedManyWithoutUsersInput
    followedCompanies?: followedCompaniesUncheckedCreateNestedManyWithoutUsersInput
    messages?: messagesUncheckedCreateNestedManyWithoutUsersInput
    payments?: paymentsUncheckedCreateNestedManyWithoutUsersInput
    personalityTestResults?: personalityTestResultsUncheckedCreateNestedManyWithoutUsersInput
    savedJobs?: savedJobsUncheckedCreateNestedManyWithoutUsersInput
    userActivitiesHistory?: userActivitiesHistoryUncheckedCreateNestedManyWithoutUsersInput
    userNotifications?: userNotificationsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutSubscriptionsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutSubscriptionsInput, usersUncheckedCreateWithoutSubscriptionsInput>
  }

  export type paymentsUpsertWithoutSubscriptionsInput = {
    update: XOR<paymentsUpdateWithoutSubscriptionsInput, paymentsUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<paymentsCreateWithoutSubscriptionsInput, paymentsUncheckedCreateWithoutSubscriptionsInput>
    where?: paymentsWhereInput
  }

  export type paymentsUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: paymentsWhereInput
    data: XOR<paymentsUpdateWithoutSubscriptionsInput, paymentsUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type paymentsUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    payment_gateway?: EnumPaymentGatewayFieldUpdateOperationsInput | $Enums.PaymentGateway
    payment_method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type paymentsUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    payment_gateway?: EnumPaymentGatewayFieldUpdateOperationsInput | $Enums.PaymentGateway
    payment_method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type membershipPlansUpsertWithoutSubscriptionsInput = {
    update: XOR<membershipPlansUpdateWithoutSubscriptionsInput, membershipPlansUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<membershipPlansCreateWithoutSubscriptionsInput, membershipPlansUncheckedCreateWithoutSubscriptionsInput>
    where?: membershipPlansWhereInput
  }

  export type membershipPlansUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: membershipPlansWhereInput
    data: XOR<membershipPlansUpdateWithoutSubscriptionsInput, membershipPlansUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type membershipPlansUpdateWithoutSubscriptionsInput = {
    plan_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: BigIntFieldUpdateOperationsInput | bigint | number
    duration_days?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: featuresUpdateManyWithoutMembershipPlansNestedInput
  }

  export type membershipPlansUncheckedUpdateWithoutSubscriptionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    plan_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: BigIntFieldUpdateOperationsInput | bigint | number
    duration_days?: IntFieldUpdateOperationsInput | number
    is_active?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: featuresUncheckedUpdateManyWithoutMembershipPlansNestedInput
  }

  export type usersUpsertWithoutSubscriptionsInput = {
    update: XOR<usersUpdateWithoutSubscriptionsInput, usersUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<usersCreateWithoutSubscriptionsInput, usersUncheckedCreateWithoutSubscriptionsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutSubscriptionsInput, usersUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type usersUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: NullableStringFieldUpdateOperationsInput | string | null
    address_ward?: NullableStringFieldUpdateOperationsInput | string | null
    address_city?: NullableStringFieldUpdateOperationsInput | string | null
    address_country?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    blogs?: blogsUpdateManyWithoutUsersNestedInput
    careerPaths?: careerPathsUpdateManyWithoutUsersNestedInput
    companies?: companiesUpdateOneWithoutUsersNestedInput
    feedbacks?: feedbacksUpdateManyWithoutUsersNestedInput
    followedCompanies?: followedCompaniesUpdateManyWithoutUsersNestedInput
    messages?: messagesUpdateManyWithoutUsersNestedInput
    payments?: paymentsUpdateManyWithoutUsersNestedInput
    personalityTestResults?: personalityTestResultsUpdateManyWithoutUsersNestedInput
    savedJobs?: savedJobsUpdateManyWithoutUsersNestedInput
    userActivitiesHistory?: userActivitiesHistoryUpdateManyWithoutUsersNestedInput
    userNotifications?: userNotificationsUpdateManyWithoutUsersNestedInput
    roles?: rolesUpdateOneRequiredWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: NullableStringFieldUpdateOperationsInput | string | null
    address_ward?: NullableStringFieldUpdateOperationsInput | string | null
    address_city?: NullableStringFieldUpdateOperationsInput | string | null
    address_country?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role_id?: IntFieldUpdateOperationsInput | number
    blogs?: blogsUncheckedUpdateManyWithoutUsersNestedInput
    careerPaths?: careerPathsUncheckedUpdateManyWithoutUsersNestedInput
    companies?: companiesUncheckedUpdateOneWithoutUsersNestedInput
    feedbacks?: feedbacksUncheckedUpdateManyWithoutUsersNestedInput
    followedCompanies?: followedCompaniesUncheckedUpdateManyWithoutUsersNestedInput
    messages?: messagesUncheckedUpdateManyWithoutUsersNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutUsersNestedInput
    personalityTestResults?: personalityTestResultsUncheckedUpdateManyWithoutUsersNestedInput
    savedJobs?: savedJobsUncheckedUpdateManyWithoutUsersNestedInput
    userActivitiesHistory?: userActivitiesHistoryUncheckedUpdateManyWithoutUsersNestedInput
    userNotifications?: userNotificationsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersCreateWithoutUserActivitiesHistoryInput = {
    id: string
    username: string
    password: string
    avatar_url?: string | null
    email: string
    phone?: string | null
    address_street?: string | null
    address_ward?: string | null
    address_city?: string | null
    address_country?: string | null
    gender?: $Enums.Gender | null
    is_deleted?: boolean
    created_at?: Date | string
    updated_at: Date | string
    blogs?: blogsCreateNestedManyWithoutUsersInput
    careerPaths?: careerPathsCreateNestedManyWithoutUsersInput
    companies?: companiesCreateNestedOneWithoutUsersInput
    feedbacks?: feedbacksCreateNestedManyWithoutUsersInput
    followedCompanies?: followedCompaniesCreateNestedManyWithoutUsersInput
    messages?: messagesCreateNestedManyWithoutUsersInput
    payments?: paymentsCreateNestedManyWithoutUsersInput
    personalityTestResults?: personalityTestResultsCreateNestedManyWithoutUsersInput
    savedJobs?: savedJobsCreateNestedManyWithoutUsersInput
    subscriptions?: subscriptionsCreateNestedManyWithoutUsersInput
    userNotifications?: userNotificationsCreateNestedManyWithoutUsersInput
    roles: rolesCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutUserActivitiesHistoryInput = {
    id: string
    username: string
    password: string
    avatar_url?: string | null
    email: string
    phone?: string | null
    address_street?: string | null
    address_ward?: string | null
    address_city?: string | null
    address_country?: string | null
    gender?: $Enums.Gender | null
    is_deleted?: boolean
    created_at?: Date | string
    updated_at: Date | string
    role_id: number
    blogs?: blogsUncheckedCreateNestedManyWithoutUsersInput
    careerPaths?: careerPathsUncheckedCreateNestedManyWithoutUsersInput
    companies?: companiesUncheckedCreateNestedOneWithoutUsersInput
    feedbacks?: feedbacksUncheckedCreateNestedManyWithoutUsersInput
    followedCompanies?: followedCompaniesUncheckedCreateNestedManyWithoutUsersInput
    messages?: messagesUncheckedCreateNestedManyWithoutUsersInput
    payments?: paymentsUncheckedCreateNestedManyWithoutUsersInput
    personalityTestResults?: personalityTestResultsUncheckedCreateNestedManyWithoutUsersInput
    savedJobs?: savedJobsUncheckedCreateNestedManyWithoutUsersInput
    subscriptions?: subscriptionsUncheckedCreateNestedManyWithoutUsersInput
    userNotifications?: userNotificationsUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutUserActivitiesHistoryInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutUserActivitiesHistoryInput, usersUncheckedCreateWithoutUserActivitiesHistoryInput>
  }

  export type usersUpsertWithoutUserActivitiesHistoryInput = {
    update: XOR<usersUpdateWithoutUserActivitiesHistoryInput, usersUncheckedUpdateWithoutUserActivitiesHistoryInput>
    create: XOR<usersCreateWithoutUserActivitiesHistoryInput, usersUncheckedCreateWithoutUserActivitiesHistoryInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutUserActivitiesHistoryInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutUserActivitiesHistoryInput, usersUncheckedUpdateWithoutUserActivitiesHistoryInput>
  }

  export type usersUpdateWithoutUserActivitiesHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: NullableStringFieldUpdateOperationsInput | string | null
    address_ward?: NullableStringFieldUpdateOperationsInput | string | null
    address_city?: NullableStringFieldUpdateOperationsInput | string | null
    address_country?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    blogs?: blogsUpdateManyWithoutUsersNestedInput
    careerPaths?: careerPathsUpdateManyWithoutUsersNestedInput
    companies?: companiesUpdateOneWithoutUsersNestedInput
    feedbacks?: feedbacksUpdateManyWithoutUsersNestedInput
    followedCompanies?: followedCompaniesUpdateManyWithoutUsersNestedInput
    messages?: messagesUpdateManyWithoutUsersNestedInput
    payments?: paymentsUpdateManyWithoutUsersNestedInput
    personalityTestResults?: personalityTestResultsUpdateManyWithoutUsersNestedInput
    savedJobs?: savedJobsUpdateManyWithoutUsersNestedInput
    subscriptions?: subscriptionsUpdateManyWithoutUsersNestedInput
    userNotifications?: userNotificationsUpdateManyWithoutUsersNestedInput
    roles?: rolesUpdateOneRequiredWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutUserActivitiesHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: NullableStringFieldUpdateOperationsInput | string | null
    address_ward?: NullableStringFieldUpdateOperationsInput | string | null
    address_city?: NullableStringFieldUpdateOperationsInput | string | null
    address_country?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role_id?: IntFieldUpdateOperationsInput | number
    blogs?: blogsUncheckedUpdateManyWithoutUsersNestedInput
    careerPaths?: careerPathsUncheckedUpdateManyWithoutUsersNestedInput
    companies?: companiesUncheckedUpdateOneWithoutUsersNestedInput
    feedbacks?: feedbacksUncheckedUpdateManyWithoutUsersNestedInput
    followedCompanies?: followedCompaniesUncheckedUpdateManyWithoutUsersNestedInput
    messages?: messagesUncheckedUpdateManyWithoutUsersNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutUsersNestedInput
    personalityTestResults?: personalityTestResultsUncheckedUpdateManyWithoutUsersNestedInput
    savedJobs?: savedJobsUncheckedUpdateManyWithoutUsersNestedInput
    subscriptions?: subscriptionsUncheckedUpdateManyWithoutUsersNestedInput
    userNotifications?: userNotificationsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersCreateWithoutUserNotificationsInput = {
    id: string
    username: string
    password: string
    avatar_url?: string | null
    email: string
    phone?: string | null
    address_street?: string | null
    address_ward?: string | null
    address_city?: string | null
    address_country?: string | null
    gender?: $Enums.Gender | null
    is_deleted?: boolean
    created_at?: Date | string
    updated_at: Date | string
    blogs?: blogsCreateNestedManyWithoutUsersInput
    careerPaths?: careerPathsCreateNestedManyWithoutUsersInput
    companies?: companiesCreateNestedOneWithoutUsersInput
    feedbacks?: feedbacksCreateNestedManyWithoutUsersInput
    followedCompanies?: followedCompaniesCreateNestedManyWithoutUsersInput
    messages?: messagesCreateNestedManyWithoutUsersInput
    payments?: paymentsCreateNestedManyWithoutUsersInput
    personalityTestResults?: personalityTestResultsCreateNestedManyWithoutUsersInput
    savedJobs?: savedJobsCreateNestedManyWithoutUsersInput
    subscriptions?: subscriptionsCreateNestedManyWithoutUsersInput
    userActivitiesHistory?: userActivitiesHistoryCreateNestedManyWithoutUsersInput
    roles: rolesCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateWithoutUserNotificationsInput = {
    id: string
    username: string
    password: string
    avatar_url?: string | null
    email: string
    phone?: string | null
    address_street?: string | null
    address_ward?: string | null
    address_city?: string | null
    address_country?: string | null
    gender?: $Enums.Gender | null
    is_deleted?: boolean
    created_at?: Date | string
    updated_at: Date | string
    role_id: number
    blogs?: blogsUncheckedCreateNestedManyWithoutUsersInput
    careerPaths?: careerPathsUncheckedCreateNestedManyWithoutUsersInput
    companies?: companiesUncheckedCreateNestedOneWithoutUsersInput
    feedbacks?: feedbacksUncheckedCreateNestedManyWithoutUsersInput
    followedCompanies?: followedCompaniesUncheckedCreateNestedManyWithoutUsersInput
    messages?: messagesUncheckedCreateNestedManyWithoutUsersInput
    payments?: paymentsUncheckedCreateNestedManyWithoutUsersInput
    personalityTestResults?: personalityTestResultsUncheckedCreateNestedManyWithoutUsersInput
    savedJobs?: savedJobsUncheckedCreateNestedManyWithoutUsersInput
    subscriptions?: subscriptionsUncheckedCreateNestedManyWithoutUsersInput
    userActivitiesHistory?: userActivitiesHistoryUncheckedCreateNestedManyWithoutUsersInput
  }

  export type usersCreateOrConnectWithoutUserNotificationsInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutUserNotificationsInput, usersUncheckedCreateWithoutUserNotificationsInput>
  }

  export type usersUpsertWithoutUserNotificationsInput = {
    update: XOR<usersUpdateWithoutUserNotificationsInput, usersUncheckedUpdateWithoutUserNotificationsInput>
    create: XOR<usersCreateWithoutUserNotificationsInput, usersUncheckedCreateWithoutUserNotificationsInput>
    where?: usersWhereInput
  }

  export type usersUpdateToOneWithWhereWithoutUserNotificationsInput = {
    where?: usersWhereInput
    data: XOR<usersUpdateWithoutUserNotificationsInput, usersUncheckedUpdateWithoutUserNotificationsInput>
  }

  export type usersUpdateWithoutUserNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: NullableStringFieldUpdateOperationsInput | string | null
    address_ward?: NullableStringFieldUpdateOperationsInput | string | null
    address_city?: NullableStringFieldUpdateOperationsInput | string | null
    address_country?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    blogs?: blogsUpdateManyWithoutUsersNestedInput
    careerPaths?: careerPathsUpdateManyWithoutUsersNestedInput
    companies?: companiesUpdateOneWithoutUsersNestedInput
    feedbacks?: feedbacksUpdateManyWithoutUsersNestedInput
    followedCompanies?: followedCompaniesUpdateManyWithoutUsersNestedInput
    messages?: messagesUpdateManyWithoutUsersNestedInput
    payments?: paymentsUpdateManyWithoutUsersNestedInput
    personalityTestResults?: personalityTestResultsUpdateManyWithoutUsersNestedInput
    savedJobs?: savedJobsUpdateManyWithoutUsersNestedInput
    subscriptions?: subscriptionsUpdateManyWithoutUsersNestedInput
    userActivitiesHistory?: userActivitiesHistoryUpdateManyWithoutUsersNestedInput
    roles?: rolesUpdateOneRequiredWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutUserNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: NullableStringFieldUpdateOperationsInput | string | null
    address_ward?: NullableStringFieldUpdateOperationsInput | string | null
    address_city?: NullableStringFieldUpdateOperationsInput | string | null
    address_country?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    role_id?: IntFieldUpdateOperationsInput | number
    blogs?: blogsUncheckedUpdateManyWithoutUsersNestedInput
    careerPaths?: careerPathsUncheckedUpdateManyWithoutUsersNestedInput
    companies?: companiesUncheckedUpdateOneWithoutUsersNestedInput
    feedbacks?: feedbacksUncheckedUpdateManyWithoutUsersNestedInput
    followedCompanies?: followedCompaniesUncheckedUpdateManyWithoutUsersNestedInput
    messages?: messagesUncheckedUpdateManyWithoutUsersNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutUsersNestedInput
    personalityTestResults?: personalityTestResultsUncheckedUpdateManyWithoutUsersNestedInput
    savedJobs?: savedJobsUncheckedUpdateManyWithoutUsersNestedInput
    subscriptions?: subscriptionsUncheckedUpdateManyWithoutUsersNestedInput
    userActivitiesHistory?: userActivitiesHistoryUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type blogsCreateWithoutUsersInput = {
    title: string
    cover_image_url: string
    description_url: string
    created_at?: Date | string
    updated_at: Date | string
  }

  export type blogsUncheckedCreateWithoutUsersInput = {
    id?: number
    title: string
    cover_image_url: string
    description_url: string
    created_at?: Date | string
    updated_at: Date | string
  }

  export type blogsCreateOrConnectWithoutUsersInput = {
    where: blogsWhereUniqueInput
    create: XOR<blogsCreateWithoutUsersInput, blogsUncheckedCreateWithoutUsersInput>
  }

  export type blogsCreateManyUsersInputEnvelope = {
    data: blogsCreateManyUsersInput | blogsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type careerPathsCreateWithoutUsersInput = {
    title: string
    description?: string | null
    resources?: string | null
    level?: string | null
    estimate_duration?: string | null
    careerPathSteps?: careerPathStepsCreateNestedManyWithoutCareerPathsInput
    jobSpecialized: jobSpecializedCreateNestedOneWithoutCareerPathsInput
  }

  export type careerPathsUncheckedCreateWithoutUsersInput = {
    id?: number
    title: string
    description?: string | null
    resources?: string | null
    level?: string | null
    estimate_duration?: string | null
    jobspecialized_id: number
    careerPathSteps?: careerPathStepsUncheckedCreateNestedManyWithoutCareerPathsInput
  }

  export type careerPathsCreateOrConnectWithoutUsersInput = {
    where: careerPathsWhereUniqueInput
    create: XOR<careerPathsCreateWithoutUsersInput, careerPathsUncheckedCreateWithoutUsersInput>
  }

  export type careerPathsCreateManyUsersInputEnvelope = {
    data: careerPathsCreateManyUsersInput | careerPathsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type companiesCreateWithoutUsersInput = {
    company_name: string
    company_website?: string | null
    address_street: string
    address_ward: string
    address_city: string
    address_country: string
    email: string
    phone: string
    business_certificate?: string | null
    company_type?: $Enums.Company_Type
    description?: string | null
    logo_url?: string | null
    background_url?: string | null
    employees?: number | null
    is_verified?: boolean
    fax_code?: string | null
    is_deleted?: boolean
    created_at?: Date | string
    updated_at: Date | string
    fields?: fieldsCreateNestedOneWithoutCompaniesInput
    companyLabels?: companyLabelsCreateNestedOneWithoutCompaniesInput
    companyActivitiesHistory?: companyActivitiesHistoryCreateNestedManyWithoutCompaniesInput
    companyNotifications?: companyNotificationsCreateNestedManyWithoutCompaniesInput
    feedbacks?: feedbacksCreateNestedManyWithoutCompaniesInput
    followedCompanies?: followedCompaniesCreateNestedManyWithoutCompaniesInput
  }

  export type companiesUncheckedCreateWithoutUsersInput = {
    company_name: string
    company_website?: string | null
    address_street: string
    address_ward: string
    address_city: string
    address_country: string
    email: string
    phone: string
    business_certificate?: string | null
    company_type?: $Enums.Company_Type
    description?: string | null
    logo_url?: string | null
    background_url?: string | null
    employees?: number | null
    is_verified?: boolean
    fax_code?: string | null
    is_deleted?: boolean
    created_at?: Date | string
    updated_at: Date | string
    field_id?: number | null
    label_id?: number | null
    companyActivitiesHistory?: companyActivitiesHistoryUncheckedCreateNestedManyWithoutCompaniesInput
    companyNotifications?: companyNotificationsUncheckedCreateNestedManyWithoutCompaniesInput
    feedbacks?: feedbacksUncheckedCreateNestedManyWithoutCompaniesInput
    followedCompanies?: followedCompaniesUncheckedCreateNestedManyWithoutCompaniesInput
  }

  export type companiesCreateOrConnectWithoutUsersInput = {
    where: companiesWhereUniqueInput
    create: XOR<companiesCreateWithoutUsersInput, companiesUncheckedCreateWithoutUsersInput>
  }

  export type feedbacksCreateWithoutUsersInput = {
    description: string
    stars: number
    work_environment?: string | null
    benefit?: string | null
    created_at?: Date | string
    companies: companiesCreateNestedOneWithoutFeedbacksInput
  }

  export type feedbacksUncheckedCreateWithoutUsersInput = {
    company_id: string
    description: string
    stars: number
    work_environment?: string | null
    benefit?: string | null
    created_at?: Date | string
  }

  export type feedbacksCreateOrConnectWithoutUsersInput = {
    where: feedbacksWhereUniqueInput
    create: XOR<feedbacksCreateWithoutUsersInput, feedbacksUncheckedCreateWithoutUsersInput>
  }

  export type feedbacksCreateManyUsersInputEnvelope = {
    data: feedbacksCreateManyUsersInput | feedbacksCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type followedCompaniesCreateWithoutUsersInput = {
    followed_at?: Date | string
    is_notified?: boolean
    companies: companiesCreateNestedOneWithoutFollowedCompaniesInput
  }

  export type followedCompaniesUncheckedCreateWithoutUsersInput = {
    company_id: string
    followed_at?: Date | string
    is_notified?: boolean
  }

  export type followedCompaniesCreateOrConnectWithoutUsersInput = {
    where: followedCompaniesWhereUniqueInput
    create: XOR<followedCompaniesCreateWithoutUsersInput, followedCompaniesUncheckedCreateWithoutUsersInput>
  }

  export type followedCompaniesCreateManyUsersInputEnvelope = {
    data: followedCompaniesCreateManyUsersInput | followedCompaniesCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type messagesCreateWithoutUsersInput = {
    id?: number
    message_content?: string | null
    response_content?: string | null
    created_at?: Date | string
  }

  export type messagesUncheckedCreateWithoutUsersInput = {
    id?: number
    message_content?: string | null
    response_content?: string | null
    created_at?: Date | string
  }

  export type messagesCreateOrConnectWithoutUsersInput = {
    where: messagesWhereUniqueInput
    create: XOR<messagesCreateWithoutUsersInput, messagesUncheckedCreateWithoutUsersInput>
  }

  export type messagesCreateManyUsersInputEnvelope = {
    data: messagesCreateManyUsersInput | messagesCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type paymentsCreateWithoutUsersInput = {
    id: string
    amount: bigint | number
    currency?: string | null
    payment_gateway: $Enums.PaymentGateway
    payment_method: $Enums.PaymentMethod
    transaction_id?: string | null
    status: $Enums.PaymentStatus
    created_at?: Date | string
    subscriptions?: subscriptionsCreateNestedOneWithoutPaymentsInput
  }

  export type paymentsUncheckedCreateWithoutUsersInput = {
    id: string
    amount: bigint | number
    currency?: string | null
    payment_gateway: $Enums.PaymentGateway
    payment_method: $Enums.PaymentMethod
    transaction_id?: string | null
    status: $Enums.PaymentStatus
    created_at?: Date | string
    subscriptions?: subscriptionsUncheckedCreateNestedOneWithoutPaymentsInput
  }

  export type paymentsCreateOrConnectWithoutUsersInput = {
    where: paymentsWhereUniqueInput
    create: XOR<paymentsCreateWithoutUsersInput, paymentsUncheckedCreateWithoutUsersInput>
  }

  export type paymentsCreateManyUsersInputEnvelope = {
    data: paymentsCreateManyUsersInput | paymentsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type personalityTestResultsCreateWithoutUsersInput = {
    answers: answersCreateNestedOneWithoutPersonalityTestResultsInput
    questions: questionsCreateNestedOneWithoutPersonalityTestResultsInput
  }

  export type personalityTestResultsUncheckedCreateWithoutUsersInput = {
    question_id: number
    answer_id: number
  }

  export type personalityTestResultsCreateOrConnectWithoutUsersInput = {
    where: personalityTestResultsWhereUniqueInput
    create: XOR<personalityTestResultsCreateWithoutUsersInput, personalityTestResultsUncheckedCreateWithoutUsersInput>
  }

  export type personalityTestResultsCreateManyUsersInputEnvelope = {
    data: personalityTestResultsCreateManyUsersInput | personalityTestResultsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type savedJobsCreateWithoutUsersInput = {
    saved_at?: Date | string
    jobs: jobsCreateNestedOneWithoutSavedJobsInput
  }

  export type savedJobsUncheckedCreateWithoutUsersInput = {
    job_id: string
    saved_at?: Date | string
  }

  export type savedJobsCreateOrConnectWithoutUsersInput = {
    where: savedJobsWhereUniqueInput
    create: XOR<savedJobsCreateWithoutUsersInput, savedJobsUncheckedCreateWithoutUsersInput>
  }

  export type savedJobsCreateManyUsersInputEnvelope = {
    data: savedJobsCreateManyUsersInput | savedJobsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type subscriptionsCreateWithoutUsersInput = {
    id: string
    start_date?: Date | string
    end_date: Date | string
    amount_paid: bigint | number
    is_extended?: boolean
    status?: $Enums.SubscriptionStatus
    payments: paymentsCreateNestedOneWithoutSubscriptionsInput
    membershipPlans: membershipPlansCreateNestedOneWithoutSubscriptionsInput
  }

  export type subscriptionsUncheckedCreateWithoutUsersInput = {
    id: string
    start_date?: Date | string
    end_date: Date | string
    amount_paid: bigint | number
    is_extended?: boolean
    status?: $Enums.SubscriptionStatus
    plan_id: number
    payment_id: string
  }

  export type subscriptionsCreateOrConnectWithoutUsersInput = {
    where: subscriptionsWhereUniqueInput
    create: XOR<subscriptionsCreateWithoutUsersInput, subscriptionsUncheckedCreateWithoutUsersInput>
  }

  export type subscriptionsCreateManyUsersInputEnvelope = {
    data: subscriptionsCreateManyUsersInput | subscriptionsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type userActivitiesHistoryCreateWithoutUsersInput = {
    id?: number
    activity_name: string
    time?: Date | string
  }

  export type userActivitiesHistoryUncheckedCreateWithoutUsersInput = {
    id?: number
    activity_name: string
    time?: Date | string
  }

  export type userActivitiesHistoryCreateOrConnectWithoutUsersInput = {
    where: userActivitiesHistoryWhereUniqueInput
    create: XOR<userActivitiesHistoryCreateWithoutUsersInput, userActivitiesHistoryUncheckedCreateWithoutUsersInput>
  }

  export type userActivitiesHistoryCreateManyUsersInputEnvelope = {
    data: userActivitiesHistoryCreateManyUsersInput | userActivitiesHistoryCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type userNotificationsCreateWithoutUsersInput = {
    id?: number
    title: string
    content?: string | null
    type?: $Enums.NotificationsType
    is_read?: boolean
    sent_at?: Date | string
    read_at?: Date | string | null
  }

  export type userNotificationsUncheckedCreateWithoutUsersInput = {
    id?: number
    title: string
    content?: string | null
    type?: $Enums.NotificationsType
    is_read?: boolean
    sent_at?: Date | string
    read_at?: Date | string | null
  }

  export type userNotificationsCreateOrConnectWithoutUsersInput = {
    where: userNotificationsWhereUniqueInput
    create: XOR<userNotificationsCreateWithoutUsersInput, userNotificationsUncheckedCreateWithoutUsersInput>
  }

  export type userNotificationsCreateManyUsersInputEnvelope = {
    data: userNotificationsCreateManyUsersInput | userNotificationsCreateManyUsersInput[]
    skipDuplicates?: boolean
  }

  export type rolesCreateWithoutUsersInput = {
    role_name: string
  }

  export type rolesUncheckedCreateWithoutUsersInput = {
    id?: number
    role_name: string
  }

  export type rolesCreateOrConnectWithoutUsersInput = {
    where: rolesWhereUniqueInput
    create: XOR<rolesCreateWithoutUsersInput, rolesUncheckedCreateWithoutUsersInput>
  }

  export type blogsUpsertWithWhereUniqueWithoutUsersInput = {
    where: blogsWhereUniqueInput
    update: XOR<blogsUpdateWithoutUsersInput, blogsUncheckedUpdateWithoutUsersInput>
    create: XOR<blogsCreateWithoutUsersInput, blogsUncheckedCreateWithoutUsersInput>
  }

  export type blogsUpdateWithWhereUniqueWithoutUsersInput = {
    where: blogsWhereUniqueInput
    data: XOR<blogsUpdateWithoutUsersInput, blogsUncheckedUpdateWithoutUsersInput>
  }

  export type blogsUpdateManyWithWhereWithoutUsersInput = {
    where: blogsScalarWhereInput
    data: XOR<blogsUpdateManyMutationInput, blogsUncheckedUpdateManyWithoutUsersInput>
  }

  export type blogsScalarWhereInput = {
    AND?: blogsScalarWhereInput | blogsScalarWhereInput[]
    OR?: blogsScalarWhereInput[]
    NOT?: blogsScalarWhereInput | blogsScalarWhereInput[]
    id?: IntFilter<"blogs"> | number
    title?: StringFilter<"blogs"> | string
    cover_image_url?: StringFilter<"blogs"> | string
    description_url?: StringFilter<"blogs"> | string
    created_at?: DateTimeFilter<"blogs"> | Date | string
    updated_at?: DateTimeFilter<"blogs"> | Date | string
    user_id?: StringFilter<"blogs"> | string
  }

  export type careerPathsUpsertWithWhereUniqueWithoutUsersInput = {
    where: careerPathsWhereUniqueInput
    update: XOR<careerPathsUpdateWithoutUsersInput, careerPathsUncheckedUpdateWithoutUsersInput>
    create: XOR<careerPathsCreateWithoutUsersInput, careerPathsUncheckedCreateWithoutUsersInput>
  }

  export type careerPathsUpdateWithWhereUniqueWithoutUsersInput = {
    where: careerPathsWhereUniqueInput
    data: XOR<careerPathsUpdateWithoutUsersInput, careerPathsUncheckedUpdateWithoutUsersInput>
  }

  export type careerPathsUpdateManyWithWhereWithoutUsersInput = {
    where: careerPathsScalarWhereInput
    data: XOR<careerPathsUpdateManyMutationInput, careerPathsUncheckedUpdateManyWithoutUsersInput>
  }

  export type careerPathsScalarWhereInput = {
    AND?: careerPathsScalarWhereInput | careerPathsScalarWhereInput[]
    OR?: careerPathsScalarWhereInput[]
    NOT?: careerPathsScalarWhereInput | careerPathsScalarWhereInput[]
    id?: IntFilter<"careerPaths"> | number
    title?: StringFilter<"careerPaths"> | string
    description?: StringNullableFilter<"careerPaths"> | string | null
    resources?: StringNullableFilter<"careerPaths"> | string | null
    level?: StringNullableFilter<"careerPaths"> | string | null
    estimate_duration?: StringNullableFilter<"careerPaths"> | string | null
    user_id?: StringFilter<"careerPaths"> | string
    jobspecialized_id?: IntFilter<"careerPaths"> | number
  }

  export type companiesUpsertWithoutUsersInput = {
    update: XOR<companiesUpdateWithoutUsersInput, companiesUncheckedUpdateWithoutUsersInput>
    create: XOR<companiesCreateWithoutUsersInput, companiesUncheckedCreateWithoutUsersInput>
    where?: companiesWhereInput
  }

  export type companiesUpdateToOneWithWhereWithoutUsersInput = {
    where?: companiesWhereInput
    data: XOR<companiesUpdateWithoutUsersInput, companiesUncheckedUpdateWithoutUsersInput>
  }

  export type companiesUpdateWithoutUsersInput = {
    company_name?: StringFieldUpdateOperationsInput | string
    company_website?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: StringFieldUpdateOperationsInput | string
    address_ward?: StringFieldUpdateOperationsInput | string
    address_city?: StringFieldUpdateOperationsInput | string
    address_country?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    business_certificate?: NullableStringFieldUpdateOperationsInput | string | null
    company_type?: EnumCompany_TypeFieldUpdateOperationsInput | $Enums.Company_Type
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    background_url?: NullableStringFieldUpdateOperationsInput | string | null
    employees?: NullableIntFieldUpdateOperationsInput | number | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    fax_code?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    fields?: fieldsUpdateOneWithoutCompaniesNestedInput
    companyLabels?: companyLabelsUpdateOneWithoutCompaniesNestedInput
    companyActivitiesHistory?: companyActivitiesHistoryUpdateManyWithoutCompaniesNestedInput
    companyNotifications?: companyNotificationsUpdateManyWithoutCompaniesNestedInput
    feedbacks?: feedbacksUpdateManyWithoutCompaniesNestedInput
    followedCompanies?: followedCompaniesUpdateManyWithoutCompaniesNestedInput
  }

  export type companiesUncheckedUpdateWithoutUsersInput = {
    company_name?: StringFieldUpdateOperationsInput | string
    company_website?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: StringFieldUpdateOperationsInput | string
    address_ward?: StringFieldUpdateOperationsInput | string
    address_city?: StringFieldUpdateOperationsInput | string
    address_country?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    business_certificate?: NullableStringFieldUpdateOperationsInput | string | null
    company_type?: EnumCompany_TypeFieldUpdateOperationsInput | $Enums.Company_Type
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    background_url?: NullableStringFieldUpdateOperationsInput | string | null
    employees?: NullableIntFieldUpdateOperationsInput | number | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    fax_code?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    field_id?: NullableIntFieldUpdateOperationsInput | number | null
    label_id?: NullableIntFieldUpdateOperationsInput | number | null
    companyActivitiesHistory?: companyActivitiesHistoryUncheckedUpdateManyWithoutCompaniesNestedInput
    companyNotifications?: companyNotificationsUncheckedUpdateManyWithoutCompaniesNestedInput
    feedbacks?: feedbacksUncheckedUpdateManyWithoutCompaniesNestedInput
    followedCompanies?: followedCompaniesUncheckedUpdateManyWithoutCompaniesNestedInput
  }

  export type feedbacksUpsertWithWhereUniqueWithoutUsersInput = {
    where: feedbacksWhereUniqueInput
    update: XOR<feedbacksUpdateWithoutUsersInput, feedbacksUncheckedUpdateWithoutUsersInput>
    create: XOR<feedbacksCreateWithoutUsersInput, feedbacksUncheckedCreateWithoutUsersInput>
  }

  export type feedbacksUpdateWithWhereUniqueWithoutUsersInput = {
    where: feedbacksWhereUniqueInput
    data: XOR<feedbacksUpdateWithoutUsersInput, feedbacksUncheckedUpdateWithoutUsersInput>
  }

  export type feedbacksUpdateManyWithWhereWithoutUsersInput = {
    where: feedbacksScalarWhereInput
    data: XOR<feedbacksUpdateManyMutationInput, feedbacksUncheckedUpdateManyWithoutUsersInput>
  }

  export type followedCompaniesUpsertWithWhereUniqueWithoutUsersInput = {
    where: followedCompaniesWhereUniqueInput
    update: XOR<followedCompaniesUpdateWithoutUsersInput, followedCompaniesUncheckedUpdateWithoutUsersInput>
    create: XOR<followedCompaniesCreateWithoutUsersInput, followedCompaniesUncheckedCreateWithoutUsersInput>
  }

  export type followedCompaniesUpdateWithWhereUniqueWithoutUsersInput = {
    where: followedCompaniesWhereUniqueInput
    data: XOR<followedCompaniesUpdateWithoutUsersInput, followedCompaniesUncheckedUpdateWithoutUsersInput>
  }

  export type followedCompaniesUpdateManyWithWhereWithoutUsersInput = {
    where: followedCompaniesScalarWhereInput
    data: XOR<followedCompaniesUpdateManyMutationInput, followedCompaniesUncheckedUpdateManyWithoutUsersInput>
  }

  export type messagesUpsertWithWhereUniqueWithoutUsersInput = {
    where: messagesWhereUniqueInput
    update: XOR<messagesUpdateWithoutUsersInput, messagesUncheckedUpdateWithoutUsersInput>
    create: XOR<messagesCreateWithoutUsersInput, messagesUncheckedCreateWithoutUsersInput>
  }

  export type messagesUpdateWithWhereUniqueWithoutUsersInput = {
    where: messagesWhereUniqueInput
    data: XOR<messagesUpdateWithoutUsersInput, messagesUncheckedUpdateWithoutUsersInput>
  }

  export type messagesUpdateManyWithWhereWithoutUsersInput = {
    where: messagesScalarWhereInput
    data: XOR<messagesUpdateManyMutationInput, messagesUncheckedUpdateManyWithoutUsersInput>
  }

  export type messagesScalarWhereInput = {
    AND?: messagesScalarWhereInput | messagesScalarWhereInput[]
    OR?: messagesScalarWhereInput[]
    NOT?: messagesScalarWhereInput | messagesScalarWhereInput[]
    id?: IntFilter<"messages"> | number
    message_content?: StringNullableFilter<"messages"> | string | null
    response_content?: StringNullableFilter<"messages"> | string | null
    created_at?: DateTimeFilter<"messages"> | Date | string
    user_id?: StringFilter<"messages"> | string
  }

  export type paymentsUpsertWithWhereUniqueWithoutUsersInput = {
    where: paymentsWhereUniqueInput
    update: XOR<paymentsUpdateWithoutUsersInput, paymentsUncheckedUpdateWithoutUsersInput>
    create: XOR<paymentsCreateWithoutUsersInput, paymentsUncheckedCreateWithoutUsersInput>
  }

  export type paymentsUpdateWithWhereUniqueWithoutUsersInput = {
    where: paymentsWhereUniqueInput
    data: XOR<paymentsUpdateWithoutUsersInput, paymentsUncheckedUpdateWithoutUsersInput>
  }

  export type paymentsUpdateManyWithWhereWithoutUsersInput = {
    where: paymentsScalarWhereInput
    data: XOR<paymentsUpdateManyMutationInput, paymentsUncheckedUpdateManyWithoutUsersInput>
  }

  export type paymentsScalarWhereInput = {
    AND?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
    OR?: paymentsScalarWhereInput[]
    NOT?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
    id?: StringFilter<"payments"> | string
    amount?: BigIntFilter<"payments"> | bigint | number
    currency?: StringNullableFilter<"payments"> | string | null
    payment_gateway?: EnumPaymentGatewayFilter<"payments"> | $Enums.PaymentGateway
    payment_method?: EnumPaymentMethodFilter<"payments"> | $Enums.PaymentMethod
    transaction_id?: StringNullableFilter<"payments"> | string | null
    status?: EnumPaymentStatusFilter<"payments"> | $Enums.PaymentStatus
    created_at?: DateTimeFilter<"payments"> | Date | string
    user_id?: StringFilter<"payments"> | string
  }

  export type personalityTestResultsUpsertWithWhereUniqueWithoutUsersInput = {
    where: personalityTestResultsWhereUniqueInput
    update: XOR<personalityTestResultsUpdateWithoutUsersInput, personalityTestResultsUncheckedUpdateWithoutUsersInput>
    create: XOR<personalityTestResultsCreateWithoutUsersInput, personalityTestResultsUncheckedCreateWithoutUsersInput>
  }

  export type personalityTestResultsUpdateWithWhereUniqueWithoutUsersInput = {
    where: personalityTestResultsWhereUniqueInput
    data: XOR<personalityTestResultsUpdateWithoutUsersInput, personalityTestResultsUncheckedUpdateWithoutUsersInput>
  }

  export type personalityTestResultsUpdateManyWithWhereWithoutUsersInput = {
    where: personalityTestResultsScalarWhereInput
    data: XOR<personalityTestResultsUpdateManyMutationInput, personalityTestResultsUncheckedUpdateManyWithoutUsersInput>
  }

  export type savedJobsUpsertWithWhereUniqueWithoutUsersInput = {
    where: savedJobsWhereUniqueInput
    update: XOR<savedJobsUpdateWithoutUsersInput, savedJobsUncheckedUpdateWithoutUsersInput>
    create: XOR<savedJobsCreateWithoutUsersInput, savedJobsUncheckedCreateWithoutUsersInput>
  }

  export type savedJobsUpdateWithWhereUniqueWithoutUsersInput = {
    where: savedJobsWhereUniqueInput
    data: XOR<savedJobsUpdateWithoutUsersInput, savedJobsUncheckedUpdateWithoutUsersInput>
  }

  export type savedJobsUpdateManyWithWhereWithoutUsersInput = {
    where: savedJobsScalarWhereInput
    data: XOR<savedJobsUpdateManyMutationInput, savedJobsUncheckedUpdateManyWithoutUsersInput>
  }

  export type subscriptionsUpsertWithWhereUniqueWithoutUsersInput = {
    where: subscriptionsWhereUniqueInput
    update: XOR<subscriptionsUpdateWithoutUsersInput, subscriptionsUncheckedUpdateWithoutUsersInput>
    create: XOR<subscriptionsCreateWithoutUsersInput, subscriptionsUncheckedCreateWithoutUsersInput>
  }

  export type subscriptionsUpdateWithWhereUniqueWithoutUsersInput = {
    where: subscriptionsWhereUniqueInput
    data: XOR<subscriptionsUpdateWithoutUsersInput, subscriptionsUncheckedUpdateWithoutUsersInput>
  }

  export type subscriptionsUpdateManyWithWhereWithoutUsersInput = {
    where: subscriptionsScalarWhereInput
    data: XOR<subscriptionsUpdateManyMutationInput, subscriptionsUncheckedUpdateManyWithoutUsersInput>
  }

  export type userActivitiesHistoryUpsertWithWhereUniqueWithoutUsersInput = {
    where: userActivitiesHistoryWhereUniqueInput
    update: XOR<userActivitiesHistoryUpdateWithoutUsersInput, userActivitiesHistoryUncheckedUpdateWithoutUsersInput>
    create: XOR<userActivitiesHistoryCreateWithoutUsersInput, userActivitiesHistoryUncheckedCreateWithoutUsersInput>
  }

  export type userActivitiesHistoryUpdateWithWhereUniqueWithoutUsersInput = {
    where: userActivitiesHistoryWhereUniqueInput
    data: XOR<userActivitiesHistoryUpdateWithoutUsersInput, userActivitiesHistoryUncheckedUpdateWithoutUsersInput>
  }

  export type userActivitiesHistoryUpdateManyWithWhereWithoutUsersInput = {
    where: userActivitiesHistoryScalarWhereInput
    data: XOR<userActivitiesHistoryUpdateManyMutationInput, userActivitiesHistoryUncheckedUpdateManyWithoutUsersInput>
  }

  export type userActivitiesHistoryScalarWhereInput = {
    AND?: userActivitiesHistoryScalarWhereInput | userActivitiesHistoryScalarWhereInput[]
    OR?: userActivitiesHistoryScalarWhereInput[]
    NOT?: userActivitiesHistoryScalarWhereInput | userActivitiesHistoryScalarWhereInput[]
    id?: IntFilter<"userActivitiesHistory"> | number
    activity_name?: StringFilter<"userActivitiesHistory"> | string
    time?: DateTimeFilter<"userActivitiesHistory"> | Date | string
    user_id?: StringFilter<"userActivitiesHistory"> | string
  }

  export type userNotificationsUpsertWithWhereUniqueWithoutUsersInput = {
    where: userNotificationsWhereUniqueInput
    update: XOR<userNotificationsUpdateWithoutUsersInput, userNotificationsUncheckedUpdateWithoutUsersInput>
    create: XOR<userNotificationsCreateWithoutUsersInput, userNotificationsUncheckedCreateWithoutUsersInput>
  }

  export type userNotificationsUpdateWithWhereUniqueWithoutUsersInput = {
    where: userNotificationsWhereUniqueInput
    data: XOR<userNotificationsUpdateWithoutUsersInput, userNotificationsUncheckedUpdateWithoutUsersInput>
  }

  export type userNotificationsUpdateManyWithWhereWithoutUsersInput = {
    where: userNotificationsScalarWhereInput
    data: XOR<userNotificationsUpdateManyMutationInput, userNotificationsUncheckedUpdateManyWithoutUsersInput>
  }

  export type userNotificationsScalarWhereInput = {
    AND?: userNotificationsScalarWhereInput | userNotificationsScalarWhereInput[]
    OR?: userNotificationsScalarWhereInput[]
    NOT?: userNotificationsScalarWhereInput | userNotificationsScalarWhereInput[]
    id?: IntFilter<"userNotifications"> | number
    user_id?: StringFilter<"userNotifications"> | string
    title?: StringFilter<"userNotifications"> | string
    content?: StringNullableFilter<"userNotifications"> | string | null
    type?: EnumNotificationsTypeFilter<"userNotifications"> | $Enums.NotificationsType
    is_read?: BoolFilter<"userNotifications"> | boolean
    sent_at?: DateTimeFilter<"userNotifications"> | Date | string
    read_at?: DateTimeNullableFilter<"userNotifications"> | Date | string | null
  }

  export type rolesUpsertWithoutUsersInput = {
    update: XOR<rolesUpdateWithoutUsersInput, rolesUncheckedUpdateWithoutUsersInput>
    create: XOR<rolesCreateWithoutUsersInput, rolesUncheckedCreateWithoutUsersInput>
    where?: rolesWhereInput
  }

  export type rolesUpdateToOneWithWhereWithoutUsersInput = {
    where?: rolesWhereInput
    data: XOR<rolesUpdateWithoutUsersInput, rolesUncheckedUpdateWithoutUsersInput>
  }

  export type rolesUpdateWithoutUsersInput = {
    role_name?: StringFieldUpdateOperationsInput | string
  }

  export type rolesUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    role_name?: StringFieldUpdateOperationsInput | string
  }

  export type personalityTestResultsCreateManyAnswersInput = {
    user_id: string
    question_id: number
  }

  export type personalityTestResultsUpdateWithoutAnswersInput = {
    questions?: questionsUpdateOneRequiredWithoutPersonalityTestResultsNestedInput
    users?: usersUpdateOneRequiredWithoutPersonalityTestResultsNestedInput
  }

  export type personalityTestResultsUncheckedUpdateWithoutAnswersInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    question_id?: IntFieldUpdateOperationsInput | number
  }

  export type personalityTestResultsUncheckedUpdateManyWithoutAnswersInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    question_id?: IntFieldUpdateOperationsInput | number
  }

  export type careerPathStepsCreateManyCareerPathsInput = {
    id?: number
    title: string
    description?: string | null
    resources?: string | null
  }

  export type careerPathStepsUpdateWithoutCareerPathsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resources?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type careerPathStepsUncheckedUpdateWithoutCareerPathsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resources?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type careerPathStepsUncheckedUpdateManyWithoutCareerPathsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resources?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type jobsCreateManyCategoriesInput = {
    id: string
    job_title: string
    description: string
    location?: string | null
    benefit?: string | null
    working_time?: string | null
    salary?: jobsCreatesalaryInput | string[]
    currency?: string | null
    job_type?: $Enums.Job_Type | null
    status?: $Enums.Job_Status | null
    job_level: string
    quantity?: number | null
    skill_tags?: jobsCreateskill_tagsInput | string[]
    education?: $Enums.Education | null
    experience?: string | null
    start_date?: Date | string
    end_date?: Date | string | null
    created_at?: Date | string
    updated_at: Date | string
    label_id?: number | null
  }

  export type jobsUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    job_title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    benefit?: NullableStringFieldUpdateOperationsInput | string | null
    working_time?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: jobsUpdatesalaryInput | string[]
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    job_type?: NullableEnumJob_TypeFieldUpdateOperationsInput | $Enums.Job_Type | null
    status?: NullableEnumJob_StatusFieldUpdateOperationsInput | $Enums.Job_Status | null
    job_level?: StringFieldUpdateOperationsInput | string
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    skill_tags?: jobsUpdateskill_tagsInput | string[]
    education?: NullableEnumEducationFieldUpdateOperationsInput | $Enums.Education | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    applicants?: applicantsUpdateManyWithoutJobsNestedInput
    jobLabels?: jobLabelsUpdateOneWithoutJobsNestedInput
    savedJobs?: savedJobsUpdateManyWithoutJobsNestedInput
  }

  export type jobsUncheckedUpdateWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    job_title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    benefit?: NullableStringFieldUpdateOperationsInput | string | null
    working_time?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: jobsUpdatesalaryInput | string[]
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    job_type?: NullableEnumJob_TypeFieldUpdateOperationsInput | $Enums.Job_Type | null
    status?: NullableEnumJob_StatusFieldUpdateOperationsInput | $Enums.Job_Status | null
    job_level?: StringFieldUpdateOperationsInput | string
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    skill_tags?: jobsUpdateskill_tagsInput | string[]
    education?: NullableEnumEducationFieldUpdateOperationsInput | $Enums.Education | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    label_id?: NullableIntFieldUpdateOperationsInput | number | null
    applicants?: applicantsUncheckedUpdateManyWithoutJobsNestedInput
    savedJobs?: savedJobsUncheckedUpdateManyWithoutJobsNestedInput
  }

  export type jobsUncheckedUpdateManyWithoutCategoriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    job_title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    benefit?: NullableStringFieldUpdateOperationsInput | string | null
    working_time?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: jobsUpdatesalaryInput | string[]
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    job_type?: NullableEnumJob_TypeFieldUpdateOperationsInput | $Enums.Job_Type | null
    status?: NullableEnumJob_StatusFieldUpdateOperationsInput | $Enums.Job_Status | null
    job_level?: StringFieldUpdateOperationsInput | string
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    skill_tags?: jobsUpdateskill_tagsInput | string[]
    education?: NullableEnumEducationFieldUpdateOperationsInput | $Enums.Education | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    label_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type companyActivitiesHistoryCreateManyCompaniesInput = {
    id?: number
    activity_name: string
    time?: Date | string
  }

  export type companyNotificationsCreateManyCompaniesInput = {
    id?: number
    title: string
    content?: string | null
    type?: $Enums.NotificationsType
    is_read?: boolean
    sent_at?: Date | string
    read_at?: Date | string | null
  }

  export type feedbacksCreateManyCompaniesInput = {
    user_id: string
    description: string
    stars: number
    work_environment?: string | null
    benefit?: string | null
    created_at?: Date | string
  }

  export type followedCompaniesCreateManyCompaniesInput = {
    user_id: string
    followed_at?: Date | string
    is_notified?: boolean
  }

  export type companyActivitiesHistoryUpdateWithoutCompaniesInput = {
    id?: IntFieldUpdateOperationsInput | number
    activity_name?: StringFieldUpdateOperationsInput | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type companyActivitiesHistoryUncheckedUpdateWithoutCompaniesInput = {
    id?: IntFieldUpdateOperationsInput | number
    activity_name?: StringFieldUpdateOperationsInput | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type companyActivitiesHistoryUncheckedUpdateManyWithoutCompaniesInput = {
    id?: IntFieldUpdateOperationsInput | number
    activity_name?: StringFieldUpdateOperationsInput | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type companyNotificationsUpdateWithoutCompaniesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationsTypeFieldUpdateOperationsInput | $Enums.NotificationsType
    is_read?: BoolFieldUpdateOperationsInput | boolean
    sent_at?: DateTimeFieldUpdateOperationsInput | Date | string
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type companyNotificationsUncheckedUpdateWithoutCompaniesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationsTypeFieldUpdateOperationsInput | $Enums.NotificationsType
    is_read?: BoolFieldUpdateOperationsInput | boolean
    sent_at?: DateTimeFieldUpdateOperationsInput | Date | string
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type companyNotificationsUncheckedUpdateManyWithoutCompaniesInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationsTypeFieldUpdateOperationsInput | $Enums.NotificationsType
    is_read?: BoolFieldUpdateOperationsInput | boolean
    sent_at?: DateTimeFieldUpdateOperationsInput | Date | string
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type feedbacksUpdateWithoutCompaniesInput = {
    description?: StringFieldUpdateOperationsInput | string
    stars?: FloatFieldUpdateOperationsInput | number
    work_environment?: NullableStringFieldUpdateOperationsInput | string | null
    benefit?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutFeedbacksNestedInput
  }

  export type feedbacksUncheckedUpdateWithoutCompaniesInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    stars?: FloatFieldUpdateOperationsInput | number
    work_environment?: NullableStringFieldUpdateOperationsInput | string | null
    benefit?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type feedbacksUncheckedUpdateManyWithoutCompaniesInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    stars?: FloatFieldUpdateOperationsInput | number
    work_environment?: NullableStringFieldUpdateOperationsInput | string | null
    benefit?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type followedCompaniesUpdateWithoutCompaniesInput = {
    followed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_notified?: BoolFieldUpdateOperationsInput | boolean
    users?: usersUpdateOneRequiredWithoutFollowedCompaniesNestedInput
  }

  export type followedCompaniesUncheckedUpdateWithoutCompaniesInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    followed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_notified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type followedCompaniesUncheckedUpdateManyWithoutCompaniesInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    followed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_notified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type companiesCreateManyCompanyLabelsInput = {
    id: string
    company_name: string
    company_website?: string | null
    address_street: string
    address_ward: string
    address_city: string
    address_country: string
    email: string
    phone: string
    business_certificate?: string | null
    company_type?: $Enums.Company_Type
    description?: string | null
    logo_url?: string | null
    background_url?: string | null
    employees?: number | null
    is_verified?: boolean
    fax_code?: string | null
    is_deleted?: boolean
    created_at?: Date | string
    updated_at: Date | string
    field_id?: number | null
  }

  export type companiesUpdateWithoutCompanyLabelsInput = {
    company_name?: StringFieldUpdateOperationsInput | string
    company_website?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: StringFieldUpdateOperationsInput | string
    address_ward?: StringFieldUpdateOperationsInput | string
    address_city?: StringFieldUpdateOperationsInput | string
    address_country?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    business_certificate?: NullableStringFieldUpdateOperationsInput | string | null
    company_type?: EnumCompany_TypeFieldUpdateOperationsInput | $Enums.Company_Type
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    background_url?: NullableStringFieldUpdateOperationsInput | string | null
    employees?: NullableIntFieldUpdateOperationsInput | number | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    fax_code?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    fields?: fieldsUpdateOneWithoutCompaniesNestedInput
    users?: usersUpdateOneRequiredWithoutCompaniesNestedInput
    companyActivitiesHistory?: companyActivitiesHistoryUpdateManyWithoutCompaniesNestedInput
    companyNotifications?: companyNotificationsUpdateManyWithoutCompaniesNestedInput
    feedbacks?: feedbacksUpdateManyWithoutCompaniesNestedInput
    followedCompanies?: followedCompaniesUpdateManyWithoutCompaniesNestedInput
  }

  export type companiesUncheckedUpdateWithoutCompanyLabelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    company_name?: StringFieldUpdateOperationsInput | string
    company_website?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: StringFieldUpdateOperationsInput | string
    address_ward?: StringFieldUpdateOperationsInput | string
    address_city?: StringFieldUpdateOperationsInput | string
    address_country?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    business_certificate?: NullableStringFieldUpdateOperationsInput | string | null
    company_type?: EnumCompany_TypeFieldUpdateOperationsInput | $Enums.Company_Type
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    background_url?: NullableStringFieldUpdateOperationsInput | string | null
    employees?: NullableIntFieldUpdateOperationsInput | number | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    fax_code?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    field_id?: NullableIntFieldUpdateOperationsInput | number | null
    companyActivitiesHistory?: companyActivitiesHistoryUncheckedUpdateManyWithoutCompaniesNestedInput
    companyNotifications?: companyNotificationsUncheckedUpdateManyWithoutCompaniesNestedInput
    feedbacks?: feedbacksUncheckedUpdateManyWithoutCompaniesNestedInput
    followedCompanies?: followedCompaniesUncheckedUpdateManyWithoutCompaniesNestedInput
  }

  export type companiesUncheckedUpdateManyWithoutCompanyLabelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    company_name?: StringFieldUpdateOperationsInput | string
    company_website?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: StringFieldUpdateOperationsInput | string
    address_ward?: StringFieldUpdateOperationsInput | string
    address_city?: StringFieldUpdateOperationsInput | string
    address_country?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    business_certificate?: NullableStringFieldUpdateOperationsInput | string | null
    company_type?: EnumCompany_TypeFieldUpdateOperationsInput | $Enums.Company_Type
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    background_url?: NullableStringFieldUpdateOperationsInput | string | null
    employees?: NullableIntFieldUpdateOperationsInput | number | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    fax_code?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    field_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type applicantsCreateManyCvsInput = {
    job_id: string
    description?: string | null
    apply_date?: Date | string
    verified_date: Date | string
    status?: $Enums.ApplicantsStatus
    feedback?: string | null
  }

  export type awardsCreateManyCvsInput = {
    id?: number
    title: string
    description?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
  }

  export type certificatesCreateManyCvsInput = {
    id?: number
    title: string
    link?: string | null
    description?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
  }

  export type educationsCreateManyCvsInput = {
    id?: number
    school: string
    graduated_type?: string | null
    gpa?: number | null
    start_date?: Date | string | null
    end_date?: Date | string | null
  }

  export type experiencesCreateManyCvsInput = {
    id?: number
    company_name?: string | null
    title?: string | null
    description?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
  }

  export type projectsCreateManyCvsInput = {
    id?: number
    title: string
    description?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
  }

  export type referencesCreateManyCvsInput = {
    id?: number
    name: string
    phone?: string | null
    email?: string | null
  }

  export type applicantsUpdateWithoutCvsInput = {
    description?: NullableStringFieldUpdateOperationsInput | string | null
    apply_date?: DateTimeFieldUpdateOperationsInput | Date | string
    verified_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumApplicantsStatusFieldUpdateOperationsInput | $Enums.ApplicantsStatus
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    jobs?: jobsUpdateOneRequiredWithoutApplicantsNestedInput
  }

  export type applicantsUncheckedUpdateWithoutCvsInput = {
    job_id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    apply_date?: DateTimeFieldUpdateOperationsInput | Date | string
    verified_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumApplicantsStatusFieldUpdateOperationsInput | $Enums.ApplicantsStatus
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type applicantsUncheckedUpdateManyWithoutCvsInput = {
    job_id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    apply_date?: DateTimeFieldUpdateOperationsInput | Date | string
    verified_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumApplicantsStatusFieldUpdateOperationsInput | $Enums.ApplicantsStatus
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type awardsUpdateWithoutCvsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type awardsUncheckedUpdateWithoutCvsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type awardsUncheckedUpdateManyWithoutCvsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type certificatesUpdateWithoutCvsInput = {
    title?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type certificatesUncheckedUpdateWithoutCvsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type certificatesUncheckedUpdateManyWithoutCvsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    link?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type educationsUpdateWithoutCvsInput = {
    school?: StringFieldUpdateOperationsInput | string
    graduated_type?: NullableStringFieldUpdateOperationsInput | string | null
    gpa?: NullableFloatFieldUpdateOperationsInput | number | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type educationsUncheckedUpdateWithoutCvsInput = {
    id?: IntFieldUpdateOperationsInput | number
    school?: StringFieldUpdateOperationsInput | string
    graduated_type?: NullableStringFieldUpdateOperationsInput | string | null
    gpa?: NullableFloatFieldUpdateOperationsInput | number | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type educationsUncheckedUpdateManyWithoutCvsInput = {
    id?: IntFieldUpdateOperationsInput | number
    school?: StringFieldUpdateOperationsInput | string
    graduated_type?: NullableStringFieldUpdateOperationsInput | string | null
    gpa?: NullableFloatFieldUpdateOperationsInput | number | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type experiencesUpdateWithoutCvsInput = {
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type experiencesUncheckedUpdateWithoutCvsInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type experiencesUncheckedUpdateManyWithoutCvsInput = {
    id?: IntFieldUpdateOperationsInput | number
    company_name?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type projectsUpdateWithoutCvsInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type projectsUncheckedUpdateWithoutCvsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type projectsUncheckedUpdateManyWithoutCvsInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type referencesUpdateWithoutCvsInput = {
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type referencesUncheckedUpdateWithoutCvsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type referencesUncheckedUpdateManyWithoutCvsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type companiesCreateManyFieldsInput = {
    id: string
    company_name: string
    company_website?: string | null
    address_street: string
    address_ward: string
    address_city: string
    address_country: string
    email: string
    phone: string
    business_certificate?: string | null
    company_type?: $Enums.Company_Type
    description?: string | null
    logo_url?: string | null
    background_url?: string | null
    employees?: number | null
    is_verified?: boolean
    fax_code?: string | null
    is_deleted?: boolean
    created_at?: Date | string
    updated_at: Date | string
    label_id?: number | null
  }

  export type companiesUpdateWithoutFieldsInput = {
    company_name?: StringFieldUpdateOperationsInput | string
    company_website?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: StringFieldUpdateOperationsInput | string
    address_ward?: StringFieldUpdateOperationsInput | string
    address_city?: StringFieldUpdateOperationsInput | string
    address_country?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    business_certificate?: NullableStringFieldUpdateOperationsInput | string | null
    company_type?: EnumCompany_TypeFieldUpdateOperationsInput | $Enums.Company_Type
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    background_url?: NullableStringFieldUpdateOperationsInput | string | null
    employees?: NullableIntFieldUpdateOperationsInput | number | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    fax_code?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutCompaniesNestedInput
    companyLabels?: companyLabelsUpdateOneWithoutCompaniesNestedInput
    companyActivitiesHistory?: companyActivitiesHistoryUpdateManyWithoutCompaniesNestedInput
    companyNotifications?: companyNotificationsUpdateManyWithoutCompaniesNestedInput
    feedbacks?: feedbacksUpdateManyWithoutCompaniesNestedInput
    followedCompanies?: followedCompaniesUpdateManyWithoutCompaniesNestedInput
  }

  export type companiesUncheckedUpdateWithoutFieldsInput = {
    id?: StringFieldUpdateOperationsInput | string
    company_name?: StringFieldUpdateOperationsInput | string
    company_website?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: StringFieldUpdateOperationsInput | string
    address_ward?: StringFieldUpdateOperationsInput | string
    address_city?: StringFieldUpdateOperationsInput | string
    address_country?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    business_certificate?: NullableStringFieldUpdateOperationsInput | string | null
    company_type?: EnumCompany_TypeFieldUpdateOperationsInput | $Enums.Company_Type
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    background_url?: NullableStringFieldUpdateOperationsInput | string | null
    employees?: NullableIntFieldUpdateOperationsInput | number | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    fax_code?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    label_id?: NullableIntFieldUpdateOperationsInput | number | null
    companyActivitiesHistory?: companyActivitiesHistoryUncheckedUpdateManyWithoutCompaniesNestedInput
    companyNotifications?: companyNotificationsUncheckedUpdateManyWithoutCompaniesNestedInput
    feedbacks?: feedbacksUncheckedUpdateManyWithoutCompaniesNestedInput
    followedCompanies?: followedCompaniesUncheckedUpdateManyWithoutCompaniesNestedInput
  }

  export type companiesUncheckedUpdateManyWithoutFieldsInput = {
    id?: StringFieldUpdateOperationsInput | string
    company_name?: StringFieldUpdateOperationsInput | string
    company_website?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: StringFieldUpdateOperationsInput | string
    address_ward?: StringFieldUpdateOperationsInput | string
    address_city?: StringFieldUpdateOperationsInput | string
    address_country?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    business_certificate?: NullableStringFieldUpdateOperationsInput | string | null
    company_type?: EnumCompany_TypeFieldUpdateOperationsInput | $Enums.Company_Type
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo_url?: NullableStringFieldUpdateOperationsInput | string | null
    background_url?: NullableStringFieldUpdateOperationsInput | string | null
    employees?: NullableIntFieldUpdateOperationsInput | number | null
    is_verified?: BoolFieldUpdateOperationsInput | boolean
    fax_code?: NullableStringFieldUpdateOperationsInput | string | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    label_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type jobSpecializedCreateManyJobCategoriesInput = {
    id?: number
    job_type: string
    description?: string | null
  }

  export type jobSpecializedUpdateWithoutJobCategoriesInput = {
    job_type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    careerPaths?: careerPathsUpdateOneWithoutJobSpecializedNestedInput
  }

  export type jobSpecializedUncheckedUpdateWithoutJobCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    job_type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    careerPaths?: careerPathsUncheckedUpdateOneWithoutJobSpecializedNestedInput
  }

  export type jobSpecializedUncheckedUpdateManyWithoutJobCategoriesInput = {
    id?: IntFieldUpdateOperationsInput | number
    job_type?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type jobsCreateManyJobLabelsInput = {
    id: string
    job_title: string
    description: string
    location?: string | null
    benefit?: string | null
    working_time?: string | null
    salary?: jobsCreatesalaryInput | string[]
    currency?: string | null
    job_type?: $Enums.Job_Type | null
    status?: $Enums.Job_Status | null
    job_level: string
    quantity?: number | null
    skill_tags?: jobsCreateskill_tagsInput | string[]
    education?: $Enums.Education | null
    experience?: string | null
    start_date?: Date | string
    end_date?: Date | string | null
    created_at?: Date | string
    updated_at: Date | string
    category_id?: number | null
  }

  export type jobsUpdateWithoutJobLabelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    job_title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    benefit?: NullableStringFieldUpdateOperationsInput | string | null
    working_time?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: jobsUpdatesalaryInput | string[]
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    job_type?: NullableEnumJob_TypeFieldUpdateOperationsInput | $Enums.Job_Type | null
    status?: NullableEnumJob_StatusFieldUpdateOperationsInput | $Enums.Job_Status | null
    job_level?: StringFieldUpdateOperationsInput | string
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    skill_tags?: jobsUpdateskill_tagsInput | string[]
    education?: NullableEnumEducationFieldUpdateOperationsInput | $Enums.Education | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    applicants?: applicantsUpdateManyWithoutJobsNestedInput
    categories?: categoriesUpdateOneWithoutJobsNestedInput
    savedJobs?: savedJobsUpdateManyWithoutJobsNestedInput
  }

  export type jobsUncheckedUpdateWithoutJobLabelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    job_title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    benefit?: NullableStringFieldUpdateOperationsInput | string | null
    working_time?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: jobsUpdatesalaryInput | string[]
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    job_type?: NullableEnumJob_TypeFieldUpdateOperationsInput | $Enums.Job_Type | null
    status?: NullableEnumJob_StatusFieldUpdateOperationsInput | $Enums.Job_Status | null
    job_level?: StringFieldUpdateOperationsInput | string
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    skill_tags?: jobsUpdateskill_tagsInput | string[]
    education?: NullableEnumEducationFieldUpdateOperationsInput | $Enums.Education | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
    applicants?: applicantsUncheckedUpdateManyWithoutJobsNestedInput
    savedJobs?: savedJobsUncheckedUpdateManyWithoutJobsNestedInput
  }

  export type jobsUncheckedUpdateManyWithoutJobLabelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    job_title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    benefit?: NullableStringFieldUpdateOperationsInput | string | null
    working_time?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: jobsUpdatesalaryInput | string[]
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    job_type?: NullableEnumJob_TypeFieldUpdateOperationsInput | $Enums.Job_Type | null
    status?: NullableEnumJob_StatusFieldUpdateOperationsInput | $Enums.Job_Status | null
    job_level?: StringFieldUpdateOperationsInput | string
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    skill_tags?: jobsUpdateskill_tagsInput | string[]
    education?: NullableEnumEducationFieldUpdateOperationsInput | $Enums.Education | null
    experience?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    category_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type applicantsCreateManyJobsInput = {
    cv_id: number
    description?: string | null
    apply_date?: Date | string
    verified_date: Date | string
    status?: $Enums.ApplicantsStatus
    feedback?: string | null
  }

  export type savedJobsCreateManyJobsInput = {
    user_id: string
    saved_at?: Date | string
  }

  export type applicantsUpdateWithoutJobsInput = {
    description?: NullableStringFieldUpdateOperationsInput | string | null
    apply_date?: DateTimeFieldUpdateOperationsInput | Date | string
    verified_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumApplicantsStatusFieldUpdateOperationsInput | $Enums.ApplicantsStatus
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    cvs?: cvsUpdateOneRequiredWithoutApplicantsNestedInput
  }

  export type applicantsUncheckedUpdateWithoutJobsInput = {
    cv_id?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    apply_date?: DateTimeFieldUpdateOperationsInput | Date | string
    verified_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumApplicantsStatusFieldUpdateOperationsInput | $Enums.ApplicantsStatus
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type applicantsUncheckedUpdateManyWithoutJobsInput = {
    cv_id?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    apply_date?: DateTimeFieldUpdateOperationsInput | Date | string
    verified_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumApplicantsStatusFieldUpdateOperationsInput | $Enums.ApplicantsStatus
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type savedJobsUpdateWithoutJobsInput = {
    saved_at?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: usersUpdateOneRequiredWithoutSavedJobsNestedInput
  }

  export type savedJobsUncheckedUpdateWithoutJobsInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    saved_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type savedJobsUncheckedUpdateManyWithoutJobsInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    saved_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type featuresCreateManyMembershipPlansInput = {
    id?: number
    feature_name: string
    description?: string | null
  }

  export type subscriptionsCreateManyMembershipPlansInput = {
    id: string
    start_date?: Date | string
    end_date: Date | string
    amount_paid: bigint | number
    is_extended?: boolean
    status?: $Enums.SubscriptionStatus
    user_id: string
    payment_id: string
  }

  export type featuresUpdateWithoutMembershipPlansInput = {
    feature_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type featuresUncheckedUpdateWithoutMembershipPlansInput = {
    id?: IntFieldUpdateOperationsInput | number
    feature_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type featuresUncheckedUpdateManyWithoutMembershipPlansInput = {
    id?: IntFieldUpdateOperationsInput | number
    feature_name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type subscriptionsUpdateWithoutMembershipPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount_paid?: BigIntFieldUpdateOperationsInput | bigint | number
    is_extended?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    payments?: paymentsUpdateOneRequiredWithoutSubscriptionsNestedInput
    users?: usersUpdateOneRequiredWithoutSubscriptionsNestedInput
  }

  export type subscriptionsUncheckedUpdateWithoutMembershipPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount_paid?: BigIntFieldUpdateOperationsInput | bigint | number
    is_extended?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    user_id?: StringFieldUpdateOperationsInput | string
    payment_id?: StringFieldUpdateOperationsInput | string
  }

  export type subscriptionsUncheckedUpdateManyWithoutMembershipPlansInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount_paid?: BigIntFieldUpdateOperationsInput | bigint | number
    is_extended?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    user_id?: StringFieldUpdateOperationsInput | string
    payment_id?: StringFieldUpdateOperationsInput | string
  }

  export type answersCreateManyQuestionsInput = {
    id?: number
    answer: string
  }

  export type personalityTestResultsCreateManyQuestionsInput = {
    user_id: string
    answer_id: number
  }

  export type answersUpdateWithoutQuestionsInput = {
    answer?: StringFieldUpdateOperationsInput | string
    personalityTestResults?: personalityTestResultsUpdateManyWithoutAnswersNestedInput
  }

  export type answersUncheckedUpdateWithoutQuestionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    answer?: StringFieldUpdateOperationsInput | string
    personalityTestResults?: personalityTestResultsUncheckedUpdateManyWithoutAnswersNestedInput
  }

  export type answersUncheckedUpdateManyWithoutQuestionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    answer?: StringFieldUpdateOperationsInput | string
  }

  export type personalityTestResultsUpdateWithoutQuestionsInput = {
    answers?: answersUpdateOneRequiredWithoutPersonalityTestResultsNestedInput
    users?: usersUpdateOneRequiredWithoutPersonalityTestResultsNestedInput
  }

  export type personalityTestResultsUncheckedUpdateWithoutQuestionsInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    answer_id?: IntFieldUpdateOperationsInput | number
  }

  export type personalityTestResultsUncheckedUpdateManyWithoutQuestionsInput = {
    user_id?: StringFieldUpdateOperationsInput | string
    answer_id?: IntFieldUpdateOperationsInput | number
  }

  export type usersCreateManyRolesInput = {
    id: string
    username: string
    password: string
    avatar_url?: string | null
    email: string
    phone?: string | null
    address_street?: string | null
    address_ward?: string | null
    address_city?: string | null
    address_country?: string | null
    gender?: $Enums.Gender | null
    is_deleted?: boolean
    created_at?: Date | string
    updated_at: Date | string
  }

  export type usersUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: NullableStringFieldUpdateOperationsInput | string | null
    address_ward?: NullableStringFieldUpdateOperationsInput | string | null
    address_city?: NullableStringFieldUpdateOperationsInput | string | null
    address_country?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    blogs?: blogsUpdateManyWithoutUsersNestedInput
    careerPaths?: careerPathsUpdateManyWithoutUsersNestedInput
    companies?: companiesUpdateOneWithoutUsersNestedInput
    feedbacks?: feedbacksUpdateManyWithoutUsersNestedInput
    followedCompanies?: followedCompaniesUpdateManyWithoutUsersNestedInput
    messages?: messagesUpdateManyWithoutUsersNestedInput
    payments?: paymentsUpdateManyWithoutUsersNestedInput
    personalityTestResults?: personalityTestResultsUpdateManyWithoutUsersNestedInput
    savedJobs?: savedJobsUpdateManyWithoutUsersNestedInput
    subscriptions?: subscriptionsUpdateManyWithoutUsersNestedInput
    userActivitiesHistory?: userActivitiesHistoryUpdateManyWithoutUsersNestedInput
    userNotifications?: userNotificationsUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: NullableStringFieldUpdateOperationsInput | string | null
    address_ward?: NullableStringFieldUpdateOperationsInput | string | null
    address_city?: NullableStringFieldUpdateOperationsInput | string | null
    address_country?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    blogs?: blogsUncheckedUpdateManyWithoutUsersNestedInput
    careerPaths?: careerPathsUncheckedUpdateManyWithoutUsersNestedInput
    companies?: companiesUncheckedUpdateOneWithoutUsersNestedInput
    feedbacks?: feedbacksUncheckedUpdateManyWithoutUsersNestedInput
    followedCompanies?: followedCompaniesUncheckedUpdateManyWithoutUsersNestedInput
    messages?: messagesUncheckedUpdateManyWithoutUsersNestedInput
    payments?: paymentsUncheckedUpdateManyWithoutUsersNestedInput
    personalityTestResults?: personalityTestResultsUncheckedUpdateManyWithoutUsersNestedInput
    savedJobs?: savedJobsUncheckedUpdateManyWithoutUsersNestedInput
    subscriptions?: subscriptionsUncheckedUpdateManyWithoutUsersNestedInput
    userActivitiesHistory?: userActivitiesHistoryUncheckedUpdateManyWithoutUsersNestedInput
    userNotifications?: userNotificationsUncheckedUpdateManyWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateManyWithoutRolesInput = {
    id?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address_street?: NullableStringFieldUpdateOperationsInput | string | null
    address_ward?: NullableStringFieldUpdateOperationsInput | string | null
    address_city?: NullableStringFieldUpdateOperationsInput | string | null
    address_country?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    is_deleted?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type blogsCreateManyUsersInput = {
    id?: number
    title: string
    cover_image_url: string
    description_url: string
    created_at?: Date | string
    updated_at: Date | string
  }

  export type careerPathsCreateManyUsersInput = {
    id?: number
    title: string
    description?: string | null
    resources?: string | null
    level?: string | null
    estimate_duration?: string | null
    jobspecialized_id: number
  }

  export type feedbacksCreateManyUsersInput = {
    company_id: string
    description: string
    stars: number
    work_environment?: string | null
    benefit?: string | null
    created_at?: Date | string
  }

  export type followedCompaniesCreateManyUsersInput = {
    company_id: string
    followed_at?: Date | string
    is_notified?: boolean
  }

  export type messagesCreateManyUsersInput = {
    id?: number
    message_content?: string | null
    response_content?: string | null
    created_at?: Date | string
  }

  export type paymentsCreateManyUsersInput = {
    id: string
    amount: bigint | number
    currency?: string | null
    payment_gateway: $Enums.PaymentGateway
    payment_method: $Enums.PaymentMethod
    transaction_id?: string | null
    status: $Enums.PaymentStatus
    created_at?: Date | string
  }

  export type personalityTestResultsCreateManyUsersInput = {
    question_id: number
    answer_id: number
  }

  export type savedJobsCreateManyUsersInput = {
    job_id: string
    saved_at?: Date | string
  }

  export type subscriptionsCreateManyUsersInput = {
    id: string
    start_date?: Date | string
    end_date: Date | string
    amount_paid: bigint | number
    is_extended?: boolean
    status?: $Enums.SubscriptionStatus
    plan_id: number
    payment_id: string
  }

  export type userActivitiesHistoryCreateManyUsersInput = {
    id?: number
    activity_name: string
    time?: Date | string
  }

  export type userNotificationsCreateManyUsersInput = {
    id?: number
    title: string
    content?: string | null
    type?: $Enums.NotificationsType
    is_read?: boolean
    sent_at?: Date | string
    read_at?: Date | string | null
  }

  export type blogsUpdateWithoutUsersInput = {
    title?: StringFieldUpdateOperationsInput | string
    cover_image_url?: StringFieldUpdateOperationsInput | string
    description_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type blogsUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    cover_image_url?: StringFieldUpdateOperationsInput | string
    description_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type blogsUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    cover_image_url?: StringFieldUpdateOperationsInput | string
    description_url?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type careerPathsUpdateWithoutUsersInput = {
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resources?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    estimate_duration?: NullableStringFieldUpdateOperationsInput | string | null
    careerPathSteps?: careerPathStepsUpdateManyWithoutCareerPathsNestedInput
    jobSpecialized?: jobSpecializedUpdateOneRequiredWithoutCareerPathsNestedInput
  }

  export type careerPathsUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resources?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    estimate_duration?: NullableStringFieldUpdateOperationsInput | string | null
    jobspecialized_id?: IntFieldUpdateOperationsInput | number
    careerPathSteps?: careerPathStepsUncheckedUpdateManyWithoutCareerPathsNestedInput
  }

  export type careerPathsUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    resources?: NullableStringFieldUpdateOperationsInput | string | null
    level?: NullableStringFieldUpdateOperationsInput | string | null
    estimate_duration?: NullableStringFieldUpdateOperationsInput | string | null
    jobspecialized_id?: IntFieldUpdateOperationsInput | number
  }

  export type feedbacksUpdateWithoutUsersInput = {
    description?: StringFieldUpdateOperationsInput | string
    stars?: FloatFieldUpdateOperationsInput | number
    work_environment?: NullableStringFieldUpdateOperationsInput | string | null
    benefit?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    companies?: companiesUpdateOneRequiredWithoutFeedbacksNestedInput
  }

  export type feedbacksUncheckedUpdateWithoutUsersInput = {
    company_id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    stars?: FloatFieldUpdateOperationsInput | number
    work_environment?: NullableStringFieldUpdateOperationsInput | string | null
    benefit?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type feedbacksUncheckedUpdateManyWithoutUsersInput = {
    company_id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    stars?: FloatFieldUpdateOperationsInput | number
    work_environment?: NullableStringFieldUpdateOperationsInput | string | null
    benefit?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type followedCompaniesUpdateWithoutUsersInput = {
    followed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_notified?: BoolFieldUpdateOperationsInput | boolean
    companies?: companiesUpdateOneRequiredWithoutFollowedCompaniesNestedInput
  }

  export type followedCompaniesUncheckedUpdateWithoutUsersInput = {
    company_id?: StringFieldUpdateOperationsInput | string
    followed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_notified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type followedCompaniesUncheckedUpdateManyWithoutUsersInput = {
    company_id?: StringFieldUpdateOperationsInput | string
    followed_at?: DateTimeFieldUpdateOperationsInput | Date | string
    is_notified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type messagesUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    message_content?: NullableStringFieldUpdateOperationsInput | string | null
    response_content?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type messagesUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    message_content?: NullableStringFieldUpdateOperationsInput | string | null
    response_content?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type messagesUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    message_content?: NullableStringFieldUpdateOperationsInput | string | null
    response_content?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type paymentsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    payment_gateway?: EnumPaymentGatewayFieldUpdateOperationsInput | $Enums.PaymentGateway
    payment_method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: subscriptionsUpdateOneWithoutPaymentsNestedInput
  }

  export type paymentsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    payment_gateway?: EnumPaymentGatewayFieldUpdateOperationsInput | $Enums.PaymentGateway
    payment_method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    subscriptions?: subscriptionsUncheckedUpdateOneWithoutPaymentsNestedInput
  }

  export type paymentsUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: BigIntFieldUpdateOperationsInput | bigint | number
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    payment_gateway?: EnumPaymentGatewayFieldUpdateOperationsInput | $Enums.PaymentGateway
    payment_method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type personalityTestResultsUpdateWithoutUsersInput = {
    answers?: answersUpdateOneRequiredWithoutPersonalityTestResultsNestedInput
    questions?: questionsUpdateOneRequiredWithoutPersonalityTestResultsNestedInput
  }

  export type personalityTestResultsUncheckedUpdateWithoutUsersInput = {
    question_id?: IntFieldUpdateOperationsInput | number
    answer_id?: IntFieldUpdateOperationsInput | number
  }

  export type personalityTestResultsUncheckedUpdateManyWithoutUsersInput = {
    question_id?: IntFieldUpdateOperationsInput | number
    answer_id?: IntFieldUpdateOperationsInput | number
  }

  export type savedJobsUpdateWithoutUsersInput = {
    saved_at?: DateTimeFieldUpdateOperationsInput | Date | string
    jobs?: jobsUpdateOneRequiredWithoutSavedJobsNestedInput
  }

  export type savedJobsUncheckedUpdateWithoutUsersInput = {
    job_id?: StringFieldUpdateOperationsInput | string
    saved_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type savedJobsUncheckedUpdateManyWithoutUsersInput = {
    job_id?: StringFieldUpdateOperationsInput | string
    saved_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type subscriptionsUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount_paid?: BigIntFieldUpdateOperationsInput | bigint | number
    is_extended?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    payments?: paymentsUpdateOneRequiredWithoutSubscriptionsNestedInput
    membershipPlans?: membershipPlansUpdateOneRequiredWithoutSubscriptionsNestedInput
  }

  export type subscriptionsUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount_paid?: BigIntFieldUpdateOperationsInput | bigint | number
    is_extended?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    plan_id?: IntFieldUpdateOperationsInput | number
    payment_id?: StringFieldUpdateOperationsInput | string
  }

  export type subscriptionsUncheckedUpdateManyWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    amount_paid?: BigIntFieldUpdateOperationsInput | bigint | number
    is_extended?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    plan_id?: IntFieldUpdateOperationsInput | number
    payment_id?: StringFieldUpdateOperationsInput | string
  }

  export type userActivitiesHistoryUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    activity_name?: StringFieldUpdateOperationsInput | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userActivitiesHistoryUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    activity_name?: StringFieldUpdateOperationsInput | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userActivitiesHistoryUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    activity_name?: StringFieldUpdateOperationsInput | string
    time?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userNotificationsUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationsTypeFieldUpdateOperationsInput | $Enums.NotificationsType
    is_read?: BoolFieldUpdateOperationsInput | boolean
    sent_at?: DateTimeFieldUpdateOperationsInput | Date | string
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userNotificationsUncheckedUpdateWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationsTypeFieldUpdateOperationsInput | $Enums.NotificationsType
    is_read?: BoolFieldUpdateOperationsInput | boolean
    sent_at?: DateTimeFieldUpdateOperationsInput | Date | string
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type userNotificationsUncheckedUpdateManyWithoutUsersInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationsTypeFieldUpdateOperationsInput | $Enums.NotificationsType
    is_read?: BoolFieldUpdateOperationsInput | boolean
    sent_at?: DateTimeFieldUpdateOperationsInput | Date | string
    read_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}